# Comparing `tmp/sympy.keras-1.0.21.tar.gz` & `tmp/sympy.keras-1.0.4.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "sympy.keras-1.0.21.tar", last modified: Sun Jun  4 15:20:04 2023, max compression
+gzip compressed data, was "sympy.keras-1.0.4.tar", last modified: Wed Oct 12 08:07:39 2022, max compression
```

## Comparing `sympy.keras-1.0.21.tar` & `sympy.keras-1.0.4.tar`

### file list

```diff
@@ -1,1465 +1,847 @@
-drwxrwxrwx   0        0        0        0 2023-06-04 15:20:04.212793 sympy.keras-1.0.21/
--rw-rw-rw-   0        0        0      529 2023-06-04 15:20:04.212793 sympy.keras-1.0.21/PKG-INFO
--rw-rw-rw-   0        0        0      185 2021-07-23 11:00:48.000000 sympy.keras-1.0.21/README.md
--rw-rw-rw-   0        0        0      371 2023-06-04 15:20:04.216812 sympy.keras-1.0.21/setup.cfg
--rw-rw-rw-   0        0        0      474 2023-02-19 07:00:04.000000 sympy.keras-1.0.21/setup.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:19:57.413351 sympy.keras-1.0.21/sympy/
--rw-rw-rw-   0        0        0     3174 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/__init__.py
--rw-rw-rw-   0        0        0     3720 2022-04-23 13:44:25.000000 sympy.keras-1.0.21/sympy/abc.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:19:57.437290 sympy.keras-1.0.21/sympy/algebra/
--rw-rw-rw-   0        0        0       34 2023-04-10 14:00:42.000000 sympy.keras-1.0.21/sympy/algebra/__init__.py
--rw-rw-rw-   0        0        0    20368 2022-04-23 13:44:25.000000 sympy.keras-1.0.21/sympy/algebra/quaternion.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:19:57.479206 sympy.keras-1.0.21/sympy/assumptions/
--rw-rw-rw-   0        0        0      163 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/assumptions/__init__.py
--rw-rw-rw-   0        0        0    43526 2021-10-01 01:55:11.000000 sympy.keras-1.0.21/sympy/assumptions/ask.py
--rw-rw-rw-   0        0        0     6673 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/assumptions/ask_generated.py
--rw-rw-rw-   0        0        0     6287 2023-05-10 14:05:08.000000 sympy.keras-1.0.21/sympy/assumptions/assume.py
--rw-rw-rw-   0        0        0    10073 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/assumptions/cnf.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:19:57.512152 sympy.keras-1.0.21/sympy/assumptions/handlers/
--rw-rw-rw-   0        0        0      115 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/assumptions/handlers/__init__.py
--rw-rw-rw-   0        0        0     6990 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/assumptions/handlers/calculus.py
--rw-rw-rw-   0        0        0     3249 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/assumptions/handlers/common.py
--rw-rw-rw-   0        0        0    19601 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/assumptions/handlers/matrices.py
--rw-rw-rw-   0        0        0     7355 2022-04-23 13:44:25.000000 sympy.keras-1.0.21/sympy/assumptions/handlers/ntheory.py
--rw-rw-rw-   0        0        0    10833 2022-04-23 13:44:25.000000 sympy.keras-1.0.21/sympy/assumptions/handlers/order.py
--rw-rw-rw-   0        0        0    21225 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/assumptions/handlers/sets.py
--rw-rw-rw-   0        0        0     7964 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/assumptions/refine.py
--rw-rw-rw-   0        0        0     2977 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/assumptions/satask.py
--rw-rw-rw-   0        0        0    13395 2022-04-23 13:44:25.000000 sympy.keras-1.0.21/sympy/assumptions/sathandlers.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:19:57.551642 sympy.keras-1.0.21/sympy/assumptions/tests/
--rw-rw-rw-   0        0        0        0 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/assumptions/tests/__init__.py
--rw-rw-rw-   0        0        0     1070 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/assumptions/tests/test_assumptions_2.py
--rw-rw-rw-   0        0        0     1153 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/assumptions/tests/test_context.py
--rw-rw-rw-   0        0        0    12258 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/assumptions/tests/test_matrices.py
--rw-rw-rw-   0        0        0    97999 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/assumptions/tests/test_query.py
--rw-rw-rw-   0        0        0     8834 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/assumptions/tests/test_refine.py
--rw-rw-rw-   0        0        0    15741 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/assumptions/tests/test_satask.py
--rw-rw-rw-   0        0        0     1842 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/assumptions/tests/test_sathandlers.py
--rw-rw-rw-   0        0        0     1159 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/assumptions/tests/test_wrapper.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:19:57.567600 sympy.keras-1.0.21/sympy/benchmarks/
--rw-rw-rw-   0        0        0        0 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/benchmarks/__init__.py
--rw-rw-rw-   0        0        0     2473 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/benchmarks/bench_discrete_log.py
--rw-rw-rw-   0        0        0    11610 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/benchmarks/bench_meijerint.py
--rw-rw-rw-   0        0        0     2997 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/benchmarks/bench_symbench.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:19:57.597597 sympy.keras-1.0.21/sympy/calculus/
--rw-rw-rw-   0        0        0      487 2023-04-10 14:00:42.000000 sympy.keras-1.0.21/sympy/calculus/__init__.py
--rw-rw-rw-   0        0        0     3264 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/calculus/euler.py
--rw-rw-rw-   0        0        0    16652 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/calculus/finite_diff.py
--rw-rw-rw-   0        0        0    10830 2022-10-01 04:16:50.000000 sympy.keras-1.0.21/sympy/calculus/singularities.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:19:57.625931 sympy.keras-1.0.21/sympy/calculus/tests/
--rw-rw-rw-   0        0        0        0 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/calculus/tests/__init__.py
--rw-rw-rw-   0        0        0    11195 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/calculus/tests/test_accumulationbounds.py
--rw-rw-rw-   0        0        0     2683 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/calculus/tests/test_euler.py
--rw-rw-rw-   0        0        0     7760 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/calculus/tests/test_finite_diff.py
--rw-rw-rw-   0        0        0     4215 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/calculus/tests/test_singularities.py
--rw-rw-rw-   0        0        0    15034 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/calculus/tests/test_util.py
--rw-rw-rw-   0        0        0    53014 2023-04-18 11:57:19.000000 sympy.keras-1.0.21/sympy/calculus/util.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:19:57.643883 sympy.keras-1.0.21/sympy/categories/
--rw-rw-rw-   0        0        0      771 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/categories/__init__.py
--rw-rw-rw-   0        0        0    30746 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/categories/baseclasses.py
--rw-rw-rw-   0        0        0    95496 2022-04-23 13:44:25.000000 sympy.keras-1.0.21/sympy/categories/diagram_drawing.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:19:57.657920 sympy.keras-1.0.21/sympy/categories/tests/
--rw-rw-rw-   0        0        0        0 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/categories/tests/__init__.py
--rw-rw-rw-   0        0        0     5767 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/categories/tests/test_baseclasses.py
--rw-rw-rw-   0        0        0    27848 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/categories/tests/test_drawing.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:19:57.736680 sympy.keras-1.0.21/sympy/codegen/
--rw-rw-rw-   0        0        0      773 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/codegen/__init__.py
--rw-rw-rw-   0        0        0     4905 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/codegen/algorithms.py
--rw-rw-rw-   0        0        0     6431 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/codegen/approximations.py
--rw-rw-rw-   0        0        0    56750 2022-10-02 01:16:37.000000 sympy.keras-1.0.21/sympy/codegen/array_utils.py
--rw-rw-rw-   0        0        0    54635 2022-10-01 04:19:03.000000 sympy.keras-1.0.21/sympy/codegen/ast.py
--rw-rw-rw-   0        0        0    11380 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/codegen/cfunctions.py
--rw-rw-rw-   0        0        0     2431 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/codegen/cnodes.py
--rw-rw-rw-   0        0        0      387 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/codegen/cutils.py
--rw-rw-rw-   0        0        0      332 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/codegen/cxxnodes.py
--rw-rw-rw-   0        0        0    18905 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/codegen/fnodes.py
--rw-rw-rw-   0        0        0     1806 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/codegen/futils.py
--rw-rw-rw-   0        0        0     2112 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/codegen/matrix_nodes.py
--rw-rw-rw-   0        0        0     3098 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/codegen/numpy_nodes.py
--rw-rw-rw-   0        0        0      658 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/codegen/pyutils.py
--rw-rw-rw-   0        0        0     6995 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/codegen/rewriting.py
--rw-rw-rw-   0        0        0     1176 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/codegen/scipy_nodes.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:19:57.812600 sympy.keras-1.0.21/sympy/codegen/tests/
--rw-rw-rw-   0        0        0        0 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/codegen/tests/__init__.py
--rw-rw-rw-   0        0        0      451 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/codegen/tests/test_abstract_nodes.py
--rw-rw-rw-   0        0        0     4700 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/codegen/tests/test_algorithms.py
--rw-rw-rw-   0        0        0     2189 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/codegen/tests/test_applications.py
--rw-rw-rw-   0        0        0     2035 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/codegen/tests/test_approximations.py
--rw-rw-rw-   0        0        0    21688 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/codegen/tests/test_ast.py
--rw-rw-rw-   0        0        0     4613 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/codegen/tests/test_cfunctions.py
--rw-rw-rw-   0        0        0     3039 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/codegen/tests/test_cnodes.py
--rw-rw-rw-   0        0        0      366 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/codegen/tests/test_cxxnodes.py
--rw-rw-rw-   0        0        0     6643 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/codegen/tests/test_fnodes.py
--rw-rw-rw-   0        0        0     1896 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/codegen/tests/test_matrix_nodes.py
--rw-rw-rw-   0        0        0     1658 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/codegen/tests/test_numpy_nodes.py
--rw-rw-rw-   0        0        0      432 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/codegen/tests/test_pynodes.py
--rw-rw-rw-   0        0        0      285 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/codegen/tests/test_pyutils.py
--rw-rw-rw-   0        0        0    15852 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/codegen/tests/test_rewriting.py
--rw-rw-rw-   0        0        0     1495 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/codegen/tests/test_scipy_nodes.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:19:57.937229 sympy.keras-1.0.21/sympy/combinatorics/
--rw-rw-rw-   0        0        0      780 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/combinatorics/__init__.py
--rw-rw-rw-   0        0        0    42986 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/combinatorics/coset_table.py
--rw-rw-rw-   0        0        0    47699 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/combinatorics/fp_groups.py
--rw-rw-rw-   0        0        0    39988 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/combinatorics/free_groups.py
--rw-rw-rw-   0        0        0     7917 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/combinatorics/generators.py
--rw-rw-rw-   0        0        0    11238 2022-04-23 13:44:25.000000 sympy.keras-1.0.21/sympy/combinatorics/graycode.py
--rw-rw-rw-   0        0        0     1940 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/combinatorics/group_constructs.py
--rw-rw-rw-   0        0        0    19318 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/combinatorics/homomorphisms.py
--rw-rw-rw-   0        0        0     7822 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/combinatorics/named_groups.py
--rw-rw-rw-   0        0        0    20586 2023-05-08 14:47:11.000000 sympy.keras-1.0.21/sympy/combinatorics/partitions.py
--rw-rw-rw-   0        0        0    21049 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/combinatorics/pc_groups.py
--rw-rw-rw-   0        0        0   163552 2022-09-24 00:48:20.000000 sympy.keras-1.0.21/sympy/combinatorics/perm_groups.py
--rw-rw-rw-   0        0        0    80708 2022-04-23 13:44:25.000000 sympy.keras-1.0.21/sympy/combinatorics/permutations.py
--rw-rw-rw-   0        0        0    28418 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/combinatorics/polyhedron.py
--rw-rw-rw-   0        0        0    11859 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/combinatorics/prufer.py
--rw-rw-rw-   0        0        0    17182 2022-04-23 13:44:25.000000 sympy.keras-1.0.21/sympy/combinatorics/rewritingsystem.py
--rw-rw-rw-   0        0        0     2449 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/combinatorics/rewritingsystem_fsm.py
--rw-rw-rw-   0        0        0     4128 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/combinatorics/schur_number.py
--rw-rw-rw-   0        0        0    15804 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/combinatorics/subsets.py
--rw-rw-rw-   0        0        0    40787 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/combinatorics/tensor_can.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:19:58.036845 sympy.keras-1.0.21/sympy/combinatorics/tests/
--rw-rw-rw-   0        0        0        0 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/combinatorics/tests/__init__.py
--rw-rw-rw-   0        0        0    28474 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/combinatorics/tests/test_coset_table.py
--rw-rw-rw-   0        0        0     9969 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/combinatorics/tests/test_fp_groups.py
--rw-rw-rw-   0        0        0     6161 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/combinatorics/tests/test_free_groups.py
--rw-rw-rw-   0        0        0     2763 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/combinatorics/tests/test_galois.py
--rw-rw-rw-   0        0        0     3567 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/combinatorics/tests/test_generators.py
--rw-rw-rw-   0        0        0     2800 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/combinatorics/tests/test_graycode.py
--rw-rw-rw-   0        0        0      450 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/combinatorics/tests/test_group_constructs.py
--rw-rw-rw-   0        0        0      989 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/combinatorics/tests/test_group_numbers.py
--rw-rw-rw-   0        0        0     3745 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/combinatorics/tests/test_homomorphisms.py
--rw-rw-rw-   0        0        0     1931 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/combinatorics/tests/test_named_groups.py
--rw-rw-rw-   0        0        0     4097 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/combinatorics/tests/test_partitions.py
--rw-rw-rw-   0        0        0     2728 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/combinatorics/tests/test_pc_groups.py
--rw-rw-rw-   0        0        0    41191 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/combinatorics/tests/test_perm_groups.py
--rw-rw-rw-   0        0        0    20149 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/combinatorics/tests/test_permutations.py
--rw-rw-rw-   0        0        0     4180 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/combinatorics/tests/test_polyhedron.py
--rw-rw-rw-   0        0        0     2649 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/combinatorics/tests/test_prufer.py
--rw-rw-rw-   0        0        0     1787 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/combinatorics/tests/test_rewriting.py
--rw-rw-rw-   0        0        0     1727 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/combinatorics/tests/test_schur_number.py
--rw-rw-rw-   0        0        0     2635 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/combinatorics/tests/test_subsets.py
--rw-rw-rw-   0        0        0    24676 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/combinatorics/tests/test_tensor_can.py
--rw-rw-rw-   0        0        0     1729 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/combinatorics/tests/test_testutil.py
--rw-rw-rw-   0        0        0     4499 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/combinatorics/tests/test_util.py
--rw-rw-rw-   0        0        0    10913 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/combinatorics/testutil.py
--rw-rw-rw-   0        0        0    16951 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/combinatorics/util.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:19:58.112637 sympy.keras-1.0.21/sympy/concrete/
--rw-rw-rw-   0        0        0      360 2021-12-16 21:56:21.000000 sympy.keras-1.0.21/sympy/concrete/__init__.py
--rw-rw-rw-   0        0        0    22783 2023-05-04 13:38:07.000000 sympy.keras-1.0.21/sympy/concrete/conditional_boolean.py
--rw-rw-rw-   0        0        0     9891 2022-04-23 13:44:25.000000 sympy.keras-1.0.21/sympy/concrete/delta.py
--rw-rw-rw-   0        0        0    11764 2023-04-28 14:38:39.000000 sympy.keras-1.0.21/sympy/concrete/exists.py
--rw-rw-rw-   0        0        0    12330 2023-04-18 11:57:18.000000 sympy.keras-1.0.21/sympy/concrete/expr_with_intlimits.py
--rw-rw-rw-   0        0        0   121020 2023-05-30 11:34:32.000000 sympy.keras-1.0.21/sympy/concrete/expr_with_limits.py
--rw-rw-rw-   0        0        0     9901 2023-05-04 13:41:27.000000 sympy.keras-1.0.21/sympy/concrete/forall.py
--rw-rw-rw-   0        0        0     5462 2022-04-23 13:44:25.000000 sympy.keras-1.0.21/sympy/concrete/gosper.py
--rw-rw-rw-   0        0        0    17283 2022-04-23 13:44:25.000000 sympy.keras-1.0.21/sympy/concrete/guess.py
--rw-rw-rw-   0        0        0     7623 2023-04-18 11:57:18.000000 sympy.keras-1.0.21/sympy/concrete/limits.py
--rw-rw-rw-   0        0        0    41710 2023-05-17 14:48:06.000000 sympy.keras-1.0.21/sympy/concrete/products.py
--rw-rw-rw-   0        0        0    16325 2023-05-22 13:07:14.000000 sympy.keras-1.0.21/sympy/concrete/reduced.py
--rw-rw-rw-   0        0        0    47982 2023-05-22 13:07:14.000000 sympy.keras-1.0.21/sympy/concrete/sets.py
--rw-rw-rw-   0        0        0    71116 2023-05-06 13:51:54.000000 sympy.keras-1.0.21/sympy/concrete/summations.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:19:58.141431 sympy.keras-1.0.21/sympy/concrete/tests/
--rw-rw-rw-   0        0        0        0 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/concrete/tests/__init__.py
--rw-rw-rw-   0        0        0    23869 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/concrete/tests/test_delta.py
--rw-rw-rw-   0        0        0     7987 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/concrete/tests/test_gosper.py
--rw-rw-rw-   0        0        0     3370 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/concrete/tests/test_guess.py
--rw-rw-rw-   0        0        0    14521 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/concrete/tests/test_products.py
--rw-rw-rw-   0        0        0    64458 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/concrete/tests/test_sums_products.py
--rw-rw-rw-   0        0        0     2258 2022-04-23 13:44:25.000000 sympy.keras-1.0.21/sympy/conftest.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:19:58.343248 sympy.keras-1.0.21/sympy/core/
--rw-rw-rw-   0        0        0     1418 2022-10-05 05:25:10.000000 sympy.keras-1.0.21/sympy/core/__init__.py
--rw-rw-rw-   0        0        0     2391 2023-04-10 14:00:43.000000 sympy.keras-1.0.21/sympy/core/_print_helpers.py
--rw-rw-rw-   0        0        0    62393 2023-06-03 10:07:31.000000 sympy.keras-1.0.21/sympy/core/add.py
--rw-rw-rw-   0        0        0      266 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/core/alphabets.py
--rw-rw-rw-   0        0        0    26959 2023-04-22 02:26:10.000000 sympy.keras-1.0.21/sympy/core/assumptions.py
--rw-rw-rw-   0        0        0     1161 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/core/backend.py
--rw-rw-rw-   0        0        0   105219 2023-05-26 13:32:03.000000 sympy.keras-1.0.21/sympy/core/basic.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:19:58.367073 sympy.keras-1.0.21/sympy/core/benchmarks/
--rw-rw-rw-   0        0        0        0 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/core/benchmarks/__init__.py
--rw-rw-rw-   0        0        0      412 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/core/benchmarks/bench_arit.py
--rw-rw-rw-   0        0        0      177 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/core/benchmarks/bench_assumptions.py
--rw-rw-rw-   0        0        0      210 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/core/benchmarks/bench_basic.py
--rw-rw-rw-   0        0        0      427 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/core/benchmarks/bench_expand.py
--rw-rw-rw-   0        0        0     1105 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/core/benchmarks/bench_numbers.py
--rw-rw-rw-   0        0        0      138 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/core/benchmarks/bench_sympify.py
--rw-rw-rw-   0        0        0     4676 2022-01-09 03:27:32.000000 sympy.keras-1.0.21/sympy/core/cache.py
--rw-rw-rw-   0        0        0    18989 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/core/compatibility.py
--rw-rw-rw-   0        0        0    17492 2023-05-06 15:04:13.000000 sympy.keras-1.0.21/sympy/core/containers.py
--rw-rw-rw-   0        0        0     9172 2023-04-18 11:57:19.000000 sympy.keras-1.0.21/sympy/core/core.py
--rw-rw-rw-   0        0        0      271 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/core/coreerrors.py
--rw-rw-rw-   0        0        0     9428 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/core/decorators.py
--rw-rw-rw-   0        0        0    52369 2022-02-19 14:23:21.000000 sympy.keras-1.0.21/sympy/core/evalf.py
--rw-rw-rw-   0        0        0   151137 2023-06-03 15:32:06.000000 sympy.keras-1.0.21/sympy/core/expr.py
--rw-rw-rw-   0        0        0    51392 2022-10-01 04:23:26.000000 sympy.keras-1.0.21/sympy/core/exprtools.py
--rw-rw-rw-   0        0        0    16299 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/core/facts.py
--rw-rw-rw-   0        0        0   164902 2023-05-12 14:53:18.000000 sympy.keras-1.0.21/sympy/core/function.py
--rw-rw-rw-   0        0        0    34882 2023-05-03 16:04:57.000000 sympy.keras-1.0.21/sympy/core/inference.py
--rw-rw-rw-   0        0        0    11519 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/core/kind.py
--rw-rw-rw-   0        0        0    11662 2021-09-19 13:11:37.000000 sympy.keras-1.0.21/sympy/core/logic.py
--rw-rw-rw-   0        0        0     9669 2023-04-18 11:57:18.000000 sympy.keras-1.0.21/sympy/core/mod.py
--rw-rw-rw-   0        0        0   105121 2023-05-22 13:07:14.000000 sympy.keras-1.0.21/sympy/core/mul.py
--rw-rw-rw-   0        0        0     4360 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/core/multidimensional.py
--rw-rw-rw-   0        0        0   147635 2023-05-29 15:22:18.000000 sympy.keras-1.0.21/sympy/core/numbers.py
--rw-rw-rw-   0        0        0    23879 2023-04-30 07:41:43.000000 sympy.keras-1.0.21/sympy/core/of.py
--rw-rw-rw-   0        0        0    30208 2023-05-10 14:05:28.000000 sympy.keras-1.0.21/sympy/core/operations.py
--rw-rw-rw-   0        0        0     3037 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/core/parameters.py
--rw-rw-rw-   0        0        0    83328 2023-06-03 10:07:25.000000 sympy.keras-1.0.21/sympy/core/power.py
--rw-rw-rw-   0        0        0   114635 2023-06-02 13:42:16.000000 sympy.keras-1.0.21/sympy/core/relational.py
--rw-rw-rw-   0        0        0     1502 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/core/rules.py
--rw-rw-rw-   0        0        0     8063 2022-10-04 03:25:15.000000 sympy.keras-1.0.21/sympy/core/singleton.py
--rw-rw-rw-   0        0        0    94245 2023-05-26 13:32:03.000000 sympy.keras-1.0.21/sympy/core/symbol.py
--rw-rw-rw-   0        0        0    18404 2022-10-06 11:55:13.000000 sympy.keras-1.0.21/sympy/core/sympify.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:19:58.573655 sympy.keras-1.0.21/sympy/core/tests/
--rw-rw-rw-   0        0        0        0 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/core/tests/__init__.py
--rw-rw-rw-   0        0        0   178552 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/core/tests/test_args.py
--rw-rw-rw-   0        0        0    77847 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/core/tests/test_arit.py
--rw-rw-rw-   0        0        0    41573 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/core/tests/test_assumptions.py
--rw-rw-rw-   0        0        0     9496 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/core/tests/test_basic.py
--rw-rw-rw-   0        0        0     2001 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/core/tests/test_cache.py
--rw-rw-rw-   0        0        0      240 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/core/tests/test_compatibility.py
--rw-rw-rw-   0        0        0    21906 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/core/tests/test_complex.py
--rw-rw-rw-   0        0        0     2441 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/core/tests/test_constructor_postprocessor.py
--rw-rw-rw-   0        0        0     7434 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/core/tests/test_containers.py
--rw-rw-rw-   0        0        0     5665 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/core/tests/test_count_ops.py
--rw-rw-rw-   0        0        0     5421 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/core/tests/test_diff.py
--rw-rw-rw-   0        0        0     1678 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/core/tests/test_equal.py
--rw-rw-rw-   0        0        0     2366 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/core/tests/test_eval.py
--rw-rw-rw-   0        0        0    28307 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/core/tests/test_evalf.py
--rw-rw-rw-   0        0        0    13383 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/core/tests/test_expand.py
--rw-rw-rw-   0        0        0    76585 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/core/tests/test_expr.py
--rw-rw-rw-   0        0        0    19021 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/core/tests/test_exprtools.py
--rw-rw-rw-   0        0        0    11579 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/core/tests/test_facts.py
--rw-rw-rw-   0        0        0    51420 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/core/tests/test_function.py
--rw-rw-rw-   0        0        0     2048 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/core/tests/test_kind.py
--rw-rw-rw-   0        0        0     5634 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/core/tests/test_logic.py
--rw-rw-rw-   0        0        0    22716 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/core/tests/test_match.py
--rw-rw-rw-   0        0        0      848 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/core/tests/test_multidimensional.py
--rw-rw-rw-   0        0        0     4436 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/core/tests/test_noncommutative.py
--rw-rw-rw-   0        0        0    75434 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/core/tests/test_numbers.py
--rw-rw-rw-   0        0        0     2859 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/core/tests/test_operations.py
--rw-rw-rw-   0        0        0     3560 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/core/tests/test_parameters.py
--rw-rw-rw-   0        0        0    24434 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/core/tests/test_power.py
--rw-rw-rw-   0        0        0     3190 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/core/tests/test_priority.py
--rw-rw-rw-   0        0        0     1233 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/core/tests/test_random.py
--rw-rw-rw-   0        0        0    42972 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/core/tests/test_relational.py
--rw-rw-rw-   0        0        0      349 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/core/tests/test_rules.py
--rw-rw-rw-   0        0        0     3036 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/core/tests/test_singleton.py
--rw-rw-rw-   0        0        0      902 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/core/tests/test_sorting.py
--rw-rw-rw-   0        0        0    30106 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/core/tests/test_subs.py
--rw-rw-rw-   0        0        0    13043 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/core/tests/test_symbol.py
--rw-rw-rw-   0        0        0    27866 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/core/tests/test_sympify.py
--rw-rw-rw-   0        0        0     4311 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/core/tests/test_traversal.py
--rw-rw-rw-   0        0        0      854 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/core/tests/test_truediv.py
--rw-rw-rw-   0        0        0     1594 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/core/tests/test_var.py
--rw-rw-rw-   0        0        0     6018 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/core/trace.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:19:58.592577 sympy.keras-1.0.21/sympy/crypto/
--rw-rw-rw-   0        0        0     1012 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/crypto/__init__.py
--rw-rw-rw-   0        0        0    69161 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/crypto/crypto.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:19:58.597609 sympy.keras-1.0.21/sympy/crypto/tests/
--rw-rw-rw-   0        0        0        0 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/crypto/tests/__init__.py
--rw-rw-rw-   0        0        0    19758 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/crypto/tests/test_crypto.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:19:58.606568 sympy.keras-1.0.21/sympy/deprecated/
--rw-rw-rw-   0        0        0      422 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/deprecated/__init__.py
--rw-rw-rw-   0        0        0     1936 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/deprecated/class_registry.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:19:58.622843 sympy.keras-1.0.21/sympy/diffgeom/
--rw-rw-rw-   0        0        0      459 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/diffgeom/__init__.py
--rw-rw-rw-   0        0        0    56375 2022-09-24 00:48:20.000000 sympy.keras-1.0.21/sympy/diffgeom/diffgeom.py
--rw-rw-rw-   0        0        0     4452 2022-04-23 13:44:25.000000 sympy.keras-1.0.21/sympy/diffgeom/rn.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:19:58.642758 sympy.keras-1.0.21/sympy/diffgeom/tests/
--rw-rw-rw-   0        0        0        0 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/diffgeom/tests/__init__.py
--rw-rw-rw-   0        0        0     1048 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/diffgeom/tests/test_class_structure.py
--rw-rw-rw-   0        0        0    14145 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/diffgeom/tests/test_diffgeom.py
--rw-rw-rw-   0        0        0     5254 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/diffgeom/tests/test_function_diffgeom_book.py
--rw-rw-rw-   0        0        0     2598 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/diffgeom/tests/test_hyperbolic_space.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:19:58.663730 sympy.keras-1.0.21/sympy/discrete/
--rw-rw-rw-   0        0        0      590 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/discrete/__init__.py
--rw-rw-rw-   0        0        0    14474 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/discrete/convolutions.py
--rw-rw-rw-   0        0        0     4541 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/discrete/recurrences.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:19:58.678692 sympy.keras-1.0.21/sympy/discrete/tests/
--rw-rw-rw-   0        0        0        0 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/discrete/tests/__init__.py
--rw-rw-rw-   0        0        0    17856 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/discrete/tests/test_convolutions.py
--rw-rw-rw-   0        0        0     3019 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/discrete/tests/test_recurrences.py
--rw-rw-rw-   0        0        0     5546 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/discrete/tests/test_transforms.py
--rw-rw-rw-   0        0        0    11724 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/discrete/transforms.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:19:58.697610 sympy.keras-1.0.21/sympy/external/
--rw-rw-rw-   0        0        0      548 2023-04-10 14:00:42.000000 sympy.keras-1.0.21/sympy/external/__init__.py
--rw-rw-rw-   0        0        0     1908 2023-04-10 14:00:42.000000 sympy.keras-1.0.21/sympy/external/gmpy.py
--rw-rw-rw-   0        0        0     7383 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/external/importtools.py
--rw-rw-rw-   0        0        0    11870 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/external/pythonmpq.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:19:58.726534 sympy.keras-1.0.21/sympy/external/tests/
--rw-rw-rw-   0        0        0        0 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/external/tests/__init__.py
--rw-rw-rw-   0        0        0     9755 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/external/tests/test_autowrap.py
--rw-rw-rw-   0        0        0    12676 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/external/tests/test_codegen.py
--rw-rw-rw-   0        0        0     1394 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/external/tests/test_importtools.py
--rw-rw-rw-   0        0        0    10123 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/external/tests/test_numpy.py
--rw-rw-rw-   0        0        0     5797 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/external/tests/test_pythonmpq.py
--rw-rw-rw-   0        0        0     1172 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/external/tests/test_scipy.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:19:58.731521 sympy.keras-1.0.21/sympy/functions/
--rw-rw-rw-   0        0        0     3332 2023-06-03 10:07:57.000000 sympy.keras-1.0.21/sympy/functions/__init__.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:19:58.748507 sympy.keras-1.0.21/sympy/functions/combinatorial/
--rw-rw-rw-   0        0        0       47 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/functions/combinatorial/__init__.py
--rw-rw-rw-   0        0        0    37555 2023-06-03 10:48:22.000000 sympy.keras-1.0.21/sympy/functions/combinatorial/factorials.py
--rw-rw-rw-   0        0        0    79397 2022-10-02 03:40:03.000000 sympy.keras-1.0.21/sympy/functions/combinatorial/numbers.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:19:58.760505 sympy.keras-1.0.21/sympy/functions/combinatorial/tests/
--rw-rw-rw-   0        0        0        0 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/functions/combinatorial/tests/__init__.py
--rw-rw-rw-   0        0        0    26310 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/functions/combinatorial/tests/test_comb_factorials.py
--rw-rw-rw-   0        0        0    34317 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/functions/combinatorial/tests/test_comb_numbers.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:19:58.808093 sympy.keras-1.0.21/sympy/functions/elementary/
--rw-rw-rw-   0        0        0      154 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/functions/elementary/__init__.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:19:58.813078 sympy.keras-1.0.21/sympy/functions/elementary/benchmarks/
--rw-rw-rw-   0        0        0        0 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/functions/elementary/benchmarks/__init__.py
--rw-rw-rw-   0        0        0      185 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/functions/elementary/benchmarks/bench_exp.py
--rw-rw-rw-   0        0        0    42828 2023-05-29 15:13:30.000000 sympy.keras-1.0.21/sympy/functions/elementary/complexes.py
--rw-rw-rw-   0        0        0    34636 2023-05-26 13:32:03.000000 sympy.keras-1.0.21/sympy/functions/elementary/exponential.py
--rw-rw-rw-   0        0        0    42896 2023-05-12 14:50:49.000000 sympy.keras-1.0.21/sympy/functions/elementary/hyperbolic.py
--rw-rw-rw-   0        0        0    18064 2022-01-23 05:40:23.000000 sympy.keras-1.0.21/sympy/functions/elementary/integers.py
--rw-rw-rw-   0        0        0    26713 2023-04-18 11:57:18.000000 sympy.keras-1.0.21/sympy/functions/elementary/miscellaneous.py
--rw-rw-rw-   0        0        0    73526 2023-05-22 15:25:59.000000 sympy.keras-1.0.21/sympy/functions/elementary/piecewise.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:19:58.859953 sympy.keras-1.0.21/sympy/functions/elementary/tests/
--rw-rw-rw-   0        0        0        0 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/functions/elementary/tests/__init__.py
--rw-rw-rw-   0        0        0    33513 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/functions/elementary/tests/test_complexes.py
--rw-rw-rw-   0        0        0    29566 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/functions/elementary/tests/test_exponential.py
--rw-rw-rw-   0        0        0    53536 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/functions/elementary/tests/test_hyperbolic.py
--rw-rw-rw-   0        0        0    20930 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/functions/elementary/tests/test_integers.py
--rw-rw-rw-   0        0        0     2054 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/functions/elementary/tests/test_interface.py
--rw-rw-rw-   0        0        0    17148 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/functions/elementary/tests/test_miscellaneous.py
--rw-rw-rw-   0        0        0    61520 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/functions/elementary/tests/test_piecewise.py
--rw-rw-rw-   0        0        0    86394 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/functions/elementary/tests/test_trigonometric.py
--rw-rw-rw-   0        0        0    95742 2023-05-12 14:49:25.000000 sympy.keras-1.0.21/sympy/functions/elementary/trigonometric.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:19:58.951889 sympy.keras-1.0.21/sympy/functions/special/
--rw-rw-rw-   0        0        0      307 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/functions/special/__init__.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:19:58.956846 sympy.keras-1.0.21/sympy/functions/special/benchmarks/
--rw-rw-rw-   0        0        0        0 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/functions/special/benchmarks/__init__.py
--rw-rw-rw-   0        0        0      164 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/functions/special/benchmarks/bench_special.py
--rw-rw-rw-   0        0        0    49482 2022-10-02 03:42:45.000000 sympy.keras-1.0.21/sympy/functions/special/bessel.py
--rw-rw-rw-   0        0        0     3820 2022-10-02 03:43:15.000000 sympy.keras-1.0.21/sympy/functions/special/beta_functions.py
--rw-rw-rw-   0        0        0     9034 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/functions/special/bsplines.py
--rw-rw-rw-   0        0        0    20006 2022-10-01 04:52:38.000000 sympy.keras-1.0.21/sympy/functions/special/delta_functions.py
--rw-rw-rw-   0        0        0    12840 2022-04-23 13:44:25.000000 sympy.keras-1.0.21/sympy/functions/special/elliptic_integrals.py
--rw-rw-rw-   0        0        0    69014 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/functions/special/error_functions.py
--rw-rw-rw-   0        0        0    42910 2023-03-29 13:46:01.000000 sympy.keras-1.0.21/sympy/functions/special/gamma_functions.py
--rw-rw-rw-   0        0        0    35561 2023-03-24 13:15:57.000000 sympy.keras-1.0.21/sympy/functions/special/hyper.py
--rw-rw-rw-   0        0        0     6446 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/functions/special/mathieu_functions.py
--rw-rw-rw-   0        0        0    39716 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/functions/special/polynomials.py
--rw-rw-rw-   0        0        0     7395 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/functions/special/singularity_functions.py
--rw-rw-rw-   0        0        0    10331 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/functions/special/spherical_harmonics.py
--rw-rw-rw-   0        0        0    17712 2023-04-18 11:57:18.000000 sympy.keras-1.0.21/sympy/functions/special/tensor_functions.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:19:59.032549 sympy.keras-1.0.21/sympy/functions/special/tests/
--rw-rw-rw-   0        0        0        0 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/functions/special/tests/__init__.py
--rw-rw-rw-   0        0        0    34191 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/functions/special/tests/test_bessel.py
--rw-rw-rw-   0        0        0     3786 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/functions/special/tests/test_beta_functions.py
--rw-rw-rw-   0        0        0     7145 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/functions/special/tests/test_bsplines.py
--rw-rw-rw-   0        0        0     7138 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/functions/special/tests/test_delta_functions.py
--rw-rw-rw-   0        0        0     6860 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/functions/special/tests/test_elliptic_integrals.py
--rw-rw-rw-   0        0        0    31222 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/functions/special/tests/test_error_functions.py
--rw-rw-rw-   0        0        0    29910 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/functions/special/tests/test_gamma_functions.py
--rw-rw-rw-   0        0        0    15990 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/functions/special/tests/test_hyper.py
--rw-rw-rw-   0        0        0     1282 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/functions/special/tests/test_mathieu.py
--rw-rw-rw-   0        0        0     5467 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/functions/special/tests/test_singularity_functions.py
--rw-rw-rw-   0        0        0    19561 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/functions/special/tests/test_spec_polynomials.py
--rw-rw-rw-   0        0        0     3850 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/functions/special/tests/test_spherical_harmonics.py
--rw-rw-rw-   0        0        0     5546 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/functions/special/tests/test_tensor_functions.py
--rw-rw-rw-   0        0        0    10474 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/functions/special/tests/test_zeta_functions.py
--rw-rw-rw-   0        0        0    18625 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/functions/special/zeta_functions.py
--rw-rw-rw-   0        0        0      123 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/galgebra.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:19:59.088399 sympy.keras-1.0.21/sympy/geometry/
--rw-rw-rw-   0        0        0      825 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/geometry/__init__.py
--rw-rw-rw-   0        0        0     9083 2022-09-24 00:48:20.000000 sympy.keras-1.0.21/sympy/geometry/curve.py
--rw-rw-rw-   0        0        0    47100 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/geometry/ellipse.py
--rw-rw-rw-   0        0        0    20388 2022-04-23 13:44:25.000000 sympy.keras-1.0.21/sympy/geometry/entity.py
--rw-rw-rw-   0        0        0      131 2022-04-23 13:44:25.000000 sympy.keras-1.0.21/sympy/geometry/exceptions.py
--rw-rw-rw-   0        0        0    75317 2022-04-23 13:44:25.000000 sympy.keras-1.0.21/sympy/geometry/line.py
--rw-rw-rw-   0        0        0    10241 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/geometry/parabola.py
--rw-rw-rw-   0        0        0    27400 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/geometry/plane.py
--rw-rw-rw-   0        0        0    36004 2021-07-27 13:23:38.000000 sympy.keras-1.0.21/sympy/geometry/point.py
--rw-rw-rw-   0        0        0    69238 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/geometry/polygon.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:19:59.137331 sympy.keras-1.0.21/sympy/geometry/tests/
--rw-rw-rw-   0        0        0        0 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/geometry/tests/__init__.py
--rw-rw-rw-   0        0        0     4479 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/geometry/tests/test_curve.py
--rw-rw-rw-   0        0        0    26370 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/geometry/tests/test_ellipse.py
--rw-rw-rw-   0        0        0     3897 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/geometry/tests/test_entity.py
--rw-rw-rw-   0        0        0     1911 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/geometry/tests/test_geometrysets.py
--rw-rw-rw-   0        0        0    37421 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/geometry/tests/test_line.py
--rw-rw-rw-   0        0        0     6150 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/geometry/tests/test_parabola.py
--rw-rw-rw-   0        0        0    12525 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/geometry/tests/test_plane.py
--rw-rw-rw-   0        0        0    16412 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/geometry/tests/test_point.py
--rw-rw-rw-   0        0        0    27601 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/geometry/tests/test_polygon.py
--rw-rw-rw-   0        0        0     6204 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/geometry/tests/test_util.py
--rw-rw-rw-   0        0        0    19260 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/geometry/util.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:19:59.168176 sympy.keras-1.0.21/sympy/holonomic/
--rw-rw-rw-   0        0        0      569 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/holonomic/__init__.py
--rw-rw-rw-   0        0        0    93978 2022-10-01 04:53:28.000000 sympy.keras-1.0.21/sympy/holonomic/holonomic.py
--rw-rw-rw-   0        0        0     1193 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/holonomic/holonomicerrors.py
--rw-rw-rw-   0        0        0     2771 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/holonomic/linearsolver.py
--rw-rw-rw-   0        0        0     2730 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/holonomic/numerical.py
--rw-rw-rw-   0        0        0    10977 2022-04-23 13:44:25.000000 sympy.keras-1.0.21/sympy/holonomic/recurrence.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:19:59.179147 sympy.keras-1.0.21/sympy/holonomic/tests/
--rw-rw-rw-   0        0        0        0 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/holonomic/tests/__init__.py
--rw-rw-rw-   0        0        0    34760 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/holonomic/tests/test_holonomic.py
--rw-rw-rw-   0        0        0     1056 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/holonomic/tests/test_recurrence.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:19:59.277161 sympy.keras-1.0.21/sympy/integrals/
--rw-rw-rw-   0        0        0     1154 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/integrals/__init__.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:19:59.285139 sympy.keras-1.0.21/sympy/integrals/benchmarks/
--rw-rw-rw-   0        0        0        0 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/integrals/benchmarks/__init__.py
--rw-rw-rw-   0        0        0      396 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/integrals/benchmarks/bench_integrate.py
--rw-rw-rw-   0        0        0      305 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/integrals/benchmarks/bench_trigintegrate.py
--rw-rw-rw-   0        0        0     7367 2022-04-23 13:44:25.000000 sympy.keras-1.0.21/sympy/integrals/deltafunctions.py
--rw-rw-rw-   0        0        0    24363 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/integrals/heurisch.py
--rw-rw-rw-   0        0        0    70274 2023-06-02 16:05:26.000000 sympy.keras-1.0.21/sympy/integrals/integrals.py
--rw-rw-rw-   0        0        0    42721 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/integrals/intpoly.py
--rw-rw-rw-   0        0        0    60693 2023-04-08 07:53:41.000000 sympy.keras-1.0.21/sympy/integrals/manualintegrate.py
--rw-rw-rw-   0        0        0    77564 2023-04-18 11:57:18.000000 sympy.keras-1.0.21/sympy/integrals/meijerint.py
--rw-rw-rw-   0        0        0      934 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/integrals/meijerint_doc.py
--rw-rw-rw-   0        0        0    52203 2023-04-18 11:57:18.000000 sympy.keras-1.0.21/sympy/integrals/prde.py
--rw-rw-rw-   0        0        0    16675 2022-04-23 13:44:25.000000 sympy.keras-1.0.21/sympy/integrals/quadrature.py
--rw-rw-rw-   0        0        0    10292 2022-04-23 13:44:25.000000 sympy.keras-1.0.21/sympy/integrals/rationaltools.py
--rw-rw-rw-   0        0        0    26576 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/integrals/rde.py
--rw-rw-rw-   0        0        0    67330 2023-03-24 13:15:58.000000 sympy.keras-1.0.21/sympy/integrals/risch.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:19:59.329478 sympy.keras-1.0.21/sympy/integrals/rubi/
--rw-rw-rw-   0        0        0     3463 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/integrals/rubi/__init__.py
--rw-rw-rw-   0        0        0   294359 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/integrals/rubi/constraints.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:19:59.345437 sympy.keras-1.0.21/sympy/integrals/rubi/parsetools/
--rw-rw-rw-   0        0        0        0 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/integrals/rubi/parsetools/__init__.py
--rw-rw-rw-   0        0        0     2874 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/integrals/rubi/parsetools/generate_rules.py
--rw-rw-rw-   0        0        0     2680 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/integrals/rubi/parsetools/generate_tests.py
--rw-rw-rw-   0        0        0    27693 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/integrals/rubi/parsetools/parse.py
--rw-rw-rw-   0        0        0     8098 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/integrals/rubi/rubimain.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:19:59.654699 sympy.keras-1.0.21/sympy/integrals/rubi/rules/
--rw-rw-rw-   0        0        0        0 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/integrals/rubi/rules/__init__.py
--rw-rw-rw-   0        0        0   211338 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/integrals/rubi/rules/binomial_products.py
--rw-rw-rw-   0        0        0    66356 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/integrals/rubi/rules/exponential.py
--rw-rw-rw-   0        0        0   231936 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/integrals/rubi/rules/hyperbolic.py
--rw-rw-rw-   0        0        0    23847 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/integrals/rubi/rules/integrand_simplification.py
--rw-rw-rw-   0        0        0   372022 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/integrals/rubi/rules/inverse_hyperbolic.py
--rw-rw-rw-   0        0        0   337025 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/integrals/rubi/rules/inverse_trig.py
--rw-rw-rw-   0        0        0    95965 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/integrals/rubi/rules/linear_products.py
--rw-rw-rw-   0        0        0   103333 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/integrals/rubi/rules/logarithms.py
--rw-rw-rw-   0        0        0   247667 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/integrals/rubi/rules/miscellaneous_algebraic.py
--rw-rw-rw-   0        0        0    54467 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/integrals/rubi/rules/miscellaneous_integration.py
--rw-rw-rw-   0        0        0   201340 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/integrals/rubi/rules/miscellaneous_trig.py
--rw-rw-rw-   0        0        0    21166 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/integrals/rubi/rules/piecewise_linear.py
--rw-rw-rw-   0        0        0   332737 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/integrals/rubi/rules/quadratic_products.py
--rw-rw-rw-   0        0        0   474580 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/integrals/rubi/rules/secant.py
--rw-rw-rw-   0        0        0   772009 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/integrals/rubi/rules/sine.py
--rw-rw-rw-   0        0        0    95525 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/integrals/rubi/rules/special_functions.py
--rw-rw-rw-   0        0        0   330601 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/integrals/rubi/rules/tangent.py
--rw-rw-rw-   0        0        0   256579 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/integrals/rubi/rules/trinomial_products.py
--rw-rw-rw-   0        0        0     1601 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/integrals/rubi/symbol.py
--rw-rw-rw-   0        0        0   270158 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/integrals/rubi/utility_function.py
--rw-rw-rw-   0        0        0     2303 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/integrals/singularityfunctions.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:19:59.756325 sympy.keras-1.0.21/sympy/integrals/tests/
--rw-rw-rw-   0        0        0        0 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/integrals/tests/__init__.py
--rw-rw-rw-   0        0        0     3709 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/integrals/tests/test_deltafunctions.py
--rw-rw-rw-   0        0        0     7074 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/integrals/tests/test_failing_integrals.py
--rw-rw-rw-   0        0        0    12468 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/integrals/tests/test_heurisch.py
--rw-rw-rw-   0        0        0    77228 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/integrals/tests/test_integrals.py
--rw-rw-rw-   0        0        0    37445 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/integrals/tests/test_intpoly.py
--rw-rw-rw-   0        0        0    29773 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/integrals/tests/test_laplace.py
--rw-rw-rw-   0        0        0      450 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/integrals/tests/test_lineintegrals.py
--rw-rw-rw-   0        0        0    34005 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/integrals/tests/test_manual.py
--rw-rw-rw-   0        0        0    32265 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/integrals/tests/test_meijerint.py
--rw-rw-rw-   0        0        0    16360 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/integrals/tests/test_prde.py
--rw-rw-rw-   0        0        0    19919 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/integrals/tests/test_quadrature.py
--rw-rw-rw-   0        0        0     5299 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/integrals/tests/test_rationaltools.py
--rw-rw-rw-   0        0        0     9571 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/integrals/tests/test_rde.py
--rw-rw-rw-   0        0        0    38630 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/integrals/tests/test_risch.py
--rw-rw-rw-   0        0        0     1266 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/integrals/tests/test_singularityfunctions.py
--rw-rw-rw-   0        0        0    27077 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/integrals/tests/test_transforms.py
--rw-rw-rw-   0        0        0     3869 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/integrals/tests/test_trigonometry.py
--rw-rw-rw-   0        0        0    63435 2023-04-18 11:57:18.000000 sympy.keras-1.0.21/sympy/integrals/transforms.py
--rw-rw-rw-   0        0        0    11077 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/integrals/trigonometry.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:19:59.777661 sympy.keras-1.0.21/sympy/interactive/
--rw-rw-rw-   0        0        0      135 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/interactive/__init__.py
--rw-rw-rw-   0        0        0     1736 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/interactive/ipythonprinting.py
--rw-rw-rw-   0        0        0    17695 2022-04-23 13:44:25.000000 sympy.keras-1.0.21/sympy/interactive/printing.py
--rw-rw-rw-   0        0        0    15021 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/interactive/session.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:19:59.788604 sympy.keras-1.0.21/sympy/interactive/tests/
--rw-rw-rw-   0        0        0        0 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/interactive/tests/__init__.py
--rw-rw-rw-   0        0        0      485 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/interactive/tests/test_interactive.py
--rw-rw-rw-   0        0        0    11799 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/interactive/tests/test_ipython.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:19:59.827937 sympy.keras-1.0.21/sympy/keras/
--rw-rw-rw-   0        0        0      298 2023-05-18 13:13:25.000000 sympy.keras-1.0.21/sympy/keras/__init__.py
--rw-rw-rw-   0        0        0      825 2022-10-15 00:39:24.000000 sympy.keras-1.0.21/sympy/keras/context.py
--rw-rw-rw-   0        0        0     1170 2022-10-05 08:31:47.000000 sympy.keras-1.0.21/sympy/keras/linalg.py
--rw-rw-rw-   0        0        0      340 2022-10-05 08:33:14.000000 sympy.keras-1.0.21/sympy/keras/losses.py
--rw-rw-rw-   0        0        0      285 2022-10-05 08:34:43.000000 sympy.keras-1.0.21/sympy/keras/math.py
--rw-rw-rw-   0        0        0     5393 2023-04-19 14:10:01.000000 sympy.keras-1.0.21/sympy/keras/network.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:19:59.836886 sympy.keras-1.0.21/sympy/keras/nn/
--rw-rw-rw-   0        0        0     2813 2023-04-18 11:57:18.000000 sympy.keras-1.0.21/sympy/keras/nn/__init__.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:19:59.841872 sympy.keras-1.0.21/sympy/keras/nn/convolutional/
--rw-rw-rw-   0        0        0        0 2022-10-06 02:34:29.000000 sympy.keras-1.0.21/sympy/keras/nn/convolutional/__init__.py
--rw-rw-rw-   0        0        0     3940 2023-04-18 11:57:18.000000 sympy.keras-1.0.21/sympy/keras/nn/convolutional/same.py
--rw-rw-rw-   0        0        0     2734 2022-09-24 00:48:21.000000 sympy.keras-1.0.21/sympy/keras/nn/functional.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:19:59.878219 sympy.keras-1.0.21/sympy/keras/nn/modules/
--rw-rw-rw-   0        0        0        0 2022-10-06 02:34:29.000000 sympy.keras-1.0.21/sympy/keras/nn/modules/__init__.py
--rw-rw-rw-   0        0        0     1769 2022-10-07 03:09:57.000000 sympy.keras-1.0.21/sympy/keras/nn/modules/classifier.py
--rw-rw-rw-   0        0        0     3850 2022-10-07 03:10:21.000000 sympy.keras-1.0.21/sympy/keras/nn/modules/container.py
--rw-rw-rw-   0        0        0    25145 2022-10-09 09:31:48.000000 sympy.keras-1.0.21/sympy/keras/nn/modules/conv.py
--rw-rw-rw-   0        0        0    14720 2023-04-18 11:57:18.000000 sympy.keras-1.0.21/sympy/keras/nn/modules/module.py
--rw-rw-rw-   0        0        0     3999 2022-10-07 03:23:40.000000 sympy.keras-1.0.21/sympy/keras/nn/modules/normalization.py
--rw-rw-rw-   0        0        0    59799 2023-04-18 11:57:18.000000 sympy.keras-1.0.21/sympy/keras/nn/modules/rnn.py
--rw-rw-rw-   0        0        0      828 2023-04-18 11:57:19.000000 sympy.keras-1.0.21/sympy/keras/nn/modules/sparse.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:19:59.887185 sympy.keras-1.0.21/sympy/keras/nn/recurrent/
--rw-rw-rw-   0        0        0        0 2022-10-06 02:34:29.000000 sympy.keras-1.0.21/sympy/keras/nn/recurrent/__init__.py
--rw-rw-rw-   0        0        0     1380 2023-04-14 12:59:10.000000 sympy.keras-1.0.21/sympy/keras/nn/recurrent/gru.py
--rw-rw-rw-   0        0        0     2139 2023-04-18 11:57:18.000000 sympy.keras-1.0.21/sympy/keras/nn/recurrent/lstm.py
--rw-rw-rw-   0        0        0      182 2022-10-05 08:01:53.000000 sympy.keras-1.0.21/sympy/keras/ops.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:19:59.901148 sympy.keras-1.0.21/sympy/keras/tensorflow/
--rw-rw-rw-   0        0        0     2677 2022-11-05 03:10:25.000000 sympy.keras-1.0.21/sympy/keras/tensorflow/__init__.py
--rw-rw-rw-   0        0        0     3639 2023-04-18 11:57:18.000000 sympy.keras-1.0.21/sympy/keras/tensorflow/hdf5.py
--rw-rw-rw-   0        0        0    12457 2023-04-18 11:57:18.000000 sympy.keras-1.0.21/sympy/keras/tensorflow/optimization.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:19:59.911093 sympy.keras-1.0.21/sympy/keras/torch/
--rw-rw-rw-   0        0        0        0 2022-11-05 01:43:29.000000 sympy.keras-1.0.21/sympy/keras/torch/__init__.py
--rw-rw-rw-   0        0        0     1609 2023-04-18 11:57:18.000000 sympy.keras-1.0.21/sympy/keras/torch/hdf5.py
--rw-rw-rw-   0        0        0     6099 2023-04-18 11:57:18.000000 sympy.keras-1.0.21/sympy/keras/torch/optimization.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:19:59.968967 sympy.keras-1.0.21/sympy/liealgebras/
--rw-rw-rw-   0        0        0       53 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/liealgebras/__init__.py
--rw-rw-rw-   0        0        0      524 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/liealgebras/cartan_matrix.py
--rw-rw-rw-   0        0        0     1793 2022-04-23 13:44:25.000000 sympy.keras-1.0.21/sympy/liealgebras/cartan_type.py
--rw-rw-rw-   0        0        0      535 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/liealgebras/dynkin_diagram.py
--rw-rw-rw-   0        0        0     6850 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/liealgebras/root_system.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:20:00.019501 sympy.keras-1.0.21/sympy/liealgebras/tests/
--rw-rw-rw-   0        0        0        0 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/liealgebras/tests/__init__.py
--rw-rw-rw-   0        0        0      303 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/liealgebras/tests/test_cartan_matrix.py
--rw-rw-rw-   0        0        0      339 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/liealgebras/tests/test_cartan_type.py
--rw-rw-rw-   0        0        0      260 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/liealgebras/tests/test_dynkin_diagram.py
--rw-rw-rw-   0        0        0      927 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/liealgebras/tests/test_root_system.py
--rw-rw-rw-   0        0        0      657 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/liealgebras/tests/test_type_A.py
--rw-rw-rw-   0        0        0      642 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/liealgebras/tests/test_type_B.py
--rw-rw-rw-   0        0        0      927 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/liealgebras/tests/test_type_C.py
--rw-rw-rw-   0        0        0      764 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/liealgebras/tests/test_type_D.py
--rw-rw-rw-   0        0        0      775 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/liealgebras/tests/test_type_E.py
--rw-rw-rw-   0        0        0     1378 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/liealgebras/tests/test_type_F.py
--rw-rw-rw-   0        0        0      548 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/liealgebras/tests/test_type_G.py
--rw-rw-rw-   0        0        0     1501 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/liealgebras/tests/test_weyl_group.py
--rw-rw-rw-   0        0        0     4317 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/liealgebras/type_a.py
--rw-rw-rw-   0        0        0     4565 2022-04-23 13:44:25.000000 sympy.keras-1.0.21/sympy/liealgebras/type_b.py
--rw-rw-rw-   0        0        0     4441 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/liealgebras/type_c.py
--rw-rw-rw-   0        0        0     4695 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/liealgebras/type_d.py
--rw-rw-rw-   0        0        0     9782 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/liealgebras/type_e.py
--rw-rw-rw-   0        0        0     4413 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/liealgebras/type_f.py
--rw-rw-rw-   0        0        0     2965 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/liealgebras/type_g.py
--rw-rw-rw-   0        0        0    14710 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/liealgebras/weyl_group.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:20:00.042091 sympy.keras-1.0.21/sympy/logic/
--rw-rw-rw-   0        0        0      232 2021-10-01 01:55:11.000000 sympy.keras-1.0.21/sympy/logic/__init__.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:20:00.057081 sympy.keras-1.0.21/sympy/logic/algorithms/
--rw-rw-rw-   0        0        0        0 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/logic/algorithms/__init__.py
--rw-rw-rw-   0        0        0     9162 2022-04-23 13:44:25.000000 sympy.keras-1.0.21/sympy/logic/algorithms/dpll.py
--rw-rw-rw-   0        0        0    20466 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/logic/algorithms/dpll2.py
--rw-rw-rw-   0        0        0     1207 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/logic/algorithms/pycosat_wrapper.py
--rw-rw-rw-   0        0        0   121362 2023-05-21 05:35:13.000000 sympy.keras-1.0.21/sympy/logic/boolalg.py
--rw-rw-rw-   0        0        0     7586 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/logic/inference.py
--rw-rw-rw-   0        0        0    19165 2023-06-02 16:05:38.000000 sympy.keras-1.0.21/sympy/logic/invoker.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:20:00.074036 sympy.keras-1.0.21/sympy/logic/tests/
--rw-rw-rw-   0        0        0        0 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/logic/tests/__init__.py
--rw-rw-rw-   0        0        0    48834 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/logic/tests/test_boolalg.py
--rw-rw-rw-   0        0        0     3886 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/logic/tests/test_dimacs.py
--rw-rw-rw-   0        0        0    13246 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/logic/tests/test_inference.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:20:00.082015 sympy.keras-1.0.21/sympy/logic/utilities/
--rw-rw-rw-   0        0        0       30 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/logic/utilities/__init__.py
--rw-rw-rw-   0        0        0     1663 2022-04-23 13:44:25.000000 sympy.keras-1.0.21/sympy/logic/utilities/dimacs.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:20:00.197545 sympy.keras-1.0.21/sympy/matrices/
--rw-rw-rw-   0        0        0     1284 2021-10-09 13:08:45.000000 sympy.keras-1.0.21/sympy/matrices/__init__.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:20:00.202535 sympy.keras-1.0.21/sympy/matrices/benchmarks/
--rw-rw-rw-   0        0        0        0 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/matrices/benchmarks/__init__.py
--rw-rw-rw-   0        0        0      306 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/matrices/benchmarks/bench_matrix.py
--rw-rw-rw-   0        0        0    75008 2023-05-01 10:14:12.000000 sympy.keras-1.0.21/sympy/matrices/common.py
--rw-rw-rw-   0        0        0    41139 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/matrices/decompositions.py
--rw-rw-rw-   0        0        0    47147 2023-04-18 11:57:18.000000 sympy.keras-1.0.21/sympy/matrices/dense.py
--rw-rw-rw-   0        0        0     5486 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/matrices/densearith.py
--rw-rw-rw-   0        0        0    11737 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/matrices/densesolve.py
--rw-rw-rw-   0        0        0     5490 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/matrices/densetools.py
--rw-rw-rw-   0        0        0    27950 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/matrices/determinant.py
--rw-rw-rw-   0        0        0    37867 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/matrices/eigen.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:20:00.327497 sympy.keras-1.0.21/sympy/matrices/expressions/
--rw-rw-rw-   0        0        0      945 2021-10-09 13:08:45.000000 sympy.keras-1.0.21/sympy/matrices/expressions/__init__.py
--rw-rw-rw-   0        0        0     2415 2023-05-01 17:01:38.000000 sympy.keras-1.0.21/sympy/matrices/expressions/adjoint.py
--rw-rw-rw-   0        0        0     5029 2022-10-05 05:30:03.000000 sympy.keras-1.0.21/sympy/matrices/expressions/applyfunc.py
--rw-rw-rw-   0        0        0    35366 2023-04-30 01:13:43.000000 sympy.keras-1.0.21/sympy/matrices/expressions/blockmatrix.py
--rw-rw-rw-   0        0        0     1411 2022-10-03 03:30:25.000000 sympy.keras-1.0.21/sympy/matrices/expressions/cofactor.py
--rw-rw-rw-   0        0        0     1745 2022-10-03 03:31:46.000000 sympy.keras-1.0.21/sympy/matrices/expressions/companion.py
--rw-rw-rw-   0        0        0     3283 2023-03-24 13:15:58.000000 sympy.keras-1.0.21/sympy/matrices/expressions/determinant.py
--rw-rw-rw-   0        0        0     6003 2022-10-03 03:32:26.000000 sympy.keras-1.0.21/sympy/matrices/expressions/diagonal.py
--rw-rw-rw-   0        0        0     1960 2022-04-23 13:44:25.000000 sympy.keras-1.0.21/sympy/matrices/expressions/dotproduct.py
--rw-rw-rw-   0        0        0     1064 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/matrices/expressions/factorizations.py
--rw-rw-rw-   0        0        0      647 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/matrices/expressions/fourier.py
--rw-rw-rw-   0        0        0     1392 2023-04-20 12:34:58.000000 sympy.keras-1.0.21/sympy/matrices/expressions/funcmatrix.py
--rw-rw-rw-   0        0        0    10081 2022-10-03 03:33:44.000000 sympy.keras-1.0.21/sympy/matrices/expressions/hadamard.py
--rw-rw-rw-   0        0        0     2711 2023-05-01 06:09:46.000000 sympy.keras-1.0.21/sympy/matrices/expressions/inverse.py
--rw-rw-rw-   0        0        0    13323 2023-05-01 10:08:15.000000 sympy.keras-1.0.21/sympy/matrices/expressions/kronecker.py
--rw-rw-rw-   0        0        0    61402 2023-05-26 13:32:03.000000 sympy.keras-1.0.21/sympy/matrices/expressions/matexpr.py
--rw-rw-rw-   0        0        0    34618 2023-05-10 13:21:00.000000 sympy.keras-1.0.21/sympy/matrices/expressions/matmul.py
--rw-rw-rw-   0        0        0     7435 2023-05-01 06:09:57.000000 sympy.keras-1.0.21/sympy/matrices/expressions/matpow.py
--rw-rw-rw-   0        0        0     1354 2022-10-03 03:42:34.000000 sympy.keras-1.0.21/sympy/matrices/expressions/minors.py
--rw-rw-rw-   0        0        0     8085 2023-03-24 13:15:58.000000 sympy.keras-1.0.21/sympy/matrices/expressions/permutation.py
--rw-rw-rw-   0        0        0     1887 2022-10-03 03:45:13.000000 sympy.keras-1.0.21/sympy/matrices/expressions/sets.py
--rw-rw-rw-   0        0        0     3351 2023-04-29 02:06:43.000000 sympy.keras-1.0.21/sympy/matrices/expressions/slice.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:20:00.435209 sympy.keras-1.0.21/sympy/matrices/expressions/tests/
--rw-rw-rw-   0        0        0        0 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/matrices/expressions/tests/__init__.py
--rw-rw-rw-   0        0        0     1065 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/matrices/expressions/tests/test_adjoint.py
--rw-rw-rw-   0        0        0     3522 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/matrices/expressions/tests/test_applyfunc.py
--rw-rw-rw-   0        0        0    15959 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/matrices/expressions/tests/test_blockmatrix.py
--rw-rw-rw-   0        0        0     1657 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/matrices/expressions/tests/test_companion.py
--rw-rw-rw-   0        0        0    15991 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/matrices/expressions/tests/test_derivatives.py
--rw-rw-rw-   0        0        0     1989 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/matrices/expressions/tests/test_determinant.py
--rw-rw-rw-   0        0        0     4516 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/matrices/expressions/tests/test_diagonal.py
--rw-rw-rw-   0        0        0     1171 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/matrices/expressions/tests/test_dotproduct.py
--rw-rw-rw-   0        0        0      786 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/matrices/expressions/tests/test_factorizations.py
--rw-rw-rw-   0        0        0     1638 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/matrices/expressions/tests/test_fourier.py
--rw-rw-rw-   0        0        0     2381 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/matrices/expressions/tests/test_funcmatrix.py
--rw-rw-rw-   0        0        0     4610 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/matrices/expressions/tests/test_hadamard.py
--rw-rw-rw-   0        0        0    12038 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/matrices/expressions/tests/test_indexing.py
--rw-rw-rw-   0        0        0     2060 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/matrices/expressions/tests/test_inverse.py
--rw-rw-rw-   0        0        0     5366 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/matrices/expressions/tests/test_kronecker.py
--rw-rw-rw-   0        0        0     1862 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/matrices/expressions/tests/test_matadd.py
--rw-rw-rw-   0        0        0    17762 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/matrices/expressions/tests/test_matexpr.py
--rw-rw-rw-   0        0        0     5963 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/matrices/expressions/tests/test_matmul.py
--rw-rw-rw-   0        0        0     7304 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/matrices/expressions/tests/test_matpow.py
--rw-rw-rw-   0        0        0     5607 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/matrices/expressions/tests/test_permutation.py
--rw-rw-rw-   0        0        0     1410 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/matrices/expressions/tests/test_sets.py
--rw-rw-rw-   0        0        0     2027 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/matrices/expressions/tests/test_slice.py
--rw-rw-rw-   0        0        0     6496 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/matrices/expressions/tests/test_special.py
--rw-rw-rw-   0        0        0     3383 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/matrices/expressions/tests/test_trace.py
--rw-rw-rw-   0        0        0     1987 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/matrices/expressions/tests/test_transpose.py
--rw-rw-rw-   0        0        0     3601 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/matrices/expressions/trace.py
--rw-rw-rw-   0        0        0    11062 2023-05-01 10:09:52.000000 sympy.keras-1.0.21/sympy/matrices/expressions/transpose.py
--rw-rw-rw-   0        0        0     2979 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/matrices/graph.py
--rw-rw-rw-   0        0        0     5991 2022-10-03 03:48:35.000000 sympy.keras-1.0.21/sympy/matrices/immutable.py
--rw-rw-rw-   0        0        0    11376 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/matrices/inverse.py
--rw-rw-rw-   0        0        0   173295 2023-04-10 14:00:42.000000 sympy.keras-1.0.21/sympy/matrices/matrices.py
--rw-rw-rw-   0        0        0     4460 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/matrices/normalforms.py
--rw-rw-rw-   0        0        0    10179 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/matrices/reductions.py
--rw-rw-rw-   0        0        0    22092 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/matrices/solvers.py
--rw-rw-rw-   0        0        0    43638 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/matrices/sparse.py
--rw-rw-rw-   0        0        0     8671 2022-04-23 13:44:25.000000 sympy.keras-1.0.21/sympy/matrices/sparsetools.py
--rw-rw-rw-   0        0        0     4347 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/matrices/subspaces.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:20:00.508790 sympy.keras-1.0.21/sympy/matrices/tests/
--rw-rw-rw-   0        0        0        0 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/matrices/tests/__init__.py
--rw-rw-rw-   0        0        0    38564 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/matrices/tests/test_commonmatrix.py
--rw-rw-rw-   0        0        0    14417 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/matrices/tests/test_decompositions.py
--rw-rw-rw-   0        0        0    13350 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/matrices/tests/test_determinant.py
--rw-rw-rw-   0        0        0    22773 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/matrices/tests/test_eigen.py
--rw-rw-rw-   0        0        0     3213 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/matrices/tests/test_graph.py
--rw-rw-rw-   0        0        0     4616 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/matrices/tests/test_immutable.py
--rw-rw-rw-   0        0        0     2066 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/matrices/tests/test_interactions.py
--rw-rw-rw-   0        0        0   145261 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/matrices/tests/test_matrices.py
--rw-rw-rw-   0        0        0     3009 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/matrices/tests/test_normalforms.py
--rw-rw-rw-   0        0        0    13951 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/matrices/tests/test_reductions.py
--rw-rw-rw-   0        0        0    20769 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/matrices/tests/test_solvers.py
--rw-rw-rw-   0        0        0    23281 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/matrices/tests/test_sparse.py
--rw-rw-rw-   0        0        0     4877 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/matrices/tests/test_sparsetools.py
--rw-rw-rw-   0        0        0     3839 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/matrices/tests/test_subspaces.py
--rw-rw-rw-   0        0        0     1823 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/matrices/utilities.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:20:00.531185 sympy.keras-1.0.21/sympy/multipledispatch/
--rw-rw-rw-   0        0        0      147 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/multipledispatch/__init__.py
--rw-rw-rw-   0        0        0     2128 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/multipledispatch/conflict.py
--rw-rw-rw-   0        0        0     2275 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/multipledispatch/core.py
--rw-rw-rw-   0        0        0    12235 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/multipledispatch/dispatcher.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:20:00.545177 sympy.keras-1.0.21/sympy/multipledispatch/tests/
--rw-rw-rw-   0        0        0        0 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/multipledispatch/tests/__init__.py
--rw-rw-rw-   0        0        0     1786 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/multipledispatch/tests/test_conflict.py
--rw-rw-rw-   0        0        0     4048 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/multipledispatch/tests/test_core.py
--rw-rw-rw-   0        0        0     6228 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/multipledispatch/tests/test_dispatcher.py
--rw-rw-rw-   0        0        0     3053 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/multipledispatch/utils.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:20:00.627609 sympy.keras-1.0.21/sympy/ntheory/
--rw-rw-rw-   0        0        0     1176 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/ntheory/__init__.py
--rw-rw-rw-   0        0        0     5213 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/ntheory/bbp_pi.py
--rw-rw-rw-   0        0        0    10425 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/ntheory/continued_fraction.py
--rw-rw-rw-   0        0        0     3692 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/ntheory/digits.py
--rw-rw-rw-   0        0        0    10161 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/ntheory/ecm.py
--rw-rw-rw-   0        0        0     6069 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/ntheory/egyptian_fraction.py
--rw-rw-rw-   0        0        0    11473 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/ntheory/elliptic_curve.py
--rw-rw-rw-   0        0        0    63259 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/ntheory/factor_.py
--rw-rw-rw-   0        0        0    28570 2022-04-23 13:44:25.000000 sympy.keras-1.0.21/sympy/ntheory/generate.py
--rw-rw-rw-   0        0        0     7655 2022-04-23 13:44:25.000000 sympy.keras-1.0.21/sympy/ntheory/modular.py
--rw-rw-rw-   0        0        0     5103 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/ntheory/multinomial.py
--rw-rw-rw-   0        0        0     5944 2023-04-10 14:00:42.000000 sympy.keras-1.0.21/sympy/ntheory/partitions_.py
--rw-rw-rw-   0        0        0    18943 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/ntheory/primetest.py
--rw-rw-rw-   0        0        0    18450 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/ntheory/qs.py
--rw-rw-rw-   0        0        0    32962 2022-04-23 13:44:25.000000 sympy.keras-1.0.21/sympy/ntheory/residue_ntheory.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:20:00.690458 sympy.keras-1.0.21/sympy/ntheory/tests/
--rw-rw-rw-   0        0        0        0 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/ntheory/tests/__init__.py
--rw-rw-rw-   0        0        0     9433 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/ntheory/tests/test_bbp_pi.py
--rw-rw-rw-   0        0        0     3583 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/ntheory/tests/test_continued_fraction.py
--rw-rw-rw-   0        0        0     1176 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/ntheory/tests/test_digits.py
--rw-rw-rw-   0        0        0     2290 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/ntheory/tests/test_ecm.py
--rw-rw-rw-   0        0        0     2378 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/ntheory/tests/test_egyptian_fraction.py
--rw-rw-rw-   0        0        0      624 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/ntheory/tests/test_elliptic_curve.py
--rw-rw-rw-   0        0        0    25024 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/ntheory/tests/test_factor_.py
--rw-rw-rw-   0        0        0     8069 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/ntheory/tests/test_generate.py
--rw-rw-rw-   0        0        0     1425 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/ntheory/tests/test_modular.py
--rw-rw-rw-   0        0        0     2344 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/ntheory/tests/test_multinomial.py
--rw-rw-rw-   0        0        0      507 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/ntheory/tests/test_partitions.py
--rw-rw-rw-   0        0        0     7062 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/ntheory/tests/test_primetest.py
--rw-rw-rw-   0        0        0     4481 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/ntheory/tests/test_qs.py
--rw-rw-rw-   0        0        0    15208 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/ntheory/tests/test_residue.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:20:00.723623 sympy.keras-1.0.21/sympy/parsing/
--rw-rw-rw-   0        0        0       99 2023-04-10 14:00:43.000000 sympy.keras-1.0.21/sympy/parsing/__init__.py
--rw-rw-rw-   0        0        0     2803 2022-08-14 11:13:22.000000 sympy.keras-1.0.21/sympy/parsing/ast_parser.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:20:00.748555 sympy.keras-1.0.21/sympy/parsing/autolev/
--rw-rw-rw-   0        0        0     3708 2022-08-14 11:13:22.000000 sympy.keras-1.0.21/sympy/parsing/autolev/__init__.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:20:00.769499 sympy.keras-1.0.21/sympy/parsing/autolev/_antlr/
--rw-rw-rw-   0        0        0      203 2022-08-14 11:17:19.000000 sympy.keras-1.0.21/sympy/parsing/autolev/_antlr/__init__.py
--rw-rw-rw-   0        0        0    13607 2022-08-14 11:17:45.000000 sympy.keras-1.0.21/sympy/parsing/autolev/_antlr/autolevlexer.py
--rw-rw-rw-   0        0        0    12821 2022-08-14 11:18:31.000000 sympy.keras-1.0.21/sympy/parsing/autolev/_antlr/autolevlistener.py
--rw-rw-rw-   0        0        0   111788 2022-08-14 11:13:22.000000 sympy.keras-1.0.21/sympy/parsing/autolev/_antlr/autolevparser.py
--rw-rw-rw-   0        0        0     2676 2022-08-14 11:13:22.000000 sympy.keras-1.0.21/sympy/parsing/autolev/_build_autolev_antlr.py
--rw-rw-rw-   0        0        0   106841 2021-06-29 22:51:23.000000 sympy.keras-1.0.21/sympy/parsing/autolev/_listener_autolev_antlr.py
--rw-rw-rw-   0        0        0     1761 2022-08-14 11:13:22.000000 sympy.keras-1.0.21/sympy/parsing/autolev/_parse_autolev_antlr.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:20:00.779472 sympy.keras-1.0.21/sympy/parsing/c/
--rw-rw-rw-   0        0        0       65 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/parsing/c/__init__.py
--rw-rw-rw-   0        0        0    40449 2022-08-14 11:13:22.000000 sympy.keras-1.0.21/sympy/parsing/c/c_parser.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:20:00.789445 sympy.keras-1.0.21/sympy/parsing/fortran/
--rw-rw-rw-   0        0        0       74 2021-01-28 01:12:36.000000 sympy.keras-1.0.21/sympy/parsing/fortran/__init__.py
--rw-rw-rw-   0        0        0    11828 2022-08-14 11:13:22.000000 sympy.keras-1.0.21/sympy/parsing/fortran/fortran_parser.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:20:00.811389 sympy.keras-1.0.21/sympy/parsing/latex/
--rw-rw-rw-   0        0        0     1026 2020-08-27 18:42:07.000000 sympy.keras-1.0.21/sympy/parsing/latex/__init__.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:20:00.829339 sympy.keras-1.0.21/sympy/parsing/latex/_antlr/
--rw-rw-rw-   0        0        0      393 2022-08-14 11:13:22.000000 sympy.keras-1.0.21/sympy/parsing/latex/_antlr/__init__.py
--rw-rw-rw-   0        0        0    31012 2022-08-14 11:13:22.000000 sympy.keras-1.0.21/sympy/parsing/latex/_antlr/latexlexer.py
--rw-rw-rw-   0        0        0   133802 2022-08-14 11:13:22.000000 sympy.keras-1.0.21/sympy/parsing/latex/_antlr/latexparser.py
--rw-rw-rw-   0        0        0     2868 2022-08-14 11:13:22.000000 sympy.keras-1.0.21/sympy/parsing/latex/_build_latex_antlr.py
--rw-rw-rw-   0        0        0    20442 2023-04-10 14:00:42.000000 sympy.keras-1.0.21/sympy/parsing/latex/_parse_latex_antlr.py
--rw-rw-rw-   0        0        0       45 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/parsing/latex/errors.py
--rw-rw-rw-   0        0        0    40265 2022-08-14 11:13:22.000000 sympy.keras-1.0.21/sympy/parsing/mathematica.py
--rw-rw-rw-   0        0        0     1906 2022-08-14 11:13:22.000000 sympy.keras-1.0.21/sympy/parsing/maxima.py
--rw-rw-rw-   0        0        0     9173 2022-08-14 11:13:22.000000 sympy.keras-1.0.21/sympy/parsing/sym_expr.py
--rw-rw-rw-   0        0        0    44245 2022-08-14 11:13:22.000000 sympy.keras-1.0.21/sympy/parsing/sympy_parser.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:20:00.892998 sympy.keras-1.0.21/sympy/parsing/tests/
--rw-rw-rw-   0        0        0        0 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/parsing/tests/__init__.py
--rw-rw-rw-   0        0        0      803 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/parsing/tests/test_ast_parser.py
--rw-rw-rw-   0        0        0     6647 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/parsing/tests/test_autolev.py
--rw-rw-rw-   0        0        0   155354 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/parsing/tests/test_c_parser.py
--rw-rw-rw-   0        0        0    11828 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/parsing/tests/test_fortran_parser.py
--rw-rw-rw-   0        0        0     7448 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/parsing/tests/test_implicit_multiplication_application.py
--rw-rw-rw-   0        0        0    11503 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/parsing/tests/test_latex.py
--rw-rw-rw-   0        0        0      426 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/parsing/tests/test_latex_deps.py
--rw-rw-rw-   0        0        0    13166 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/parsing/tests/test_mathematica.py
--rw-rw-rw-   0        0        0     1987 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/parsing/tests/test_maxima.py
--rw-rw-rw-   0        0        0     5668 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/parsing/tests/test_sym_expr.py
--rw-rw-rw-   0        0        0    12253 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/parsing/tests/test_sympy_parser.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:20:00.944930 sympy.keras-1.0.21/sympy/physics/
--rw-rw-rw-   0        0        0      138 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/physics/__init__.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:20:00.956867 sympy.keras-1.0.21/sympy/physics/continuum_mechanics/
--rw-rw-rw-   0        0        0       23 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/physics/continuum_mechanics/__init__.py
--rw-rw-rw-   0        0        0    81736 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/physics/continuum_mechanics/beam.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:20:00.968834 sympy.keras-1.0.21/sympy/physics/control/
--rw-rw-rw-   0        0        0       61 2023-04-10 14:00:42.000000 sympy.keras-1.0.21/sympy/physics/control/__init__.py
--rw-rw-rw-   0        0        0    41769 2023-04-10 14:00:42.000000 sympy.keras-1.0.21/sympy/physics/control/lti.py
--rw-rw-rw-   0        0        0      556 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/physics/gaussopt.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:20:00.974855 sympy.keras-1.0.21/sympy/physics/hep/
--rw-rw-rw-   0        0        0        0 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/physics/hep/__init__.py
--rw-rw-rw-   0        0        0    24138 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/physics/hep/gamma_matrices.py
--rw-rw-rw-   0        0        0     6424 2022-04-23 13:44:25.000000 sympy.keras-1.0.21/sympy/physics/hydrogen.py
--rw-rw-rw-   0        0        0     4051 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/physics/matrices.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:20:01.024700 sympy.keras-1.0.21/sympy/physics/mechanics/
--rw-rw-rw-   0        0        0      483 2023-04-10 14:00:42.000000 sympy.keras-1.0.21/sympy/physics/mechanics/__init__.py
--rw-rw-rw-   0        0        0     7656 2023-04-10 14:00:42.000000 sympy.keras-1.0.21/sympy/physics/mechanics/body.py
--rw-rw-rw-   0        0        0    22849 2023-04-10 14:00:42.000000 sympy.keras-1.0.21/sympy/physics/mechanics/functions.py
--rw-rw-rw-   0        0        0    27354 2023-04-10 14:00:42.000000 sympy.keras-1.0.21/sympy/physics/mechanics/kane.py
--rw-rw-rw-   0        0        0    17999 2023-04-10 14:00:42.000000 sympy.keras-1.0.21/sympy/physics/mechanics/lagrange.py
--rw-rw-rw-   0        0        0    15396 2023-04-10 14:00:42.000000 sympy.keras-1.0.21/sympy/physics/mechanics/linearize.py
--rw-rw-rw-   0        0        0     6458 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/physics/mechanics/models.py
--rw-rw-rw-   0        0        0     5852 2023-04-10 14:00:42.000000 sympy.keras-1.0.21/sympy/physics/mechanics/particle.py
--rw-rw-rw-   0        0        0     9013 2023-04-10 14:00:42.000000 sympy.keras-1.0.21/sympy/physics/mechanics/rigidbody.py
--rw-rw-rw-   0        0        0    18633 2023-04-10 14:00:43.000000 sympy.keras-1.0.21/sympy/physics/mechanics/system.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:20:01.053629 sympy.keras-1.0.21/sympy/physics/optics/
--rw-rw-rw-   0        0        0      559 2023-04-10 14:00:42.000000 sympy.keras-1.0.21/sympy/physics/optics/__init__.py
--rw-rw-rw-   0        0        0    19619 2023-04-10 14:00:42.000000 sympy.keras-1.0.21/sympy/physics/optics/gaussopt.py
--rw-rw-rw-   0        0        0     5457 2023-04-10 14:00:42.000000 sympy.keras-1.0.21/sympy/physics/optics/medium.py
--rw-rw-rw-   0        0        0    21164 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/physics/optics/polarization.py
--rw-rw-rw-   0        0        0    21194 2023-04-10 14:00:42.000000 sympy.keras-1.0.21/sympy/physics/optics/utils.py
--rw-rw-rw-   0        0        0     8806 2023-04-10 14:00:42.000000 sympy.keras-1.0.21/sympy/physics/optics/waves.py
--rw-rw-rw-   0        0        0     5745 2023-04-10 14:00:43.000000 sympy.keras-1.0.21/sympy/physics/paulialgebra.py
--rw-rw-rw-   0        0        0     2000 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/physics/pring.py
--rw-rw-rw-   0        0        0     1961 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/physics/qho_1d.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:20:01.230448 sympy.keras-1.0.21/sympy/physics/quantum/
--rw-rw-rw-   0        0        0      705 2023-04-10 14:00:42.000000 sympy.keras-1.0.21/sympy/physics/quantum/__init__.py
--rw-rw-rw-   0        0        0     4239 2023-04-10 14:00:42.000000 sympy.keras-1.0.21/sympy/physics/quantum/anticommutator.py
--rw-rw-rw-   0        0        0     5978 2023-04-10 14:00:42.000000 sympy.keras-1.0.21/sympy/physics/quantum/boson.py
--rw-rw-rw-   0        0        0     8464 2023-04-10 14:00:43.000000 sympy.keras-1.0.21/sympy/physics/quantum/cartesian.py
--rw-rw-rw-   0        0        0    22343 2023-04-10 14:00:42.000000 sympy.keras-1.0.21/sympy/physics/quantum/cg.py
--rw-rw-rw-   0        0        0    12792 2023-04-10 14:00:42.000000 sympy.keras-1.0.21/sympy/physics/quantum/circuitplot.py
--rw-rw-rw-   0        0        0    13504 2023-04-10 14:00:42.000000 sympy.keras-1.0.21/sympy/physics/quantum/circuitutils.py
--rw-rw-rw-   0        0        0     6435 2023-04-10 14:00:43.000000 sympy.keras-1.0.21/sympy/physics/quantum/commutator.py
--rw-rw-rw-   0        0        0     1439 2023-04-10 14:00:42.000000 sympy.keras-1.0.21/sympy/physics/quantum/constants.py
--rw-rw-rw-   0        0        0     2167 2023-04-10 14:00:42.000000 sympy.keras-1.0.21/sympy/physics/quantum/dagger.py
--rw-rw-rw-   0        0        0     9792 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/physics/quantum/density.py
--rw-rw-rw-   0        0        0     4404 2023-04-10 14:00:42.000000 sympy.keras-1.0.21/sympy/physics/quantum/fermion.py
--rw-rw-rw-   0        0        0    41297 2023-04-10 14:00:42.000000 sympy.keras-1.0.21/sympy/physics/quantum/gate.py
--rw-rw-rw-   0        0        0     9692 2023-04-10 14:00:42.000000 sympy.keras-1.0.21/sympy/physics/quantum/grover.py
--rw-rw-rw-   0        0        0    19311 2023-04-10 14:00:42.000000 sympy.keras-1.0.21/sympy/physics/quantum/hilbert.py
--rw-rw-rw-   0        0        0    27060 2023-04-10 14:00:42.000000 sympy.keras-1.0.21/sympy/physics/quantum/identitysearch.py
--rw-rw-rw-   0        0        0     4178 2023-04-10 14:00:42.000000 sympy.keras-1.0.21/sympy/physics/quantum/innerproduct.py
--rw-rw-rw-   0        0        0     3470 2022-04-23 13:44:25.000000 sympy.keras-1.0.21/sympy/physics/quantum/matrixcache.py
--rw-rw-rw-   0        0        0     8162 2023-04-10 14:00:42.000000 sympy.keras-1.0.21/sympy/physics/quantum/matrixutils.py
--rw-rw-rw-   0        0        0    18869 2023-04-10 14:00:42.000000 sympy.keras-1.0.21/sympy/physics/quantum/operator.py
--rw-rw-rw-   0        0        0    11444 2023-04-10 14:00:42.000000 sympy.keras-1.0.21/sympy/physics/quantum/operatorordering.py
--rw-rw-rw-   0        0        0     9365 2023-04-10 14:00:43.000000 sympy.keras-1.0.21/sympy/physics/quantum/operatorset.py
--rw-rw-rw-   0        0        0    17138 2023-04-10 14:00:43.000000 sympy.keras-1.0.21/sympy/physics/quantum/pauli.py
--rw-rw-rw-   0        0        0     1639 2023-04-10 14:00:43.000000 sympy.keras-1.0.21/sympy/physics/quantum/piab.py
--rw-rw-rw-   0        0        0     6994 2023-04-10 14:00:42.000000 sympy.keras-1.0.21/sympy/physics/quantum/qapply.py
--rw-rw-rw-   0        0        0     6268 2023-04-10 14:00:42.000000 sympy.keras-1.0.21/sympy/physics/quantum/qasm.py
--rw-rw-rw-   0        0        0    14122 2023-04-10 14:00:42.000000 sympy.keras-1.0.21/sympy/physics/quantum/qexpr.py
--rw-rw-rw-   0        0        0     6145 2023-04-10 14:00:42.000000 sympy.keras-1.0.21/sympy/physics/quantum/qft.py
--rw-rw-rw-   0        0        0    25447 2023-04-10 14:00:43.000000 sympy.keras-1.0.21/sympy/physics/quantum/qubit.py
--rw-rw-rw-   0        0        0    17731 2023-04-10 14:00:42.000000 sympy.keras-1.0.21/sympy/physics/quantum/represent.py
--rw-rw-rw-   0        0        0    21077 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/physics/quantum/sho1d.py
--rw-rw-rw-   0        0        0     5709 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/physics/quantum/shor.py
--rw-rw-rw-   0        0        0    72354 2023-04-10 14:00:42.000000 sympy.keras-1.0.21/sympy/physics/quantum/spin.py
--rw-rw-rw-   0        0        0    28942 2023-04-10 14:00:42.000000 sympy.keras-1.0.21/sympy/physics/quantum/state.py
--rw-rw-rw-   0        0        0    14596 2023-04-10 14:00:42.000000 sympy.keras-1.0.21/sympy/physics/quantum/tensorproduct.py
--rw-rw-rw-   0        0        0    88087 2023-04-10 14:00:42.000000 sympy.keras-1.0.21/sympy/physics/secondquant.py
--rw-rw-rw-   0        0        0     2435 2022-04-23 13:44:25.000000 sympy.keras-1.0.21/sympy/physics/sho.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:20:01.269877 sympy.keras-1.0.21/sympy/physics/tests/
--rw-rw-rw-   0        0        0        0 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/physics/tests/__init__.py
--rw-rw-rw-   0        0        0     8563 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/physics/tests/test_clebsch_gordan.py
--rw-rw-rw-   0        0        0     4987 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/physics/tests/test_hydrogen.py
--rw-rw-rw-   0        0        0     1477 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/physics/tests/test_paulialgebra.py
--rw-rw-rw-   0        0        0     2948 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/physics/tests/test_physics_matrices.py
--rw-rw-rw-   0        0        0     1261 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/physics/tests/test_pring.py
--rw-rw-rw-   0        0        0     1775 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/physics/tests/test_qho_1d.py
--rw-rw-rw-   0        0        0    48450 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/physics/tests/test_secondquant.py
--rw-rw-rw-   0        0        0      693 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/physics/tests/test_sho.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:20:01.298776 sympy.keras-1.0.21/sympy/physics/units/
--rw-rw-rw-   0        0        0     7137 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/physics/units/__init__.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:20:01.311745 sympy.keras-1.0.21/sympy/physics/units/definitions/
--rw-rw-rw-   0        0        0     3320 2023-04-10 14:00:43.000000 sympy.keras-1.0.21/sympy/physics/units/definitions/__init__.py
--rw-rw-rw-   0        0        0     1720 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/physics/units/definitions/dimension_definitions.py
--rw-rw-rw-   0        0        0    13695 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/physics/units/definitions/unit_definitions.py
--rw-rw-rw-   0        0        0    23146 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/physics/units/dimensions.py
--rw-rw-rw-   0        0        0     5871 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/physics/units/prefixes.py
--rw-rw-rw-   0        0        0     9407 2023-04-03 13:20:24.000000 sympy.keras-1.0.21/sympy/physics/units/quantities.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:20:01.338641 sympy.keras-1.0.21/sympy/physics/units/systems/
--rw-rw-rw-   0        0        0      244 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/physics/units/systems/__init__.py
--rw-rw-rw-   0        0        0     3111 2023-04-10 14:00:42.000000 sympy.keras-1.0.21/sympy/physics/units/systems/cgs.py
--rw-rw-rw-   0        0        0     4866 2023-04-10 14:00:42.000000 sympy.keras-1.0.21/sympy/physics/units/systems/length_weight_time.py
--rw-rw-rw-   0        0        0      940 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/physics/units/systems/mks.py
--rw-rw-rw-   0        0        0      811 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/physics/units/systems/mksa.py
--rw-rw-rw-   0        0        0      849 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/physics/units/systems/natural.py
--rw-rw-rw-   0        0        0     1353 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/physics/units/systems/si.py
--rw-rw-rw-   0        0        0     3309 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/physics/units/unitsystem.py
--rw-rw-rw-   0        0        0     7521 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/physics/units/util.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:20:01.380567 sympy.keras-1.0.21/sympy/physics/vector/
--rw-rw-rw-   0        0        0      541 2023-04-10 14:00:42.000000 sympy.keras-1.0.21/sympy/physics/vector/__init__.py
--rw-rw-rw-   0        0        0    18857 2023-04-10 14:00:42.000000 sympy.keras-1.0.21/sympy/physics/vector/dyadic.py
--rw-rw-rw-   0        0        0     8412 2023-04-10 14:00:42.000000 sympy.keras-1.0.21/sympy/physics/vector/fieldfunctions.py
--rw-rw-rw-   0        0        0    31037 2023-04-10 14:00:42.000000 sympy.keras-1.0.21/sympy/physics/vector/frame.py
--rw-rw-rw-   0        0        0    23068 2023-04-10 14:00:43.000000 sympy.keras-1.0.21/sympy/physics/vector/functions.py
--rw-rw-rw-   0        0        0    15081 2023-04-10 14:00:42.000000 sympy.keras-1.0.21/sympy/physics/vector/point.py
--rw-rw-rw-   0        0        0    13692 2023-04-10 14:00:42.000000 sympy.keras-1.0.21/sympy/physics/vector/printing.py
--rw-rw-rw-   0        0        0    24899 2023-04-10 14:00:42.000000 sympy.keras-1.0.21/sympy/physics/vector/vector.py
--rw-rw-rw-   0        0        0    23439 2022-04-23 13:44:25.000000 sympy.keras-1.0.21/sympy/physics/wigner.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:20:01.408646 sympy.keras-1.0.21/sympy/plotting/
--rw-rw-rw-   0        0        0      285 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/plotting/__init__.py
--rw-rw-rw-   0        0        0    26119 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/plotting/experimental_lambdify.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:20:01.427585 sympy.keras-1.0.21/sympy/plotting/intervalmath/
--rw-rw-rw-   0        0        0      261 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/plotting/intervalmath/__init__.py
--rw-rw-rw-   0        0        0    16401 2022-04-23 13:44:25.000000 sympy.keras-1.0.21/sympy/plotting/intervalmath/interval_arithmetic.py
--rw-rw-rw-   0        0        0     2393 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/plotting/intervalmath/interval_membership.py
--rw-rw-rw-   0        0        0    14824 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/plotting/intervalmath/lib_interval.py
--rw-rw-rw-   0        0        0    75997 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/plotting/plot.py
--rw-rw-rw-   0        0        0    14517 2022-04-23 13:44:25.000000 sympy.keras-1.0.21/sympy/plotting/plot_implicit.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:20:01.506356 sympy.keras-1.0.21/sympy/plotting/pygletplot/
--rw-rw-rw-   0        0        0     4252 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/plotting/pygletplot/__init__.py
--rw-rw-rw-   0        0        0    12473 2022-04-23 13:44:25.000000 sympy.keras-1.0.21/sympy/plotting/pygletplot/color_scheme.py
--rw-rw-rw-   0        0        0     3105 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/plotting/pygletplot/managed_window.py
--rw-rw-rw-   0        0        0    13398 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/plotting/pygletplot/plot.py
--rw-rw-rw-   0        0        0     8755 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/plotting/pygletplot/plot_axes.py
--rw-rw-rw-   0        0        0     4009 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/plotting/pygletplot/plot_camera.py
--rw-rw-rw-   0        0        0     6942 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/plotting/pygletplot/plot_controller.py
--rw-rw-rw-   0        0        0     2822 2022-04-23 13:44:25.000000 sympy.keras-1.0.21/sympy/plotting/pygletplot/plot_curve.py
--rw-rw-rw-   0        0        0     5371 2022-04-23 13:44:25.000000 sympy.keras-1.0.21/sympy/plotting/pygletplot/plot_interval.py
--rw-rw-rw-   0        0        0    14113 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/plotting/pygletplot/plot_mode.py
--rw-rw-rw-   0        0        0    11456 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/plotting/pygletplot/plot_mode_base.py
--rw-rw-rw-   0        0        0     5333 2022-04-23 13:44:25.000000 sympy.keras-1.0.21/sympy/plotting/pygletplot/plot_modes.py
--rw-rw-rw-   0        0        0      338 2022-04-23 13:44:25.000000 sympy.keras-1.0.21/sympy/plotting/pygletplot/plot_object.py
--rw-rw-rw-   0        0        0     1447 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/plotting/pygletplot/plot_rotation.py
--rw-rw-rw-   0        0        0     3791 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/plotting/pygletplot/plot_surface.py
--rw-rw-rw-   0        0        0     4850 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/plotting/pygletplot/plot_window.py
--rw-rw-rw-   0        0        0     4610 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/plotting/pygletplot/util.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:20:01.530326 sympy.keras-1.0.21/sympy/plotting/tests/
--rw-rw-rw-   0        0        0        0 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/plotting/tests/__init__.py
--rw-rw-rw-   0        0        0     3127 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/plotting/tests/test_experimental_lambdify.py
--rw-rw-rw-   0        0        0    25204 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/plotting/tests/test_plot.py
--rw-rw-rw-   0        0        0     5804 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/plotting/tests/test_plot_implicit.py
--rw-rw-rw-   0        0        0    12761 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/plotting/tests/test_textplot.py
--rw-rw-rw-   0        0        0     2092 2022-10-01 05:02:59.000000 sympy.keras-1.0.21/sympy/plotting/textplot.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:20:01.773676 sympy.keras-1.0.21/sympy/polys/
--rw-rw-rw-   0        0        0      515 2023-05-02 03:55:50.000000 sympy.keras-1.0.21/sympy/polys/__init__.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:20:01.799895 sympy.keras-1.0.21/sympy/polys/agca/
--rw-rw-rw-   0        0        0      102 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/polys/agca/__init__.py
--rw-rw-rw-   0        0        0     3834 2023-04-10 14:00:42.000000 sympy.keras-1.0.21/sympy/polys/agca/extensions.py
--rw-rw-rw-   0        0        0    21967 2022-04-23 13:44:25.000000 sympy.keras-1.0.21/sympy/polys/agca/homomorphisms.py
--rw-rw-rw-   0        0        0    10810 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/polys/agca/ideals.py
--rw-rw-rw-   0        0        0    46873 2022-04-23 13:44:25.000000 sympy.keras-1.0.21/sympy/polys/agca/modules.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:20:01.820844 sympy.keras-1.0.21/sympy/polys/agca/tests/
--rw-rw-rw-   0        0        0        0 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/polys/agca/tests/__init__.py
--rw-rw-rw-   0        0        0     6455 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/polys/agca/tests/test_extensions.py
--rw-rw-rw-   0        0        0     4224 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/polys/agca/tests/test_homomorphisms.py
--rw-rw-rw-   0        0        0     3788 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/polys/agca/tests/test_ideals.py
--rw-rw-rw-   0        0        0    13552 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/polys/agca/tests/test_modules.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:20:01.841873 sympy.keras-1.0.21/sympy/polys/benchmarks/
--rw-rw-rw-   0        0        0        0 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/polys/benchmarks/__init__.py
--rw-rw-rw-   0        0        0     1502 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/polys/benchmarks/bench_galoispolys.py
--rw-rw-rw-   0        0        0      803 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/polys/benchmarks/bench_groebnertools.py
--rw-rw-rw-   0        0        0   446778 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/polys/benchmarks/bench_solvers.py
--rw-rw-rw-   0        0        0    56467 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/polys/compatibility.py
--rw-rw-rw-   0        0        0     7072 2023-04-18 11:57:18.000000 sympy.keras-1.0.21/sympy/polys/constructor.py
--rw-rw-rw-   0        0        0    33395 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/polys/densearith.py
--rw-rw-rw-   0        0        0    35913 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/polys/densebasic.py
--rw-rw-rw-   0        0        0    25775 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/polys/densetools.py
--rw-rw-rw-   0        0        0     5747 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/polys/dispersion.py
--rw-rw-rw-   0        0        0    21789 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/polys/distributedmodules.py
--rw-rw-rw-   0        0        0    16356 2022-04-23 13:44:25.000000 sympy.keras-1.0.21/sympy/polys/domainmatrix.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:20:01.976294 sympy.keras-1.0.21/sympy/polys/domains/
--rw-rw-rw-   0        0        0     1299 2023-04-29 09:31:14.000000 sympy.keras-1.0.21/sympy/polys/domains/__init__.py
--rw-rw-rw-   0        0        0      380 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/polys/domains/characteristiczero.py
--rw-rw-rw-   0        0        0     3442 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/polys/domains/complexfield.py
--rw-rw-rw-   0        0        0      691 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/polys/domains/compositedomain.py
--rw-rw-rw-   0        0        0    16865 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/polys/domains/domain.py
--rw-rw-rw-   0        0        0      394 2022-04-23 13:44:25.000000 sympy.keras-1.0.21/sympy/polys/domains/domainelement.py
--rw-rw-rw-   0        0        0     5923 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/polys/domains/expressiondomain.py
--rw-rw-rw-   0        0        0     2477 2022-04-23 13:44:25.000000 sympy.keras-1.0.21/sympy/polys/domains/field.py
--rw-rw-rw-   0        0        0     3256 2022-04-23 13:44:25.000000 sympy.keras-1.0.21/sympy/polys/domains/finitefield.py
--rw-rw-rw-   0        0        0     4478 2022-04-23 13:44:25.000000 sympy.keras-1.0.21/sympy/polys/domains/fractionfield.py
--rw-rw-rw-   0        0        0    11066 2023-04-29 09:34:14.000000 sympy.keras-1.0.21/sympy/polys/domains/gaussiandomains.py
--rw-rw-rw-   0        0        0      464 2022-04-23 13:44:25.000000 sympy.keras-1.0.21/sympy/polys/domains/gmpyfinitefield.py
--rw-rw-rw-   0        0        0     2600 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/polys/domains/gmpyintegerring.py
--rw-rw-rw-   0        0        0     2784 2022-04-23 13:44:25.000000 sympy.keras-1.0.21/sympy/polys/domains/gmpyrationalfield.py
--rw-rw-rw-   0        0        0     1617 2023-04-10 14:00:42.000000 sympy.keras-1.0.21/sympy/polys/domains/groundtypes.py
--rw-rw-rw-   0        0        0     1146 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/polys/domains/integerring.py
--rw-rw-rw-   0        0        0     5062 2022-04-23 13:44:25.000000 sympy.keras-1.0.21/sympy/polys/domains/modularinteger.py
--rw-rw-rw-   0        0        0     4560 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/polys/domains/mpelements.py
--rw-rw-rw-   0        0        0     6046 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/polys/domains/old_fractionfield.py
--rw-rw-rw-   0        0        0    13944 2023-04-10 14:00:43.000000 sympy.keras-1.0.21/sympy/polys/domains/old_polynomialring.py
--rw-rw-rw-   0        0        0     4554 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/polys/domains/polynomialring.py
--rw-rw-rw-   0        0        0      482 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/polys/domains/pythonfinitefield.py
--rw-rw-rw-   0        0        0     2929 2022-04-23 13:44:25.000000 sympy.keras-1.0.21/sympy/polys/domains/pythonintegerring.py
--rw-rw-rw-   0        0        0     7435 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/polys/domains/pythonrational.py
--rw-rw-rw-   0        0        0     2184 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/polys/domains/pythonrationalfield.py
--rw-rw-rw-   0        0        0     5708 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/polys/domains/quotientring.py
--rw-rw-rw-   0        0        0      902 2022-04-23 13:44:25.000000 sympy.keras-1.0.21/sympy/polys/domains/rationalfield.py
--rw-rw-rw-   0        0        0     7377 2023-04-29 09:33:27.000000 sympy.keras-1.0.21/sympy/polys/domains/realfield.py
--rw-rw-rw-   0        0        0     3238 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/polys/domains/ring.py
--rw-rw-rw-   0        0        0      368 2022-04-23 13:44:25.000000 sympy.keras-1.0.21/sympy/polys/domains/simpledomain.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:20:01.991254 sympy.keras-1.0.21/sympy/polys/domains/tests/
--rw-rw-rw-   0        0        0        0 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/polys/domains/tests/__init__.py
--rw-rw-rw-   0        0        0    43962 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/polys/domains/tests/test_domains.py
--rw-rw-rw-   0        0        0     3312 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/polys/domains/tests/test_polynomialring.py
--rw-rw-rw-   0        0        0     1459 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/polys/domains/tests/test_quotientring.py
--rw-rw-rw-   0        0        0    41225 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/polys/euclidtools.py
--rw-rw-rw-   0        0        0    38052 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/polys/factortools.py
--rw-rw-rw-   0        0        0     4328 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/polys/fglmtools.py
--rw-rw-rw-   0        0        0    20286 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/polys/fields.py
--rw-rw-rw-   0        0        0    51936 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/polys/galoistools.py
--rw-rw-rw-   0        0        0    23347 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/polys/groebnertools.py
--rw-rw-rw-   0        0        0     3732 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/polys/heuristicgcd.py
--rw-rw-rw-   0        0        0    58646 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/polys/modulargcd.py
--rw-rw-rw-   0        0        0    18407 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/polys/monomials.py
--rw-rw-rw-   0        0        0    11958 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/polys/multivariate_resultants.py
--rw-rw-rw-   0        0        0    32605 2023-04-10 14:00:42.000000 sympy.keras-1.0.21/sympy/polys/numberfields.py
--rw-rw-rw-   0        0        0     8380 2023-04-10 14:00:42.000000 sympy.keras-1.0.21/sympy/polys/orderings.py
--rw-rw-rw-   0        0        0    10096 2021-09-12 00:26:25.000000 sympy.keras-1.0.21/sympy/polys/orthopolys.py
--rw-rw-rw-   0        0        0    14653 2022-04-23 13:44:25.000000 sympy.keras-1.0.21/sympy/polys/partfrac.py
--rw-rw-rw-   0        0        0    53415 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/polys/polyclasses.py
--rw-rw-rw-   0        0        0     1597 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/polys/polyconfig.py
--rw-rw-rw-   0        0        0     4521 2023-04-10 14:00:42.000000 sympy.keras-1.0.21/sympy/polys/polyerrors.py
--rw-rw-rw-   0        0        0    10012 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/polys/polyfuncs.py
--rw-rw-rw-   0        0        0     3201 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/polys/polymatrix.py
--rw-rw-rw-   0        0        0    21225 2023-04-10 14:00:42.000000 sympy.keras-1.0.21/sympy/polys/polyoptions.py
--rw-rw-rw-   0        0        0    95962 2022-04-23 13:44:25.000000 sympy.keras-1.0.21/sympy/polys/polyquinticconst.py
--rw-rw-rw-   0        0        0    33404 2023-04-18 11:57:18.000000 sympy.keras-1.0.21/sympy/polys/polyroots.py
--rw-rw-rw-   0        0        0   187297 2022-09-24 00:48:20.000000 sympy.keras-1.0.21/sympy/polys/polytools.py
--rw-rw-rw-   0        0        0    14016 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/polys/polyutils.py
--rw-rw-rw-   0        0        0     2833 2022-04-23 13:44:25.000000 sympy.keras-1.0.21/sympy/polys/rationaltools.py
--rw-rw-rw-   0        0        0    57681 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/polys/ring_series.py
--rw-rw-rw-   0        0        0    68538 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/polys/rings.py
--rw-rw-rw-   0        0        0    60683 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/polys/rootisolation.py
--rw-rw-rw-   0        0        0    39168 2023-04-10 14:00:42.000000 sympy.keras-1.0.21/sympy/polys/rootoftools.py
--rw-rw-rw-   0        0        0     2014 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/polys/solvers.py
--rw-rw-rw-   0        0        0    10537 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/polys/specialpolys.py
--rw-rw-rw-   0        0        0    11401 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/polys/sqfreetools.py
--rw-rw-rw-   0        0        0    88039 2022-04-23 13:44:25.000000 sympy.keras-1.0.21/sympy/polys/subresultants_qq_zz.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:20:02.180276 sympy.keras-1.0.21/sympy/polys/tests/
--rw-rw-rw-   0        0        0        0 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/polys/tests/__init__.py
--rw-rw-rw-   0        0        0     3820 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/polys/tests/test_appellseqs.py
--rw-rw-rw-   0        0        0     6378 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/polys/tests/test_constructor.py
--rw-rw-rw-   0        0        0    40428 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/polys/tests/test_densearith.py
--rw-rw-rw-   0        0        0    21477 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/polys/tests/test_densebasic.py
--rw-rw-rw-   0        0        0    24572 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/polys/tests/test_densetools.py
--rw-rw-rw-   0        0        0     3183 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/polys/tests/test_dispersion.py
--rw-rw-rw-   0        0        0     7639 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/polys/tests/test_distributedmodules.py
--rw-rw-rw-   0        0        0    19482 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/polys/tests/test_euclidtools.py
--rw-rw-rw-   0        0        0    24560 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/polys/tests/test_factortools.py
--rw-rw-rw-   0        0        0    10245 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/polys/tests/test_fields.py
--rw-rw-rw-   0        0        0    28130 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/polys/tests/test_galoistools.py
--rw-rw-rw-   0        0        0    18584 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/polys/tests/test_groebnertools.py
--rw-rw-rw-   0        0        0     4031 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/polys/tests/test_heuristicgcd.py
--rw-rw-rw-   0        0        0     1286 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/polys/tests/test_injections.py
--rw-rw-rw-   0        0        0     9042 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/polys/tests/test_modulargcd.py
--rw-rw-rw-   0        0        0    10988 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/polys/tests/test_monomials.py
--rw-rw-rw-   0        0        0     9501 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/polys/tests/test_multivariate_resultants.py
--rw-rw-rw-   0        0        0     4254 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/polys/tests/test_orderings.py
--rw-rw-rw-   0        0        0     6379 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/polys/tests/test_orthopolys.py
--rw-rw-rw-   0        0        0     7096 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/polys/tests/test_partfrac.py
--rw-rw-rw-   0        0        0    13321 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/polys/tests/test_polyclasses.py
--rw-rw-rw-   0        0        0     4520 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/polys/tests/test_polyfuncs.py
--rw-rw-rw-   0        0        0     7353 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/polys/tests/test_polymatrix.py
--rw-rw-rw-   0        0        0    12416 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/polys/tests/test_polyoptions.py
--rw-rw-rw-   0        0        0    26805 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/polys/tests/test_polyroots.py
--rw-rw-rw-   0        0        0   126961 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/polys/tests/test_polytools.py
--rw-rw-rw-   0        0        0    11547 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/polys/tests/test_polyutils.py
--rw-rw-rw-   0        0        0     4143 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/polys/tests/test_pythonrational.py
--rw-rw-rw-   0        0        0     2397 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/polys/tests/test_rationaltools.py
--rw-rw-rw-   0        0        0    24662 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/polys/tests/test_ring_series.py
--rw-rw-rw-   0        0        0    45393 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/polys/tests/test_rings.py
--rw-rw-rw-   0        0        0    32724 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/polys/tests/test_rootisolation.py
--rw-rw-rw-   0        0        0    21918 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/polys/tests/test_rootoftools.py
--rw-rw-rw-   0        0        0    13655 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/polys/tests/test_solvers.py
--rw-rw-rw-   0        0        0     4995 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/polys/tests/test_specialpolys.py
--rw-rw-rw-   0        0        0     4387 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/polys/tests/test_sqfreetools.py
--rw-rw-rw-   0        0        0    13138 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/polys/tests/test_subresultants_qq_zz.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:20:02.358106 sympy.keras-1.0.21/sympy/printing/
--rw-rw-rw-   0        0        0      780 2023-04-10 14:00:42.000000 sympy.keras-1.0.21/sympy/printing/__init__.py
--rw-rw-rw-   0        0        0    26568 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/printing/c.py
--rw-rw-rw-   0        0        0    20302 2023-04-10 14:00:43.000000 sympy.keras-1.0.21/sympy/printing/codeprinter.py
--rw-rw-rw-   0        0        0     2461 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/printing/conventions.py
--rw-rw-rw-   0        0        0     5628 2022-04-23 13:44:25.000000 sympy.keras-1.0.21/sympy/printing/cxx.py
--rw-rw-rw-   0        0        0      638 2023-04-10 14:00:42.000000 sympy.keras-1.0.21/sympy/printing/defaults.py
--rw-rw-rw-   0        0        0     8341 2023-04-10 14:00:42.000000 sympy.keras-1.0.21/sympy/printing/dot.py
--rw-rw-rw-   0        0        0    28352 2022-04-23 13:44:25.000000 sympy.keras-1.0.21/sympy/printing/fortran.py
--rw-rw-rw-   0        0        0    18284 2022-10-05 05:30:22.000000 sympy.keras-1.0.21/sympy/printing/glsl.py
--rw-rw-rw-   0        0        0      475 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/printing/gtk.py
--rw-rw-rw-   0        0        0    10935 2022-10-05 05:30:29.000000 sympy.keras-1.0.21/sympy/printing/jscode.py
--rw-rw-rw-   0        0        0    22346 2022-10-05 05:30:35.000000 sympy.keras-1.0.21/sympy/printing/julia.py
--rw-rw-rw-   0        0        0     4359 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/printing/lambdarepr.py
--rw-rw-rw-   0        0        0    75744 2023-03-17 14:49:13.000000 sympy.keras-1.0.21/sympy/printing/latex.py
--rw-rw-rw-   0        0        0    16741 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/printing/llvmjitcode.py
--rw-rw-rw-   0        0        0    10075 2022-10-05 05:30:41.000000 sympy.keras-1.0.21/sympy/printing/maple.py
--rw-rw-rw-   0        0        0     9123 2023-04-03 13:20:24.000000 sympy.keras-1.0.21/sympy/printing/mathematica.py
--rw-rw-rw-   0        0        0    69522 2023-04-03 13:20:24.000000 sympy.keras-1.0.21/sympy/printing/mathml.py
--rw-rw-rw-   0        0        0    19776 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/printing/numpy.py
--rw-rw-rw-   0        0        0    24877 2022-10-05 05:30:47.000000 sympy.keras-1.0.21/sympy/printing/octave.py
--rw-rw-rw-   0        0        0     4418 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/printing/precedence.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:20:02.379844 sympy.keras-1.0.21/sympy/printing/pretty/
--rw-rw-rw-   0        0        0      222 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/printing/pretty/__init__.py
--rw-rw-rw-   0        0        0    81003 2023-04-10 14:00:43.000000 sympy.keras-1.0.21/sympy/printing/pretty/pretty.py
--rw-rw-rw-   0        0        0    19568 2023-04-10 14:00:42.000000 sympy.keras-1.0.21/sympy/printing/pretty/pretty_symbology.py
--rw-rw-rw-   0        0        0    20117 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/printing/pretty/stringpict.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:20:02.401869 sympy.keras-1.0.21/sympy/printing/pretty/tests/
--rw-rw-rw-   0        0        0        0 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/printing/pretty/tests/__init__.py
--rw-rw-rw-   0        0        0   185171 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/printing/pretty/tests/test_pretty.py
--rw-rw-rw-   0        0        0    13253 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/printing/preview.py
--rw-rw-rw-   0        0        0    10550 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/printing/printer.py
--rw-rw-rw-   0        0        0    25731 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/printing/pycode.py
--rw-rw-rw-   0        0        0     3171 2023-04-10 14:00:42.000000 sympy.keras-1.0.21/sympy/printing/python.py
--rw-rw-rw-   0        0        0    14121 2022-10-05 05:30:53.000000 sympy.keras-1.0.21/sympy/printing/rcode.py
--rw-rw-rw-   0        0        0     8677 2022-04-23 13:44:25.000000 sympy.keras-1.0.21/sympy/printing/repr.py
--rw-rw-rw-   0        0        0    20782 2022-10-05 05:30:59.000000 sympy.keras-1.0.21/sympy/printing/rust.py
--rw-rw-rw-   0        0        0    19899 2023-04-10 14:00:42.000000 sympy.keras-1.0.21/sympy/printing/string.py
--rw-rw-rw-   0        0        0    11694 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/printing/tableform.py
--rw-rw-rw-   0        0        0     8988 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/printing/tensorflow.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:20:02.609818 sympy.keras-1.0.21/sympy/printing/tests/
--rw-rw-rw-   0        0        0        0 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/printing/tests/__init__.py
--rw-rw-rw-   0        0        0    21016 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/printing/tests/test_aesaracode.py
--rw-rw-rw-   0        0        0    30804 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/printing/tests/test_c.py
--rw-rw-rw-   0        0        0     1410 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/printing/tests/test_codeprinter.py
--rw-rw-rw-   0        0        0     5257 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/printing/tests/test_conventions.py
--rw-rw-rw-   0        0        0     1858 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/printing/tests/test_cupy.py
--rw-rw-rw-   0        0        0     2490 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/printing/tests/test_cxx.py
--rw-rw-rw-   0        0        0     4648 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/printing/tests/test_dot.py
--rw-rw-rw-   0        0        0    35518 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/printing/tests/test_fortran.py
--rw-rw-rw-   0        0        0    28421 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/printing/tests/test_glsl.py
--rw-rw-rw-   0        0        0      500 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/printing/tests/test_gtk.py
--rw-rw-rw-   0        0        0    10536 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/printing/tests/test_jax.py
--rw-rw-rw-   0        0        0    11369 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/printing/tests/test_jscode.py
--rw-rw-rw-   0        0        0    13875 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/printing/tests/test_julia.py
--rw-rw-rw-   0        0        0     6947 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/printing/tests/test_lambdarepr.py
--rw-rw-rw-   0        0        0   135670 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/printing/tests/test_latex.py
--rw-rw-rw-   0        0        0     5344 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/printing/tests/test_llvmjit.py
--rw-rw-rw-   0        0        0    13135 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/printing/tests/test_maple.py
--rw-rw-rw-   0        0        0    10954 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/printing/tests/test_mathematica.py
--rw-rw-rw-   0        0        0    96650 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/printing/tests/test_mathml.py
--rw-rw-rw-   0        0        0    10360 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/printing/tests/test_numpy.py
--rw-rw-rw-   0        0        0    18728 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/printing/tests/test_octave.py
--rw-rw-rw-   0        0        0     2787 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/printing/tests/test_precedence.py
--rw-rw-rw-   0        0        0      988 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/printing/tests/test_preview.py
--rw-rw-rw-   0        0        0    15894 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/printing/tests/test_pycode.py
--rw-rw-rw-   0        0        0     8128 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/printing/tests/test_python.py
--rw-rw-rw-   0        0        0    13779 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/printing/tests/test_rcode.py
--rw-rw-rw-   0        0        0    12689 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/printing/tests/test_repr.py
--rw-rw-rw-   0        0        0    11504 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/printing/tests/test_rust.py
--rw-rw-rw-   0        0        0    20919 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/printing/tests/test_smtlib.py
--rw-rw-rw-   0        0        0    42262 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/printing/tests/test_str.py
--rw-rw-rw-   0        0        0     5692 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/printing/tests/test_tableform.py
--rw-rw-rw-   0        0        0    15578 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/printing/tests/test_tensorflow.py
--rw-rw-rw-   0        0        0    21394 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/printing/tests/test_theanocode.py
--rw-rw-rw-   0        0        0     6080 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/printing/tests/test_tree.py
--rw-rw-rw-   0        0        0    17631 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/printing/theanocode.py
--rw-rw-rw-   0        0        0     2580 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/printing/tree.py
--rw-rw-rw-   0        0        0       24 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/release.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:20:02.619762 sympy.keras-1.0.21/sympy/sandbox/
--rw-rw-rw-   0        0        0      189 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/sandbox/__init__.py
--rw-rw-rw-   0        0        0     2056 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/sandbox/indexed_integrals.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:20:02.623751 sympy.keras-1.0.21/sympy/sandbox/tests/
--rw-rw-rw-   0        0        0        0 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/sandbox/tests/__init__.py
--rw-rw-rw-   0        0        0     1179 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/sandbox/tests/test_indexed_integrals.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:20:02.696557 sympy.keras-1.0.21/sympy/series/
--rw-rw-rw-   0        0        0      484 2023-04-10 14:00:42.000000 sympy.keras-1.0.21/sympy/series/__init__.py
--rw-rw-rw-   0        0        0     3223 2022-04-23 13:44:25.000000 sympy.keras-1.0.21/sympy/series/acceleration.py
--rw-rw-rw-   0        0        0     3082 2022-04-23 13:44:25.000000 sympy.keras-1.0.21/sympy/series/approximants.py
--rw-rw-rw-   0        0        0      255 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/series/aseries.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:20:02.707623 sympy.keras-1.0.21/sympy/series/benchmarks/
--rw-rw-rw-   0        0        0        0 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/series/benchmarks/__init__.py
--rw-rw-rw-   0        0        0      173 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/series/benchmarks/bench_limit.py
--rw-rw-rw-   0        0        0      207 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/series/benchmarks/bench_order.py
--rw-rw-rw-   0        0        0    35064 2022-10-01 05:14:56.000000 sympy.keras-1.0.21/sympy/series/formal.py
--rw-rw-rw-   0        0        0    18756 2022-10-01 05:15:05.000000 sympy.keras-1.0.21/sympy/series/fourier.py
--rw-rw-rw-   0        0        0    21663 2022-04-23 13:44:25.000000 sympy.keras-1.0.21/sympy/series/gruntz.py
--rw-rw-rw-   0        0        0     1757 2022-04-23 13:44:25.000000 sympy.keras-1.0.21/sympy/series/kauers.py
--rw-rw-rw-   0        0        0    16613 2023-04-18 11:57:18.000000 sympy.keras-1.0.21/sympy/series/limits.py
--rw-rw-rw-   0        0        0     7366 2022-10-01 05:15:49.000000 sympy.keras-1.0.21/sympy/series/limitseq.py
--rw-rw-rw-   0        0        0    16909 2023-04-18 11:57:18.000000 sympy.keras-1.0.21/sympy/series/order.py
--rw-rw-rw-   0        0        0     2155 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/series/residues.py
--rw-rw-rw-   0        0        0    34736 2023-04-18 11:57:18.000000 sympy.keras-1.0.21/sympy/series/sequences.py
--rw-rw-rw-   0        0        0      289 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/series/series.py
--rw-rw-rw-   0        0        0     2910 2023-04-18 11:57:18.000000 sympy.keras-1.0.21/sympy/series/series_class.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:20:02.781395 sympy.keras-1.0.21/sympy/series/tests/
--rw-rw-rw-   0        0        0        0 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/series/tests/__init__.py
--rw-rw-rw-   0        0        0     1012 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/series/tests/test_approximants.py
--rw-rw-rw-   0        0        0     2371 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/series/tests/test_aseries.py
--rw-rw-rw-   0        0        0     4947 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/series/tests/test_demidovich.py
--rw-rw-rw-   0        0        0    22495 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/series/tests/test_formal.py
--rw-rw-rw-   0        0        0     5891 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/series/tests/test_fourier.py
--rw-rw-rw-   0        0        0    16060 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/series/tests/test_gruntz.py
--rw-rw-rw-   0        0        0     1102 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/series/tests/test_kauers.py
--rw-rw-rw-   0        0        0    44263 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/series/tests/test_limits.py
--rw-rw-rw-   0        0        0     5691 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/series/tests/test_limitseq.py
--rw-rw-rw-   0        0        0     1875 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/series/tests/test_lseries.py
--rw-rw-rw-   0        0        0    18284 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/series/tests/test_nseries.py
--rw-rw-rw-   0        0        0    16500 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/series/tests/test_order.py
--rw-rw-rw-   0        0        0     3178 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/series/tests/test_residues.py
--rw-rw-rw-   0        0        0    11161 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/series/tests/test_sequences.py
--rw-rw-rw-   0        0        0    15478 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/series/tests/test_series.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:20:02.824504 sympy.keras-1.0.21/sympy/sets/
--rw-rw-rw-   0        0        0      939 2023-04-18 11:57:19.000000 sympy.keras-1.0.21/sympy/sets/__init__.py
--rw-rw-rw-   0        0        0    19118 2023-06-02 10:50:38.000000 sympy.keras-1.0.21/sympy/sets/contains.py
--rw-rw-rw-   0        0        0    86115 2023-05-30 15:12:04.000000 sympy.keras-1.0.21/sympy/sets/fancysets.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:20:02.852227 sympy.keras-1.0.21/sympy/sets/handlers/
--rw-rw-rw-   0        0        0        0 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/sets/handlers/__init__.py
--rw-rw-rw-   0        0        0     1777 2021-09-11 15:26:48.000000 sympy.keras-1.0.21/sympy/sets/handlers/add.py
--rw-rw-rw-   0        0        0     1332 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/sets/handlers/comparison.py
--rw-rw-rw-   0        0        0     6964 2022-10-05 05:31:48.000000 sympy.keras-1.0.21/sympy/sets/handlers/functions.py
--rw-rw-rw-   0        0        0     5087 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/sets/handlers/issubset.py
--rw-rw-rw-   0        0        0     1803 2021-09-11 15:26:48.000000 sympy.keras-1.0.21/sympy/sets/handlers/mul.py
--rw-rw-rw-   0        0        0     3098 2021-09-11 15:26:48.000000 sympy.keras-1.0.21/sympy/sets/handlers/power.py
--rw-rw-rw-   0        0        0     7440 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/sets/ordinals.py
--rw-rw-rw-   0        0        0     3037 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/sets/powerset.py
--rw-rw-rw-   0        0        0    12898 2023-04-18 11:57:18.000000 sympy.keras-1.0.21/sympy/sets/setexpr.py
--rw-rw-rw-   0        0        0   130706 2023-05-30 13:24:53.000000 sympy.keras-1.0.21/sympy/sets/sets.py
--rw-rw-rw-   0        0        0    14635 2023-04-18 11:57:18.000000 sympy.keras-1.0.21/sympy/sets/subset.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:20:02.888082 sympy.keras-1.0.21/sympy/sets/tests/
--rw-rw-rw-   0        0        0        0 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/sets/tests/__init__.py
--rw-rw-rw-   0        0        0    11352 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/sets/tests/test_conditionset.py
--rw-rw-rw-   0        0        0     1559 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/sets/tests/test_contains.py
--rw-rw-rw-   0        0        0    51685 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/sets/tests/test_fancysets.py
--rw-rw-rw-   0        0        0     2637 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/sets/tests/test_ordinals.py
--rw-rw-rw-   0        0        0     4805 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/sets/tests/test_powerset.py
--rw-rw-rw-   0        0        0    14797 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/sets/tests/test_setexpr.py
--rw-rw-rw-   0        0        0    66659 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/sets/tests/test_sets.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:20:02.976844 sympy.keras-1.0.21/sympy/simplify/
--rw-rw-rw-   0        0        0      827 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/simplify/__init__.py
--rw-rw-rw-   0        0        0     3577 2022-04-23 13:44:25.000000 sympy.keras-1.0.21/sympy/simplify/combsimp.py
--rw-rw-rw-   0        0        0    25548 2022-09-24 00:48:20.000000 sympy.keras-1.0.21/sympy/simplify/cse_main.py
--rw-rw-rw-   0        0        0     1362 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/simplify/cse_opts.py
--rw-rw-rw-   0        0        0    10156 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/simplify/epathtools.py
--rw-rw-rw-   0        0        0    66574 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/simplify/fu.py
--rw-rw-rw-   0        0        0    18847 2022-10-03 03:51:24.000000 sympy.keras-1.0.21/sympy/simplify/gammasimp.py
--rw-rw-rw-   0        0        0    84094 2023-03-24 13:15:58.000000 sympy.keras-1.0.21/sympy/simplify/hyperexpand.py
--rw-rw-rw-   0        0        0      432 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/simplify/hyperexpand_doc.py
--rw-rw-rw-   0        0        0    25670 2022-04-23 13:44:25.000000 sympy.keras-1.0.21/sympy/simplify/powsimp.py
--rw-rw-rw-   0        0        0    37874 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/simplify/radsimp.py
--rw-rw-rw-   0        0        0     7645 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/simplify/ratsimp.py
--rw-rw-rw-   0        0        0    61008 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/simplify/simplify.py
--rw-rw-rw-   0        0        0    21298 2022-04-23 13:44:25.000000 sympy.keras-1.0.21/sympy/simplify/sqrtdenest.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:20:03.048582 sympy.keras-1.0.21/sympy/simplify/tests/
--rw-rw-rw-   0        0        0        0 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/simplify/tests/__init__.py
--rw-rw-rw-   0        0        0     2958 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/simplify/tests/test_combsimp.py
--rw-rw-rw-   0        0        0    25299 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/simplify/tests/test_cse.py
--rw-rw-rw-   0        0        0     3525 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/simplify/tests/test_epathtools.py
--rw-rw-rw-   0        0        0    18651 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/simplify/tests/test_fu.py
--rw-rw-rw-   0        0        0     2199 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/simplify/tests/test_function.py
--rw-rw-rw-   0        0        0     5320 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/simplify/tests/test_gammasimp.py
--rw-rw-rw-   0        0        0    40851 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/simplify/tests/test_hyperexpand.py
--rw-rw-rw-   0        0        0    14313 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/simplify/tests/test_powsimp.py
--rw-rw-rw-   0        0        0    18789 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/simplify/tests/test_radsimp.py
--rw-rw-rw-   0        0        0     2210 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/simplify/tests/test_ratsimp.py
--rw-rw-rw-   0        0        0     1127 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/simplify/tests/test_rewrite.py
--rw-rw-rw-   0        0        0    41565 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/simplify/tests/test_simplify.py
--rw-rw-rw-   0        0        0     7470 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/simplify/tests/test_sqrtdenest.py
--rw-rw-rw-   0        0        0    19949 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/simplify/tests/test_trigsimp.py
--rw-rw-rw-   0        0        0      893 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/simplify/traversaltools.py
--rw-rw-rw-   0        0        0    44783 2022-10-05 05:32:16.000000 sympy.keras-1.0.21/sympy/simplify/trigsimp.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:20:03.107380 sympy.keras-1.0.21/sympy/solvers/
--rw-rw-rw-   0        0        0     1111 2021-09-18 22:51:30.000000 sympy.keras-1.0.21/sympy/solvers/__init__.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:20:03.112367 sympy.keras-1.0.21/sympy/solvers/benchmarks/
--rw-rw-rw-   0        0        0        0 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/solvers/benchmarks/__init__.py
--rw-rw-rw-   0        0        0      288 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/solvers/benchmarks/bench_solvers.py
--rw-rw-rw-   0        0        0    12904 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/solvers/bivariate.py
--rw-rw-rw-   0        0        0     3027 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/solvers/decompogen.py
--rw-rw-rw-   0        0        0     9955 2022-04-23 13:44:25.000000 sympy.keras-1.0.21/sympy/solvers/deutils.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:20:03.124307 sympy.keras-1.0.21/sympy/solvers/diophantine/
--rw-rw-rw-   0        0        0       51 2023-04-10 14:00:42.000000 sympy.keras-1.0.21/sympy/solvers/diophantine/__init__.py
--rw-rw-rw-   0        0        0   108636 2023-04-10 14:00:42.000000 sympy.keras-1.0.21/sympy/solvers/diophantine/diophantine.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:20:03.131319 sympy.keras-1.0.21/sympy/solvers/diophantine/tests/
--rw-rw-rw-   0        0        0        0 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/solvers/diophantine/tests/__init__.py
--rw-rw-rw-   0        0        0    42265 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/solvers/diophantine/tests/test_diophantine.py
--rw-rw-rw-   0        0        0    33322 2022-10-01 05:12:12.000000 sympy.keras-1.0.21/sympy/solvers/inequalities.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:20:03.166243 sympy.keras-1.0.21/sympy/solvers/ode/
--rw-rw-rw-   0        0        0      237 2023-04-10 14:00:43.000000 sympy.keras-1.0.21/sympy/solvers/ode/__init__.py
--rw-rw-rw-   0        0        0   276970 2023-04-03 13:20:24.000000 sympy.keras-1.0.21/sympy/solvers/ode/ode.py
--rw-rw-rw-   0        0        0    26804 2022-10-01 05:12:47.000000 sympy.keras-1.0.21/sympy/solvers/ode/single.py
--rw-rw-rw-   0        0        0    16106 2023-04-03 13:20:24.000000 sympy.keras-1.0.21/sympy/solvers/ode/subscheck.py
--rw-rw-rw-   0        0        0    65203 2021-07-27 13:23:38.000000 sympy.keras-1.0.21/sympy/solvers/ode/systems.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:20:03.232551 sympy.keras-1.0.21/sympy/solvers/ode/tests/
--rw-rw-rw-   0        0        0        0 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/solvers/ode/tests/__init__.py
--rw-rw-rw-   0        0        0     5319 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/solvers/ode/tests/test_lie_group.py
--rw-rw-rw-   0        0        0    48311 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/solvers/ode/tests/test_ode.py
--rw-rw-rw-   0        0        0    29348 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/solvers/ode/tests/test_riccati.py
--rw-rw-rw-   0        0        0    99983 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/solvers/ode/tests/test_single.py
--rw-rw-rw-   0        0        0    12468 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/solvers/ode/tests/test_subscheck.py
--rw-rw-rw-   0        0        0   129359 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/solvers/ode/tests/test_systems.py
--rw-rw-rw-   0        0        0    36156 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/solvers/pde.py
--rw-rw-rw-   0        0        0     9679 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/solvers/polysys.py
--rw-rw-rw-   0        0        0    25004 2022-04-23 13:44:25.000000 sympy.keras-1.0.21/sympy/solvers/recurr.py
--rw-rw-rw-   0        0        0   134668 2023-04-18 11:57:18.000000 sympy.keras-1.0.21/sympy/solvers/solvers.py
--rw-rw-rw-   0        0        0   109399 2023-03-24 13:15:58.000000 sympy.keras-1.0.21/sympy/solvers/solveset.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:20:03.288589 sympy.keras-1.0.21/sympy/solvers/tests/
--rw-rw-rw-   0        0        0        0 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/solvers/tests/__init__.py
--rw-rw-rw-   0        0        0     8707 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/solvers/tests/test_constantsimp.py
--rw-rw-rw-   0        0        0     2943 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/solvers/tests/test_decompogen.py
--rw-rw-rw-   0        0        0    20688 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/solvers/tests/test_inequalities.py
--rw-rw-rw-   0        0        0     4738 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/solvers/tests/test_numeric.py
--rw-rw-rw-   0        0        0     9257 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/solvers/tests/test_pde.py
--rw-rw-rw-   0        0        0     6873 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/solvers/tests/test_polysys.py
--rw-rw-rw-   0        0        0    11418 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/solvers/tests/test_recurr.py
--rw-rw-rw-   0        0        0   105060 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/solvers/tests/test_solvers.py
--rw-rw-rw-   0        0        0   134515 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/solvers/tests/test_solveset.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:20:03.400280 sympy.keras-1.0.21/sympy/stats/
--rw-rw-rw-   0        0        0     5916 2023-04-10 14:00:42.000000 sympy.keras-1.0.21/sympy/stats/__init__.py
--rw-rw-rw-   0        0        0     7780 2023-03-24 13:15:58.000000 sympy.keras-1.0.21/sympy/stats/compound_rv.py
--rw-rw-rw-   0        0        0    26497 2023-04-18 11:57:18.000000 sympy.keras-1.0.21/sympy/stats/crv.py
--rw-rw-rw-   0        0        0   113892 2023-04-30 07:41:49.000000 sympy.keras-1.0.21/sympy/stats/crv_types.py
--rw-rw-rw-   0        0        0    15343 2023-04-10 14:00:42.000000 sympy.keras-1.0.21/sympy/stats/drv.py
--rw-rw-rw-   0        0        0    20738 2023-04-18 11:57:18.000000 sympy.keras-1.0.21/sympy/stats/drv_types.py
--rw-rw-rw-   0        0        0     3106 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/stats/error_prop.py
--rw-rw-rw-   0        0        0    19188 2023-03-24 13:15:58.000000 sympy.keras-1.0.21/sympy/stats/frv.py
--rw-rw-rw-   0        0        0    16150 2023-04-10 14:00:42.000000 sympy.keras-1.0.21/sympy/stats/frv_types.py
--rw-rw-rw-   0        0        0    13667 2023-04-10 14:00:42.000000 sympy.keras-1.0.21/sympy/stats/joint_rv.py
--rw-rw-rw-   0        0        0    28592 2023-04-10 14:00:42.000000 sympy.keras-1.0.21/sympy/stats/joint_rv_types.py
--rw-rw-rw-   0        0        0    15887 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/stats/matrix_distributions.py
--rw-rw-rw-   0        0        0      855 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/stats/random_matrix.py
--rw-rw-rw-   0        0        0    14465 2023-04-10 14:00:43.000000 sympy.keras-1.0.21/sympy/stats/random_matrix_models.py
--rw-rw-rw-   0        0        0    50680 2023-05-10 13:31:13.000000 sympy.keras-1.0.21/sympy/stats/rv.py
--rw-rw-rw-   0        0        0    13003 2023-04-10 14:00:42.000000 sympy.keras-1.0.21/sympy/stats/rv_interface.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:20:03.414242 sympy.keras-1.0.21/sympy/stats/sampling/
--rw-rw-rw-   0        0        0        0 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/stats/sampling/__init__.py
--rw-rw-rw-   0        0        0     4229 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/stats/sampling/sample_numpy.py
--rw-rw-rw-   0        0        0     2995 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/stats/sampling/sample_pymc.py
--rw-rw-rw-   0        0        0     6329 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/stats/sampling/sample_scipy.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:20:03.427207 sympy.keras-1.0.21/sympy/stats/sampling/tests/
--rw-rw-rw-   0        0        0        0 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/stats/sampling/tests/__init__.py
--rw-rw-rw-   0        0        0     5708 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/stats/sampling/tests/test_sample_continuous_rv.py
--rw-rw-rw-   0        0        0     3319 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/stats/sampling/tests/test_sample_discrete_rv.py
--rw-rw-rw-   0        0        0     3061 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/stats/sampling/tests/test_sample_finite_rv.py
--rw-rw-rw-   0        0        0     2179 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/stats/stochastic_process.py
--rw-rw-rw-   0        0        0    63317 2023-04-10 14:00:42.000000 sympy.keras-1.0.21/sympy/stats/stochastic_process_types.py
--rw-rw-rw-   0        0        0    10121 2023-04-18 15:26:29.000000 sympy.keras-1.0.21/sympy/stats/symbolic_multivariate_probability.py
--rw-rw-rw-   0        0        0    62649 2023-05-18 14:00:53.000000 sympy.keras-1.0.21/sympy/stats/symbolic_probability.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:20:03.495023 sympy.keras-1.0.21/sympy/stats/tests/
--rw-rw-rw-   0        0        0        0 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/stats/tests/__init__.py
--rw-rw-rw-   0        0        0     6263 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/stats/tests/test_compound_rv.py
--rw-rw-rw-   0        0        0    56018 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/stats/tests/test_continuous_rv.py
--rw-rw-rw-   0        0        0    10676 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/stats/tests/test_discrete_rv.py
--rw-rw-rw-   0        0        0     1933 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/stats/tests/test_error_prop.py
--rw-rw-rw-   0        0        0    20413 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/stats/tests/test_finite_rv.py
--rw-rw-rw-   0        0        0    18653 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/stats/tests/test_joint_rv.py
--rw-rw-rw-   0        0        0     8857 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/stats/tests/test_matrix_distributions.py
--rw-rw-rw-   0        0        0     3991 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/stats/tests/test_mix.py
--rw-rw-rw-   0        0        0     5842 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/stats/tests/test_random_matrix.py
--rw-rw-rw-   0        0        0    12959 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/stats/tests/test_rv.py
--rw-rw-rw-   0        0        0    39335 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/stats/tests/test_stochastic_process.py
--rw-rw-rw-   0        0        0     5576 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/stats/tests/test_symbolic_multivariate.py
--rw-rw-rw-   0        0        0     9398 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/stats/tests/test_symbolic_probability.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:20:03.531947 sympy.keras-1.0.21/sympy/strategies/
--rw-rw-rw-   0        0        0     1142 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/strategies/__init__.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:20:03.548897 sympy.keras-1.0.21/sympy/strategies/branch/
--rw-rw-rw-   0        0        0      177 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/strategies/branch/__init__.py
--rw-rw-rw-   0        0        0     2911 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/strategies/branch/core.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:20:03.561834 sympy.keras-1.0.21/sympy/strategies/branch/tests/
--rw-rw-rw-   0        0        0        0 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/strategies/branch/tests/__init__.py
--rw-rw-rw-   0        0        0     2246 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/strategies/branch/tests/test_core.py
--rw-rw-rw-   0        0        0      942 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/strategies/branch/tests/test_tools.py
--rw-rw-rw-   0        0        0     1322 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/strategies/branch/tests/test_traverse.py
--rw-rw-rw-   0        0        0      356 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/strategies/branch/tools.py
--rw-rw-rw-   0        0        0      798 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/strategies/branch/traverse.py
--rw-rw-rw-   0        0        0     3035 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/strategies/core.py
--rw-rw-rw-   0        0        0     4247 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/strategies/rl.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:20:03.581781 sympy.keras-1.0.21/sympy/strategies/tests/
--rw-rw-rw-   0        0        0        0 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/strategies/tests/__init__.py
--rw-rw-rw-   0        0        0     2152 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/strategies/tests/test_core.py
--rw-rw-rw-   0        0        0     1949 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/strategies/tests/test_rl.py
--rw-rw-rw-   0        0        0      875 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/strategies/tests/test_tools.py
--rw-rw-rw-   0        0        0     2082 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/strategies/tests/test_traverse.py
--rw-rw-rw-   0        0        0     2400 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/strategies/tests/test_tree.py
--rw-rw-rw-   0        0        0     1264 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/strategies/tools.py
--rw-rw-rw-   0        0        0     1183 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/strategies/traverse.py
--rw-rw-rw-   0        0        0     3713 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/strategies/tree.py
--rw-rw-rw-   0        0        0      348 2022-04-23 13:44:25.000000 sympy.keras-1.0.21/sympy/strategies/util.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:20:03.618208 sympy.keras-1.0.21/sympy/tensor/
--rw-rw-rw-   0        0        0      461 2021-12-26 07:35:18.000000 sympy.keras-1.0.21/sympy/tensor/__init__.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:20:03.654986 sympy.keras-1.0.21/sympy/tensor/array/
--rw-rw-rw-   0        0        0     6068 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/tensor/array/__init__.py
--rw-rw-rw-   0        0        0     8544 2022-10-03 04:04:04.000000 sympy.keras-1.0.21/sympy/tensor/array/array_comprehension.py
--rw-rw-rw-   0        0        0     9822 2022-10-03 04:04:35.000000 sympy.keras-1.0.21/sympy/tensor/array/arrayop.py
--rw-rw-rw-   0        0        0     6144 2022-09-24 00:48:20.000000 sympy.keras-1.0.21/sympy/tensor/array/dense_ndim_array.py
--rw-rw-rw-   0        0        0      277 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/tensor/array/mutable_ndim_array.py
--rw-rw-rw-   0        0        0    15185 2022-10-03 04:04:45.000000 sympy.keras-1.0.21/sympy/tensor/array/ndim_array.py
--rw-rw-rw-   0        0        0     6833 2022-09-24 00:48:20.000000 sympy.keras-1.0.21/sympy/tensor/array/sparse_ndim_array.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:20:03.694174 sympy.keras-1.0.21/sympy/tensor/array/tests/
--rw-rw-rw-   0        0        0        0 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/tensor/array/tests/__init__.py
--rw-rw-rw-   0        0        0     4750 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/tensor/array/tests/test_array_comprehension.py
--rw-rw-rw-   0        0        0     1603 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/tensor/array/tests/test_array_derivatives.py
--rw-rw-rw-   0        0        0    25844 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/tensor/array/tests/test_arrayop.py
--rw-rw-rw-   0        0        0    15823 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/tensor/array/tests/test_immutable_ndim_array.py
--rw-rw-rw-   0        0        0    13070 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/tensor/array/tests/test_mutable_ndim_array.py
--rw-rw-rw-   0        0        0     2232 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/tensor/array/tests/test_ndim_array.py
--rw-rw-rw-   0        0        0      648 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/tensor/array/tests/test_ndim_array_conversions.py
--rw-rw-rw-   0        0        0     1862 2022-10-03 04:05:16.000000 sympy.keras-1.0.21/sympy/tensor/functions.py
--rw-rw-rw-   0        0        0    15462 2022-04-23 13:44:25.000000 sympy.keras-1.0.21/sympy/tensor/index_methods.py
--rw-rw-rw-   0        0        0   116617 2023-06-04 11:53:22.000000 sympy.keras-1.0.21/sympy/tensor/indexed.py
--rw-rw-rw-   0        0        0   230782 2023-04-18 11:57:18.000000 sympy.keras-1.0.21/sympy/tensor/tensor.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:20:03.730862 sympy.keras-1.0.21/sympy/tensor/tests/
--rw-rw-rw-   0        0        0        0 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/tensor/tests/__init__.py
--rw-rw-rw-   0        0        0     1552 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/tensor/tests/test_functions.py
--rw-rw-rw-   0        0        0     7112 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/tensor/tests/test_index_methods.py
--rw-rw-rw-   0        0        0    16157 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/tensor/tests/test_indexed.py
--rw-rw-rw-   0        0        0      424 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/tensor/tests/test_printing.py
--rw-rw-rw-   0        0        0    75711 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/tensor/tests/test_tensor.py
--rw-rw-rw-   0        0        0      908 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/tensor/tests/test_tensor_element.py
--rw-rw-rw-   0        0        0    17945 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/tensor/tests/test_tensor_operators.py
--rw-rw-rw-   0        0        0     2739 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/tensor/toperators.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:20:03.773216 sympy.keras-1.0.21/sympy/testing/
--rw-rw-rw-   0        0        0      100 2023-04-10 14:00:42.000000 sympy.keras-1.0.21/sympy/testing/__init__.py
--rw-rw-rw-   0        0        0      216 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/testing/matrices.py
--rw-rw-rw-   0        0        0     9197 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/testing/pytest.py
--rw-rw-rw-   0        0        0     4650 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/testing/quality_unicode.py
--rw-rw-rw-   0        0        0     5319 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/testing/randtest.py
--rw-rw-rw-   0        0        0    88872 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/testing/runtests.py
--rw-rw-rw-   0        0        0    18558 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/testing/runtests_pytest.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:20:03.813550 sympy.keras-1.0.21/sympy/testing/tests/
--rw-rw-rw-   0        0        0        0 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/testing/tests/__init__.py
--rw-rw-rw-   0        0        0     9588 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/testing/tests/diagnose_imports.py
--rw-rw-rw-   0        0        0    19222 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/testing/tests/test_code_quality.py
--rw-rw-rw-   0        0        0      183 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/testing/tests/test_deprecated.py
--rw-rw-rw-   0        0        0     1459 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/testing/tests/test_module_imports.py
--rw-rw-rw-   0        0        0     6778 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/testing/tests/test_pytest.py
--rw-rw-rw-   0        0        0     6338 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/testing/tests/test_runtests_pytest.py
--rw-rw-rw-   0        0        0     1042 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/testing/tmpfiles.py
--rw-rw-rw-   0        0        0      644 2021-10-23 09:40:54.000000 sympy.keras-1.0.21/sympy/this.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:20:03.832501 sympy.keras-1.0.21/sympy/unify/
--rw-rw-rw-   0        0        0      234 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/unify/__init__.py
--rw-rw-rw-   0        0        0     7210 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/unify/core.py
--rw-rw-rw-   0        0        0     1795 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/unify/rewrite.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:20:03.846434 sympy.keras-1.0.21/sympy/unify/tests/
--rw-rw-rw-   0        0        0        0 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/unify/tests/__init__.py
--rw-rw-rw-   0        0        0     2002 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/unify/tests/test_rewrite.py
--rw-rw-rw-   0        0        0     5922 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/unify/tests/test_sympy.py
--rw-rw-rw-   0        0        0     3029 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/unify/tests/test_unify.py
--rw-rw-rw-   0        0        0     3966 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/unify/usympy.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:20:03.957486 sympy.keras-1.0.21/sympy/utilities/
--rw-rw-rw-   0        0        0      581 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/utilities/__init__.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:20:03.980426 sympy.keras-1.0.21/sympy/utilities/_compilation/
--rw-rw-rw-   0        0        0      640 2023-04-10 14:00:42.000000 sympy.keras-1.0.21/sympy/utilities/_compilation/__init__.py
--rw-rw-rw-   0        0        0     2884 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/utilities/_compilation/availability.py
--rw-rw-rw-   0        0        0    20378 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/utilities/_compilation/compilation.py
--rw-rw-rw-   0        0        0     9026 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/utilities/_compilation/runners.py
--rw-rw-rw-   0        0        0     7850 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/utilities/_compilation/util.py
--rw-rw-rw-   0        0        0    40939 2022-04-23 13:44:25.000000 sympy.keras-1.0.21/sympy/utilities/autowrap.py
--rw-rw-rw-   0        0        0     6296 2022-04-23 13:44:25.000000 sympy.keras-1.0.21/sympy/utilities/benchmarking.py
--rw-rw-rw-   0        0        0    81318 2023-04-10 14:00:42.000000 sympy.keras-1.0.21/sympy/utilities/codegen.py
--rw-rw-rw-   0        0        0     7096 2022-04-23 13:44:25.000000 sympy.keras-1.0.21/sympy/utilities/decorator.py
--rw-rw-rw-   0        0        0    43339 2022-04-23 13:44:25.000000 sympy.keras-1.0.21/sympy/utilities/enumerative.py
--rw-rw-rw-   0        0        0     7164 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/utilities/exceptions.py
--rw-rw-rw-   0        0        0    75173 2022-04-23 13:44:25.000000 sympy.keras-1.0.21/sympy/utilities/iterables.py
--rw-rw-rw-   0        0        0    45113 2022-10-05 05:33:49.000000 sympy.keras-1.0.21/sympy/utilities/lambdify.py
--rw-rw-rw-   0        0        0      400 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/utilities/magic.py
--rw-rw-rw-   0        0        0     4018 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/utilities/matchpy_connector.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:20:03.986437 sympy.keras-1.0.21/sympy/utilities/mathml/
--rw-rw-rw-   0        0        0     2065 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/utilities/mathml/__init__.py
--rw-rw-rw-   0        0        0     1441 2022-04-23 13:44:25.000000 sympy.keras-1.0.21/sympy/utilities/memoization.py
--rw-rw-rw-   0        0        0    14404 2022-10-12 05:55:42.000000 sympy.keras-1.0.21/sympy/utilities/misc.py
--rw-rw-rw-   0        0        0     1823 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/utilities/pkgdata.py
--rw-rw-rw-   0        0        0      294 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/utilities/pytest.py
--rw-rw-rw-   0        0        0      321 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/utilities/quality_unicode.py
--rw-rw-rw-   0        0        0      430 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/utilities/randtest.py
--rw-rw-rw-   0        0        0      446 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/utilities/runtests.py
--rw-rw-rw-   0        0        0     1481 2022-04-23 13:44:24.000000 sympy.keras-1.0.21/sympy/utilities/source.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:20:04.097742 sympy.keras-1.0.21/sympy/utilities/tests/
--rw-rw-rw-   0        0        0        0 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/utilities/tests/__init__.py
--rw-rw-rw-   0        0        0    14603 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/utilities/tests/test_autowrap.py
--rw-rw-rw-   0        0        0    55496 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/utilities/tests/test_codegen.py
--rw-rw-rw-   0        0        0    18543 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/utilities/tests/test_codegen_julia.py
--rw-rw-rw-   0        0        0    17833 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/utilities/tests/test_codegen_octave.py
--rw-rw-rw-   0        0        0    12323 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/utilities/tests/test_codegen_rust.py
--rw-rw-rw-   0        0        0     3705 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/utilities/tests/test_decorator.py
--rw-rw-rw-   0        0        0      489 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/utilities/tests/test_deprecated.py
--rw-rw-rw-   0        0        0     6089 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/utilities/tests/test_enumerative.py
--rw-rw-rw-   0        0        0      716 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/utilities/tests/test_exceptions.py
--rw-rw-rw-   0        0        0    34905 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/utilities/tests/test_iterables.py
--rw-rw-rw-   0        0        0    59666 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/utilities/tests/test_lambdify.py
--rw-rw-rw-   0        0        0     4850 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/utilities/tests/test_matchpy_connector.py
--rw-rw-rw-   0        0        0      836 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/utilities/tests/test_mathml.py
--rw-rw-rw-   0        0        0     4726 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/utilities/tests/test_misc.py
--rw-rw-rw-   0        0        0    23301 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/utilities/tests/test_pickling.py
--rw-rw-rw-   0        0        0      289 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/utilities/tests/test_source.py
--rw-rw-rw-   0        0        0      337 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/utilities/tests/test_timeutils.py
--rw-rw-rw-   0        0        0    94546 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/utilities/tests/test_wester.py
--rw-rw-rw-   0        0        0       66 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/utilities/tests/test_xxe.py
--rw-rw-rw-   0        0        0     1970 2022-04-23 13:44:25.000000 sympy.keras-1.0.21/sympy/utilities/timeutils.py
--rw-rw-rw-   0        0        0      300 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/utilities/tmpfiles.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:20:04.164295 sympy.keras-1.0.21/sympy/vector/
--rw-rw-rw-   0        0        0     1010 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/vector/__init__.py
--rw-rw-rw-   0        0        0    11589 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/vector/basisdependent.py
--rw-rw-rw-   0        0        0    37333 2022-10-06 07:32:37.000000 sympy.keras-1.0.21/sympy/vector/coordsysrect.py
--rw-rw-rw-   0        0        0     3614 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/vector/deloperator.py
--rw-rw-rw-   0        0        0     8356 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/vector/dyadic.py
--rw-rw-rw-   0        0        0    15679 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/vector/functions.py
--rw-rw-rw-   0        0        0    16069 2022-10-01 05:13:58.000000 sympy.keras-1.0.21/sympy/vector/implicitregion.py
--rw-rw-rw-   0        0        0     5929 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/vector/integrals.py
--rw-rw-rw-   0        0        0    10612 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/vector/operators.py
--rw-rw-rw-   0        0        0    11694 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/vector/orienters.py
--rw-rw-rw-   0        0        0     5193 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/vector/parametricregion.py
--rw-rw-rw-   0        0        0     4650 2021-07-23 11:00:52.000000 sympy.keras-1.0.21/sympy/vector/point.py
--rw-rw-rw-   0        0        0     2089 2022-09-24 00:48:20.000000 sympy.keras-1.0.21/sympy/vector/scalar.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:20:04.212793 sympy.keras-1.0.21/sympy/vector/tests/
--rw-rw-rw-   0        0        0        0 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/vector/tests/__init__.py
--rw-rw-rw-   0        0        0    19595 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/vector/tests/test_coordsysrect.py
--rw-rw-rw-   0        0        0     4949 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/vector/tests/test_dyadic.py
--rw-rw-rw-   0        0        0    14094 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/vector/tests/test_field_functions.py
--rw-rw-rw-   0        0        0     8050 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/vector/tests/test_functions.py
--rw-rw-rw-   0        0        0     4028 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/vector/tests/test_implicitregion.py
--rw-rw-rw-   0        0        0     5093 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/vector/tests/test_integrals.py
--rw-rw-rw-   0        0        0     1613 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/vector/tests/test_operators.py
--rw-rw-rw-   0        0        0     4009 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/vector/tests/test_parametricregion.py
--rw-rw-rw-   0        0        0     7708 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/vector/tests/test_printing.py
--rw-rw-rw-   0        0        0     7861 2023-05-04 12:34:25.000000 sympy.keras-1.0.21/sympy/vector/tests/test_vector.py
--rw-rw-rw-   0        0        0    17558 2022-09-24 00:48:20.000000 sympy.keras-1.0.21/sympy/vector/vector.py
-drwxrwxrwx   0        0        0        0 2023-06-04 15:19:57.428314 sympy.keras-1.0.21/sympy.keras.egg-info/
--rw-rw-rw-   0        0        0        3 2022-10-06 02:48:27.000000 sympy.keras-1.0.21/sympy.keras.egg-info/.gitignore
--rw-rw-rw-   0        0        0      529 2023-06-04 15:19:57.000000 sympy.keras-1.0.21/sympy.keras.egg-info/PKG-INFO
--rw-rw-rw-   0        0        0    45690 2023-06-04 15:19:57.000000 sympy.keras-1.0.21/sympy.keras.egg-info/SOURCES.txt
--rw-rw-rw-   0        0        0        1 2023-06-04 15:19:57.000000 sympy.keras-1.0.21/sympy.keras.egg-info/dependency_links.txt
--rw-rw-rw-   0        0        0       21 2023-06-04 15:19:57.000000 sympy.keras-1.0.21/sympy.keras.egg-info/requires.txt
--rw-rw-rw-   0        0        0        6 2023-06-04 15:19:57.000000 sympy.keras-1.0.21/sympy.keras.egg-info/top_level.txt
+drwxrwxrwx   0        0        0        0 2022-10-12 08:07:39.769126 sympy.keras-1.0.4/
+-rw-rw-rw-   0        0        0      528 2022-10-12 08:07:39.769126 sympy.keras-1.0.4/PKG-INFO
+-rw-rw-rw-   0        0        0      185 2021-07-23 11:00:48.000000 sympy.keras-1.0.4/README.md
+-rw-rw-rw-   0        0        0      370 2022-10-12 08:07:39.770123 sympy.keras-1.0.4/setup.cfg
+-rw-rw-rw-   0        0        0      374 2022-10-07 02:44:43.000000 sympy.keras-1.0.4/setup.py
+drwxrwxrwx   0        0        0        0 2022-10-12 08:07:39.390881 sympy.keras-1.0.4/sympy/
+-rw-rw-rw-   0        0        0     3174 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/__init__.py
+-rw-rw-rw-   0        0        0     3720 2022-04-23 13:44:25.000000 sympy.keras-1.0.4/sympy/abc.py
+drwxrwxrwx   0        0        0        0 2022-10-12 08:07:39.398859 sympy.keras-1.0.4/sympy/algebra/
+-rw-rw-rw-   0        0        0       62 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/algebra/__init__.py
+-rw-rw-rw-   0        0        0    20368 2022-04-23 13:44:25.000000 sympy.keras-1.0.4/sympy/algebra/quaternion.py
+drwxrwxrwx   0        0        0        0 2022-10-12 08:07:39.402849 sympy.keras-1.0.4/sympy/assumptions/
+-rw-rw-rw-   0        0        0      163 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/assumptions/__init__.py
+-rw-rw-rw-   0        0        0    43526 2021-10-01 01:55:11.000000 sympy.keras-1.0.4/sympy/assumptions/ask.py
+-rw-rw-rw-   0        0        0     6673 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/assumptions/ask_generated.py
+-rw-rw-rw-   0        0        0     6276 2022-04-23 13:44:25.000000 sympy.keras-1.0.4/sympy/assumptions/assume.py
+-rw-rw-rw-   0        0        0    10073 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/assumptions/cnf.py
+drwxrwxrwx   0        0        0        0 2022-10-12 08:07:39.406415 sympy.keras-1.0.4/sympy/assumptions/handlers/
+-rw-rw-rw-   0        0        0      115 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/assumptions/handlers/__init__.py
+-rw-rw-rw-   0        0        0     6990 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/assumptions/handlers/calculus.py
+-rw-rw-rw-   0        0        0     3249 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/assumptions/handlers/common.py
+-rw-rw-rw-   0        0        0    19601 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/assumptions/handlers/matrices.py
+-rw-rw-rw-   0        0        0     7355 2022-04-23 13:44:25.000000 sympy.keras-1.0.4/sympy/assumptions/handlers/ntheory.py
+-rw-rw-rw-   0        0        0    10833 2022-04-23 13:44:25.000000 sympy.keras-1.0.4/sympy/assumptions/handlers/order.py
+-rw-rw-rw-   0        0        0    21225 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/assumptions/handlers/sets.py
+-rw-rw-rw-   0        0        0     7964 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/assumptions/refine.py
+-rw-rw-rw-   0        0        0     2977 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/assumptions/satask.py
+-rw-rw-rw-   0        0        0    13395 2022-04-23 13:44:25.000000 sympy.keras-1.0.4/sympy/assumptions/sathandlers.py
+drwxrwxrwx   0        0        0        0 2022-10-12 08:07:39.408410 sympy.keras-1.0.4/sympy/calculus/
+-rw-rw-rw-   0        0        0      830 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/calculus/__init__.py
+-rw-rw-rw-   0        0        0     3264 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/calculus/euler.py
+-rw-rw-rw-   0        0        0    16652 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/calculus/finite_diff.py
+-rw-rw-rw-   0        0        0    10830 2022-10-01 04:16:50.000000 sympy.keras-1.0.4/sympy/calculus/singularities.py
+-rw-rw-rw-   0        0        0    53018 2021-09-11 15:26:48.000000 sympy.keras-1.0.4/sympy/calculus/util.py
+drwxrwxrwx   0        0        0        0 2022-10-12 08:07:39.410404 sympy.keras-1.0.4/sympy/categories/
+-rw-rw-rw-   0        0        0      771 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/categories/__init__.py
+-rw-rw-rw-   0        0        0    30746 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/categories/baseclasses.py
+-rw-rw-rw-   0        0        0    95496 2022-04-23 13:44:25.000000 sympy.keras-1.0.4/sympy/categories/diagram_drawing.py
+drwxrwxrwx   0        0        0        0 2022-10-12 08:07:39.416388 sympy.keras-1.0.4/sympy/codegen/
+-rw-rw-rw-   0        0        0      773 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/codegen/__init__.py
+-rw-rw-rw-   0        0        0     4905 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/codegen/algorithms.py
+-rw-rw-rw-   0        0        0     6431 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/codegen/approximations.py
+-rw-rw-rw-   0        0        0    56750 2022-10-02 01:16:37.000000 sympy.keras-1.0.4/sympy/codegen/array_utils.py
+-rw-rw-rw-   0        0        0    54635 2022-10-01 04:19:03.000000 sympy.keras-1.0.4/sympy/codegen/ast.py
+-rw-rw-rw-   0        0        0    11380 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/codegen/cfunctions.py
+-rw-rw-rw-   0        0        0     2431 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/codegen/cnodes.py
+-rw-rw-rw-   0        0        0      387 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/codegen/cutils.py
+-rw-rw-rw-   0        0        0      332 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/codegen/cxxnodes.py
+-rw-rw-rw-   0        0        0    18905 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/codegen/fnodes.py
+-rw-rw-rw-   0        0        0     1806 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/codegen/futils.py
+-rw-rw-rw-   0        0        0     2112 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/codegen/matrix_nodes.py
+-rw-rw-rw-   0        0        0     3098 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/codegen/numpy_nodes.py
+-rw-rw-rw-   0        0        0      658 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/codegen/pyutils.py
+-rw-rw-rw-   0        0        0     6995 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/codegen/rewriting.py
+-rw-rw-rw-   0        0        0     1176 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/codegen/scipy_nodes.py
+drwxrwxrwx   0        0        0        0 2022-10-12 08:07:39.428808 sympy.keras-1.0.4/sympy/combinatorics/
+-rw-rw-rw-   0        0        0      780 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/combinatorics/__init__.py
+-rw-rw-rw-   0        0        0    42986 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/combinatorics/coset_table.py
+-rw-rw-rw-   0        0        0    47699 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/combinatorics/fp_groups.py
+-rw-rw-rw-   0        0        0    39988 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/combinatorics/free_groups.py
+-rw-rw-rw-   0        0        0     7917 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/combinatorics/generators.py
+-rw-rw-rw-   0        0        0    11238 2022-04-23 13:44:25.000000 sympy.keras-1.0.4/sympy/combinatorics/graycode.py
+-rw-rw-rw-   0        0        0     1940 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/combinatorics/group_constructs.py
+-rw-rw-rw-   0        0        0    19318 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/combinatorics/homomorphisms.py
+-rw-rw-rw-   0        0        0     7822 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/combinatorics/named_groups.py
+-rw-rw-rw-   0        0        0    20615 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/combinatorics/partitions.py
+-rw-rw-rw-   0        0        0    21049 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/combinatorics/pc_groups.py
+-rw-rw-rw-   0        0        0   163552 2022-09-24 00:48:20.000000 sympy.keras-1.0.4/sympy/combinatorics/perm_groups.py
+-rw-rw-rw-   0        0        0    80708 2022-04-23 13:44:25.000000 sympy.keras-1.0.4/sympy/combinatorics/permutations.py
+-rw-rw-rw-   0        0        0    28418 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/combinatorics/polyhedron.py
+-rw-rw-rw-   0        0        0    11859 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/combinatorics/prufer.py
+-rw-rw-rw-   0        0        0    17182 2022-04-23 13:44:25.000000 sympy.keras-1.0.4/sympy/combinatorics/rewritingsystem.py
+-rw-rw-rw-   0        0        0     2449 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/combinatorics/rewritingsystem_fsm.py
+-rw-rw-rw-   0        0        0     4128 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/combinatorics/schur_number.py
+-rw-rw-rw-   0        0        0    15804 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/combinatorics/subsets.py
+-rw-rw-rw-   0        0        0    40787 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/combinatorics/tensor_can.py
+-rw-rw-rw-   0        0        0    10913 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/combinatorics/testutil.py
+-rw-rw-rw-   0        0        0    16951 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/combinatorics/util.py
+drwxrwxrwx   0        0        0        0 2022-10-12 08:07:39.437272 sympy.keras-1.0.4/sympy/concrete/
+-rw-rw-rw-   0        0        0      360 2021-12-16 21:56:21.000000 sympy.keras-1.0.4/sympy/concrete/__init__.py
+-rw-rw-rw-   0        0        0    22953 2022-09-24 00:48:20.000000 sympy.keras-1.0.4/sympy/concrete/conditional_boolean.py
+-rw-rw-rw-   0        0        0     9891 2022-04-23 13:44:25.000000 sympy.keras-1.0.4/sympy/concrete/delta.py
+-rw-rw-rw-   0        0        0    11613 2022-01-23 07:02:53.000000 sympy.keras-1.0.4/sympy/concrete/exists.py
+-rw-rw-rw-   0        0        0    12358 2022-01-27 22:10:33.000000 sympy.keras-1.0.4/sympy/concrete/expr_with_intlimits.py
+-rw-rw-rw-   0        0        0   115312 2022-10-11 10:23:15.000000 sympy.keras-1.0.4/sympy/concrete/expr_with_limits.py
+-rw-rw-rw-   0        0        0     9852 2022-01-27 22:10:33.000000 sympy.keras-1.0.4/sympy/concrete/forall.py
+-rw-rw-rw-   0        0        0     5462 2022-04-23 13:44:25.000000 sympy.keras-1.0.4/sympy/concrete/gosper.py
+-rw-rw-rw-   0        0        0    17283 2022-04-23 13:44:25.000000 sympy.keras-1.0.4/sympy/concrete/guess.py
+-rw-rw-rw-   0        0        0     7627 2022-01-01 12:24:42.000000 sympy.keras-1.0.4/sympy/concrete/limits.py
+-rw-rw-rw-   0        0        0    41512 2022-02-20 02:33:56.000000 sympy.keras-1.0.4/sympy/concrete/products.py
+-rw-rw-rw-   0        0        0    15618 2022-10-11 08:11:21.000000 sympy.keras-1.0.4/sympy/concrete/reduced.py
+-rw-rw-rw-   0        0        0    47878 2022-01-27 23:22:17.000000 sympy.keras-1.0.4/sympy/concrete/sets.py
+-rw-rw-rw-   0        0        0    70219 2022-10-09 07:15:03.000000 sympy.keras-1.0.4/sympy/concrete/summations.py
+-rw-rw-rw-   0        0        0     2258 2022-04-23 13:44:25.000000 sympy.keras-1.0.4/sympy/conftest.py
+drwxrwxrwx   0        0        0        0 2022-10-12 08:07:39.455000 sympy.keras-1.0.4/sympy/core/
+-rw-rw-rw-   0        0        0     1418 2022-10-05 05:25:10.000000 sympy.keras-1.0.4/sympy/core/__init__.py
+-rw-rw-rw-   0        0        0     2388 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/core/_print_helpers.py
+-rw-rw-rw-   0        0        0    61709 2022-10-11 02:53:41.000000 sympy.keras-1.0.4/sympy/core/add.py
+-rw-rw-rw-   0        0        0      266 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/core/alphabets.py
+-rw-rw-rw-   0        0        0    26814 2022-10-11 08:05:11.000000 sympy.keras-1.0.4/sympy/core/assumptions.py
+-rw-rw-rw-   0        0        0     1161 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/core/backend.py
+-rw-rw-rw-   0        0        0   101122 2022-10-12 07:48:08.000000 sympy.keras-1.0.4/sympy/core/basic.py
+-rw-rw-rw-   0        0        0     4676 2022-01-09 03:27:32.000000 sympy.keras-1.0.4/sympy/core/cache.py
+-rw-rw-rw-   0        0        0    18989 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/core/compatibility.py
+-rw-rw-rw-   0        0        0    16803 2022-10-04 02:15:21.000000 sympy.keras-1.0.4/sympy/core/containers.py
+-rw-rw-rw-   0        0        0     9204 2022-10-05 09:46:37.000000 sympy.keras-1.0.4/sympy/core/core.py
+-rw-rw-rw-   0        0        0      271 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/core/coreerrors.py
+-rw-rw-rw-   0        0        0     9428 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/core/decorators.py
+-rw-rw-rw-   0        0        0    52369 2022-02-19 14:23:21.000000 sympy.keras-1.0.4/sympy/core/evalf.py
+-rw-rw-rw-   0        0        0   149965 2022-10-04 03:46:52.000000 sympy.keras-1.0.4/sympy/core/expr.py
+-rw-rw-rw-   0        0        0    51392 2022-10-01 04:23:26.000000 sympy.keras-1.0.4/sympy/core/exprtools.py
+-rw-rw-rw-   0        0        0    16299 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/core/facts.py
+-rw-rw-rw-   0        0        0   158286 2022-10-12 05:10:27.000000 sympy.keras-1.0.4/sympy/core/function.py
+-rw-rw-rw-   0        0        0    34657 2022-09-24 00:48:21.000000 sympy.keras-1.0.4/sympy/core/inference.py
+-rw-rw-rw-   0        0        0    11519 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/core/kind.py
+-rw-rw-rw-   0        0        0    11662 2021-09-19 13:11:37.000000 sympy.keras-1.0.4/sympy/core/logic.py
+-rw-rw-rw-   0        0        0     9652 2022-10-04 02:16:03.000000 sympy.keras-1.0.4/sympy/core/mod.py
+-rw-rw-rw-   0        0        0   101552 2022-10-12 08:02:09.000000 sympy.keras-1.0.4/sympy/core/mul.py
+-rw-rw-rw-   0        0        0     4360 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/core/multidimensional.py
+-rw-rw-rw-   0        0        0   147406 2022-10-11 08:14:33.000000 sympy.keras-1.0.4/sympy/core/numbers.py
+-rw-rw-rw-   0        0        0    23859 2022-10-02 01:43:14.000000 sympy.keras-1.0.4/sympy/core/of.py
+-rw-rw-rw-   0        0        0    29564 2022-10-04 02:16:14.000000 sympy.keras-1.0.4/sympy/core/operations.py
+-rw-rw-rw-   0        0        0     3037 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/core/parameters.py
+-rw-rw-rw-   0        0        0    80157 2022-10-09 07:17:43.000000 sympy.keras-1.0.4/sympy/core/power.py
+-rw-rw-rw-   0        0        0   109086 2022-10-09 07:18:23.000000 sympy.keras-1.0.4/sympy/core/relational.py
+-rw-rw-rw-   0        0        0     1502 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/core/rules.py
+-rw-rw-rw-   0        0        0     8063 2022-10-04 03:25:15.000000 sympy.keras-1.0.4/sympy/core/singleton.py
+-rw-rw-rw-   0        0        0    91849 2022-10-11 10:12:49.000000 sympy.keras-1.0.4/sympy/core/symbol.py
+-rw-rw-rw-   0        0        0    18404 2022-10-06 11:55:13.000000 sympy.keras-1.0.4/sympy/core/sympify.py
+-rw-rw-rw-   0        0        0     6018 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/core/trace.py
+drwxrwxrwx   0        0        0        0 2022-10-12 08:07:39.455998 sympy.keras-1.0.4/sympy/crypto/
+-rw-rw-rw-   0        0        0     1012 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/crypto/__init__.py
+-rw-rw-rw-   0        0        0    69161 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/crypto/crypto.py
+drwxrwxrwx   0        0        0        0 2022-10-12 08:07:39.456995 sympy.keras-1.0.4/sympy/deprecated/
+-rw-rw-rw-   0        0        0      422 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/deprecated/__init__.py
+-rw-rw-rw-   0        0        0     1936 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/deprecated/class_registry.py
+drwxrwxrwx   0        0        0        0 2022-10-12 08:07:39.457992 sympy.keras-1.0.4/sympy/diffgeom/
+-rw-rw-rw-   0        0        0      459 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/diffgeom/__init__.py
+-rw-rw-rw-   0        0        0    56375 2022-09-24 00:48:20.000000 sympy.keras-1.0.4/sympy/diffgeom/diffgeom.py
+-rw-rw-rw-   0        0        0     4452 2022-04-23 13:44:25.000000 sympy.keras-1.0.4/sympy/diffgeom/rn.py
+drwxrwxrwx   0        0        0        0 2022-10-12 08:07:39.459987 sympy.keras-1.0.4/sympy/discrete/
+-rw-rw-rw-   0        0        0      590 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/discrete/__init__.py
+-rw-rw-rw-   0        0        0    14474 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/discrete/convolutions.py
+-rw-rw-rw-   0        0        0     4541 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/discrete/recurrences.py
+-rw-rw-rw-   0        0        0    11724 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/discrete/transforms.py
+drwxrwxrwx   0        0        0        0 2022-10-12 08:07:39.461980 sympy.keras-1.0.4/sympy/external/
+-rw-rw-rw-   0        0        0      578 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/external/__init__.py
+-rw-rw-rw-   0        0        0     2874 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/external/gmpy.py
+-rw-rw-rw-   0        0        0     7383 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/external/importtools.py
+-rw-rw-rw-   0        0        0    11870 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/external/pythonmpq.py
+drwxrwxrwx   0        0        0        0 2022-10-12 08:07:39.461980 sympy.keras-1.0.4/sympy/functions/
+-rw-rw-rw-   0        0        0     3335 2022-01-23 00:35:40.000000 sympy.keras-1.0.4/sympy/functions/__init__.py
+drwxrwxrwx   0        0        0        0 2022-10-12 08:07:39.462979 sympy.keras-1.0.4/sympy/functions/combinatorial/
+-rw-rw-rw-   0        0        0       47 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/functions/combinatorial/__init__.py
+-rw-rw-rw-   0        0        0    37195 2022-10-02 03:39:17.000000 sympy.keras-1.0.4/sympy/functions/combinatorial/factorials.py
+-rw-rw-rw-   0        0        0    79397 2022-10-02 03:40:03.000000 sympy.keras-1.0.4/sympy/functions/combinatorial/numbers.py
+drwxrwxrwx   0        0        0        0 2022-10-12 08:07:39.469185 sympy.keras-1.0.4/sympy/functions/elementary/
+-rw-rw-rw-   0        0        0      154 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/functions/elementary/__init__.py
+-rw-rw-rw-   0        0        0    43443 2022-10-02 03:40:22.000000 sympy.keras-1.0.4/sympy/functions/elementary/complexes.py
+-rw-rw-rw-   0        0        0    34309 2022-10-10 09:58:34.000000 sympy.keras-1.0.4/sympy/functions/elementary/exponential.py
+-rw-rw-rw-   0        0        0    42641 2022-10-02 03:40:56.000000 sympy.keras-1.0.4/sympy/functions/elementary/hyperbolic.py
+-rw-rw-rw-   0        0        0    18064 2022-01-23 05:40:23.000000 sympy.keras-1.0.4/sympy/functions/elementary/integers.py
+-rw-rw-rw-   0        0        0    26547 2022-10-09 07:20:20.000000 sympy.keras-1.0.4/sympy/functions/elementary/miscellaneous.py
+-rw-rw-rw-   0        0        0    72772 2022-10-11 03:48:54.000000 sympy.keras-1.0.4/sympy/functions/elementary/piecewise.py
+-rw-rw-rw-   0        0        0    95490 2022-10-02 03:42:17.000000 sympy.keras-1.0.4/sympy/functions/elementary/trigonometric.py
+drwxrwxrwx   0        0        0        0 2022-10-12 08:07:39.476211 sympy.keras-1.0.4/sympy/functions/special/
+-rw-rw-rw-   0        0        0      307 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/functions/special/__init__.py
+-rw-rw-rw-   0        0        0    49482 2022-10-02 03:42:45.000000 sympy.keras-1.0.4/sympy/functions/special/bessel.py
+-rw-rw-rw-   0        0        0     3820 2022-10-02 03:43:15.000000 sympy.keras-1.0.4/sympy/functions/special/beta_functions.py
+-rw-rw-rw-   0        0        0     9034 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/functions/special/bsplines.py
+-rw-rw-rw-   0        0        0    20006 2022-10-01 04:52:38.000000 sympy.keras-1.0.4/sympy/functions/special/delta_functions.py
+-rw-rw-rw-   0        0        0    12840 2022-04-23 13:44:25.000000 sympy.keras-1.0.4/sympy/functions/special/elliptic_integrals.py
+-rw-rw-rw-   0        0        0    69014 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/functions/special/error_functions.py
+-rw-rw-rw-   0        0        0    42896 2022-10-02 03:43:29.000000 sympy.keras-1.0.4/sympy/functions/special/gamma_functions.py
+-rw-rw-rw-   0        0        0    35561 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/functions/special/hyper.py
+-rw-rw-rw-   0        0        0     6446 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/functions/special/mathieu_functions.py
+-rw-rw-rw-   0        0        0    39716 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/functions/special/polynomials.py
+-rw-rw-rw-   0        0        0     7395 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/functions/special/singularity_functions.py
+-rw-rw-rw-   0        0        0    10331 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/functions/special/spherical_harmonics.py
+-rw-rw-rw-   0        0        0    17726 2022-10-02 03:49:41.000000 sympy.keras-1.0.4/sympy/functions/special/tensor_functions.py
+-rw-rw-rw-   0        0        0    18625 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/functions/special/zeta_functions.py
+-rw-rw-rw-   0        0        0      123 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/galgebra.py
+drwxrwxrwx   0        0        0        0 2022-10-12 08:07:39.482784 sympy.keras-1.0.4/sympy/geometry/
+-rw-rw-rw-   0        0        0      825 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/geometry/__init__.py
+-rw-rw-rw-   0        0        0     9083 2022-09-24 00:48:20.000000 sympy.keras-1.0.4/sympy/geometry/curve.py
+-rw-rw-rw-   0        0        0    47100 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/geometry/ellipse.py
+-rw-rw-rw-   0        0        0    20388 2022-04-23 13:44:25.000000 sympy.keras-1.0.4/sympy/geometry/entity.py
+-rw-rw-rw-   0        0        0      131 2022-04-23 13:44:25.000000 sympy.keras-1.0.4/sympy/geometry/exceptions.py
+-rw-rw-rw-   0        0        0    75317 2022-04-23 13:44:25.000000 sympy.keras-1.0.4/sympy/geometry/line.py
+-rw-rw-rw-   0        0        0    10241 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/geometry/parabola.py
+-rw-rw-rw-   0        0        0    27400 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/geometry/plane.py
+-rw-rw-rw-   0        0        0    36004 2021-07-27 13:23:38.000000 sympy.keras-1.0.4/sympy/geometry/point.py
+-rw-rw-rw-   0        0        0    69238 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/geometry/polygon.py
+-rw-rw-rw-   0        0        0    19260 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/geometry/util.py
+drwxrwxrwx   0        0        0        0 2022-10-12 08:07:39.485776 sympy.keras-1.0.4/sympy/holonomic/
+-rw-rw-rw-   0        0        0      569 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/holonomic/__init__.py
+-rw-rw-rw-   0        0        0    93978 2022-10-01 04:53:28.000000 sympy.keras-1.0.4/sympy/holonomic/holonomic.py
+-rw-rw-rw-   0        0        0     1193 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/holonomic/holonomicerrors.py
+-rw-rw-rw-   0        0        0     2771 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/holonomic/linearsolver.py
+-rw-rw-rw-   0        0        0     2730 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/holonomic/numerical.py
+-rw-rw-rw-   0        0        0    10977 2022-04-23 13:44:25.000000 sympy.keras-1.0.4/sympy/holonomic/recurrence.py
+drwxrwxrwx   0        0        0        0 2022-10-12 08:07:39.492756 sympy.keras-1.0.4/sympy/integrals/
+-rw-rw-rw-   0        0        0     1154 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/integrals/__init__.py
+-rw-rw-rw-   0        0        0     7367 2022-04-23 13:44:25.000000 sympy.keras-1.0.4/sympy/integrals/deltafunctions.py
+-rw-rw-rw-   0        0        0    24363 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/integrals/heurisch.py
+-rw-rw-rw-   0        0        0    69513 2022-10-01 04:54:28.000000 sympy.keras-1.0.4/sympy/integrals/integrals.py
+-rw-rw-rw-   0        0        0    42721 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/integrals/intpoly.py
+-rw-rw-rw-   0        0        0    60660 2022-04-23 13:44:25.000000 sympy.keras-1.0.4/sympy/integrals/manualintegrate.py
+-rw-rw-rw-   0        0        0    77565 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/integrals/meijerint.py
+-rw-rw-rw-   0        0        0      934 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/integrals/meijerint_doc.py
+-rw-rw-rw-   0        0        0    52215 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/integrals/prde.py
+-rw-rw-rw-   0        0        0    16675 2022-04-23 13:44:25.000000 sympy.keras-1.0.4/sympy/integrals/quadrature.py
+-rw-rw-rw-   0        0        0    10292 2022-04-23 13:44:25.000000 sympy.keras-1.0.4/sympy/integrals/rationaltools.py
+-rw-rw-rw-   0        0        0    26576 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/integrals/rde.py
+-rw-rw-rw-   0        0        0    67325 2022-04-23 13:44:25.000000 sympy.keras-1.0.4/sympy/integrals/risch.py
+drwxrwxrwx   0        0        0        0 2022-10-12 08:07:39.497373 sympy.keras-1.0.4/sympy/integrals/rubi/
+-rw-rw-rw-   0        0        0     3463 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/integrals/rubi/__init__.py
+-rw-rw-rw-   0        0        0   294359 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/integrals/rubi/constraints.py
+drwxrwxrwx   0        0        0        0 2022-10-12 08:07:39.499246 sympy.keras-1.0.4/sympy/integrals/rubi/parsetools/
+-rw-rw-rw-   0        0        0        0 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/integrals/rubi/parsetools/__init__.py
+-rw-rw-rw-   0        0        0     2874 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/integrals/rubi/parsetools/generate_rules.py
+-rw-rw-rw-   0        0        0     2680 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/integrals/rubi/parsetools/generate_tests.py
+-rw-rw-rw-   0        0        0    27693 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/integrals/rubi/parsetools/parse.py
+-rw-rw-rw-   0        0        0     8098 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/integrals/rubi/rubimain.py
+drwxrwxrwx   0        0        0        0 2022-10-12 08:07:39.511778 sympy.keras-1.0.4/sympy/integrals/rubi/rules/
+-rw-rw-rw-   0        0        0        0 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/integrals/rubi/rules/__init__.py
+-rw-rw-rw-   0        0        0   211338 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/integrals/rubi/rules/binomial_products.py
+-rw-rw-rw-   0        0        0    66356 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/integrals/rubi/rules/exponential.py
+-rw-rw-rw-   0        0        0   231936 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/integrals/rubi/rules/hyperbolic.py
+-rw-rw-rw-   0        0        0    23847 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/integrals/rubi/rules/integrand_simplification.py
+-rw-rw-rw-   0        0        0   372022 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/integrals/rubi/rules/inverse_hyperbolic.py
+-rw-rw-rw-   0        0        0   337025 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/integrals/rubi/rules/inverse_trig.py
+-rw-rw-rw-   0        0        0    95965 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/integrals/rubi/rules/linear_products.py
+-rw-rw-rw-   0        0        0   103333 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/integrals/rubi/rules/logarithms.py
+-rw-rw-rw-   0        0        0   247667 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/integrals/rubi/rules/miscellaneous_algebraic.py
+-rw-rw-rw-   0        0        0    54467 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/integrals/rubi/rules/miscellaneous_integration.py
+-rw-rw-rw-   0        0        0   201340 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/integrals/rubi/rules/miscellaneous_trig.py
+-rw-rw-rw-   0        0        0    21166 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/integrals/rubi/rules/piecewise_linear.py
+-rw-rw-rw-   0        0        0   332737 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/integrals/rubi/rules/quadratic_products.py
+-rw-rw-rw-   0        0        0   474580 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/integrals/rubi/rules/secant.py
+-rw-rw-rw-   0        0        0   772009 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/integrals/rubi/rules/sine.py
+-rw-rw-rw-   0        0        0    95525 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/integrals/rubi/rules/special_functions.py
+-rw-rw-rw-   0        0        0   330601 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/integrals/rubi/rules/tangent.py
+-rw-rw-rw-   0        0        0   256579 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/integrals/rubi/rules/trinomial_products.py
+-rw-rw-rw-   0        0        0     1601 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/integrals/rubi/symbol.py
+-rw-rw-rw-   0        0        0   270158 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/integrals/rubi/utility_function.py
+-rw-rw-rw-   0        0        0     2303 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/integrals/singularityfunctions.py
+-rw-rw-rw-   0        0        0    63448 2022-10-02 03:51:00.000000 sympy.keras-1.0.4/sympy/integrals/transforms.py
+-rw-rw-rw-   0        0        0    11077 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/integrals/trigonometry.py
+drwxrwxrwx   0        0        0        0 2022-10-12 08:07:39.513773 sympy.keras-1.0.4/sympy/interactive/
+-rw-rw-rw-   0        0        0      135 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/interactive/__init__.py
+-rw-rw-rw-   0        0        0     1736 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/interactive/ipythonprinting.py
+-rw-rw-rw-   0        0        0    17695 2022-04-23 13:44:25.000000 sympy.keras-1.0.4/sympy/interactive/printing.py
+-rw-rw-rw-   0        0        0    15021 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/interactive/session.py
+drwxrwxrwx   0        0        0        0 2022-10-12 08:07:39.516892 sympy.keras-1.0.4/sympy/keras/
+-rw-rw-rw-   0        0        0      340 2022-10-12 05:24:15.000000 sympy.keras-1.0.4/sympy/keras/__init__.py
+-rw-rw-rw-   0        0        0     1170 2022-10-05 08:31:47.000000 sympy.keras-1.0.4/sympy/keras/linalg.py
+-rw-rw-rw-   0        0        0      340 2022-10-05 08:33:14.000000 sympy.keras-1.0.4/sympy/keras/losses.py
+-rw-rw-rw-   0        0        0      285 2022-10-05 08:34:43.000000 sympy.keras-1.0.4/sympy/keras/math.py
+-rw-rw-rw-   0        0        0    11011 2022-10-12 05:59:44.000000 sympy.keras-1.0.4/sympy/keras/model.py
+drwxrwxrwx   0        0        0        0 2022-10-12 08:07:39.516892 sympy.keras-1.0.4/sympy/keras/nn/
+-rw-rw-rw-   0        0        0     2454 2022-10-07 03:14:15.000000 sympy.keras-1.0.4/sympy/keras/nn/__init__.py
+drwxrwxrwx   0        0        0        0 2022-10-12 08:07:39.517891 sympy.keras-1.0.4/sympy/keras/nn/convolutional/
+-rw-rw-rw-   0        0        0        0 2022-10-06 02:34:29.000000 sympy.keras-1.0.4/sympy/keras/nn/convolutional/__init__.py
+-rw-rw-rw-   0        0        0     3956 2022-10-05 08:14:45.000000 sympy.keras-1.0.4/sympy/keras/nn/convolutional/same.py
+-rw-rw-rw-   0        0        0     2734 2022-09-24 00:48:21.000000 sympy.keras-1.0.4/sympy/keras/nn/functional.py
+drwxrwxrwx   0        0        0        0 2022-10-12 08:07:39.521880 sympy.keras-1.0.4/sympy/keras/nn/modules/
+-rw-rw-rw-   0        0        0        0 2022-10-06 02:34:29.000000 sympy.keras-1.0.4/sympy/keras/nn/modules/__init__.py
+-rw-rw-rw-   0        0        0     1769 2022-10-07 03:09:57.000000 sympy.keras-1.0.4/sympy/keras/nn/modules/classifier.py
+-rw-rw-rw-   0        0        0     3850 2022-10-07 03:10:21.000000 sympy.keras-1.0.4/sympy/keras/nn/modules/container.py
+-rw-rw-rw-   0        0        0    25145 2022-10-09 09:31:48.000000 sympy.keras-1.0.4/sympy/keras/nn/modules/conv.py
+-rw-rw-rw-   0        0        0    14635 2022-10-09 07:46:00.000000 sympy.keras-1.0.4/sympy/keras/nn/modules/module.py
+-rw-rw-rw-   0        0        0     3999 2022-10-07 03:23:40.000000 sympy.keras-1.0.4/sympy/keras/nn/modules/normalization.py
+-rw-rw-rw-   0        0        0    59809 2022-10-11 07:56:20.000000 sympy.keras-1.0.4/sympy/keras/nn/modules/rnn.py
+-rw-rw-rw-   0        0        0      829 2022-10-09 09:32:09.000000 sympy.keras-1.0.4/sympy/keras/nn/modules/sparse.py
+drwxrwxrwx   0        0        0        0 2022-10-12 08:07:39.522877 sympy.keras-1.0.4/sympy/keras/nn/recurrent/
+-rw-rw-rw-   0        0        0        0 2022-10-06 02:34:29.000000 sympy.keras-1.0.4/sympy/keras/nn/recurrent/__init__.py
+-rw-rw-rw-   0        0        0     1384 2022-10-05 08:38:56.000000 sympy.keras-1.0.4/sympy/keras/nn/recurrent/gru.py
+-rw-rw-rw-   0        0        0     2140 2022-10-05 08:46:37.000000 sympy.keras-1.0.4/sympy/keras/nn/recurrent/lstm.py
+-rw-rw-rw-   0        0        0      182 2022-10-05 08:01:53.000000 sympy.keras-1.0.4/sympy/keras/ops.py
+drwxrwxrwx   0        0        0        0 2022-10-12 08:07:39.529515 sympy.keras-1.0.4/sympy/liealgebras/
+-rw-rw-rw-   0        0        0       53 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/liealgebras/__init__.py
+-rw-rw-rw-   0        0        0      524 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/liealgebras/cartan_matrix.py
+-rw-rw-rw-   0        0        0     1793 2022-04-23 13:44:25.000000 sympy.keras-1.0.4/sympy/liealgebras/cartan_type.py
+-rw-rw-rw-   0        0        0      535 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/liealgebras/dynkin_diagram.py
+-rw-rw-rw-   0        0        0     6850 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/liealgebras/root_system.py
+-rw-rw-rw-   0        0        0     4317 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/liealgebras/type_a.py
+-rw-rw-rw-   0        0        0     4565 2022-04-23 13:44:25.000000 sympy.keras-1.0.4/sympy/liealgebras/type_b.py
+-rw-rw-rw-   0        0        0     4441 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/liealgebras/type_c.py
+-rw-rw-rw-   0        0        0     4695 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/liealgebras/type_d.py
+-rw-rw-rw-   0        0        0     9782 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/liealgebras/type_e.py
+-rw-rw-rw-   0        0        0     4413 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/liealgebras/type_f.py
+-rw-rw-rw-   0        0        0     2965 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/liealgebras/type_g.py
+-rw-rw-rw-   0        0        0    14710 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/liealgebras/weyl_group.py
+drwxrwxrwx   0        0        0        0 2022-10-12 08:07:39.531512 sympy.keras-1.0.4/sympy/logic/
+-rw-rw-rw-   0        0        0      232 2021-10-01 01:55:11.000000 sympy.keras-1.0.4/sympy/logic/__init__.py
+drwxrwxrwx   0        0        0        0 2022-10-12 08:07:39.533506 sympy.keras-1.0.4/sympy/logic/algorithms/
+-rw-rw-rw-   0        0        0        0 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/logic/algorithms/__init__.py
+-rw-rw-rw-   0        0        0     9162 2022-04-23 13:44:25.000000 sympy.keras-1.0.4/sympy/logic/algorithms/dpll.py
+-rw-rw-rw-   0        0        0    20466 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/logic/algorithms/dpll2.py
+-rw-rw-rw-   0        0        0     1207 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/logic/algorithms/pycosat_wrapper.py
+-rw-rw-rw-   0        0        0   118416 2022-10-07 07:54:31.000000 sympy.keras-1.0.4/sympy/logic/boolalg.py
+-rw-rw-rw-   0        0        0     7586 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/logic/inference.py
+-rw-rw-rw-   0        0        0    17270 2022-10-11 00:28:47.000000 sympy.keras-1.0.4/sympy/logic/invoker.py
+drwxrwxrwx   0        0        0        0 2022-10-12 08:07:39.533506 sympy.keras-1.0.4/sympy/logic/utilities/
+-rw-rw-rw-   0        0        0       30 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/logic/utilities/__init__.py
+-rw-rw-rw-   0        0        0     1663 2022-04-23 13:44:25.000000 sympy.keras-1.0.4/sympy/logic/utilities/dimacs.py
+drwxrwxrwx   0        0        0        0 2022-10-12 08:07:39.544653 sympy.keras-1.0.4/sympy/matrices/
+-rw-rw-rw-   0        0        0     1284 2021-10-09 13:08:45.000000 sympy.keras-1.0.4/sympy/matrices/__init__.py
+-rw-rw-rw-   0        0        0    75119 2022-10-03 03:59:23.000000 sympy.keras-1.0.4/sympy/matrices/common.py
+-rw-rw-rw-   0        0        0    41139 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/matrices/decompositions.py
+-rw-rw-rw-   0        0        0    47149 2022-10-11 03:39:37.000000 sympy.keras-1.0.4/sympy/matrices/dense.py
+-rw-rw-rw-   0        0        0     5486 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/matrices/densearith.py
+-rw-rw-rw-   0        0        0    11737 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/matrices/densesolve.py
+-rw-rw-rw-   0        0        0     5490 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/matrices/densetools.py
+-rw-rw-rw-   0        0        0    27950 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/matrices/determinant.py
+-rw-rw-rw-   0        0        0    37867 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/matrices/eigen.py
+drwxrwxrwx   0        0        0        0 2022-10-12 08:07:39.554628 sympy.keras-1.0.4/sympy/matrices/expressions/
+-rw-rw-rw-   0        0        0      945 2021-10-09 13:08:45.000000 sympy.keras-1.0.4/sympy/matrices/expressions/__init__.py
+-rw-rw-rw-   0        0        0     1709 2022-10-02 03:53:38.000000 sympy.keras-1.0.4/sympy/matrices/expressions/adjoint.py
+-rw-rw-rw-   0        0        0     5029 2022-10-05 05:30:03.000000 sympy.keras-1.0.4/sympy/matrices/expressions/applyfunc.py
+-rw-rw-rw-   0        0        0    34217 2022-10-12 05:58:26.000000 sympy.keras-1.0.4/sympy/matrices/expressions/blockmatrix.py
+-rw-rw-rw-   0        0        0     1411 2022-10-03 03:30:25.000000 sympy.keras-1.0.4/sympy/matrices/expressions/cofactor.py
+-rw-rw-rw-   0        0        0     1745 2022-10-03 03:31:46.000000 sympy.keras-1.0.4/sympy/matrices/expressions/companion.py
+-rw-rw-rw-   0        0        0     3268 2022-10-04 02:17:22.000000 sympy.keras-1.0.4/sympy/matrices/expressions/determinant.py
+-rw-rw-rw-   0        0        0     6003 2022-10-03 03:32:26.000000 sympy.keras-1.0.4/sympy/matrices/expressions/diagonal.py
+-rw-rw-rw-   0        0        0     1960 2022-04-23 13:44:25.000000 sympy.keras-1.0.4/sympy/matrices/expressions/dotproduct.py
+-rw-rw-rw-   0        0        0     1064 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/matrices/expressions/factorizations.py
+-rw-rw-rw-   0        0        0      647 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/matrices/expressions/fourier.py
+-rw-rw-rw-   0        0        0     1387 2022-10-03 03:33:26.000000 sympy.keras-1.0.4/sympy/matrices/expressions/funcmatrix.py
+-rw-rw-rw-   0        0        0    10081 2022-10-03 03:33:44.000000 sympy.keras-1.0.4/sympy/matrices/expressions/hadamard.py
+-rw-rw-rw-   0        0        0     2685 2022-10-03 03:34:47.000000 sympy.keras-1.0.4/sympy/matrices/expressions/inverse.py
+-rw-rw-rw-   0        0        0    13326 2022-10-03 03:35:43.000000 sympy.keras-1.0.4/sympy/matrices/expressions/kronecker.py
+-rw-rw-rw-   0        0        0     4289 2022-10-03 03:35:59.000000 sympy.keras-1.0.4/sympy/matrices/expressions/matadd.py
+-rw-rw-rw-   0        0        0    59129 2022-10-11 09:43:38.000000 sympy.keras-1.0.4/sympy/matrices/expressions/matexpr.py
+-rw-rw-rw-   0        0        0    32293 2022-10-12 05:58:22.000000 sympy.keras-1.0.4/sympy/matrices/expressions/matmul.py
+-rw-rw-rw-   0        0        0     7022 2022-10-03 03:41:36.000000 sympy.keras-1.0.4/sympy/matrices/expressions/matpow.py
+-rw-rw-rw-   0        0        0     1354 2022-10-03 03:42:34.000000 sympy.keras-1.0.4/sympy/matrices/expressions/minors.py
+-rw-rw-rw-   0        0        0     8075 2022-10-03 03:44:59.000000 sympy.keras-1.0.4/sympy/matrices/expressions/permutation.py
+-rw-rw-rw-   0        0        0     1887 2022-10-03 03:45:13.000000 sympy.keras-1.0.4/sympy/matrices/expressions/sets.py
+-rw-rw-rw-   0        0        0     3352 2022-10-03 03:46:14.000000 sympy.keras-1.0.4/sympy/matrices/expressions/slice.py
+-rw-rw-rw-   0        0        0     3601 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/matrices/expressions/trace.py
+-rw-rw-rw-   0        0        0    10022 2022-10-12 05:58:18.000000 sympy.keras-1.0.4/sympy/matrices/expressions/transpose.py
+-rw-rw-rw-   0        0        0     2979 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/matrices/graph.py
+-rw-rw-rw-   0        0        0     5991 2022-10-03 03:48:35.000000 sympy.keras-1.0.4/sympy/matrices/immutable.py
+-rw-rw-rw-   0        0        0    11376 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/matrices/inverse.py
+-rw-rw-rw-   0        0        0   173337 2022-09-24 00:48:20.000000 sympy.keras-1.0.4/sympy/matrices/matrices.py
+-rw-rw-rw-   0        0        0     4460 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/matrices/normalforms.py
+-rw-rw-rw-   0        0        0    10179 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/matrices/reductions.py
+-rw-rw-rw-   0        0        0    22092 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/matrices/solvers.py
+-rw-rw-rw-   0        0        0    43638 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/matrices/sparse.py
+-rw-rw-rw-   0        0        0     8671 2022-04-23 13:44:25.000000 sympy.keras-1.0.4/sympy/matrices/sparsetools.py
+-rw-rw-rw-   0        0        0     4347 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/matrices/subspaces.py
+-rw-rw-rw-   0        0        0     1823 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/matrices/utilities.py
+drwxrwxrwx   0        0        0        0 2022-10-12 08:07:39.556622 sympy.keras-1.0.4/sympy/multipledispatch/
+-rw-rw-rw-   0        0        0      147 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/multipledispatch/__init__.py
+-rw-rw-rw-   0        0        0     2128 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/multipledispatch/conflict.py
+-rw-rw-rw-   0        0        0     2275 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/multipledispatch/core.py
+-rw-rw-rw-   0        0        0    12235 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/multipledispatch/dispatcher.py
+-rw-rw-rw-   0        0        0     3053 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/multipledispatch/utils.py
+drwxrwxrwx   0        0        0        0 2022-10-12 08:07:39.565216 sympy.keras-1.0.4/sympy/ntheory/
+-rw-rw-rw-   0        0        0     1176 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/ntheory/__init__.py
+-rw-rw-rw-   0        0        0     5213 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/ntheory/bbp_pi.py
+-rw-rw-rw-   0        0        0    10425 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/ntheory/continued_fraction.py
+-rw-rw-rw-   0        0        0     3692 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/ntheory/digits.py
+-rw-rw-rw-   0        0        0    10161 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/ntheory/ecm.py
+-rw-rw-rw-   0        0        0     6069 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/ntheory/egyptian_fraction.py
+-rw-rw-rw-   0        0        0    11473 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/ntheory/elliptic_curve.py
+-rw-rw-rw-   0        0        0    63259 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/ntheory/factor_.py
+-rw-rw-rw-   0        0        0    28570 2022-04-23 13:44:25.000000 sympy.keras-1.0.4/sympy/ntheory/generate.py
+-rw-rw-rw-   0        0        0     7655 2022-04-23 13:44:25.000000 sympy.keras-1.0.4/sympy/ntheory/modular.py
+-rw-rw-rw-   0        0        0     5103 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/ntheory/multinomial.py
+-rw-rw-rw-   0        0        0     5971 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/ntheory/partitions_.py
+-rw-rw-rw-   0        0        0    18943 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/ntheory/primetest.py
+-rw-rw-rw-   0        0        0    18450 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/ntheory/qs.py
+-rw-rw-rw-   0        0        0    32962 2022-04-23 13:44:25.000000 sympy.keras-1.0.4/sympy/ntheory/residue_ntheory.py
+drwxrwxrwx   0        0        0        0 2022-10-12 08:07:39.568208 sympy.keras-1.0.4/sympy/parsing/
+-rw-rw-rw-   0        0        0      129 2020-08-27 18:42:07.000000 sympy.keras-1.0.4/sympy/parsing/__init__.py
+-rw-rw-rw-   0        0        0     2803 2022-08-14 11:13:22.000000 sympy.keras-1.0.4/sympy/parsing/ast_parser.py
+drwxrwxrwx   0        0        0        0 2022-10-12 08:07:39.569205 sympy.keras-1.0.4/sympy/parsing/autolev/
+-rw-rw-rw-   0        0        0     3708 2022-08-14 11:13:22.000000 sympy.keras-1.0.4/sympy/parsing/autolev/__init__.py
+drwxrwxrwx   0        0        0        0 2022-10-12 08:07:39.571200 sympy.keras-1.0.4/sympy/parsing/autolev/_antlr/
+-rw-rw-rw-   0        0        0      203 2022-08-14 11:17:19.000000 sympy.keras-1.0.4/sympy/parsing/autolev/_antlr/__init__.py
+-rw-rw-rw-   0        0        0    13607 2022-08-14 11:17:45.000000 sympy.keras-1.0.4/sympy/parsing/autolev/_antlr/autolevlexer.py
+-rw-rw-rw-   0        0        0    12821 2022-08-14 11:18:31.000000 sympy.keras-1.0.4/sympy/parsing/autolev/_antlr/autolevlistener.py
+-rw-rw-rw-   0        0        0   111788 2022-08-14 11:13:22.000000 sympy.keras-1.0.4/sympy/parsing/autolev/_antlr/autolevparser.py
+-rw-rw-rw-   0        0        0     2676 2022-08-14 11:13:22.000000 sympy.keras-1.0.4/sympy/parsing/autolev/_build_autolev_antlr.py
+-rw-rw-rw-   0        0        0   106841 2021-06-29 22:51:23.000000 sympy.keras-1.0.4/sympy/parsing/autolev/_listener_autolev_antlr.py
+-rw-rw-rw-   0        0        0     1761 2022-08-14 11:13:22.000000 sympy.keras-1.0.4/sympy/parsing/autolev/_parse_autolev_antlr.py
+drwxrwxrwx   0        0        0        0 2022-10-12 08:07:39.572197 sympy.keras-1.0.4/sympy/parsing/c/
+-rw-rw-rw-   0        0        0       65 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/parsing/c/__init__.py
+-rw-rw-rw-   0        0        0    40449 2022-08-14 11:13:22.000000 sympy.keras-1.0.4/sympy/parsing/c/c_parser.py
+drwxrwxrwx   0        0        0        0 2022-10-12 08:07:39.575190 sympy.keras-1.0.4/sympy/parsing/fortran/
+-rw-rw-rw-   0        0        0       74 2021-01-28 01:12:36.000000 sympy.keras-1.0.4/sympy/parsing/fortran/__init__.py
+-rw-rw-rw-   0        0        0    11828 2022-08-14 11:13:22.000000 sympy.keras-1.0.4/sympy/parsing/fortran/fortran_parser.py
+drwxrwxrwx   0        0        0        0 2022-10-12 08:07:39.577184 sympy.keras-1.0.4/sympy/parsing/latex/
+-rw-rw-rw-   0        0        0     1026 2020-08-27 18:42:07.000000 sympy.keras-1.0.4/sympy/parsing/latex/__init__.py
+drwxrwxrwx   0        0        0        0 2022-10-12 08:07:39.578181 sympy.keras-1.0.4/sympy/parsing/latex/_antlr/
+-rw-rw-rw-   0        0        0      393 2022-08-14 11:13:22.000000 sympy.keras-1.0.4/sympy/parsing/latex/_antlr/__init__.py
+-rw-rw-rw-   0        0        0    31012 2022-08-14 11:13:22.000000 sympy.keras-1.0.4/sympy/parsing/latex/_antlr/latexlexer.py
+-rw-rw-rw-   0        0        0   133802 2022-08-14 11:13:22.000000 sympy.keras-1.0.4/sympy/parsing/latex/_antlr/latexparser.py
+-rw-rw-rw-   0        0        0     2868 2022-08-14 11:13:22.000000 sympy.keras-1.0.4/sympy/parsing/latex/_build_latex_antlr.py
+-rw-rw-rw-   0        0        0    21041 2022-08-14 11:24:00.000000 sympy.keras-1.0.4/sympy/parsing/latex/_parse_latex_antlr.py
+-rw-rw-rw-   0        0        0       45 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/parsing/latex/errors.py
+-rw-rw-rw-   0        0        0    40265 2022-08-14 11:13:22.000000 sympy.keras-1.0.4/sympy/parsing/mathematica.py
+-rw-rw-rw-   0        0        0     1906 2022-08-14 11:13:22.000000 sympy.keras-1.0.4/sympy/parsing/maxima.py
+-rw-rw-rw-   0        0        0     9173 2022-08-14 11:13:22.000000 sympy.keras-1.0.4/sympy/parsing/sym_expr.py
+-rw-rw-rw-   0        0        0    44245 2022-08-14 11:13:22.000000 sympy.keras-1.0.4/sympy/parsing/sympy_parser.py
+drwxrwxrwx   0        0        0        0 2022-10-12 08:07:39.582170 sympy.keras-1.0.4/sympy/physics/
+-rw-rw-rw-   0        0        0      138 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/physics/__init__.py
+drwxrwxrwx   0        0        0        0 2022-10-12 08:07:39.583168 sympy.keras-1.0.4/sympy/physics/continuum_mechanics/
+-rw-rw-rw-   0        0        0       23 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/physics/continuum_mechanics/__init__.py
+-rw-rw-rw-   0        0        0    81736 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/physics/continuum_mechanics/beam.py
+drwxrwxrwx   0        0        0        0 2022-10-12 08:07:39.584165 sympy.keras-1.0.4/sympy/physics/control/
+-rw-rw-rw-   0        0        0      128 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/physics/control/__init__.py
+-rw-rw-rw-   0        0        0    41835 2021-07-25 01:20:20.000000 sympy.keras-1.0.4/sympy/physics/control/lti.py
+-rw-rw-rw-   0        0        0      556 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/physics/gaussopt.py
+drwxrwxrwx   0        0        0        0 2022-10-12 08:07:39.585162 sympy.keras-1.0.4/sympy/physics/hep/
+-rw-rw-rw-   0        0        0        0 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/physics/hep/__init__.py
+-rw-rw-rw-   0        0        0    24138 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/physics/hep/gamma_matrices.py
+-rw-rw-rw-   0        0        0     6424 2022-04-23 13:44:25.000000 sympy.keras-1.0.4/sympy/physics/hydrogen.py
+-rw-rw-rw-   0        0        0     4051 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/physics/matrices.py
+drwxrwxrwx   0        0        0        0 2022-10-12 08:07:39.591145 sympy.keras-1.0.4/sympy/physics/mechanics/
+-rw-rw-rw-   0        0        0     1294 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/physics/mechanics/__init__.py
+-rw-rw-rw-   0        0        0     7676 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/physics/mechanics/body.py
+-rw-rw-rw-   0        0        0    23227 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/physics/mechanics/functions.py
+-rw-rw-rw-   0        0        0    27381 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/physics/mechanics/kane.py
+-rw-rw-rw-   0        0        0    18030 2022-04-23 13:44:25.000000 sympy.keras-1.0.4/sympy/physics/mechanics/lagrange.py
+-rw-rw-rw-   0        0        0    15422 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/physics/mechanics/linearize.py
+-rw-rw-rw-   0        0        0     6458 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/physics/mechanics/models.py
+-rw-rw-rw-   0        0        0     5876 2022-04-23 13:44:25.000000 sympy.keras-1.0.4/sympy/physics/mechanics/particle.py
+-rw-rw-rw-   0        0        0     9038 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/physics/mechanics/rigidbody.py
+-rw-rw-rw-   0        0        0    18663 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/physics/mechanics/system.py
+drwxrwxrwx   0        0        0        0 2022-10-12 08:07:39.593142 sympy.keras-1.0.4/sympy/physics/optics/
+-rw-rw-rw-   0        0        0     1327 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/physics/optics/__init__.py
+-rw-rw-rw-   0        0        0    19986 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/physics/optics/gaussopt.py
+-rw-rw-rw-   0        0        0     5479 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/physics/optics/medium.py
+-rw-rw-rw-   0        0        0    21164 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/physics/optics/polarization.py
+-rw-rw-rw-   0        0        0    21518 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/physics/optics/utils.py
+-rw-rw-rw-   0        0        0     8827 2022-04-23 13:44:25.000000 sympy.keras-1.0.4/sympy/physics/optics/waves.py
+-rw-rw-rw-   0        0        0     5783 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/physics/paulialgebra.py
+-rw-rw-rw-   0        0        0     2000 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/physics/pring.py
+-rw-rw-rw-   0        0        0     1961 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/physics/qho_1d.py
+drwxrwxrwx   0        0        0        0 2022-10-12 08:07:39.610531 sympy.keras-1.0.4/sympy/physics/quantum/
+-rw-rw-rw-   0        0        0     1501 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/physics/quantum/__init__.py
+-rw-rw-rw-   0        0        0     4275 2022-04-23 13:44:25.000000 sympy.keras-1.0.4/sympy/physics/quantum/anticommutator.py
+-rw-rw-rw-   0        0        0     6096 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/physics/quantum/boson.py
+-rw-rw-rw-   0        0        0     8675 2022-04-23 13:44:25.000000 sympy.keras-1.0.4/sympy/physics/quantum/cartesian.py
+-rw-rw-rw-   0        0        0    22430 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/physics/quantum/cg.py
+-rw-rw-rw-   0        0        0    12927 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/physics/quantum/circuitplot.py
+-rw-rw-rw-   0        0        0    13693 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/physics/quantum/circuitutils.py
+-rw-rw-rw-   0        0        0     6467 2022-04-23 13:44:25.000000 sympy.keras-1.0.4/sympy/physics/quantum/commutator.py
+-rw-rw-rw-   0        0        0     1466 2022-04-23 13:44:25.000000 sympy.keras-1.0.4/sympy/physics/quantum/constants.py
+-rw-rw-rw-   0        0        0     2195 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/physics/quantum/dagger.py
+-rw-rw-rw-   0        0        0     9792 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/physics/quantum/density.py
+-rw-rw-rw-   0        0        0     4480 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/physics/quantum/fermion.py
+-rw-rw-rw-   0        0        0    41749 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/physics/quantum/gate.py
+-rw-rw-rw-   0        0        0     9809 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/physics/quantum/grover.py
+-rw-rw-rw-   0        0        0    19417 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/physics/quantum/hilbert.py
+-rw-rw-rw-   0        0        0    27367 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/physics/quantum/identitysearch.py
+-rw-rw-rw-   0        0        0     4213 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/physics/quantum/innerproduct.py
+-rw-rw-rw-   0        0        0     3470 2022-04-23 13:44:25.000000 sympy.keras-1.0.4/sympy/physics/quantum/matrixcache.py
+-rw-rw-rw-   0        0        0     8473 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/physics/quantum/matrixutils.py
+-rw-rw-rw-   0        0        0    19019 2022-09-24 00:48:20.000000 sympy.keras-1.0.4/sympy/physics/quantum/operator.py
+-rw-rw-rw-   0        0        0    11505 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/physics/quantum/operatorordering.py
+-rw-rw-rw-   0        0        0     9431 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/physics/quantum/operatorset.py
+-rw-rw-rw-   0        0        0    17262 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/physics/quantum/pauli.py
+-rw-rw-rw-   0        0        0     1707 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/physics/quantum/piab.py
+-rw-rw-rw-   0        0        0     7022 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/physics/quantum/qapply.py
+-rw-rw-rw-   0        0        0     6299 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/physics/quantum/qasm.py
+-rw-rw-rw-   0        0        0    14169 2022-09-24 00:48:20.000000 sympy.keras-1.0.4/sympy/physics/quantum/qexpr.py
+-rw-rw-rw-   0        0        0     6206 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/physics/quantum/qft.py
+-rw-rw-rw-   0        0        0    25696 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/physics/quantum/qubit.py
+-rw-rw-rw-   0        0        0    17874 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/physics/quantum/represent.py
+-rw-rw-rw-   0        0        0    21077 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/physics/quantum/sho1d.py
+-rw-rw-rw-   0        0        0     5709 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/physics/quantum/shor.py
+-rw-rw-rw-   0        0        0    72711 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/physics/quantum/spin.py
+-rw-rw-rw-   0        0        0    29115 2022-09-24 00:48:20.000000 sympy.keras-1.0.4/sympy/physics/quantum/state.py
+-rw-rw-rw-   0        0        0    14655 2022-04-23 13:44:25.000000 sympy.keras-1.0.4/sympy/physics/quantum/tensorproduct.py
+-rw-rw-rw-   0        0        0    88767 2022-04-23 13:44:25.000000 sympy.keras-1.0.4/sympy/physics/secondquant.py
+-rw-rw-rw-   0        0        0     2435 2022-04-23 13:44:25.000000 sympy.keras-1.0.4/sympy/physics/sho.py
+drwxrwxrwx   0        0        0        0 2022-10-12 08:07:39.612836 sympy.keras-1.0.4/sympy/physics/units/
+-rw-rw-rw-   0        0        0     7137 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/physics/units/__init__.py
+drwxrwxrwx   0        0        0        0 2022-10-12 08:07:39.613836 sympy.keras-1.0.4/sympy/physics/units/definitions/
+-rw-rw-rw-   0        0        0     7194 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/physics/units/definitions/__init__.py
+-rw-rw-rw-   0        0        0     1720 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/physics/units/definitions/dimension_definitions.py
+-rw-rw-rw-   0        0        0    13695 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/physics/units/definitions/unit_definitions.py
+-rw-rw-rw-   0        0        0    23146 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/physics/units/dimensions.py
+-rw-rw-rw-   0        0        0     5871 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/physics/units/prefixes.py
+-rw-rw-rw-   0        0        0     9423 2022-09-24 00:48:20.000000 sympy.keras-1.0.4/sympy/physics/units/quantities.py
+drwxrwxrwx   0        0        0        0 2022-10-12 08:07:39.617573 sympy.keras-1.0.4/sympy/physics/units/systems/
+-rw-rw-rw-   0        0        0      244 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/physics/units/systems/__init__.py
+-rw-rw-rw-   0        0        0     3582 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/physics/units/systems/cgs.py
+-rw-rw-rw-   0        0        0     6726 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/physics/units/systems/length_weight_time.py
+-rw-rw-rw-   0        0        0      940 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/physics/units/systems/mks.py
+-rw-rw-rw-   0        0        0      811 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/physics/units/systems/mksa.py
+-rw-rw-rw-   0        0        0      849 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/physics/units/systems/natural.py
+-rw-rw-rw-   0        0        0     1353 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/physics/units/systems/si.py
+-rw-rw-rw-   0        0        0     3309 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/physics/units/unitsystem.py
+-rw-rw-rw-   0        0        0     7521 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/physics/units/util.py
+drwxrwxrwx   0        0        0        0 2022-10-12 08:07:39.622533 sympy.keras-1.0.4/sympy/physics/vector/
+-rw-rw-rw-   0        0        0     1123 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/physics/vector/__init__.py
+-rw-rw-rw-   0        0        0    18879 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/physics/vector/dyadic.py
+-rw-rw-rw-   0        0        0     8568 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/physics/vector/fieldfunctions.py
+-rw-rw-rw-   0        0        0    31084 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/physics/vector/frame.py
+-rw-rw-rw-   0        0        0    23310 2022-04-23 13:44:25.000000 sympy.keras-1.0.4/sympy/physics/vector/functions.py
+-rw-rw-rw-   0        0        0    15102 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/physics/vector/point.py
+-rw-rw-rw-   0        0        0    13785 2022-10-06 08:57:11.000000 sympy.keras-1.0.4/sympy/physics/vector/printing.py
+-rw-rw-rw-   0        0        0    24921 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/physics/vector/vector.py
+-rw-rw-rw-   0        0        0    23439 2022-04-23 13:44:25.000000 sympy.keras-1.0.4/sympy/physics/wigner.py
+drwxrwxrwx   0        0        0        0 2022-10-12 08:07:39.625280 sympy.keras-1.0.4/sympy/plotting/
+-rw-rw-rw-   0        0        0      285 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/plotting/__init__.py
+-rw-rw-rw-   0        0        0    26119 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/plotting/experimental_lambdify.py
+drwxrwxrwx   0        0        0        0 2022-10-12 08:07:39.626309 sympy.keras-1.0.4/sympy/plotting/intervalmath/
+-rw-rw-rw-   0        0        0      261 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/plotting/intervalmath/__init__.py
+-rw-rw-rw-   0        0        0    16401 2022-04-23 13:44:25.000000 sympy.keras-1.0.4/sympy/plotting/intervalmath/interval_arithmetic.py
+-rw-rw-rw-   0        0        0     2393 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/plotting/intervalmath/interval_membership.py
+-rw-rw-rw-   0        0        0    14824 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/plotting/intervalmath/lib_interval.py
+-rw-rw-rw-   0        0        0    75997 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/plotting/plot.py
+-rw-rw-rw-   0        0        0    14517 2022-04-23 13:44:25.000000 sympy.keras-1.0.4/sympy/plotting/plot_implicit.py
+drwxrwxrwx   0        0        0        0 2022-10-12 08:07:39.633294 sympy.keras-1.0.4/sympy/plotting/pygletplot/
+-rw-rw-rw-   0        0        0     4252 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/plotting/pygletplot/__init__.py
+-rw-rw-rw-   0        0        0    12473 2022-04-23 13:44:25.000000 sympy.keras-1.0.4/sympy/plotting/pygletplot/color_scheme.py
+-rw-rw-rw-   0        0        0     3105 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/plotting/pygletplot/managed_window.py
+-rw-rw-rw-   0        0        0    13398 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/plotting/pygletplot/plot.py
+-rw-rw-rw-   0        0        0     8755 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/plotting/pygletplot/plot_axes.py
+-rw-rw-rw-   0        0        0     4009 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/plotting/pygletplot/plot_camera.py
+-rw-rw-rw-   0        0        0     6942 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/plotting/pygletplot/plot_controller.py
+-rw-rw-rw-   0        0        0     2822 2022-04-23 13:44:25.000000 sympy.keras-1.0.4/sympy/plotting/pygletplot/plot_curve.py
+-rw-rw-rw-   0        0        0     5371 2022-04-23 13:44:25.000000 sympy.keras-1.0.4/sympy/plotting/pygletplot/plot_interval.py
+-rw-rw-rw-   0        0        0    14113 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/plotting/pygletplot/plot_mode.py
+-rw-rw-rw-   0        0        0    11456 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/plotting/pygletplot/plot_mode_base.py
+-rw-rw-rw-   0        0        0     5333 2022-04-23 13:44:25.000000 sympy.keras-1.0.4/sympy/plotting/pygletplot/plot_modes.py
+-rw-rw-rw-   0        0        0      338 2022-04-23 13:44:25.000000 sympy.keras-1.0.4/sympy/plotting/pygletplot/plot_object.py
+-rw-rw-rw-   0        0        0     1447 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/plotting/pygletplot/plot_rotation.py
+-rw-rw-rw-   0        0        0     3791 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/plotting/pygletplot/plot_surface.py
+-rw-rw-rw-   0        0        0     4850 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/plotting/pygletplot/plot_window.py
+-rw-rw-rw-   0        0        0     4610 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/plotting/pygletplot/util.py
+-rw-rw-rw-   0        0        0     2092 2022-10-01 05:02:59.000000 sympy.keras-1.0.4/sympy/plotting/textplot.py
+drwxrwxrwx   0        0        0        0 2022-10-12 08:07:39.655230 sympy.keras-1.0.4/sympy/polys/
+-rw-rw-rw-   0        0        0     1531 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/polys/__init__.py
+drwxrwxrwx   0        0        0        0 2022-10-12 08:07:39.657223 sympy.keras-1.0.4/sympy/polys/agca/
+-rw-rw-rw-   0        0        0      102 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/polys/agca/__init__.py
+-rw-rw-rw-   0        0        0     3831 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/polys/agca/extensions.py
+-rw-rw-rw-   0        0        0    21967 2022-04-23 13:44:25.000000 sympy.keras-1.0.4/sympy/polys/agca/homomorphisms.py
+-rw-rw-rw-   0        0        0    10810 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/polys/agca/ideals.py
+-rw-rw-rw-   0        0        0    46873 2022-04-23 13:44:25.000000 sympy.keras-1.0.4/sympy/polys/agca/modules.py
+-rw-rw-rw-   0        0        0    56467 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/polys/compatibility.py
+-rw-rw-rw-   0        0        0     7080 2022-04-23 13:44:25.000000 sympy.keras-1.0.4/sympy/polys/constructor.py
+-rw-rw-rw-   0        0        0    33395 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/polys/densearith.py
+-rw-rw-rw-   0        0        0    35913 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/polys/densebasic.py
+-rw-rw-rw-   0        0        0    25775 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/polys/densetools.py
+-rw-rw-rw-   0        0        0     5747 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/polys/dispersion.py
+-rw-rw-rw-   0        0        0    21789 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/polys/distributedmodules.py
+-rw-rw-rw-   0        0        0    16356 2022-04-23 13:44:25.000000 sympy.keras-1.0.4/sympy/polys/domainmatrix.py
+drwxrwxrwx   0        0        0        0 2022-10-12 08:07:39.672220 sympy.keras-1.0.4/sympy/polys/domains/
+-rw-rw-rw-   0        0        0     2382 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/polys/domains/__init__.py
+-rw-rw-rw-   0        0        0     4144 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/polys/domains/algebraicfield.py
+-rw-rw-rw-   0        0        0      380 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/polys/domains/characteristiczero.py
+-rw-rw-rw-   0        0        0     3442 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/polys/domains/complexfield.py
+-rw-rw-rw-   0        0        0      691 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/polys/domains/compositedomain.py
+-rw-rw-rw-   0        0        0    16865 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/polys/domains/domain.py
+-rw-rw-rw-   0        0        0      394 2022-04-23 13:44:25.000000 sympy.keras-1.0.4/sympy/polys/domains/domainelement.py
+-rw-rw-rw-   0        0        0     5923 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/polys/domains/expressiondomain.py
+-rw-rw-rw-   0        0        0     2477 2022-04-23 13:44:25.000000 sympy.keras-1.0.4/sympy/polys/domains/field.py
+-rw-rw-rw-   0        0        0     3256 2022-04-23 13:44:25.000000 sympy.keras-1.0.4/sympy/polys/domains/finitefield.py
+-rw-rw-rw-   0        0        0     4478 2022-04-23 13:44:25.000000 sympy.keras-1.0.4/sympy/polys/domains/fractionfield.py
+-rw-rw-rw-   0        0        0    11063 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/polys/domains/gaussiandomains.py
+-rw-rw-rw-   0        0        0      464 2022-04-23 13:44:25.000000 sympy.keras-1.0.4/sympy/polys/domains/gmpyfinitefield.py
+-rw-rw-rw-   0        0        0     2600 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/polys/domains/gmpyintegerring.py
+-rw-rw-rw-   0        0        0     2784 2022-04-23 13:44:25.000000 sympy.keras-1.0.4/sympy/polys/domains/gmpyrationalfield.py
+-rw-rw-rw-   0        0        0     1631 2022-04-23 13:44:25.000000 sympy.keras-1.0.4/sympy/polys/domains/groundtypes.py
+-rw-rw-rw-   0        0        0     1146 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/polys/domains/integerring.py
+-rw-rw-rw-   0        0        0     5062 2022-04-23 13:44:25.000000 sympy.keras-1.0.4/sympy/polys/domains/modularinteger.py
+-rw-rw-rw-   0        0        0     4560 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/polys/domains/mpelements.py
+-rw-rw-rw-   0        0        0     6046 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/polys/domains/old_fractionfield.py
+-rw-rw-rw-   0        0        0    13941 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/polys/domains/old_polynomialring.py
+-rw-rw-rw-   0        0        0     4554 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/polys/domains/polynomialring.py
+-rw-rw-rw-   0        0        0      482 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/polys/domains/pythonfinitefield.py
+-rw-rw-rw-   0        0        0     2929 2022-04-23 13:44:25.000000 sympy.keras-1.0.4/sympy/polys/domains/pythonintegerring.py
+-rw-rw-rw-   0        0        0     7435 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/polys/domains/pythonrational.py
+-rw-rw-rw-   0        0        0     2184 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/polys/domains/pythonrationalfield.py
+-rw-rw-rw-   0        0        0     5708 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/polys/domains/quotientring.py
+-rw-rw-rw-   0        0        0      902 2022-04-23 13:44:25.000000 sympy.keras-1.0.4/sympy/polys/domains/rationalfield.py
+-rw-rw-rw-   0        0        0     3454 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/polys/domains/realfield.py
+-rw-rw-rw-   0        0        0     3238 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/polys/domains/ring.py
+-rw-rw-rw-   0        0        0      368 2022-04-23 13:44:25.000000 sympy.keras-1.0.4/sympy/polys/domains/simpledomain.py
+-rw-rw-rw-   0        0        0    41225 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/polys/euclidtools.py
+-rw-rw-rw-   0        0        0    38052 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/polys/factortools.py
+-rw-rw-rw-   0        0        0     4328 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/polys/fglmtools.py
+-rw-rw-rw-   0        0        0    20286 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/polys/fields.py
+-rw-rw-rw-   0        0        0    51936 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/polys/galoistools.py
+-rw-rw-rw-   0        0        0    23347 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/polys/groebnertools.py
+-rw-rw-rw-   0        0        0     3732 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/polys/heuristicgcd.py
+-rw-rw-rw-   0        0        0    58646 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/polys/modulargcd.py
+-rw-rw-rw-   0        0        0    18407 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/polys/monomials.py
+-rw-rw-rw-   0        0        0    11958 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/polys/multivariate_resultants.py
+-rw-rw-rw-   0        0        0    32631 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/polys/numberfields.py
+-rw-rw-rw-   0        0        0     8449 2022-04-23 13:44:25.000000 sympy.keras-1.0.4/sympy/polys/orderings.py
+-rw-rw-rw-   0        0        0    10096 2021-09-12 00:26:25.000000 sympy.keras-1.0.4/sympy/polys/orthopolys.py
+-rw-rw-rw-   0        0        0    14653 2022-04-23 13:44:25.000000 sympy.keras-1.0.4/sympy/polys/partfrac.py
+-rw-rw-rw-   0        0        0    53415 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/polys/polyclasses.py
+-rw-rw-rw-   0        0        0     1597 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/polys/polyconfig.py
+-rw-rw-rw-   0        0        0     4518 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/polys/polyerrors.py
+-rw-rw-rw-   0        0        0    10012 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/polys/polyfuncs.py
+-rw-rw-rw-   0        0        0     3201 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/polys/polymatrix.py
+-rw-rw-rw-   0        0        0    21177 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/polys/polyoptions.py
+-rw-rw-rw-   0        0        0    95962 2022-04-23 13:44:25.000000 sympy.keras-1.0.4/sympy/polys/polyquinticconst.py
+-rw-rw-rw-   0        0        0    33405 2022-04-23 13:44:25.000000 sympy.keras-1.0.4/sympy/polys/polyroots.py
+-rw-rw-rw-   0        0        0   187297 2022-09-24 00:48:20.000000 sympy.keras-1.0.4/sympy/polys/polytools.py
+-rw-rw-rw-   0        0        0    14016 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/polys/polyutils.py
+-rw-rw-rw-   0        0        0     2833 2022-04-23 13:44:25.000000 sympy.keras-1.0.4/sympy/polys/rationaltools.py
+-rw-rw-rw-   0        0        0    57681 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/polys/ring_series.py
+-rw-rw-rw-   0        0        0    68538 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/polys/rings.py
+-rw-rw-rw-   0        0        0    60683 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/polys/rootisolation.py
+-rw-rw-rw-   0        0        0    39193 2022-09-24 00:48:20.000000 sympy.keras-1.0.4/sympy/polys/rootoftools.py
+-rw-rw-rw-   0        0        0     2014 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/polys/solvers.py
+-rw-rw-rw-   0        0        0    10537 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/polys/specialpolys.py
+-rw-rw-rw-   0        0        0    11401 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/polys/sqfreetools.py
+-rw-rw-rw-   0        0        0    88039 2022-04-23 13:44:25.000000 sympy.keras-1.0.4/sympy/polys/subresultants_qq_zz.py
+drwxrwxrwx   0        0        0        0 2022-10-12 08:07:39.687797 sympy.keras-1.0.4/sympy/printing/
+-rw-rw-rw-   0        0        0     1468 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/printing/__init__.py
+-rw-rw-rw-   0        0        0    26568 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/printing/c.py
+-rw-rw-rw-   0        0        0    20299 2022-04-23 13:44:25.000000 sympy.keras-1.0.4/sympy/printing/codeprinter.py
+-rw-rw-rw-   0        0        0     2461 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/printing/conventions.py
+-rw-rw-rw-   0        0        0     5628 2022-04-23 13:44:25.000000 sympy.keras-1.0.4/sympy/printing/cxx.py
+-rw-rw-rw-   0        0        0      635 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/printing/defaults.py
+-rw-rw-rw-   0        0        0     8364 2022-04-23 13:44:25.000000 sympy.keras-1.0.4/sympy/printing/dot.py
+-rw-rw-rw-   0        0        0    28352 2022-04-23 13:44:25.000000 sympy.keras-1.0.4/sympy/printing/fortran.py
+-rw-rw-rw-   0        0        0    18284 2022-10-05 05:30:22.000000 sympy.keras-1.0.4/sympy/printing/glsl.py
+-rw-rw-rw-   0        0        0      475 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/printing/gtk.py
+-rw-rw-rw-   0        0        0    10935 2022-10-05 05:30:29.000000 sympy.keras-1.0.4/sympy/printing/jscode.py
+-rw-rw-rw-   0        0        0    22346 2022-10-05 05:30:35.000000 sympy.keras-1.0.4/sympy/printing/julia.py
+-rw-rw-rw-   0        0        0     4359 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/printing/lambdarepr.py
+-rw-rw-rw-   0        0        0    75619 2022-10-06 09:30:51.000000 sympy.keras-1.0.4/sympy/printing/latex.py
+-rw-rw-rw-   0        0        0    16741 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/printing/llvmjitcode.py
+-rw-rw-rw-   0        0        0    10075 2022-10-05 05:30:41.000000 sympy.keras-1.0.4/sympy/printing/maple.py
+-rw-rw-rw-   0        0        0     9131 2022-04-23 13:44:25.000000 sympy.keras-1.0.4/sympy/printing/mathematica.py
+-rw-rw-rw-   0        0        0    69538 2022-10-06 09:31:00.000000 sympy.keras-1.0.4/sympy/printing/mathml.py
+-rw-rw-rw-   0        0        0    24877 2022-10-05 05:30:47.000000 sympy.keras-1.0.4/sympy/printing/octave.py
+-rw-rw-rw-   0        0        0     4418 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/printing/precedence.py
+drwxrwxrwx   0        0        0        0 2022-10-12 08:07:39.688794 sympy.keras-1.0.4/sympy/printing/pretty/
+-rw-rw-rw-   0        0        0      222 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/printing/pretty/__init__.py
+-rw-rw-rw-   0        0        0    81008 2021-10-01 01:55:11.000000 sympy.keras-1.0.4/sympy/printing/pretty/pretty.py
+-rw-rw-rw-   0        0        0    19676 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/printing/pretty/pretty_symbology.py
+-rw-rw-rw-   0        0        0    20117 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/printing/pretty/stringpict.py
+-rw-rw-rw-   0        0        0    13253 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/printing/preview.py
+-rw-rw-rw-   0        0        0    10550 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/printing/printer.py
+-rw-rw-rw-   0        0        0    25731 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/printing/pycode.py
+-rw-rw-rw-   0        0        0     3168 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/printing/python.py
+-rw-rw-rw-   0        0        0    14121 2022-10-05 05:30:53.000000 sympy.keras-1.0.4/sympy/printing/rcode.py
+-rw-rw-rw-   0        0        0     8677 2022-04-23 13:44:25.000000 sympy.keras-1.0.4/sympy/printing/repr.py
+-rw-rw-rw-   0        0        0    20782 2022-10-05 05:30:59.000000 sympy.keras-1.0.4/sympy/printing/rust.py
+-rw-rw-rw-   0        0        0    19899 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/printing/str.py
+-rw-rw-rw-   0        0        0    11694 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/printing/tableform.py
+-rw-rw-rw-   0        0        0     8988 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/printing/tensorflow.py
+-rw-rw-rw-   0        0        0    17631 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/printing/theanocode.py
+-rw-rw-rw-   0        0        0     2580 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/printing/tree.py
+-rw-rw-rw-   0        0        0       24 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/release.py
+drwxrwxrwx   0        0        0        0 2022-10-12 08:07:39.689792 sympy.keras-1.0.4/sympy/sandbox/
+-rw-rw-rw-   0        0        0      189 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/sandbox/__init__.py
+-rw-rw-rw-   0        0        0     2056 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/sandbox/indexed_integrals.py
+drwxrwxrwx   0        0        0        0 2022-10-12 08:07:39.696772 sympy.keras-1.0.4/sympy/series/
+-rw-rw-rw-   0        0        0      723 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/series/__init__.py
+-rw-rw-rw-   0        0        0     3223 2022-04-23 13:44:25.000000 sympy.keras-1.0.4/sympy/series/acceleration.py
+-rw-rw-rw-   0        0        0     3082 2022-04-23 13:44:25.000000 sympy.keras-1.0.4/sympy/series/approximants.py
+-rw-rw-rw-   0        0        0      255 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/series/aseries.py
+-rw-rw-rw-   0        0        0    35064 2022-10-01 05:14:56.000000 sympy.keras-1.0.4/sympy/series/formal.py
+-rw-rw-rw-   0        0        0    18756 2022-10-01 05:15:05.000000 sympy.keras-1.0.4/sympy/series/fourier.py
+-rw-rw-rw-   0        0        0    21663 2022-04-23 13:44:25.000000 sympy.keras-1.0.4/sympy/series/gruntz.py
+-rw-rw-rw-   0        0        0     1757 2022-04-23 13:44:25.000000 sympy.keras-1.0.4/sympy/series/kauers.py
+-rw-rw-rw-   0        0        0    13585 2022-10-03 03:49:35.000000 sympy.keras-1.0.4/sympy/series/limits.py
+-rw-rw-rw-   0        0        0     7366 2022-10-01 05:15:49.000000 sympy.keras-1.0.4/sympy/series/limitseq.py
+-rw-rw-rw-   0        0        0    16894 2022-10-03 03:50:04.000000 sympy.keras-1.0.4/sympy/series/order.py
+-rw-rw-rw-   0        0        0     2155 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/series/residues.py
+-rw-rw-rw-   0        0        0    34756 2022-10-01 05:16:21.000000 sympy.keras-1.0.4/sympy/series/sequences.py
+-rw-rw-rw-   0        0        0      289 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/series/series.py
+-rw-rw-rw-   0        0        0     2927 2022-09-24 00:48:20.000000 sympy.keras-1.0.4/sympy/series/series_class.py
+drwxrwxrwx   0        0        0        0 2022-10-12 08:07:39.701137 sympy.keras-1.0.4/sympy/sets/
+-rw-rw-rw-   0        0        0      940 2021-10-04 23:41:22.000000 sympy.keras-1.0.4/sympy/sets/__init__.py
+-rw-rw-rw-   0        0        0    18895 2022-01-08 06:06:56.000000 sympy.keras-1.0.4/sympy/sets/contains.py
+-rw-rw-rw-   0        0        0    62381 2022-10-03 03:50:51.000000 sympy.keras-1.0.4/sympy/sets/fancysets.py
+drwxrwxrwx   0        0        0        0 2022-10-12 08:07:39.704999 sympy.keras-1.0.4/sympy/sets/handlers/
+-rw-rw-rw-   0        0        0        0 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/sets/handlers/__init__.py
+-rw-rw-rw-   0        0        0     1777 2021-09-11 15:26:48.000000 sympy.keras-1.0.4/sympy/sets/handlers/add.py
+-rw-rw-rw-   0        0        0     1332 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/sets/handlers/comparison.py
+-rw-rw-rw-   0        0        0     6964 2022-10-05 05:31:48.000000 sympy.keras-1.0.4/sympy/sets/handlers/functions.py
+-rw-rw-rw-   0        0        0     5087 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/sets/handlers/issubset.py
+-rw-rw-rw-   0        0        0     1803 2021-09-11 15:26:48.000000 sympy.keras-1.0.4/sympy/sets/handlers/mul.py
+-rw-rw-rw-   0        0        0     3098 2021-09-11 15:26:48.000000 sympy.keras-1.0.4/sympy/sets/handlers/power.py
+-rw-rw-rw-   0        0        0     7440 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/sets/ordinals.py
+-rw-rw-rw-   0        0        0     3037 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/sets/powerset.py
+-rw-rw-rw-   0        0        0    12932 2021-08-20 13:41:01.000000 sympy.keras-1.0.4/sympy/sets/setexpr.py
+-rw-rw-rw-   0        0        0   129211 2022-10-05 05:31:55.000000 sympy.keras-1.0.4/sympy/sets/sets.py
+-rw-rw-rw-   0        0        0    14681 2022-01-08 06:07:28.000000 sympy.keras-1.0.4/sympy/sets/subset.py
+drwxrwxrwx   0        0        0        0 2022-10-12 08:07:39.711982 sympy.keras-1.0.4/sympy/simplify/
+-rw-rw-rw-   0        0        0      827 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/simplify/__init__.py
+-rw-rw-rw-   0        0        0     3577 2022-04-23 13:44:25.000000 sympy.keras-1.0.4/sympy/simplify/combsimp.py
+-rw-rw-rw-   0        0        0    25548 2022-09-24 00:48:20.000000 sympy.keras-1.0.4/sympy/simplify/cse_main.py
+-rw-rw-rw-   0        0        0     1362 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/simplify/cse_opts.py
+-rw-rw-rw-   0        0        0    10156 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/simplify/epathtools.py
+-rw-rw-rw-   0        0        0    66574 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/simplify/fu.py
+-rw-rw-rw-   0        0        0    18847 2022-10-03 03:51:24.000000 sympy.keras-1.0.4/sympy/simplify/gammasimp.py
+-rw-rw-rw-   0        0        0    83784 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/simplify/hyperexpand.py
+-rw-rw-rw-   0        0        0      432 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/simplify/hyperexpand_doc.py
+-rw-rw-rw-   0        0        0    25670 2022-04-23 13:44:25.000000 sympy.keras-1.0.4/sympy/simplify/powsimp.py
+-rw-rw-rw-   0        0        0    37874 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/simplify/radsimp.py
+-rw-rw-rw-   0        0        0     7645 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/simplify/ratsimp.py
+-rw-rw-rw-   0        0        0    61008 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/simplify/simplify.py
+-rw-rw-rw-   0        0        0    21298 2022-04-23 13:44:25.000000 sympy.keras-1.0.4/sympy/simplify/sqrtdenest.py
+-rw-rw-rw-   0        0        0      893 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/simplify/traversaltools.py
+-rw-rw-rw-   0        0        0    44783 2022-10-05 05:32:16.000000 sympy.keras-1.0.4/sympy/simplify/trigsimp.py
+drwxrwxrwx   0        0        0        0 2022-10-12 08:07:39.718833 sympy.keras-1.0.4/sympy/solvers/
+-rw-rw-rw-   0        0        0     1111 2021-09-18 22:51:30.000000 sympy.keras-1.0.4/sympy/solvers/__init__.py
+-rw-rw-rw-   0        0        0    12904 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/solvers/bivariate.py
+-rw-rw-rw-   0        0        0     3027 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/solvers/decompogen.py
+-rw-rw-rw-   0        0        0     9955 2022-04-23 13:44:25.000000 sympy.keras-1.0.4/sympy/solvers/deutils.py
+drwxrwxrwx   0        0        0        0 2022-10-12 08:07:39.719832 sympy.keras-1.0.4/sympy/solvers/diophantine/
+-rw-rw-rw-   0        0        0      102 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/solvers/diophantine/__init__.py
+-rw-rw-rw-   0        0        0   108749 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/solvers/diophantine/diophantine.py
+-rw-rw-rw-   0        0        0    33322 2022-10-01 05:12:12.000000 sympy.keras-1.0.4/sympy/solvers/inequalities.py
+drwxrwxrwx   0        0        0        0 2022-10-12 08:07:39.721831 sympy.keras-1.0.4/sympy/solvers/ode/
+-rw-rw-rw-   0        0        0      445 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/solvers/ode/__init__.py
+-rw-rw-rw-   0        0        0   276986 2022-10-01 05:12:34.000000 sympy.keras-1.0.4/sympy/solvers/ode/ode.py
+-rw-rw-rw-   0        0        0    26804 2022-10-01 05:12:47.000000 sympy.keras-1.0.4/sympy/solvers/ode/single.py
+-rw-rw-rw-   0        0        0    16114 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/solvers/ode/subscheck.py
+-rw-rw-rw-   0        0        0    65203 2021-07-27 13:23:38.000000 sympy.keras-1.0.4/sympy/solvers/ode/systems.py
+-rw-rw-rw-   0        0        0    36156 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/solvers/pde.py
+-rw-rw-rw-   0        0        0     9679 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/solvers/polysys.py
+-rw-rw-rw-   0        0        0    25004 2022-04-23 13:44:25.000000 sympy.keras-1.0.4/sympy/solvers/recurr.py
+-rw-rw-rw-   0        0        0   134684 2022-10-01 05:12:03.000000 sympy.keras-1.0.4/sympy/solvers/solvers.py
+-rw-rw-rw-   0        0        0   109351 2022-10-01 05:12:21.000000 sympy.keras-1.0.4/sympy/solvers/solveset.py
+drwxrwxrwx   0        0        0        0 2022-10-12 08:07:39.732799 sympy.keras-1.0.4/sympy/stats/
+-rw-rw-rw-   0        0        0     8554 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/stats/__init__.py
+-rw-rw-rw-   0        0        0     7797 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/stats/compound_rv.py
+-rw-rw-rw-   0        0        0    26526 2021-08-11 13:17:24.000000 sympy.keras-1.0.4/sympy/stats/crv.py
+-rw-rw-rw-   0        0        0   114366 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/stats/crv_types.py
+-rw-rw-rw-   0        0        0    16244 2021-09-05 20:02:09.000000 sympy.keras-1.0.4/sympy/stats/drv.py
+-rw-rw-rw-   0        0        0    20854 2021-10-04 23:41:22.000000 sympy.keras-1.0.4/sympy/stats/drv_types.py
+-rw-rw-rw-   0        0        0     3106 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/stats/error_prop.py
+-rw-rw-rw-   0        0        0    19214 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/stats/frv.py
+-rw-rw-rw-   0        0        0    16282 2021-09-05 20:02:09.000000 sympy.keras-1.0.4/sympy/stats/frv_types.py
+-rw-rw-rw-   0        0        0    13725 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/stats/joint_rv.py
+-rw-rw-rw-   0        0        0    28877 2021-10-04 23:41:22.000000 sympy.keras-1.0.4/sympy/stats/joint_rv_types.py
+-rw-rw-rw-   0        0        0    15887 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/stats/matrix_distributions.py
+-rw-rw-rw-   0        0        0      855 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/stats/random_matrix.py
+-rw-rw-rw-   0        0        0    14825 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/stats/random_matrix_models.py
+-rw-rw-rw-   0        0        0    52526 2022-10-03 04:01:54.000000 sympy.keras-1.0.4/sympy/stats/rv.py
+-rw-rw-rw-   0        0        0    13467 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/stats/rv_interface.py
+-rw-rw-rw-   0        0        0     2179 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/stats/stochastic_process.py
+-rw-rw-rw-   0        0        0    63637 2021-09-05 20:02:07.000000 sympy.keras-1.0.4/sympy/stats/stochastic_process_types.py
+-rw-rw-rw-   0        0        0    10154 2022-10-03 04:02:45.000000 sympy.keras-1.0.4/sympy/stats/symbolic_multivariate_probability.py
+-rw-rw-rw-   0        0        0    33161 2022-10-04 02:17:58.000000 sympy.keras-1.0.4/sympy/stats/symbolic_probability.py
+drwxrwxrwx   0        0        0        0 2022-10-12 08:07:39.735788 sympy.keras-1.0.4/sympy/strategies/
+-rw-rw-rw-   0        0        0     1142 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/strategies/__init__.py
+drwxrwxrwx   0        0        0        0 2022-10-12 08:07:39.736785 sympy.keras-1.0.4/sympy/strategies/branch/
+-rw-rw-rw-   0        0        0      177 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/strategies/branch/__init__.py
+-rw-rw-rw-   0        0        0     2911 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/strategies/branch/core.py
+-rw-rw-rw-   0        0        0      356 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/strategies/branch/tools.py
+-rw-rw-rw-   0        0        0      798 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/strategies/branch/traverse.py
+-rw-rw-rw-   0        0        0     3035 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/strategies/core.py
+-rw-rw-rw-   0        0        0     4247 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/strategies/rl.py
+-rw-rw-rw-   0        0        0     1264 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/strategies/tools.py
+-rw-rw-rw-   0        0        0     1183 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/strategies/traverse.py
+-rw-rw-rw-   0        0        0     3713 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/strategies/tree.py
+-rw-rw-rw-   0        0        0      348 2022-04-23 13:44:25.000000 sympy.keras-1.0.4/sympy/strategies/util.py
+drwxrwxrwx   0        0        0        0 2022-10-12 08:07:39.740362 sympy.keras-1.0.4/sympy/tensor/
+-rw-rw-rw-   0        0        0      461 2021-12-26 07:35:18.000000 sympy.keras-1.0.4/sympy/tensor/__init__.py
+drwxrwxrwx   0        0        0        0 2022-10-12 08:07:39.743355 sympy.keras-1.0.4/sympy/tensor/array/
+-rw-rw-rw-   0        0        0     6068 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/tensor/array/__init__.py
+-rw-rw-rw-   0        0        0     8544 2022-10-03 04:04:04.000000 sympy.keras-1.0.4/sympy/tensor/array/array_comprehension.py
+-rw-rw-rw-   0        0        0     4780 2022-10-03 04:04:22.000000 sympy.keras-1.0.4/sympy/tensor/array/array_derivatives.py
+-rw-rw-rw-   0        0        0     9822 2022-10-03 04:04:35.000000 sympy.keras-1.0.4/sympy/tensor/array/arrayop.py
+-rw-rw-rw-   0        0        0     6144 2022-09-24 00:48:20.000000 sympy.keras-1.0.4/sympy/tensor/array/dense_ndim_array.py
+-rw-rw-rw-   0        0        0      277 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/tensor/array/mutable_ndim_array.py
+-rw-rw-rw-   0        0        0    15185 2022-10-03 04:04:45.000000 sympy.keras-1.0.4/sympy/tensor/array/ndim_array.py
+-rw-rw-rw-   0        0        0     6833 2022-09-24 00:48:20.000000 sympy.keras-1.0.4/sympy/tensor/array/sparse_ndim_array.py
+-rw-rw-rw-   0        0        0     1862 2022-10-03 04:05:16.000000 sympy.keras-1.0.4/sympy/tensor/functions.py
+-rw-rw-rw-   0        0        0    15462 2022-04-23 13:44:25.000000 sympy.keras-1.0.4/sympy/tensor/index_methods.py
+-rw-rw-rw-   0        0        0    94464 2022-10-11 08:19:53.000000 sympy.keras-1.0.4/sympy/tensor/indexed.py
+-rw-rw-rw-   0        0        0   231123 2022-10-04 02:18:35.000000 sympy.keras-1.0.4/sympy/tensor/tensor.py
+-rw-rw-rw-   0        0        0     2739 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/tensor/toperators.py
+drwxrwxrwx   0        0        0        0 2022-10-12 08:07:39.749340 sympy.keras-1.0.4/sympy/testing/
+-rw-rw-rw-   0        0        0      139 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/testing/__init__.py
+-rw-rw-rw-   0        0        0     6296 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/testing/benchmarking.py
+-rw-rw-rw-   0        0        0      216 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/testing/matrices.py
+-rw-rw-rw-   0        0        0     9197 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/testing/pytest.py
+-rw-rw-rw-   0        0        0     4650 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/testing/quality_unicode.py
+-rw-rw-rw-   0        0        0     5319 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/testing/randtest.py
+-rw-rw-rw-   0        0        0    88872 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/testing/runtests.py
+-rw-rw-rw-   0        0        0     1042 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/testing/tmpfiles.py
+-rw-rw-rw-   0        0        0      644 2021-10-23 09:40:54.000000 sympy.keras-1.0.4/sympy/this.py
+drwxrwxrwx   0        0        0        0 2022-10-12 08:07:39.750337 sympy.keras-1.0.4/sympy/unify/
+-rw-rw-rw-   0        0        0      234 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/unify/__init__.py
+-rw-rw-rw-   0        0        0     7210 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/unify/core.py
+-rw-rw-rw-   0        0        0     1795 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/unify/rewrite.py
+-rw-rw-rw-   0        0        0     3966 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/unify/usympy.py
+drwxrwxrwx   0        0        0        0 2022-10-12 08:07:39.758315 sympy.keras-1.0.4/sympy/utilities/
+-rw-rw-rw-   0        0        0      581 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/utilities/__init__.py
+drwxrwxrwx   0        0        0        0 2022-10-12 08:07:39.762305 sympy.keras-1.0.4/sympy/utilities/_compilation/
+-rw-rw-rw-   0        0        0      751 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/utilities/_compilation/__init__.py
+-rw-rw-rw-   0        0        0     2884 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/utilities/_compilation/availability.py
+-rw-rw-rw-   0        0        0    20378 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/utilities/_compilation/compilation.py
+-rw-rw-rw-   0        0        0     9026 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/utilities/_compilation/runners.py
+-rw-rw-rw-   0        0        0     7850 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/utilities/_compilation/util.py
+-rw-rw-rw-   0        0        0    40939 2022-04-23 13:44:25.000000 sympy.keras-1.0.4/sympy/utilities/autowrap.py
+-rw-rw-rw-   0        0        0     6296 2022-04-23 13:44:25.000000 sympy.keras-1.0.4/sympy/utilities/benchmarking.py
+-rw-rw-rw-   0        0        0    81667 2022-10-06 07:32:59.000000 sympy.keras-1.0.4/sympy/utilities/codegen.py
+-rw-rw-rw-   0        0        0     7096 2022-04-23 13:44:25.000000 sympy.keras-1.0.4/sympy/utilities/decorator.py
+-rw-rw-rw-   0        0        0    43339 2022-04-23 13:44:25.000000 sympy.keras-1.0.4/sympy/utilities/enumerative.py
+-rw-rw-rw-   0        0        0     7164 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/utilities/exceptions.py
+-rw-rw-rw-   0        0        0    75173 2022-04-23 13:44:25.000000 sympy.keras-1.0.4/sympy/utilities/iterables.py
+-rw-rw-rw-   0        0        0    45113 2022-10-05 05:33:49.000000 sympy.keras-1.0.4/sympy/utilities/lambdify.py
+-rw-rw-rw-   0        0        0      400 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/utilities/magic.py
+-rw-rw-rw-   0        0        0     4018 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/utilities/matchpy_connector.py
+drwxrwxrwx   0        0        0        0 2022-10-12 08:07:39.762305 sympy.keras-1.0.4/sympy/utilities/mathml/
+-rw-rw-rw-   0        0        0     2065 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/utilities/mathml/__init__.py
+-rw-rw-rw-   0        0        0     1441 2022-04-23 13:44:25.000000 sympy.keras-1.0.4/sympy/utilities/memoization.py
+-rw-rw-rw-   0        0        0    14404 2022-10-12 05:55:42.000000 sympy.keras-1.0.4/sympy/utilities/misc.py
+-rw-rw-rw-   0        0        0     1823 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/utilities/pkgdata.py
+-rw-rw-rw-   0        0        0      294 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/utilities/pytest.py
+-rw-rw-rw-   0        0        0      321 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/utilities/quality_unicode.py
+-rw-rw-rw-   0        0        0     1481 2022-04-23 13:44:24.000000 sympy.keras-1.0.4/sympy/utilities/source.py
+-rw-rw-rw-   0        0        0     1970 2022-04-23 13:44:25.000000 sympy.keras-1.0.4/sympy/utilities/timeutils.py
+-rw-rw-rw-   0        0        0      300 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/utilities/tmpfiles.py
+drwxrwxrwx   0        0        0        0 2022-10-12 08:07:39.768129 sympy.keras-1.0.4/sympy/vector/
+-rw-rw-rw-   0        0        0     1010 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/vector/__init__.py
+-rw-rw-rw-   0        0        0    11589 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/vector/basisdependent.py
+-rw-rw-rw-   0        0        0    37333 2022-10-06 07:32:37.000000 sympy.keras-1.0.4/sympy/vector/coordsysrect.py
+-rw-rw-rw-   0        0        0     3614 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/vector/deloperator.py
+-rw-rw-rw-   0        0        0     8356 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/vector/dyadic.py
+-rw-rw-rw-   0        0        0    15679 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/vector/functions.py
+-rw-rw-rw-   0        0        0    16069 2022-10-01 05:13:58.000000 sympy.keras-1.0.4/sympy/vector/implicitregion.py
+-rw-rw-rw-   0        0        0     5929 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/vector/integrals.py
+-rw-rw-rw-   0        0        0    10612 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/vector/operators.py
+-rw-rw-rw-   0        0        0    11694 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/vector/orienters.py
+-rw-rw-rw-   0        0        0     5193 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/vector/parametricregion.py
+-rw-rw-rw-   0        0        0     4650 2021-07-23 11:00:52.000000 sympy.keras-1.0.4/sympy/vector/point.py
+-rw-rw-rw-   0        0        0     2089 2022-09-24 00:48:20.000000 sympy.keras-1.0.4/sympy/vector/scalar.py
+-rw-rw-rw-   0        0        0    17558 2022-09-24 00:48:20.000000 sympy.keras-1.0.4/sympy/vector/vector.py
+drwxrwxrwx   0        0        0        0 2022-10-12 08:07:39.397863 sympy.keras-1.0.4/sympy.keras.egg-info/
+-rw-rw-rw-   0        0        0        3 2022-10-06 02:48:27.000000 sympy.keras-1.0.4/sympy.keras.egg-info/.gitignore
+-rw-rw-rw-   0        0        0      528 2022-10-12 08:07:39.000000 sympy.keras-1.0.4/sympy.keras.egg-info/PKG-INFO
+-rw-rw-rw-   0        0        0    23693 2022-10-12 08:07:39.000000 sympy.keras-1.0.4/sympy.keras.egg-info/SOURCES.txt
+-rw-rw-rw-   0        0        0        1 2022-10-12 08:07:39.000000 sympy.keras-1.0.4/sympy.keras.egg-info/dependency_links.txt
+-rw-rw-rw-   0        0        0       21 2022-10-12 08:07:39.000000 sympy.keras-1.0.4/sympy.keras.egg-info/requires.txt
+-rw-rw-rw-   0        0        0        6 2022-10-12 08:07:39.000000 sympy.keras-1.0.4/sympy.keras.egg-info/top_level.txt
```

### Comparing `sympy.keras-1.0.21/PKG-INFO` & `sympy.keras-1.0.4/PKG-INFO`

 * *Files 24% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 1.1
 Name: sympy.keras
-Version: 1.0.21
+Version: 1.0.4
 Summary: UNKNOWN
 Home-page: https://github.com/cosmosZhou/sympy
 Author: Cosmos
 Author-email: 744984949@qq.com
 License: MIT
 Description: # axiom
```

### Comparing `sympy.keras-1.0.21/sympy/__init__.py` & `sympy.keras-1.0.4/sympy/__init__.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/abc.py` & `sympy.keras-1.0.4/sympy/abc.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/algebra/quaternion.py` & `sympy.keras-1.0.4/sympy/algebra/quaternion.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/assumptions/ask.py` & `sympy.keras-1.0.4/sympy/assumptions/ask.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/assumptions/ask_generated.py` & `sympy.keras-1.0.4/sympy/assumptions/ask_generated.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/assumptions/assume.py` & `sympy.keras-1.0.4/sympy/assumptions/assume.py`

 * *Files 1% similar despite different names*

```diff
@@ -90,15 +90,16 @@
 
     @property
     def func(self):
         return self._args[0]
 
     @cacheit
     def sort_key(self, order=None):
-        return self.class_key(), (1, (self.arg.class_key(),), (self.func.name, self.arg.sort_key())), S.One.sort_key(), S.One
+        return (self.class_key(), (2, (self.func.name, self.arg.sort_key())),
+                S.One.sort_key(), S.One)
 
     def __eq__(self, other):
         if type(other) is AppliedPredicate:
             return self._args == other._args
         return False
 
     def __hash__(self):
@@ -167,15 +168,15 @@
         self.handlers.append(handler)
 
     def remove_handler(self, handler):
         self.handlers.remove(handler)
 
     @cacheit
     def sort_key(self, order=None):
-        return self.class_key(), (0, (), (self.name,)), S.One.sort_key(), S.One
+        return self.class_key(), (1, (self.name,)), S.One.sort_key(), S.One
 
     def eval(self, expr, assumptions=True):
         """
         Evaluate self(expr) under the given assumptions.
 
         This uses only direct resolution methods, not logical inference.
         """
```

### Comparing `sympy.keras-1.0.21/sympy/assumptions/cnf.py` & `sympy.keras-1.0.4/sympy/assumptions/cnf.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/assumptions/handlers/calculus.py` & `sympy.keras-1.0.4/sympy/assumptions/handlers/calculus.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/assumptions/handlers/common.py` & `sympy.keras-1.0.4/sympy/assumptions/handlers/common.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/assumptions/handlers/matrices.py` & `sympy.keras-1.0.4/sympy/assumptions/handlers/matrices.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/assumptions/handlers/ntheory.py` & `sympy.keras-1.0.4/sympy/assumptions/handlers/ntheory.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/assumptions/handlers/order.py` & `sympy.keras-1.0.4/sympy/assumptions/handlers/order.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/assumptions/handlers/sets.py` & `sympy.keras-1.0.4/sympy/assumptions/handlers/sets.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/assumptions/refine.py` & `sympy.keras-1.0.4/sympy/assumptions/refine.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/assumptions/satask.py` & `sympy.keras-1.0.4/sympy/assumptions/satask.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/assumptions/sathandlers.py` & `sympy.keras-1.0.4/sympy/assumptions/sathandlers.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/calculus/euler.py` & `sympy.keras-1.0.4/sympy/calculus/euler.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/calculus/finite_diff.py` & `sympy.keras-1.0.4/sympy/calculus/finite_diff.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/calculus/singularities.py` & `sympy.keras-1.0.4/sympy/calculus/singularities.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/calculus/util.py` & `sympy.keras-1.0.4/sympy/calculus/util.py`

 * *Files 0% similar despite different names*

```diff
@@ -153,15 +153,15 @@
     ======
 
     NotImplementedError
         If any of the intervals, in the given domain, for which function
         is continuous are not finite or real,
         OR if the critical points of the function on the domain can't be found.
     """
-    from sympy.solvers.solveset import solveset
+    from sympy.solvers.solveset import solveset    
     if isinstance(domain, EmptySet):
         return EmptySet(etype=dtype.real)
 
     period = periodicity(f, symbol)
     if period is S.Zero:
         # the expression is constant wrt symbol
         return FiniteSet(f.expand())
```

### Comparing `sympy.keras-1.0.21/sympy/categories/__init__.py` & `sympy.keras-1.0.4/sympy/categories/__init__.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/categories/baseclasses.py` & `sympy.keras-1.0.4/sympy/categories/baseclasses.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/categories/diagram_drawing.py` & `sympy.keras-1.0.4/sympy/categories/diagram_drawing.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/codegen/__init__.py` & `sympy.keras-1.0.4/sympy/codegen/__init__.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/codegen/algorithms.py` & `sympy.keras-1.0.4/sympy/codegen/algorithms.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/codegen/approximations.py` & `sympy.keras-1.0.4/sympy/codegen/approximations.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/codegen/array_utils.py` & `sympy.keras-1.0.4/sympy/codegen/array_utils.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/codegen/ast.py` & `sympy.keras-1.0.4/sympy/codegen/ast.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/codegen/cfunctions.py` & `sympy.keras-1.0.4/sympy/codegen/cfunctions.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/codegen/cnodes.py` & `sympy.keras-1.0.4/sympy/codegen/cnodes.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/codegen/fnodes.py` & `sympy.keras-1.0.4/sympy/codegen/fnodes.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/codegen/futils.py` & `sympy.keras-1.0.4/sympy/codegen/futils.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/codegen/matrix_nodes.py` & `sympy.keras-1.0.4/sympy/codegen/matrix_nodes.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/codegen/numpy_nodes.py` & `sympy.keras-1.0.4/sympy/codegen/numpy_nodes.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/codegen/pyutils.py` & `sympy.keras-1.0.4/sympy/codegen/pyutils.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/codegen/rewriting.py` & `sympy.keras-1.0.4/sympy/codegen/rewriting.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/codegen/scipy_nodes.py` & `sympy.keras-1.0.4/sympy/codegen/scipy_nodes.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/combinatorics/__init__.py` & `sympy.keras-1.0.4/sympy/combinatorics/__init__.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/combinatorics/coset_table.py` & `sympy.keras-1.0.4/sympy/combinatorics/coset_table.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/combinatorics/fp_groups.py` & `sympy.keras-1.0.4/sympy/combinatorics/fp_groups.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/combinatorics/free_groups.py` & `sympy.keras-1.0.4/sympy/combinatorics/free_groups.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/combinatorics/generators.py` & `sympy.keras-1.0.4/sympy/combinatorics/generators.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/combinatorics/graycode.py` & `sympy.keras-1.0.4/sympy/combinatorics/graycode.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/combinatorics/group_constructs.py` & `sympy.keras-1.0.4/sympy/combinatorics/group_constructs.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/combinatorics/homomorphisms.py` & `sympy.keras-1.0.4/sympy/combinatorics/homomorphisms.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/combinatorics/named_groups.py` & `sympy.keras-1.0.4/sympy/combinatorics/named_groups.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/combinatorics/partitions.py` & `sympy.keras-1.0.4/sympy/combinatorics/partitions.py`

 * *Files 0% similar despite different names*

```diff
@@ -106,15 +106,16 @@
         >>> l = [d, b, a + 1, a, c]
         >>> l.sort(key=default_sort_key); l
         [{{1, 2}}, {{1}, {2}}, {{1, x}}, {{3, 4}}, {{0, 1, 2, 3}}]
         """
         if order is None:
             members = self.members
         else:
-            members = tuple(sorted(self.members, key=lambda w: default_sort_key(w, order)))
+            members = tuple(sorted(self.members,
+                             key=lambda w: default_sort_key(w, order)))
         return tuple(map(default_sort_key, (self.size, members, self.rank)))
 
     @property
     def partition(self):
         """Return partition as a sorted list of lists.
 
         Examples
```

### Comparing `sympy.keras-1.0.21/sympy/combinatorics/pc_groups.py` & `sympy.keras-1.0.4/sympy/combinatorics/pc_groups.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/combinatorics/perm_groups.py` & `sympy.keras-1.0.4/sympy/combinatorics/perm_groups.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/combinatorics/permutations.py` & `sympy.keras-1.0.4/sympy/combinatorics/permutations.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/combinatorics/polyhedron.py` & `sympy.keras-1.0.4/sympy/combinatorics/polyhedron.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/combinatorics/prufer.py` & `sympy.keras-1.0.4/sympy/combinatorics/prufer.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/combinatorics/rewritingsystem.py` & `sympy.keras-1.0.4/sympy/combinatorics/rewritingsystem.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/combinatorics/rewritingsystem_fsm.py` & `sympy.keras-1.0.4/sympy/combinatorics/rewritingsystem_fsm.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/combinatorics/schur_number.py` & `sympy.keras-1.0.4/sympy/combinatorics/schur_number.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/combinatorics/subsets.py` & `sympy.keras-1.0.4/sympy/combinatorics/subsets.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/combinatorics/tensor_can.py` & `sympy.keras-1.0.4/sympy/combinatorics/tensor_can.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/combinatorics/testutil.py` & `sympy.keras-1.0.4/sympy/combinatorics/testutil.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/combinatorics/util.py` & `sympy.keras-1.0.4/sympy/combinatorics/util.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/concrete/conditional_boolean.py` & `sympy.keras-1.0.4/sympy/concrete/conditional_boolean.py`

 * *Files 1% similar despite different names*

```diff
@@ -288,15 +288,15 @@
                 elif domain.is_UniversalSet:
                     limits = [*self.limits]
                     limits[i] = (x,)
                     return self.func(self.expr, *limits).simplify()
 
         for i, limit in enumerate(self.limits):
             if len(limit) == 1:
-                continue
+                continue            
             if len(limit) == 3:
                 e, cond, baseset = limit
                 if baseset.is_set:
                     if cond == self.expr: 
                         return S.BooleanTrue
             else:
                 e, s = limit
@@ -337,39 +337,39 @@
                             if sym.type == e.type:
                                 _expr = expr._subs(sym, e)                        
                                 if _expr != e:
                                     _function = function._subs(e, expr)
                                     if _function == function:
                                         return self
                                     limits = self.limits_update({e: (sym, base_set)})
-                                    function = _function
+                                    function = _function          
                                 else:
                                     base_set = base_set._subs(sym, e)
                                     limits = self.limits_update(e, base_set)
                             else:
                                 _function = function._subs(e, expr)
                                 if _function == function:
                                     return self
                                 limits = self.limits_update({e: (sym, base_set)})
-                                function = _function
+                                function = _function          
                         else:
                             limits = self.limits_update({e: (sym, base_set)})                            
                         return self.func(function, *limits).simplify()
                 else:  # s.type.is_bool: 
                     if s.is_Equal:
                         if e == s.lhs:
                             y = s.rhs
                         elif e == s.rhs:
                             y = s.lhs
                         else:
                             y = None
                         if y is not None and not y.has(e):
                             function = function._subs(e, y)
                             if function.is_BooleanAtom:
-                                return function
+                                return function 
                             limits = self.limits_delete(e)
                             if limits:
                                 return self.func(function, *limits)
                             return function
                     if s == self.expr or s.dummy_eq(self.expr):  # s.invert() | self.expr
                         return S.BooleanTrue
 
@@ -384,15 +384,15 @@
                 x, a, b = limit
                 diff = b - a
                 if diff.is_Number:
                     limits_behind = limits[::-1]
                     functions = []
                     for j in range(diff):
                         limits_before = [self.limits[t]._subs(x, a + j) for t in range(i)]                        
-                        limits = limits_before + limits_behind
+                        limits = limits_before + limits_behind 
                         
                         functions.append(self.func(function._subs(x, a + j), *limits).doit(**hints).simplify())
 
                     return self.operator(*functions)
             else:
                 limit = limit.doit()
                 x, *ab = limit
@@ -411,26 +411,26 @@
                             limits.append((arg,))
                     continue
 
             limits.append(limit)
         return self.func(function, *limits[::-1])
 
     def _pretty(self, p, func):
-        from sympy.printing.pretty.stringpict import prettyForm, stringPict
+        from sympy.printing.pretty.stringpict import prettyForm, stringPict                    
         prettyFunc = p._print("%s[%s]" % (func,
                                           ','.join([limit._format_ineq(p) for limit in self.limits])))
         prettyArgs = prettyForm(*p._print_seq([self.expr], delimiter=', ').parens())
         
         pform = prettyForm(binding=prettyForm.FUNC, *stringPict.next(prettyFunc, prettyArgs))
 
         # store pform parts so it can be reassembled e.g. when powered
         pform.prettyFunc = prettyFunc
         pform.prettyArgs = prettyArgs
 
-        return pform
+        return pform                
 
     def existent_symbols(self):
         free_symbols = Boolean.existent_symbols(self)        
         bound_symbols = {var.base: var.indices for var in self.bound_symbols if var.is_Sliced}
 
         if bound_symbols:
             deletes = set()
@@ -441,15 +441,15 @@
                         slices = bound_symbols[base]
                         if len(symbol.indices) == len(slices) and \
                         all(k >= b and b < e for k, (b, e) in zip(symbol.indices, slices)):
                             deletes.add(symbol)
 
             free_symbols -= deletes
             
-        return free_symbols
+        return free_symbols                    
 
     def detect_previous_dependence(self, i, x):
         for j in range(i - 1, -1, -1):
             limit = self.limits[j]
             t, *ab = limit
             if t == x:
                 if len(ab) == 2:
@@ -532,15 +532,15 @@
                     return self.expr.simplify()
                     
             if cond.is_bool:
                 if cond.is_Equal and x in cond.args:
                     y = cond.rhs if x == cond.lhs else cond.lhs
                     return self.subs_with_independent_variable(i, x, y)
                 if cond.is_Element and cond.lhs == x and cond.rhs.is_FiniteSet and len(cond.rhs) == 1:
-                    y, = cond.rhs.args
+                    [y] = cond.rhs.args
                     return self.subs_with_independent_variable(i, x, y)
                 
                 if self.detect_previous_dependence(i, x):
                     continue
                 
                 limits = [*self.limits]
                 del limits[i]          
@@ -548,15 +548,15 @@
                 if limits:
                     expr = self.func(self.expr, *limits).simplify()
                 else:
                     expr = self.expr
                 return self.invert_type.operator(cond, expr)
             
             if cond.is_FiniteSet and len(cond) == 1: 
-                y, = cond.args
+                [y] = cond.args
                 return self.subs_with_independent_variable(i, x, y)
             
             if self.detect_previous_dependence(i, x):
                 continue
             
             limits = [*self.limits]
             del limits[i]                        
@@ -583,15 +583,16 @@
                 elif len(args) == 1:
                     limit = var.domain_latex(args[0])
                 else:
                     a, b = args
                     if b.is_set:
                         limit = var.domain_latex(a, baseset=b)
                     else:
-                        limit = var.domain_latex(var.range(*args))
+                        from sympy import Range
+                        limit = var.domain_latex((Range if var.is_integer else Interval)(*args))
 
                 limits.append(limit)
 
             limit = r'\substack{%s}' % '\\\\'.join(limits)
 
         latex = r"\%s_{%s}{%s}" % (self.latexname, limit, latex)
         return latex
```

### Comparing `sympy.keras-1.0.21/sympy/concrete/delta.py` & `sympy.keras-1.0.4/sympy/concrete/delta.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/concrete/exists.py` & `sympy.keras-1.0.4/sympy/concrete/exists.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,14 +1,14 @@
 from sympy.logic.boolalg import Boolean, And, Or
 from sympy.concrete.conditional_boolean import Quantifier
 from sympy.sets.sets import FiniteSet
 from sympy.concrete.expr_with_limits import ExprWithLimits
 from sympy.core.relational import Unequal
 from sympy.core.sympify import sympify
-from sympy.core.singleton import S
+
 
 class Exists(Quantifier):
     """
     Any[x:A] q(x) <=> conditionset(x, q(x), A) != 
     """
     
     operator = Or
@@ -40,14 +40,15 @@
                         kwargs.clear()
                         kwargs[clue] = self
                         return self.func(function, *self.limits, **kwargs).simplify()
                     
         return Quantifier.subs(self, *args, **kwargs)
 
     def simplify(self, **kwargs):
+        from sympy import S
         from sympy.sets.contains import Element, NotElement
         if self.expr.is_Equal:
             limits_dict = self.limits_dict
             x = None
             if self.expr.lhs in limits_dict:
                 x = self.expr.lhs
                 y = self.expr.rhs
@@ -78,20 +79,20 @@
                         return function
         
         if self.expr.is_Element: 
             limits_dict = self.limits_dict
             x = None
             if self.expr.lhs in limits_dict:
                 x = self.expr.lhs
-                S = self.expr.rhs
+                S = self.expr.rhs                
             
             if x is not None:
                 domain = limits_dict[x]
                 if isinstance(domain, list):
-                    return self
+                    return self                          
 #                     function = Unequal(S, x.emptySet)
                 elif domain.is_set:
                     if domain.is_FiniteSet:
                         function = Element(domain.arg, S)
                     else:
                         function = Unequal(S & domain, x.emptySet)                        
                 else:
@@ -112,15 +113,15 @@
             if self.expr.lhs in limits_dict:
                 x = self.expr.lhs
                 S = self.expr.rhs
                 
             if x is not None:
                 domain = limits_dict[x]
                 if isinstance(domain, list):
-                    from sympy import Equal
+                    from sympy import Equal 
                     function = Equal(S, x.emptySet)
                 elif domain.is_set:
                     if domain.is_FiniteSet:
                         function = NotElement(domain.arg, S)
                     else:
                         function = Unequal(domain // S, x.emptySet)                        
                 else:
@@ -154,15 +155,15 @@
                     if eq.lhs in limits_dict:
                         old, new = eq.args
                     elif eq.rhs in limits_dict:
                         new, old = eq.args
                     else:
                         continue
                     
-                    continue
+                    continue 
                 
         if self.expr.is_Or:
             limits_dict = self.limits_dict
             for i, eq in enumerate(self.expr.args):
                 if eq.is_NotElement and eq.lhs in limits_dict:
                     domain = limits_dict[eq.lhs]
                     if not isinstance(domain, list) and domain in eq.rhs:
@@ -294,23 +295,14 @@
         if cond.is_set:
             return Unequal(cond, x.emptySet)
         return self.func[x](cond)
 
     @property
     def canonical(self):
         return self
-
-    @classmethod
-    def identity(cls, self, **kwargs):        
-        return S.false.copy(**kwargs)
-
-    @classmethod
-    def is_identity(cls, self):        
-        return self.is_BooleanFalse
-
-
-from sympy.concrete.forall import All
+    
+from sympy.concrete.forall import All     
 Any = Exists
 Any.invert_type = All
 All.invert_type = Any
 
 from sympy.concrete.limits import *
```

### Comparing `sympy.keras-1.0.21/sympy/concrete/expr_with_intlimits.py` & `sympy.keras-1.0.4/sympy/concrete/expr_with_intlimits.py`

 * *Files 0% similar despite different names*

```diff
@@ -326,15 +326,15 @@
                     x, a, b = limit
                     if b.is_set:
                         assert a.is_bool
                         return r"%s \in %s \left|%s\right." % (p._print(x), p._print(b), p._print(a))
                         
                     if x.is_integer:
                         if b.is_Add and b.args[0].is_One:
-                            b -= 1
+                            b -= 1                            
                             cmp = r"\leq"
                         else:
                             cmp = r"\lt"
                     else:
                         cmp = r"\leq"
                     return r"%s \leq %s %s %s" % (p._print(a), p._print(x), cmp, p._print(b))
```

### Comparing `sympy.keras-1.0.21/sympy/concrete/expr_with_limits.py` & `sympy.keras-1.0.4/sympy/concrete/expr_with_limits.py`

 * *Files 2% similar despite different names*

```diff
@@ -35,15 +35,15 @@
         limits, orientation = _process_limits(*symbols)
         for i, li in enumerate(limits):
             if len(li) == 4:
                 function = function.subs(li[0], li[-1])
                 limits[i] = tuple(li[:-1])
                 
             elif len(li) == 3:
-                oldsymbol, a, b = li
+                oldsymbol, a, b = li 
 # added here to remove the domain of this variable!
                 if isinstance(oldsymbol, Symbol) and oldsymbol.is_bounded:
                     newsymbol = oldsymbol.unbounded
                     function = function._subs(oldsymbol, newsymbol)
                     limits[i] = Tuple(newsymbol, *li[1:])
                 else:
                     if oldsymbol.is_integer and a == b:
@@ -58,19 +58,18 @@
 #         free = function.free_symbols
 #         if len(free) != 1:
 #             raise ValueError(
 #                 "specify dummy variables for %s" % function)
 #         limits, orientation = [Tuple(s) for s in free], 1
         limits, orientation = [], 1
 
-    # unnest any nested calls
-    if assumptions.get('evaluate', True):
-        while cls == type(function):
-            limits = list(function.limits) + limits
-            function = function.expr
+    # denest any nested calls
+    while cls == type(function):
+        limits = list(function.limits) + limits
+        function = function.expr
 
     # Any embedded piecewise functions need to be brought out to the
     # top level. We only fold Piecewise that contain the integration
     # variable.
     reps = {}
     symbols_of_integration = set([i[0] for i in limits])
     for p in function.atoms(Piecewise):
@@ -121,15 +120,15 @@
                                 limits.append(Tuple(x, start, stop))
                             else:
                                 limits.append(Tuple(x, domain))
                         else:
                             limits.append(Tuple(x))
                     else:
                         limits.append(Tuple(*V))
-                    continue
+                    continue            
                 if len(V) == 2:
                     if isinstance(V[1], Range) and V[1].step.is_One:
                         V = V[0], V[1].start, V[1].stop
                     elif isinstance(V[1], set):
                         V = V[0], FiniteSet(*V[1])
             V = sympify(flatten(V))  # a list of sympified elements
             if isinstance(V[0], (Symbol, Idx)) or getattr(V[0], '_diff_wrt', False):
@@ -199,40 +198,18 @@
 class ExprWithLimits(Expr):
     __slots__ = ['is_commutative']
 
     def _eval_is_integer(self):
         return self.expr.is_integer
 
     def _eval_is_random(self):
-        if self.expr.is_random:
-            return True
-
-        for x, *ab in self.limits:
-            for v in ab:
-                if v.is_random:
-                    return True
+        return self.expr.is_random
 
-    def yield_random_symbols(self):
-        limits = self.limits
-        expr = self.expr
-        for v in expr.yield_random_symbols():
-            if v.is_Indexed or v.is_Sliced or v.is_SlicedIndexed:
-                if v_enlarged := v.enlarge_indices(limits, expr):
-                    yield v_enlarged
-                else:
-                    yield v
-            else:                    
-                yield v
-
-        for x, *ab in limits:
-            for v in ab:
-                yield from v.yield_random_symbols()
-    
     def finite_aggregate(self, x, s):
-        k, *_ = s.args
+        k, *_ = s.args            
         expr = self.expr._subs(x, k)
         return expr.simplify()
 
     def limits_intersect(self, expr, clue=None):
         return limits_intersect(self.limits, expr.limits, clue=clue)
 
     def limits_union(self, expr):
@@ -241,18 +218,14 @@
 # precondition, self and other are structurally equal!
     def _dummy_eq(self, other):
         _self = other
         for (x, *ab), (_x, *_ab) in zip(other.limits, self.limits):
             if x != _x:
                 if not ab and x.domain != _x.domain:
                     return False
-
-                if _x in _self.variables:
-                    return False
-
                 _self = _self.limits_subs(x, _x)
                 if not _self.is_ExprWithLimits:
                     return False
                     
         return _self.limits == self.limits and _self.expr._dummy_eq(self.expr)
 
     @property
@@ -268,164 +241,143 @@
 
     def limits_delete(self, dic):
         return limits_delete(self.limits, dic)
 
     def limits_common(self, eq, is_or=False):
         return limits_common(self.limits, eq.limits, is_or)
 
-    def limits_in_context(self, has_args=None, parent=None):
-        if has_args:
-            return [*self.limits]
-        
-        limits = []
-        for limit in self.limits:
-            x, *ab = limit
-            if not ab and x.is_integer:
-                domain = self.expr.domain_defined(x)
-                limit = (x, domain)
-            limits.append(limit)
-            
-        limits.reverse()
-        return limits
-
     @property
     def dtype(self):
         return self.expr.dtype
 
-    def __new__(cls, expr, *symbols, **assumptions): 
+    def __new__(cls, function, *symbols, **assumptions): 
         limits = []
         symbols = [*symbols]
         for i in range(len(symbols) - 1, -1, -1):
             sym = symbols[i]
             if isinstance(sym, tuple):
                 sym = Tuple(*sym)
             
             if isinstance(sym, Tuple):
-                x, *ab = sym
+                x, *ab = sym 
                 if x.is_symbol:
                     if len(sym) == 2:
                         [domain] = ab
                         if domain.is_set:
                             assert x.type in domain.etype or domain.etype in x.type, "domain.etype = %s\n, x.type = %s" % (domain.etype, x.type)
                             if x.is_Symbol and x.is_bounded:
                                 domain &= x.domain_bounded
                                 _x = x.unbounded
                                 sym = _x, domain
-                                expr = expr._subs(x, _x)                            
+                                function = function._subs(x, _x)                            
                             elif domain.is_Range and domain.step.is_One:
                                 if domain.is_UniversalSet:
                                     sym = (x,)
                                 else:
                                     sym = (x, domain.start, domain.stop)
                             elif domain.is_Interval:
                                 if domain.is_UniversalSet:
                                     sym = (x,)
-                                elif domain.left_open and domain.right_open:
+                                elif not domain.left_open and not domain.right_open:
                                     sym = (x, domain.start, domain.stop)
                                     
                             elif domain.is_ConditionSet and domain.variable == x:
                                 if domain.base_set.is_UniversalSet:
                                     sym = (x, domain.condition)
                                 else:
                                     sym = (x, domain.condition, domain.base_set)
                         elif domain.is_bool:
                             if domain.is_BinaryCondition:
                                 if domain.lhs == x:
                                     if domain.is_GreaterEqual:
-                                        if x.is_integer:
-                                            sym = (x, domain.rhs, S.Infinity)
+                                        sym = (x, domain.rhs, S.Infinity)
                                     elif domain.is_Less:
                                         if x.is_integer:
                                             if x.is_nonnegative:
-                                                _x = x.unbounded
-                                                sym = _x, 0, domain.rhs
-                                                expr = expr._subs(x, _x)
+                                                sym = (x, 0, domain.rhs)
+                                                function = function._subs(x, x.unbounded)
                                             else:
                                                 sym = (x, -S.Infinity, domain.rhs)
-                                        elif x.is_real:
-                                            if x.is_positive:
-                                                _x = x.unbounded
-                                                sym = _x, 0, domain.rhs
-                                                expr = expr._subs(x, _x)
+                                    elif domain.is_LessEqual:
+                                        if x.is_integer:
+                                            ...
+                                        else:
+                                            if x.is_nonnegative:
+                                                if x.is_positive:
+                                                    domain = Interval(0, domain.rhs, left_open=True)
+                                                    sym = (x, domain)
+                                                else:
+                                                    sym = (x, 0, domain.rhs)
+                                                function = function._subs(x, x.unbounded)
                                             else:
                                                 sym = (x, -S.Infinity, domain.rhs)
-                                                
                                     elif domain.is_Greater:
                                         if x.is_integer:
                                             if domain.rhs.is_integer:
                                                 sym = (x, domain.rhs + 1, S.Infinity)
-                                        elif x.is_real:
-                                            sym = (x, domain.rhs, S.Infinity)
-                                            
-                                    elif domain.is_Element:
-                                        domain = domain.rhs
-                                        args = [domain]
-                                        if x.is_integer:
-                                            if domain.is_Range:
-                                                args = domain.args        
                                         else:
-                                            if domain.is_Interval and domain.is_open:
-                                                args = domain.args
-                                        sym = x, *args
-
+                                            ...    
+                                    elif domain.is_Element:
+                                        sym = (x, domain.rhs)
                                 elif domain.rhs == x:
-                                    if domain.is_LessEqual:  # lhs <= x
-                                        if x.is_integer:
-                                            sym = (x, domain.lhs, S.Infinity)
+                                    if domain.is_LessEqual:  # lhs <= x 
+                                        sym = (x, domain.lhs, S.Infinity)
                                     elif domain.is_Greater:  # lhs > x
                                         if x.is_integer:
                                             if x.is_nonnegative:
-                                                _x = x.unbounded
-                                                sym = _x, 0, domain.lhs
-                                                expr = expr._subs(x, _x)
+                                                sym = (x, 0, domain.lhs)
+                                                function = function._subs(x, x.unbounded)
                                             else: 
                                                 sym = (x, -S.Infinity, domain.lhs)
-                                        elif x.is_real:
-                                            if x.is_positive:
-                                                _x = x.unbounded
-                                                sym = _x, 0, domain.lhs
-                                                expr = expr._subs(x, _x)
-                                            else: 
+                                        else:
+                                            ...
+                                    elif domain.is_GreaterEqual:  # lhs >= x
+                                        if x.is_integer:
+                                            ...
+                                        else:
+                                            if x.is_nonnegative:
+                                                sym = (x, 0, domain.lhs)
+                                                function = function._subs(x, x.unbounded)
+                                            else:
                                                 sym = (x, -S.Infinity, domain.lhs)
-
                             elif domain:
-                                return expr.copy(**assumptions)
+                                return function.copy(**assumptions)
                             elif domain.is_BooleanFalse:
-                                return cls.identity(expr)
-
+                                return cls.identity(function)
+                        
                     elif len(sym) == 3:
-                        a, b = ab
-                        if x.is_Symbol and x.is_bounded and not a.is_bool:
+                        if x.is_Symbol and x.is_bounded and not ab[0].is_bool:
                             _x = x.unbounded
-                            sym = _x, a, b
-                            expr = expr._subs(x, _x)
-                        
+                            function = function._subs(x, _x)
+                            sym = (_x, *ab)
+                            
+                        a, b = ab
                         if a.is_bool:
                             if a:
                                 if b.is_Range and x.is_integer:
                                     if b.is_UniversalSet:
                                         sym = (x,)
                                     else:
                                         sym = (x, b.start, b.stop)
                                 else:
                                     sym = (x, b)
                             elif b.is_UniversalSet:
                                 sym = (x, a)
                         elif x.type.is_DtypeInteger and not b.is_set:
                             if a == b - 1:
-                                expr = expr._subs(x, a)                        
+                                function = function._subs(x, a)                        
                                 for j in range(i - 1, -1, -1):
                                     _x, *ab = symbols[j]                
                                     symbols[j] = (_x, *(sympify(e)._subs(x, a) for e in ab))
                                     if _x == x:
-                                        break
+                                        break                            
                                     
                                 continue
                             elif a == b:
-                                return cls.identity(expr, **assumptions)
+                                return cls.identity(function, **assumptions)
                     
                     limits.append(Tuple(*sym))
                 else:
                     if ab:
                         if x.is_BlockMatrix:
                             flat_list = x.args
                         else:
@@ -438,27 +390,30 @@
                         for arg in x._args[::-1]:
                             limits.append(Tuple(arg,))
                     
             else:
                 limits.append(Tuple(sym,))
                 
         limits.reverse()
-        return cls.unnest(expr, limits, symbols, **assumptions)
-
-    @classmethod
-    def unnest(cls, expr, limits, symbols, **assumptions):
-    # unnest any nested calls
-        while cls == type(expr):
-            limits = list(expr.limits) + limits
-            expr = expr.expr
+    # denest any nested calls
+        while cls == type(function):
+            limits = list(function.limits) + limits
+            function = function.expr
 
-        if not limits and symbols or cls.is_identity(expr):
-            return expr.copy(**assumptions)
+        if not limits and symbols:
+            return function.copy(**assumptions)
+        
+        args = [function] + limits
+        
+        if cls.is_Boolean:
+            obj = Boolean.__new__(cls, *args, **assumptions)
+        else:
+            obj = Expr.__new__(cls, *args, **assumptions)
 
-        return Expr.__new__(cls, expr, *limits, **assumptions)
+        return obj
 
     @property
     def expr(self):
         """Return the expression applied across limits.
 
         Examples
         ========
@@ -579,22 +534,15 @@
                 
                 isyms.update(symbols)
         return isyms
 
     @property
     def is_number(self):
         """Return True if the Sum has no free symbols, else False."""
-        if self.free_symbols:
-            return False
-        
-        from sympy.core.function import AppliedUndef
-        for f in self.finditer(AppliedUndef):
-            return False
-
-        return True
+        return not self.free_symbols
 
     def _eval_interval(self, x, a, b):
         limits = [(i if i[0] != x else (x, a, b)) for i in self.limits]
         integrand = self.expr
         return self.func(integrand, *limits)
 
     def _eval_subs(self, old, new, **hints):
@@ -692,15 +640,15 @@
                         for index in indices: 
                             if index.is_symbol:
                                 indexDomain = index.domain
                                 _indexDomain = self.domain_defined(index)
                                 if _indexDomain != indexDomain:
                                     _index = index.copy(domain=_indexDomain)
                                     _function = _function._subs(index, _index)
-                                    reps[index] = _index
+                                    reps[index] = _index                                
                                        
                     _function = _function._subs(x, new)
                     
                     if reps:
                         for index, _index in reps.items():
                             _function = _function._subs(_index, index)
                 else:
@@ -719,15 +667,16 @@
             if self.is_Boolean:
                 kwargs['equivalent'] = self
 
             index = self.variables.index(x)
             limits = [*self.limits]
             if 'domain' in new._assumptions:
                 if len(domain) == 2:
-                    assert new.domain == x.range(*domain)
+                    dom = (Range if x.is_integer else Interval)(*domain)
+                    assert new.domain == dom
                 elif domain:
                     dom = domain[0]
                     if not dom.is_set:
                         dom = new.domain_conditioned(dom)
                     assert new.domain == dom
                 limits[index] = (new,)
             elif len(domain) == 1:
@@ -779,21 +728,14 @@
         from sympy.solvers import solve
         if len(self.limits) == 1:
             limit = self.limits[0]
             x, *domain = limit
 
             if old == x:
                 if self.expr._has(new):
-                    if x.is_Indexed and old.is_Indexed and new.is_Indexed:                         
-                        v = self.generate_var({x, old, new}, dtype=new.dtype)
-                        self_tmp = self.limits_subs(old, v)
-                        if self_tmp != self:
-                            self_tmp = self_tmp.limits_subs(v, new)
-                            if self_tmp != self:
-                                return self_tmp
                     return self
                 
                 if not domain: 
                     if new._has(x):
                         p = new.as_poly(x)
                         if p is None or p.degree() != 1:
                             return self
@@ -846,17 +788,17 @@
                     if len(domain) == 2:
                         a, b = domain
                         if a.is_bool:
                             cond, baseset = domain
                             assert baseset.is_set
                             cond = cond._subs(old, new)                            
                             self = self.func(function, (x, cond, baseset))
-                        else:
+                        else: 
                             from sympy import Element
-                            cond = Element(new, x.range(a, b))
+                            cond = Element(new, (Range if x.is_integer else Interval)(a, b))
                             self = self.func(function, (x, cond))
                     elif len(domain) == 1:
                         cond = domain[0]
                         if cond.is_bool:
                             cond = cond._subs(old, new)
                             self = self.func(function, (x, cond))
                             
@@ -928,15 +870,15 @@
             
             limits = [*self.limits]
             variables = self.variables
             hit = False
             for i, limit in enumerate(limits):
                 x, *domain = limit
                 if old == x and not new.has(x):
-                    return self._subs_limits(x, domain, new, simplify=simplify)
+                    return self._subs_limits(x, domain, new)
 
                 if len(domain) == 2:
                     a, b = domain
 
                 p = old.as_poly(x)
                 if p is None or p.degree() == 0:
                     continue
@@ -987,19 +929,14 @@
         if _this == this:
             return self
         return _this
         
 #     Override this stub if you want to do anything more than
 #     attempt a replacement of old with new in the arguments of self.
     def _subs_utility(self, old, new, **hints):
-        if old.is_Sliced:
-            this = self._subs_sliced(old, new, **hints)
-            if this != self:
-                return this
-
         if old.is_symbol and not self.expr._has(old):
             if not any(limit._has(old) for limit in self.limits):
                 return self
             
             intersect = self._if_new_has_variables(old, new)
             if intersect:
                 return self._subs_if_new_has_variables(old, new, intersect)
@@ -1014,17 +951,17 @@
                     hit = True
             if hit:
                 self = self.func(self.expr, *limits)
                 if hints.get('simplify', True):
                     self = self.simplify()
             return self
             
-        if not old.is_Surrogate:
-            if intersect := self._if_new_has_variables(old, new):
-                return self._subs_if_new_has_variables(old, new, intersect)
+        intersect = self._if_new_has_variables(old, new)
+        if intersect: 
+            return self._subs_if_new_has_variables(old, new, intersect)
         
         from sympy.core.basic import _aresame
         if self == old or _aresame(self, old) or self.dummy_eq(old): 
             return new
 
         if old in self.variables_set:
             for i in range(len(self.limits) - 1, -1, -1):
@@ -1037,22 +974,22 @@
                 
                 limit = self.limits[i]
                 
                 if len(limit) <= 1 or not limit[1].is_bool:
                     _limit = limit._subs_limits(old, new)
                     if _limit != limit:
                         limits[i] = _limit
-                        hit = True
+                        hit = True                    
                     
                 for j in range(i + 1, len(self.limits)):
                     limit = self.limits[j]
                     _limit = limit._subs_limits(old, new)
                     if _limit != limit:
                         limits[j] = _limit
-                        hit = True
+                        hit = True                    
                 if hit:
                     self = self.func(self.expr, *limits)
                 break
             return self
             
     def _subs_sliced_utility(self, old, new, **hints):
         if old.is_symbol and not self.expr._has(old):
@@ -1101,22 +1038,22 @@
                 
                 if len(limit) and limit[1].is_bool:
                     ...
                 else:
                     _limit = limit._subs_limits(old, new)
                     if _limit != limit:
                         limits[i] = _limit
-                        hit = True
+                        hit = True                    
                     
                 for j in range(i + 1, len(self.limits)):
                     limit = self.limits[j]
                     _limit = limit._subs_limits(old, new)
                     if _limit != limit:
                         limits[j] = _limit
-                        hit = True
+                        hit = True                    
                 if hit:
                     self = self.func(self.expr, *limits)
                 break
             return self
         
         rule = {}
         for limit in self.limits[::-1]:
@@ -1141,44 +1078,29 @@
             
     def _subs(self, old, new, **hints):
         this = self._subs_utility(old, new, **hints)
         if this is not None:
             return this
         
         if old.has(*self.variables) and not new.has(*self.variables):
-            if new.free_symbols:
-                return self
+            return self
         
         from sympy.core.basic import _aresame
-        expr, *limits = self.args
-        expr = expr._subs(old, new)
-        hit = not _aresame(expr, self.expr)
-        
-        for i, limit in enumerate(limits):
-            x, *cond = limit
-            try:
-                x = x._subs(old, new)
-            except Exception as e:
-                if str(e) == 'empty slices':
-                    return expr
-                raise e
-            
-            innerHit = not _aresame(x, limit[0])
-            for j, c in enumerate(cond):
-                c = c._subs(old, new)
-                if not _aresame(c, cond[j]):
-                    innerHit = True
-                    cond[j] = c
-                
-            if innerHit:
-                limits[i] = (x, *cond)
+        hit = False
+        args = [*self.args]
+        for i, arg in enumerate(args):
+            if not hasattr(arg, '_eval_subs'):
+                continue
+            arg = arg._subs(old, new)
+            if not _aresame(arg, args[i]):
                 hit = True
-
+                args[i] = arg
         if hit:
-            return self.func(expr, *limits)
+            rv = self.func(*args)
+            return rv
         return self
 
     def _subs_sliced(self, old, new, **hints):
         this = self._subs_sliced_utility(old, new, **hints)
         if this is not None:
             return this
         
@@ -1194,25 +1116,25 @@
             arg = arg._subs(old, new)    
             if not _aresame(arg, args[i]):
                 hit = True
                 args[i] = arg
         if hit:
             rv = self.func(*args)
             return rv
-        return self
+        return self    
     
     def _has_symbol(self, pattern):
         if (hit := self._has_variable(pattern)) is not None:
             return hit
         
         return self.expr._has(pattern) or any(arg._has(pattern) for arg in self.limits)
 
     def _has_indexed(self, pattern):
         if (hit := self._has_variable(pattern)) is not None:
-            return hit
+            return hit        
         
         base = pattern.base
         if base.is_Indexed:
             base = base.base
             
         for path in self.finditer(base, definition=True):
             history = self.fetch_from_path(*path, history=True)
@@ -1225,29 +1147,26 @@
                 length = 4
                 if len(history) >= length and history[-length].is_symbol:
                     last = history[-length]
                     length += 1
 
             if last.is_Indexed and len(history) >= length and history[-length].is_Sliced and history[-length].base == last:
                 last = history[-length]
-
+                            
             if path[0]:
                 if path[1]:
                     print("unresolved cases")
                     return True
                 else:
                     if last._has(pattern):
                         return True
             else:
-                history.insert(0, self)
-                for this in reversed(history):
-                    if this.is_ExprWithLimits:
-                        last = last.enlarge_indices(this.limits)
-                        if last._has(pattern):
-                            return True
+                last = last.enlarge_indices(self.limits)
+                if last._has(pattern):
+                    return True
         else:
             return False
         
     def _has_sliced(self, pattern):
         if (hit := self._has_variable(pattern)) is not None:
             return hit
         
@@ -1263,15 +1182,15 @@
                 history = self.fetch_from_path(*path, history=True)
                 last = history[-2]
                 if last.is_Indexed and len(history) >= 3 and history[-3].is_Sliced and history[-3].base == last:
                     last = history[-3]
                 
                 last = last.enlarge_indices(self.limits)
                 if last._has(pattern):
-                    return last not in self.variables
+                    return True
         else:
             return False
 
     def _has_variable(self, pattern):
         for i, (x, *args) in enumerate(self.limits):
             if x == pattern:
                 mapping = self.limits_dict
@@ -1292,15 +1211,15 @@
         """Helper for .has()"""
         if pattern.is_Symbol:
             return self._has_symbol(pattern)
         
         if pattern.is_Indexed:
             return self._has_indexed(pattern)
         
-        if pattern.is_Sliced or pattern.is_SlicedIndexed:
+        if pattern.is_Sliced:
             return self._has_sliced(pattern)
         
         return Expr._has(self, pattern)
 
     @classmethod
     def class_key(cls):
         """Nice order of classes. """
@@ -1308,33 +1227,33 @@
 
     def _eval_shape(self):
         return self.expr.shape
 
     @cacheit
     def _eval_domain_defined(self, x, allow_empty=True, **_): 
         if x.dtype.is_set:
-            return x.universalSet
+            return x.universalSet            
         
-        domain = x.domain
+        domain = x.domain        
         if x in self.variables:
             return domain
                     
         for limit in self.limits:
             var, *ab = limit
             if var.is_Sliced:
                 domain &= var._eval_domain_defined(x, allow_empty=allow_empty)
             else:
                 domain &= var.domain_defined(x)
             for e in ab:
                 domain &= e.domain_defined(x)
                 
         if self.expr._has(x):
             bound_domain = self.expr.domain_defined(x)
-            for limit in self.limits:
-                bound_domain = bound_domain.adjust_domain(*limit)
+            for var in self.variables:
+                bound_domain = bound_domain.delete_from_domain(var)
                 
             domain &= bound_domain
             if x not in self.expr.free_symbols:
                 v = self.variable
                 if not v.is_Sliced:
                     v_domain = self.limits_dict[v]
                     for var in self.expr.free_symbols:
@@ -1357,66 +1276,52 @@
         
         i, *_ = self.limits[0]
         i_ = Wild(i.name)
 
         dic = expr.match(self.expr.subs(i, i_))
         if dic:
             return dic[i_]
-    # this simplication procedure is not meant for Sum / Integral / Product, since redundant bound variable can influence the result
+
     def simplify(self, deep=False, **kwargs):
         limits = [*self.limits]
         dic = {x: domain for x, *domain in limits}
         updated = False
         for var, *domain in limits:
             if len(domain) == 1:
                 domain = domain[0]
                 if domain.is_set:
                     continue
             if not var.is_Sliced:
                 continue
             
             start, stop = var.index
-            default = True
-            if stop.is_finite:
-                if var.base[stop] in dic and not dic[var.base[stop]] and not dic[var]:
-                    del dic[var.base[stop]]
-                    del dic[var]
-                    dic[var.base[start: stop + 1]] = ()
-                    updated = True
-                    default = False
-                elif not self.expr.has(var.base[stop - 1]): 
-                    del dic[var]
-                    _var = var.base[start: stop - 1]
-                    if not domain or not domain._has(_var):
-                        domain = ()
-                    dic[_var] = domain
-                    updated = True
-                    default = False
-                    
+            if var.base[stop] in dic and not dic[var.base[stop]] and not dic[var]:
+                del dic[var.base[stop]]
+                del dic[var]
+                dic[var.base[start: stop + 1]] = ()
+                updated = True
             elif var.base[start - 1] in dic and not dic[var.base[start - 1]] and not dic[var]:
                 del dic[var.base[start - 1]]
                 del dic[var]
                 dic[var.base[start - 1: stop]] = ()
                 updated = True
-                default = False
-                
+            elif not self.expr.has(var.base[stop - 1]): 
+                del dic[var]
+                _var = var.base[start: stop - 1]
+                if not domain._has(_var):
+                    domain = ()
+                dic[_var] = domain
+                updated = True
             elif not self.expr.has(var.base[start]):
-                if domain:
-                    if not domain._has(var.base[start]):
-                        del dic[var]
-                        dic[var.base[start + 1: stop]] = domain
-                        updated = True
-                else:
+                if not domain._has(var.base[start]):
                     del dic[var]
                     dic[var.base[start + 1: stop]] = domain
                     updated = True
-                    
-                default = False
+            else:
                 
-            if default:
                 validDomain = S.Zero.emptySet
                 for p in self.expr.preorder_traversal():
                     if p.is_Sliced and p.base == var.base:
                         if len(p.indices) == 1:
                             validDomain |= Range(*p.indices[0])
                     elif p.is_Indexed and p.base == var.base:
                         if len(p.indices) == 1:
@@ -1426,35 +1331,32 @@
                     universe = Range(*var.indices[0])
                     if validDomain != universe and validDomain in universe:
                         if validDomain.is_Range:
                             start, end = validDomain.start, validDomain.stop
                             del dic[var]
                             dic[var.base[start: end]] = domain
                             updated = True
-                        elif validDomain.is_FiniteSet:
-                            if len(validDomain) == 1:
-                                index, = validDomain
-                                del dic[var]
-                                dic[var.base[index]] = domain
-                                updated = True
-                            
 
         if updated:
             dic_original = {x: domain for x, *domain in limits}
-            limits = [(key, *dic[key]) for key in dic.keys() - dic_original.keys()] + limits
+            limits = [(key, *dic[key])for key in dic.keys() - dic_original.keys()] + limits
             for key in dic_original.keys() - dic.keys():
                 del limits[[x for x, *_ in limits].index(key)]
 
             if self.is_bool:
                 kwargs = {'equivalent': self}
             else:
                 kwargs = {}
             return self.func(self.expr, *limits, **kwargs)
         return self
 
+    @classmethod
+    def identity(cls, self, **assumptions):
+        return cls.operator.identity.copy(**assumptions)
+
     @property
     def expr_within_context(self):
         expr = self.expr
         for x, domain in self.limits_dict.items():
             if not isinstance(domain, list) and domain.is_set:
                 expr = expr._subs(x, x.copy(domain=domain))
         return expr
@@ -1468,48 +1370,27 @@
                 domain = self.expr.domain_defined(x)
                 shape.append(domain.size)
             elif len(ab) == 2:
                 a, b = ab
                 shape.append(b - a)
             else:
                 [domain] = ab
-                start, stop, step = domain.args
+                start, stop, step = domain.args 
                 shape.append(Ceiling((stop - start) / step))
         shape.reverse()
         return tuple(shape)
 
-    @cacheit
-    def compile(self, *syms):
-        assert all(self._has(v) for v in syms)
-        
-        expr = self.expr
-        vars = []
-        for v in self.variables: 
-            if expr._has(v):
-                vars.append(v)
-                assert v not in syms
-        
-        shape = []
-        for v, a, b in self.limits:
-            if a:
-                expr = expr._subs(v, v + a)
-                
-            shape.append((b - a).precompile(*syms))
-            
-        expr = expr.precompile(*vars, *syms)
-        
-        from sympy.keras.network import NetWorkMetaClass
-        return NetWorkMetaClass.mapping[self.func.__name__](expr, *shape)
-
 
 class AddWithLimits(ExprWithLimits):
     r"""Represents unevaluated oriented additions.
         Parent class for Integral and Sum.
     """
 
+    is_complex = True
+    
     def __new__(cls, function, *symbols, **assumptions):
         pre = _common_new(cls, function, *symbols, **assumptions)
         if type(pre) is tuple:
             function, limits, orientation = pre
         else:
             return pre
         
@@ -1517,27 +1398,27 @@
             assert not limits
             if function.is_FiniteSet: 
                 return Add(*function.args)
             if function.is_Range:
                 a, b = function.start, function.stop - 1
                 return (a + b) * (b - a + 1) / 2
         else:
-            if not function:
-                return function
             function = orientation * function  # orientation not used in ExprWithLimits
             
         return Expr.__new__(cls, function, *limits, **assumptions)
 
     def _eval_adjoint(self):
         if all([x.is_real for x in flatten(self.limits)]):
             return self.func(self.expr.adjoint(), *self.limits)
+        return None
 
     def _eval_conjugate(self):
         if all([x.is_real for x in flatten(self.limits)]):
             return self.func(self.expr.conjugate(), *self.limits)
+        return None
 
     def _eval_transpose(self, axis=-1):
         if axis == self.default_axis:
             if all([x.is_real for x in flatten(self.limits)]):
                 return self.func(self.expr.transpose(), *self.limits)
 
     def _eval_factor(self, **hints):
@@ -1571,46 +1452,44 @@
         elif summand != self.expr:
             if summand._coeff_isneg():
                 return -self.func(-summand, *self.limits)
             return self.func(summand, *self.limits)
         
         return self
 
-    def _subs(self, old, new, **hints):
-        expr = self.expr.subs(old, new)
-        limits = [*self.limits]
-        hit = expr != self.expr
-        for i, (x, *ab) in enumerate(limits):
-            ab = [t._subs(old, new) for t in ab]
-            if x.is_Sliced:
-                try:
-                    x = x._subs(old, new)
-                except Exception as e:
-                    if e.args[0] == 'empty slices':
-                        return expr
-                    raise e
-
-            elif x.is_Indexed or x.is_SlicedIndexed:
-                x = x._subs(old, new)
-
-            limits[i] = (x, *ab)
-            hit |= limits[i] != self.limits[i]
-            
-        if hit:
-            return self.func(expr, *limits)
-        
-        return self
+    def _eval_is_extended_real(self):
+        function = self.expr                
+        for x, domain in self.limits_dict.items():
+            if not isinstance(domain, list) and not domain.is_bool and not x.shape:
+                _x = x.copy(domain=domain)
+                if _x != x:
+                    function = function._subs(x, _x)
+                
+        return function.is_extended_real
+    
+    def _eval_is_extended_positive(self):
+        function = self.expr                
+        for x, domain in self.limits_dict.items():
+            if not isinstance(domain, list) and not domain.is_bool and not x.shape:
+                _x = x.copy(domain=domain)
+                if _x != x:
+                    function = function._subs(x, _x)
+        return function.is_extended_positive
 
-    def __iter__(self):
-        raise TypeError
+    def _eval_is_extended_negative(self):
+        function = self.expr                
+        for x, domain in self.limits_dict.items():
+            if not isinstance(domain, list) and not domain.is_bool and not x.shape:
+                _x = x.copy(domain=domain)
+                if _x != x:
+                    function = function._subs(x, _x)
+                    
+        return function.is_extended_negative
 
-    def __getitem__(self, indices):
-        return self.func(self.expr[indices], *self.limits)
 
-        
 class MINMAXBase(ExprWithLimits):
     
     def _eval_is_hyper_real(self):
         return self.expr.is_hyper_real
         
     def _eval_is_extended_real(self):
         for x, *ab in self.limits:
@@ -1635,32 +1514,30 @@
 
         return True
 
     def _eval_shape(self):
         return self.expr.shape
     
     def _eval_is_finite(self):
-        function = self.expr
+        function = self.expr                
         for x, domain in self.limits_dict.items():
-            if not isinstance(domain, list) and not domain.is_bool:
+            if not isinstance(domain, list):
                 _x = x.copy(domain=domain)
                 function = function._subs(x, _x)
         return function.is_finite
     
     def simplify(self, deep=False, **kwargs):
-        if len(self.limits) == 1:
-            limit, = self.limits
-            if len(limit) == 2:
-                x, domain = limit
-                if domain.is_FiniteSet and len(domain) == 1:
-                    return self.finite_aggregate(x, domain)			
-            if self.expr.is_Piecewise:
-                x, domain = limit.coerce_setlimit()
-                return self.expr.as_multiple_terms(x, domain, self.func)
-
+        if not self.limits:
+            if self.expr.is_Lamda:
+                if len(self.expr.limits) == 1 and not self.expr.variable.shape:
+                    function = self.expr.expr
+                    self = self.func(function, *self.expr.limits).simplify(**kwargs)
+            elif self.expr.is_Piecewise:
+                self = self.expr.func(*((self.func(e).simplify(), c) for e, c in self.expr.args)).simplify()            
+            return self
         (x, *ab), *limits = self.limits
         independent, dependent = self.expr.as_independent(x, as_Add=True)
         if not independent.is_zero: 
             if limits:
                 function = self.func(dependent, (x, *ab)) + independent
                 return self.func(function, *limits)
             else:
@@ -1678,15 +1555,15 @@
         if self.expr.is_Log:
             return self.expr.func(self.func(self.expr.arg, *self.limits))
         
         return ExprWithLimits.simplify(self, deep=deep)
     
     def bounds(self, x, domain, cls):
         try:
-            assert self.expr.is_infinitesimal is None
+            assert self.expr.is_infinitesimal is None                    
             from sympy import limit
             maxi = domain.max()
             if maxi.is_infinite:
                 maxi = limit(self.expr, x, maxi)
 #             elif maxi.is_infinitesimal:            
 #                 maxi = self.expr._subs(x, maxi, symbol=False)
             else:
@@ -1774,20 +1651,20 @@
 
     def doit(self, **hints):
         x, *domain = self.limits[0]
         if len(self.limits) != 1 or x.is_set:
             return self
         
         if len(domain) == 1:
-            [domain] = domain
+            [domain] = domain  
         elif len(domain) == 2: 
             if domain[-1].is_set: 
                 return self
             else:
-                domain = x.range(*domain)
+                domain = (Range if x.is_integer else Interval)(*domain)
         else:
             domain = x.domain
                          
         if domain.is_CartesianSpace or not domain.etype.is_extended_real:
             return self
 
         if self.expr.is_infinitesimal is not None:
@@ -1817,22 +1694,14 @@
             
     # infimum returns the value which is bound to be below (<=) the minimum!
     def infimum(self):
         if not self.limits and self.expr.is_set:
             return self.expr.infimum()
         return self
     
-    @classmethod
-    def identity(cls, self, **_):
-        return S.Infinity
-    
-    @classmethod
-    def is_identity(cls, self):        
-        return self.is_Infinity
-    
 
 MIN = Minima
 
                 
 class Maxima(MINMAXBase):
     r"""Represents unevaluated MAX operator.
     Maxima[f,x]
@@ -1852,20 +1721,20 @@
 
     def doit(self, **hints):
         x, *domain = self.limits[0]
         if len(self.limits) != 1 or x.is_set:
             return self
             
         if len(domain) == 1:
-            domain, = domain
+            [domain] = domain  
         elif len(domain) == 2:
             if domain[-1].is_set: 
                 return self
             else:
-                domain = x.range(*domain)
+                domain = (Range if x.is_integer else Interval)(*domain)
         else:
             domain = x.domain
             
         if domain.is_CartesianSpace or not domain.etype.is_extended_real:
             return self
 
         if self.expr.is_infinitesimal is not None:
@@ -1899,22 +1768,14 @@
                 return True
 
     def _eval_is_extended_negative(self):
         if not self.limits and self.expr.is_set:
             if self.expr.supremum().is_extended_negative:
                 return True
 
-    @classmethod
-    def identity(cls, self, **_):
-        return S.NegativeInfinity
-    
-    @classmethod
-    def is_identity(cls, self):        
-        return self.is_NegativeInfinity
-
 
 Maxima.reversed_type = MIN
 MIN.reversed_type = Maxima
 
 
 class ArgMinMaxBase(ExprWithLimits):
 
@@ -1945,25 +1806,25 @@
         for x, *_ in self.limits:
             x_shape = x.shape
             if shape is None:
                 shape = x_shape
                 continue
             if x_shape == shape:
                 shape = (2, *shape)                
-                continue
+                continue            
             assert x_shape == shape[1:], 'illegal shape %s' % x_shape
             shape = (shape[0] + 1, *x_shape)
                 
         return shape
     
     def simplify(self, deep=False, **kwargs):
         if not self.limits:
             if self.expr.is_Lamda:
                 if len(self.expr.limits) == 1 and not self.expr.variable.shape:
-                    function = self.expr.expr
+                    function = self.expr.expr                    
                     return self.func(function, *self.expr.limits).simplify(**kwargs)
             return self
         * _, (x, *_) = self.limits
         independent, dependent = self.expr.as_independent(x, as_Add=True)
         if not independent.is_zero: 
             return self.func(dependent, *self.limits)
         
@@ -2001,23 +1862,15 @@
         if isinstance(self.expr, Add):
             tex += r"\left(%s\right)" % p._print(self.expr)
         else:
             tex += p._print(self.expr)
 
         return tex
 
-    @property
-    def dtype(self):
-        return self.variable.dtype
-    
-    @classmethod
-    def is_identity(cls, self):
-        ...
 
-    
 class ArgMin(ArgMinMaxBase):
     r"""Represents unevaluated argmin operator.
     Minima[f,x]
     minimizes f with respect to x.
     """
 
     def __new__(cls, function, *symbols, **assumptions):
@@ -2028,22 +1881,22 @@
         if len(self.limits) != 1:
             return self
         x, *domain = self.limits[0]
         if x.is_set:
             return self
 
         if len(domain) == 1:
-            [domain] = domain
+            [domain] = domain  
         elif len(domain) == 2: 
             if domain[-1].is_set: 
                 return self
             else:
-                domain = x.range(*domain)
+                domain = (Range if x.is_integer else Interval)(*domain)
         else:
-            domain = x.domain
+            domain = x.domain        
             if domain.is_CartesianSpace:
                 return self
         assert self.expr.is_infinitesimal is None
         p = self.expr.as_poly(x)
 
         if p is not None:
             if p.degree() == 1:
@@ -2077,20 +1930,20 @@
 
     def doit(self, **hints):
         if len(self.limits) != 1:
             return self
         x, *domain = self.limits[0]
 
         if len(domain) == 1:
-            [domain] = domain
+            [domain] = domain  
         elif len(domain) == 2: 
             if domain[-1].is_set: 
                 return self
             else:
-                domain = x.range(*domain)
+                domain = (Range if x.is_integer else Interval)(*domain)
         else:
             domain = x.domain
             if domain.is_CartesianSpace:
                 return self
 
         p = self.expr.as_poly(x)
 
@@ -2098,15 +1951,15 @@
             if p.degree() == 1:
                 a = p.coeff_monomial(x)
                 if a.is_extended_positive:
                     return domain.max()
                 elif a.is_extended_negative:
                     return domain.min()
             elif p.degree() == 0:
-                return self
+                return self                
             elif p.degree() <= 0:
                 from sympy.matrices.expressions.matexpr import ZeroMatrix
                 return ZeroMatrix(*self.shape)
         elif self.expr.is_MinMaxBase:
             print('error, unreliable implementation')
             return self.expr.func(*(self.func(arg, *self.limits).doit() for arg in self.expr.args))
                 
@@ -2124,39 +1977,35 @@
     def _eval_is_extended_real(self): 
         return self.expr.is_extended_real
         
     def _eval_shape(self):
         return self.expr.shape
     
     def _eval_is_finite(self):
-        function = self.expr
+        function = self.expr                
         for x, domain in self.limits_dict.items():
-            if isinstance(domain, list):
-                return
-
-            if domain.is_Interval:
-                return
-
-            if domain.is_Range:
-                a, b = domain.args
-                if a.is_infinite or b.is_infinite:
-                    return
+            if not isinstance(domain, list):
+                if domain.is_Range or domain.is_Interval:
+                    a, b = domain.args
+                    if a.is_infinite or b.is_infinite:
+                        return
+                    
+                _x = x.copy(domain=domain)
+                function = function._subs(x, _x)
         return function.is_finite
     
     def simplify(self, deep=False, **kwargs):
-        if len(self.limits) == 1:
-            limit = self.limits[0]
-            if len(limit) == 2:
-                x, domain = limit
-                if domain.is_FiniteSet and len(domain) == 1:
-                    return self.finite_aggregate(x, domain)
-            if self.expr.is_Piecewise:
-                x, domain = limit.coerce_setlimit()
-                return self.expr.as_multiple_terms(x, domain, self.func)
-
+        if not self.limits:
+            if self.expr.is_Lamda:
+                if len(self.expr.limits) == 1 and not self.expr.variable.shape:
+                    function = self.expr.expr
+                    self = self.func(function, *self.expr.limits).simplify(**kwargs)
+            elif self.expr.is_Piecewise:
+                self = self.expr.func(*((self.func(e).simplify(), c) for e, c in self.expr.args)).simplify()            
+            return self
         (x, *ab), *limits = self.limits
         independent, dependent = self.expr.as_independent(x, as_Add=True)
         if not independent.is_zero: 
             if limits:
                 function = self.func(dependent, (x, *ab)) + independent
                 return self.func(function, *limits)
             else:
@@ -2166,15 +2015,15 @@
                     for x, *ab in self.limits:
                         if len(ab) == 2:
                             a, b = ab
                             if a.is_bool:
                                 conds.append(Unequal(b, x.emptySet))
                                 conds.append(a.invert())
                             else:
-                                domain = x.range(a, b)
+                                domain = (Range if x.is_integer else Interval)(a, b)
                                 conds.append(Unequal(domain, x.emptySet))
                         else:
                             [domain] = ab
                             if domain.is_set:
                                 conds.append(Unequal(domain, x.emptySet))
                             else:
                                 conds.append(domain.invert())
@@ -2194,15 +2043,15 @@
         if self.expr.is_Log:
             return self.expr.func(self.func(self.expr.arg, *self.limits))
         
         return ExprWithLimits.simplify(self, deep=deep)
     
     def bounds(self, x, domain, cls):
         try:
-            assert self.expr.is_infinitesimal is None
+            assert self.expr.is_infinitesimal is None                    
             from sympy import limit
             maxi = domain.max()
             if maxi.is_infinite:
                 maxi = limit(self.expr, x, maxi)
 #             elif maxi.is_infinitesimal:            
 #                 maxi = self.expr._subs(x, maxi, symbol=False)
             else:
@@ -2257,37 +2106,23 @@
             return self
         
         x, *domain = self.limits[0]
         if x.is_set:
             return self
 
         if not domain:
-            domain = x.domain
+            domain = x.domain             
             if domain.is_CartesianSpace:
                 return self
             
             if domain.is_ComplexRegion:
                 return self
         
         return self
 
-    def domain_definition(self):
-        expr, *limits = self.args
-        cond = expr.domain_definition()
-        if cond:
-            return cond
-
-        import std
-        if (_limits := std.deleteIndices(limits, lambda limit: not cond._has(limit[0]))) is not None:
-            limits = _limits
-            if not limits:
-                return cond
-        from sympy import All
-        return All(cond, *limits) 
-
 
 class Inf(INFSUPBase):
     r"""Represents unevaluated MIN operator.
     Inf[f,x]
     minimizes f with respect to x.
     """
     
@@ -2304,20 +2139,20 @@
 
     def doit(self, **hints):
         x, *domain = self.limits[0]        
         if len(self.limits) != 1 or x.is_set:
             return INFSUPBase.doit(self, **hints)
         
         if len(domain) == 1:
-            [domain] = domain
+            [domain] = domain  
         elif len(domain) == 2: 
             if domain[-1].is_set: 
                 return self
             else:
-                domain = x.range(*domain)
+                domain = (Range if x.is_integer else Interval)(*domain)
         else:
             domain = x.domain
                          
         if domain.is_CartesianSpace or domain.is_ComplexRegion:
             return INFSUPBase.doit(self, **hints)
 
         if self.expr.is_infinitesimal is not None:
@@ -2361,17 +2196,14 @@
             return self.expr.infimum()
         return self
     
     @property
     def defaultValue(self):
         return S.Infinity
 
-    identity = Minima.identity
-    is_identity = Minima.is_identity
-
                 
 class Sup(INFSUPBase):
     r"""Represents unevaluated MAX operator.
     Sup[f,x]
     maximizes f with respect to x.
     """
     
@@ -2388,20 +2220,20 @@
 
     def doit(self, **hints):
         x, *domain = self.limits[0]        
         if len(self.limits) != 1 or x.is_set:
             return INFSUPBase.doit(self, **hints)
             
         if len(domain) == 1:
-            [domain] = domain
+            [domain] = domain  
         elif len(domain) == 2: 
             if domain[-1].is_set: 
                 return self
             else:
-                domain = x.range(*domain)
+                domain = (Range if x.is_integer else Interval)(*domain)
         else:
             domain = x.domain
             
         if domain.is_CartesianSpace or domain.is_ComplexRegion:
             return INFSUPBase.doit(self, **hints)
 
         if self.expr.is_infinitesimal is not None:
@@ -2413,15 +2245,15 @@
         if p is not None:
             if p.degree() == 1: 
                 a = p.coeff_monomial(x)       
                 b = p.nth(0)         
                 if a.is_extended_positive:
                     return a * domain.max() + b
                 elif a.is_extended_negative:
-                    return a * domain.min() + b
+                    return a * domain.min() + b                        
             elif p.degree() == 0:
                 return p.nth(0)
             elif p.degree() < 0:
                 return self.expr
         elif self.expr.is_MinMaxBase:
             return self.expr.func(*(self.func(arg, *self.limits).doit() for arg in self.expr.args))
         return self
@@ -2449,16 +2281,14 @@
             if self.expr.supremum().is_extended_negative:
                 return True
 
     @property
     def defaultValue(self):
         return S.NegativeInfinity
 
-    identity = Maxima.identity
-    is_identity = Maxima.is_identity
 
 Sup.reversed_type = Inf
 Inf.reversed_type = Sup
 
 
 class Lamda(ExprWithLimits):
     r"""Represents unevaluated Lamda operator.
@@ -2475,15 +2305,15 @@
 
         for i, limit in enumerate(symbols):
             if isinstance(limit, tuple) and len(limit) > 1:
                 x, *domain = limit
                 if 'domain' in x._assumptions:
 #                     local variable
                     if len(domain) == 2:
-                        if x.domain == x.range(*domain):
+                        if x.domain == (Range if x.is_integer else Interval)(*domain):
                             symbols[i] = (x,)
                             continue
                     _x = Symbol(x.name, integer=True)
                     symbols[i] = (_x, *domain)
 
                     function = function._subs(x, _x)
                 if len(domain) == 1:
@@ -2526,15 +2356,15 @@
         return 1, self
 
     def squeeze(self):
         if not self.expr._has(self.variables[-1]):
             limits = self.limits[:-1]
             if limits:
                 return self.func(self.expr, *limits).squeeze()
-            return self.expr
+            return self.expr            
         return self
     
     @classmethod
     def simplify_Equal(cls, self, lhs, rhs):
         """
         precondition: self.lhs is a Lamda object!
         """
@@ -2575,20 +2405,15 @@
                 if a == b:
                     function = self.expr._subs(x, a)                    
                     limits = [*self.limits]
                     del limits[i]
                     if limits:
                         return self.func(function, *limits).simplify(squeeze=squeeze)
                     return function
-                if a.is_zero:
-                    if b.is_infinite:
-                        limits = [*self.limits]
-                        limits[i] = (x,)
-                        return self.func(self.expr, *limits).simplify(squeeze=squeeze)
-                else: 
+                if not a.is_zero: 
                     function = self.expr._subs(x, x + a)
                     limits = [*self.limits]
                     limits[i] = (x, 0, b - a)
                     return self.func(function, *limits).simplify(squeeze=squeeze)
         
         if len(self.limits) > 1:
             this = self.func(self.expr, self.limits[0])
@@ -2650,15 +2475,15 @@
                 for v in variables_set:
                     if not index._has(v):
                         continue
                     _v = Dummy(domain=v.domain_assumed, **v.type.dict)
                     _index = index._subs(v, _v)
                     if _index == index:
 # if the substitution fails, it means that index has v only in its domain, not in its definition or explicit expression, 
-# like i = Symbol(domain = Interval(j, oo)), where i has j, but only in its domain, not in its definition
+# like i = Symbol(domain = Interval(j, oo)), where i has j, but only in its domain, not in its definition                        
                         continue
                     index = _index
                     reps[_v] = v
                     assert not index._has(v)
                     
                 expr = expr._subs(x, index)  # .simplify() will result in prolonged process
                 if not index._has(x): 
@@ -2749,21 +2574,15 @@
                 
         elif len(ab) == 2:
             start, stop = ab
             if start != 0:
                 expr = expr._subs(x, start + x)
         
         if x != indices:
-            indices = sympify(indices)
-            for i, (k, *ab) in enumerate(limits):
-                if indices._has(k):
-                    k_ = expr.generate_var(integer=True, excludes=self.variables_set)
-                    expr = expr._subs(k, k_)
-                    limits[i] = (k_, *ab)
-
+            indices = sympify(indices)    
             expr = expr._subs(x, indices)
             if not indices._has(x) and expr._has(x):
                 for var in postorder_traversal(expr):
                     if var._has(x):
                         break
                 expr = expr._subs(var, var.definition)
                 expr = expr._subs(x, indices)
@@ -2799,15 +2618,15 @@
     def is_square(self):
         return self.rows == self.cols
 
     def inverse(self):
         from sympy.matrices.expressions.inverse import Inverse
         return Inverse(self)
 
-    def _eval_determinant(self, **kwargs):
+    def _eval_determinant(self):
         from sympy.concrete.products import Product
         if not self.is_square:
             return
         if self.is_upper or self.is_lower:
             i, *domain = self.limits[0]
             if len(domain) == 2:
                 a, b = domain
@@ -2815,18 +2634,15 @@
                 if not domain:
                     domain = i.domain
                 elif len(domain) == 1:
                     domain = domain[0]
                 assert domain.is_Range
                 a, b = domain.min(), domain.max() + 1
 
-            prod = Product[i:a:b](self[i, i])
-            if kwargs.get('deep'):
-                prod = prod.doit(**kwargs)
-            return prod
+            return Product[i:a:b](self[i, i]).doit()
 
     @property
     def is_lower(self):
         """Check if matrix is a lower triangular matrix. True can be returned
         even if the matrix is not square.
 
         Examples
@@ -2928,22 +2744,17 @@
         i = self.generate_var(domain=Range(self.rows))
         j = i.generate_var(domain=Range(i))
         if self[i, j].is_zero:
             return True
 
     def _latex(self, p):
         args = []
-        expr, *limits = self.args
-        for limit in limits:
+        for limit in self.limits:
             if len(limit) == 1:
-                k, = limit
-                if len(limits) == 1 and expr == k:
-                    return r'\left[*\mathbb{N}\right]'
-
-                args.append(p._print(k))
+                args.append(p._print(limit[0]))
             elif len(limit) == 2:
                 var, domain = limit
                 if domain.step == 1:
                     if domain.start == 0:
                         parmas = [var, domain.stop]
                     else:
                         parmas = [var, domain.start, domain.stop]
@@ -2958,29 +2769,29 @@
                     args.append(r"%s:%s" % (p._print(limit[0]), p._print(limit[2])))
                 else:
                     args.append(r"%s:%s:%s" % (p._print(limit[0]), p._print(limit[1]), p._print(limit[2])))
 
         tex = r"[%s]" % ','.join(args)
 
         from sympy import MatMul
-        if isinstance(expr, (Add, Mul, MatMul)):
-            tex += r"\left(%s\right)" % p._print(expr)
+        if isinstance(self.expr, (Add, Mul, MatMul)):
+            tex += r"\left(%s\right)" % p._print(self.expr)
         else:
-            tex += p._print(expr)
+            tex += p._print(self.expr)
 
         return tex
 
     def _sympystr(self, p):
-        limits = ', '.join([limit._format_ineq(p) for limit in self.limits])
-        return 'Lamda[%s](%s)' % (limits, p._print(self.expr))
+        limits = ','.join([limit._format_ineq(p) for limit in self.limits])
+        return '[%s](%s)' % (limits, p._print(self.expr))
 
     def _eval_is_finite(self):
         expr = self.expr
         for x, domain in self.limits_dict.items():
-            if not isinstance(domain, list) and not domain.is_bool:
+            if not isinstance(domain, list):
                 _x = x.copy(domain=domain)
                 expr = expr._subs(x, _x)
         return expr.is_finite
 
     def _eval_is_extended_integer(self):
         return self.expr.is_extended_integer
     
@@ -3013,23 +2824,23 @@
     def _eval_is_extended_complex(self):
         return self.expr.is_extended_complex
 
     def _eval_is_hyper_complex(self):
         return self.expr.is_hyper_complex
     
     def _eval_is_extended_positive(self):
-        expr = self.expr
+        expr = self.expr                
         for x, domain in self.limits_dict.items():
             if not isinstance(domain, list):
                 _x = x.copy(domain=domain)
                 expr = expr._subs(x, _x)
         return expr.is_extended_positive
 
     def _eval_is_extended_negative(self):
-        expr = self.expr
+        expr = self.expr                
         for x, domain in self.limits_dict.items():
             if not isinstance(domain, list):
                 _x = x.copy(domain=domain)
                 expr = expr._subs(x, _x)
         return expr.is_extended_negative
     
     def _eval_transpose(self, axis=-1):
@@ -3049,15 +2860,15 @@
                             if len(indices) == 1:
                                 [index] = indices
                                 if index == var:
                                     slices = [slice(*s) for s in slices]
                                     slices.append(slice(size))
                                     return expr.base[tuple(slices)]
                     
-                return
+                return 
 
         if axis < len(self.limits):
             [*limits] = self.limits
             limits[axis], limits[axis - 1] = limits[axis - 1], limits[axis] 
             return self.func(self.expr, *limits).simplify()
 
     def generate_int_limit(self, index=-1, excludes=None, generator=None, var=None):
@@ -3127,29 +2938,28 @@
         if tensor is not None:
             sizes = [1] * (len(tensor.shape) + 1)
             sizes[axis] = size
             return torch.tile(torch.unsqueeze(tensor.torch, axis), sizes)
         
         inputs, W, bias, stride, padding, dilation = self.of_conv1d()
         if inputs is not None:
-#             https://numpy.org/doc/stable/reference/generated/numpy.convolve.html
-#             https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.convolve.html
             return torch.nn.functional.conv1d(
                 inputs.torch.transpose(1, 2), 
                 W.torch.transpose(0, 2), 
                 bias.torch, 
                 stride,
                 padding, 
                 dilation, 1).transpose(1, 2)
                         
         shape = [s if isinstance(s, int) else s.torch for s in self.shape]
-        network = self.expr.compile(*self.variables)
         import itertools
-        network.prepare(torch=True)
-        results = [network(*indices, torch=True) for indices in itertools.product(*(range(size) for size in shape[:len(self.limits)]))]
+        results = []
+        for indices in itertools.product(*(range(size) for size in shape[:len(self.limits)])):
+            results.append(self[indices].torch)
+        
         import torch
         return torch.stack(results).reshape(shape)
     
     @cacheit
     def of_embedding(self):
         try:
             expr = self.expr
@@ -3160,14 +2970,15 @@
         except:
             ...
 
         return None, None
         
     @cacheit
     def of_conv1d(self):
+        from sympy.core.singleton import S
         from sympy.concrete.summations import Sum
         from sympy.core.containers import Tuple
         from sympy.core.symbol import Symbol
         from sympy.functions.elementary.integers import Floor
         
         try:
             expr, (i, S[0], N_seq_length), (k, S[0], N_batch_size) = self.args
@@ -3326,29 +3137,9 @@
                     
             else:
                 raise
     
             return tensor, axis, size
         except:
             return None, None, None
-
-    def limits_in_context(self, has_args=None, parent=None):
-        if has_args:
-            return [*self.limits]
-        from sympy import oo
-        limits = []
-        for limit in self.limits:
-            x, *ab = limit
-            if not ab:
-                domain = self.expr.domain_defined(x)                     
-                domain &= Range(0, oo)
-                limit = (x, domain)
-            limits.append(limit)
-        limits.reverse()
-        
-        return limits
     
-    @classmethod
-    def is_identity(cls, expr):
-        ... 
-
 from sympy.concrete.limits import *
```

### Comparing `sympy.keras-1.0.21/sympy/concrete/forall.py` & `sympy.keras-1.0.4/sympy/concrete/forall.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,13 +1,13 @@
 from sympy.logic.boolalg import Boolean, And, Or
 from sympy.concrete.expr_with_limits import ExprWithLimits
 from sympy.concrete.conditional_boolean import Quantifier
 from sympy.core.sympify import sympify
 from sympy.core.relational import Equal
-from sympy.core.singleton import S
+
 
 class ForAll(Quantifier):
     """
     All[p] q <=> !p | q
     """
     
     operator = And
@@ -46,16 +46,17 @@
             if len(ab) == 1:
                 domain = ab[0]
             else:
                 a, b = ab
                 if b.is_set:
                     domain = b & old.domain_conditioned(a)
                 else:
-                    domain = wrt.range(a, b)
-
+                    from sympy import Range
+                    domain = (Range if wrt.is_integer else Interval)(a, b)
+                            
             eqs = []
             if not domain.is_set:
                 domain = old.domain_conditioned(domain)
 
             from sympy.sets.contains import NotElement
             limit_cond = NotElement(new, domain).simplify()
             eqs.append(limit_cond)
@@ -87,15 +88,16 @@
                 continue
             if len(ab) == 1:
                 domain = ab[0]
             else:
                 a, b = ab
                 if b.is_set:
                     continue
-                domain = x.range(a, b)
+                from sympy import Range
+                domain = (Range if x.is_integer else Interval)(a, b)
                 
             if self.expr._has(x) and domain.is_set:
                 _eval_domain_defined = self.expr.domain_defined(x)
                 if _eval_domain_defined in domain:
                     deletes.append(x)
                 domain &= _eval_domain_defined
                 if domain.is_FiniteSet:
@@ -259,21 +261,13 @@
     def reduced_cond(self, x, cond, baseset=None):
         if baseset:
             return self.func.invert_type[x:baseset](cond.invert())
         if cond.is_set:
             return Equal(cond, x.emptySet)
         return self.func.invert_type[x](cond.invert())
     
-    @classmethod
-    def identity(cls, self, **kwargs):
-        return S.true.copy(**kwargs)
-
-    @classmethod
-    def is_identity(cls, self):        
-        return self.is_BooleanTrue
-
     latexname = 'forall'
 
 
 from sympy.concrete.limits import *
 
 All = ForAll
```

### Comparing `sympy.keras-1.0.21/sympy/concrete/gosper.py` & `sympy.keras-1.0.4/sympy/concrete/gosper.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/concrete/guess.py` & `sympy.keras-1.0.4/sympy/concrete/guess.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/concrete/limits.py` & `sympy.keras-1.0.4/sympy/concrete/limits.py`

 * *Files 0% similar despite different names*

```diff
@@ -267,17 +267,17 @@
 x = !!x
 
 11:
 Any[p] f = p & f
 12:
 All[p] f = !q | f
 13:
-x & !x = false
+x & !x = false  
 14:
-true = !false
+true = !false 
 
 lemma:
 1:
 x => x | y
 from x = x | x & y = (x | y) & x
 2:
 if x => y, then y & x = x
@@ -300,15 +300,15 @@
 from definition
 5:
 Any[p] All[q] f => All[q] Any[p] f
 
 prove:
 Any[p] All[q] f = (!q | f) & p = = !q & p | f & p = (!q | f & p) & (p | f & p)
 All[q] Any[p] f = !q | (f & p)
-and
+and 
 (!q | f & p) & (p | f & p) => !q | (f & p)
 
 6:
 x => x
 x = x & x => x
 
 7:
```

### Comparing `sympy.keras-1.0.21/sympy/concrete/products.py` & `sympy.keras-1.0.4/sympy/concrete/products.py`

 * *Files 2% similar despite different names*

```diff
@@ -233,15 +233,15 @@
         for index, limit in enumerate(self.limits):
             if len(limit) == 1:
                 i = limit[0]
                 domain = self.expr.domain_defined(i)
                 if domain.is_Range: 
                     a, b = domain.start, domain.stop
                 else:
-                    return self
+                    return self 
             else:
                 i, a, b = limit
                 
             dif = b - a
             if dif.is_Integer and dif < 0:
                 a, b = b + 1, a - 1
                 f = 1 / f
@@ -251,15 +251,15 @@
                 if index < len(self.limits) - 1:
                     i, a, b = self.limits[-1]
                     dif = b - a
                     if dif.is_Integer:
                         limits = self.limits[index:-1]
                         args = []
                         for index in range(dif):
-                            _i = a + index
+                            _i = a + index                            
                             args.append(self.func(f._subs(i, _i), *[limit._subs(i, _i) for limit in limits]).simplify())
                             
                         return self.operator(*args)
                 if index == 0:
                     return self.simplify()
                 
                 return self.func(powsimp(f), *self.limits[index:]).simplify()
@@ -368,51 +368,51 @@
         return product_simplify(self)
 
     def _eval_transpose(self, axis=-1):
         if axis == self.default_axis: 
             return self.func(self.expr.transpose(), *self.limits)        
 
     def _eval_is_finite(self):
-        function = self.expr
+        function = self.expr                
         for x, domain in self.limits_dict.items():
-            if not isinstance(domain, list) and not domain.is_bool:
+            if not isinstance(domain, list):
                 if domain.is_infinite:
                     return None
                     
                 _x = x.copy(domain=domain)
                 function = function._subs(x, _x)
         return function.is_finite
 
     def _eval_is_extended_real(self):
-        function = self.expr
+        function = self.expr                
         for x, domain in self.limits_dict.items():
             if not isinstance(domain, list):
                 _x = x.copy(domain=domain)
                 if _x != x:
                     function = function._subs(x, _x)
                 
         return function.is_extended_real
 
     def _eval_is_extended_positive(self):
-        function = self.expr
+        function = self.expr                
         for x, domain in self.limits_dict.items():
             if not isinstance(domain, list):
                 if domain.is_infinite:
                     return
                     
                 _x = x.copy(domain=domain)
                 function = function._subs(x, _x)
         return function.is_extended_positive
 
     def _eval_is_extended_negative(self):
-        function = self.expr
+        function = self.expr                
         for x, domain in self.limits_dict.items():
             if not isinstance(domain, list):
                 if domain.is_infinite:
-                    return
+                    return 
                     
                 _x = x.copy(domain=domain)
                 function = function._subs(x, _x)
         return function.is_extended_negative
 
     def is_convergent(self):
         r"""
@@ -576,23 +576,23 @@
                 x, a, b = limit
                 if not function._has(x):
                     return function ** (b - a)
                 
                 if a == b - 1: 
                     return function._subs(x, a).simplify(deep=deep)
                 if a >= b:
-                    return S.One
+                    return S.One            
             return self
         
         limit = self.limits[0]
         if len(limit) == 1:
             x = limit[0]
             domain = x.domain
             if domain.is_Range: 
-                limit = x, domain.start, domain.stop
+                limit = x, domain.start, domain.stop 
 
         if len(limit) == 2:
             x, domain = limit
             if domain.is_FiniteSet and len(domain) == 1:
                 return self.finite_aggregate(x, domain)
             if not self.expr._has(x):
                 from sympy import Card
@@ -605,23 +605,15 @@
                 return self.expr.as_multiple_terms(x, Range(a, b), self.func)
             if not self.expr._has(x):
                 return self.expr ** (b - a)
             
             if self.expr.is_Mul:
                 if len(self.expr.args) == 2:
                     fx1, fx = self.expr.args
-                    if fx1.is_Pow and fx1.exp == -1:
-                        fx1, fx = fx, fx1
-                        hit = True    
-                    elif fx.is_Pow and fx.exp == -1:
-                        hit = True
-                    else:
-                        hit = False
-                        
-                    if hit:
+                    if fx.is_Pow and fx.exp == -1:
                         fx = 1 / fx
                         from sympy import Wild
                         pattern = fx.subs(x, Wild(x.name, **x.assumptions0))
 
                         res = fx1.match(pattern)
                         if res:
                             x_, *_ = res.values()
@@ -629,15 +621,19 @@
                                 return fx1._subs(x, b - 1) / fx._subs(x, a)
             if a == b - 1: 
                 return self.expr._subs(x, a)
             if a >= b:
                 return S.One
         else:
             x, *_ = limit
+        import sympy
         function = self.expr
+        if isinstance(function, sympy.exp):
+            function = function.as_Mul()
+
         independent, dependent = function.as_independent(x, as_Add=False)
         if independent == S.One:
             return self
 
         if dependent == S.One:
             if len(limit) > 1:
                 return self.expr ** (b - a)
@@ -672,22 +668,15 @@
             return self.operator(self.func(first, *self.limits), self.func(second, *self.limits))
         return self
 
     @classmethod
     def identity(cls, self, **_):
         from sympy import OneMatrix
         return OneMatrix(*self.shape)
-
-    @classmethod
-    def is_identity(cls, self, **_):
-        if self.shape:
-            return self.is_OneMatrix
-        return self.is_One
-
-
+        
 class MatProduct(ExprWithIntLimits, MatrixExpr):
     r"""Represents unevaluated products of matrices.
 
     ``MatProduct`` represents a finite or infinite product, with the first
     argument being the general form of terms in the series, and the second
     argument being ``(dummy_variable, start, end)``, with ``dummy_variable``
     taking all integer values from ``start`` through ``end``. In accordance
@@ -1007,15 +996,15 @@
                 x, a, b = limit
                 if not function._has(x):
                     return function ^ (b - a)
                 
                 if a == b - 1:
                     return function._subs(x, a).simplify(deep=deep)
                 if a >= b:
-                    return S.One
+                    return S.One            
             return self
         
         limit = self.limits[0]
         if len(limit) == 2:
             x, domain = limit
             if domain.is_FiniteSet and len(domain) == 1:
                 return self.finite_aggregate(x, domain)
@@ -1030,15 +1019,19 @@
             if a == b - 1:
                 return self.expr._subs(x, a)
             from sympy import Identity
             if a >= b:
                 return Identity(self.shape[0])
         else:
             x, *_ = limit
+        import sympy
         function = self.expr
+        if isinstance(function, sympy.exp):
+            function = function.as_Mul()
+
         independent, dependent = function.as_independent(x, as_Add=False)
         if independent == S.One:
             return self
 
         if dependent == S.One:
             if len(limit) > 1:
                 return self.expr ^ (b - a)
@@ -1086,15 +1079,15 @@
                             if stop is None:
                                 stop = self.shape[1]
                             
                             if start == 0 and stop == self.shape[1]:
                                 return self
                             
                         if len(self.limits) > 1:
-                            return
+                            return 
                         limit = self.limits[0]
                         x, a, b = limit
                         if a < b:
                             return self.func[x:a:b - 1](self.expr) @ self.expr._subs(x, b - 1)[:, j]
                         else:
                             return
                 start = 0
@@ -1254,19 +1247,14 @@
         return self
 
     @classmethod
     def identity(cls, self, **_):
         from sympy import Identity
         return Identity(self.shape[-1])
 
-    @classmethod
-    def is_identity(cls, self, **_):
-        return self.is_Identity
-
-
 def product(*args, **kwargs):
     r"""
     Compute the product.
 
     The notation for symbols is similar to the notation used in Sum or
     Integral. product(f, (i, a, b)) computes the product of f with
     respect to i from a to b, i.e.,
```

### Comparing `sympy.keras-1.0.21/sympy/concrete/reduced.py` & `sympy.keras-1.0.4/sympy/concrete/reduced.py`

 * *Files 1% similar despite different names*

```diff
@@ -2,38 +2,15 @@
 from sympy.concrete.summations import Sum
 from sympy.core.cache import cacheit
 
 
 class Reduced(Function):
     is_elementwise = False
 
-    def _subs(self, old, new, **hints):
-        #need to consider the shape reduction, if the shape is reduced, then reduced operator should be removed!
-        if old == new:
-            return self
-
-        if old.is_Sliced:
-            this = self._subs_sliced(old, new, **hints)
-            if this != self:
-                return this
-        
-        from sympy.core.basic import _aresame
-        if _aresame(self, old) or self.dummy_eq(old):
-            return new
-
-        arg = self.arg._subs(old, new, **hints)
-        if not _aresame(arg, self.arg):
-            if len(arg.shape) < len(self.arg.shape):
-                return arg
-
-            return self.func(arg)
-
-        return self
-
-
+    
 class ReducedSum(Reduced):
     r"""Represents unevaluated reduced summation.
     input must be a multi-dimensional tensor
     """
     is_complex = True
     
     def _eval_is_zero(self):
@@ -56,31 +33,30 @@
 
         if f.is_FiniteSet:
             x, *args = f.args
             rest = f.func(*args)
             from sympy import NotElement, Bool
             sgm = x * Bool(NotElement(x, rest).simplify()).simplify()
             if not rest:
-                return sgm
+                return sgm             
             return self.func(rest).doit(deep=deep) + sgm
         else:
             return self
         return f
 
     @cacheit
     def _eval_shape(self):
         return self.arg.shape[:-1]
 
     @property
     def dtype(self):
         return self.arg.dtype
 
     def _sympystr(self, p):
-        # return '\N{N-ARY SUMMATION}(%s)' % p._print(self.arg)
-        return 'ReducedSum(%s)' % p._print(self.arg)
+        return '\N{N-ARY SUMMATION}(%s)' % p._print(self.arg)
 
     def _latex(self, p, exp=None):
         expr = p._print(self.arg)
         if self.arg.is_Add or self.arg.is_MatMul:
             expr = r"\left(%s\right)" % expr
         expr = r"\sum{%s}" % expr
         if exp is None:
@@ -135,15 +111,15 @@
                     coeff.append(arg)
                                 
             if coeff:
                 coeff = self.arg.func(*coeff)
                 function = self.arg.func(*args)
                 return coeff * self.func(function)
         return self
-    
+
 
 class ReducedMean(Reduced):
     r"""Represents unevaluated reduced mean.
     input must be a multi-dimensional tensor
     """
     is_complex = True
     
@@ -167,15 +143,15 @@
 
         if f.is_FiniteSet:
             x, *args = f.args
             rest = f.func(*args)
             from sympy import NotElement, Bool
             sgm = x * Bool(NotElement(x, rest).simplify()).simplify()
             if not rest:
-                return sgm
+                return sgm             
             return self.func(rest).doit(deep=deep) + sgm
         else:
             return self
         return f
 
     @cacheit
     def _eval_shape(self):
@@ -273,15 +249,15 @@
 
         if f.is_FiniteSet:
             x, *args = f.args
             rest = f.func(*args)
             from sympy import NotElement, Bool
             sgm = x * Bool(NotElement(x, rest).simplify()).simplify()
             if not rest:
-                return sgm
+                return sgm             
             return self.func(rest).doit(deep=deep) + sgm
         else:
             return self
         return f
 
     @cacheit
     def _eval_shape(self):
@@ -384,15 +360,15 @@
 
         if f.is_FiniteSet:
             x, *args = f.args
             rest = f.func(*args)
             from sympy import NotElement, Bool
             sgm = x * Bool(NotElement(x, rest).simplify()).simplify()
             if not rest:
-                return sgm
+                return sgm             
             return self.func(rest).doit(deep=deep) + sgm
         else:
             return self
         return f
 
     @cacheit
     def _eval_shape(self):
@@ -538,9 +514,8 @@
     
 class ReducedArgMin(ReducedArgMinMaxBase):
     r"""Represents unevaluated reduced ArgMin.
     input must be a multi-dimensional tensor
     """
     
     def _eval_torch(self):
-        return self.arg.torch.argmin(-1)
-    
+        return self.arg.torch.argmin(-1)
```

### Comparing `sympy.keras-1.0.21/sympy/concrete/sets.py` & `sympy.keras-1.0.4/sympy/concrete/sets.py`

 * *Files 2% similar despite different names*

```diff
@@ -66,23 +66,23 @@
     def handle_finite_sets(self, unk):
         if self.is_ConditionSet:
             return conditionset(self.variable, self.condition, self.base_set & unk)            
         else:
             match_index = self.match_index(unk)
             if match_index is not None:
                 if match_index in self.limits_dict[self.variable]:
-                    return unk
+                    return unk            
             
     def intersection_sets(self, b):
         if self.is_ConditionSet:
             if b.is_ConditionSet and self.variable == b.variable:
                 return conditionset(self.variable, self.condition & b.condition, self.base_set & b.base_set)
             base_set = self.variable.domain & self.base_set
             if base_set in b:
-                return self
+                return self                
             return conditionset(self.variable, self.condition, self.base_set & b)
     
     @property
     def condition(self):
         if self.is_ConditionSet:
             return self.limits[0][1]
         
@@ -381,16 +381,16 @@
 
     def _sympystr(self, p):
         if self.is_ConditionSet: 
             return 'ConditionSet(%s)' % ', '.join(p.doprint(arg) for arg in self.limits[0])
         
         limits = ','.join([limit._format_ineq(p) for limit in self.limits])
         if limits:
-            return 'Cup[%s](%s)' % (limits, p.doprint(self.expr))
-        return 'Cup(%s)' % p.doprint(self.expr)
+            return '[%s](%s)' % (limits, p.doprint(self.expr))
+        return '(%s)' % p.doprint(self.expr)
 
     def int_limit(self):
         if len(self.limits) == 1:
             limit = self.limits[0]
             if len(limit) == 3 and not limit[2].is_set:
                 return limit
 
@@ -399,17 +399,19 @@
             limit = self.limits[0]
             if len(limit) == 2:
                 return limit
             if len(limit) == 3: 
                 x, a, b = limit
                 if a.is_bool:
                     return x, conditionset(x, a, b)
-                return x, x.range(a, b) 
+                is_integer = limit[0].is_integer                 
+                return x, (Range if is_integer else Interval)(a, b) 
             else:
-                x, = limit
+#                 assert len(limit) == 1
+                x = limit[0]
                 return x, x.universalSet
 
     def image_set(self):
         function = self.expr
         if isinstance(function, FiniteSet) and len(function) == 1:
             condition_limit = self.condition_limit()
             if condition_limit is not None:
@@ -419,15 +421,15 @@
 
     def finite_set(self):
         function = self.expr
         limit = self.int_limit()
         if limit is None:
             return
 
-        x, a, b = limit
+        x, a, b = limit        
         if isinstance(function, FiniteSet):
             if len(function) == 1:
                 expr, *_ = function
                 if isinstance(expr, Indexed):
                     if len(expr.indices) == 1:
                         base = expr.base
                     else:
@@ -506,15 +508,15 @@
 
         return tex
     
     def _complement(self, universe):
         # DeMorgan's Law
         if self.is_ConditionSet:
             if self.base_set == universe:
-                return ~self
+                return ~self   
             if universe.is_ConditionSet:
                 if self.variable == universe.variable and universe.base_set == self.base_set:
                     return conditionset(self.variable, universe.condition & self.condition.invert(), self.base_set)                    
 
     def __invert__(self):
         assert self.is_ConditionSet
         condition = self.condition.invert()
@@ -602,15 +604,15 @@
             return b
 
         return Union(*map(boundary_of_set, range(len(self.args))))
 
     def as_relational(self, symbol):
         """Rewrite a Union in terms of equalities and logic operators. """
         if len(self.args) == 2:
-            a, b = self.args
+            a, b = self.args            
             if (a.sup == b.inf and a.inf is S.NegativeInfinity
                     and b.sup is S.Infinity):
                 from sympy.core.relational import Ne
                 return And(Ne(symbol, a.sup), symbol < b.sup, symbol > a.inf)        
         return Or(*[set.as_relational(symbol) for set in self.args])
 
     @property
@@ -659,110 +661,110 @@
             ...
 
     def min(self): 
         m = Minima(self.expr.min(), *self.limits)
         m_ = m.doit()
         if m_ is not m:
             m = m_
-        return m
+        return m        
 
     def max(self):
         m = Maxima(self.expr.min(), *self.limits)
         m_ = m.doit()
         if m_ is not m:
             m = m_
         return m
 
     def _eval_is_extended_integer(self):
-        function = self.expr
+        function = self.expr                
         for x, domain in self.limits_dict.items():
             if not isinstance(domain, list):
                 _x = x.copy(domain=domain)
                 function = function._subs(x, _x)
         return function.is_extended_integer
     
     def _eval_is_super_integer(self):
         return self.expr_within_context.is_super_integer
     
     def _eval_is_extended_rational(self):
-        expr = self.expr
+        expr = self.expr                
         for x, domain in self.limits_dict.items():
             if not isinstance(domain, list):
                 _x = x.copy(domain=domain)
                 expr = expr._subs(x, _x)
         return expr.is_extended_rational
     
     def _eval_is_hyper_rational(self):
-        expr = self.expr
+        expr = self.expr                
         for x, domain in self.limits_dict.items():
             if not isinstance(domain, list):
                 _x = x.copy(domain=domain)
                 expr = expr._subs(x, _x)
         return expr.is_hyper_rational
     
     def _eval_is_super_rational(self):
-        expr = self.expr
+        expr = self.expr                
         for x, domain in self.limits_dict.items():
             if not isinstance(domain, list):
                 _x = x.copy(domain=domain)
                 expr = expr._subs(x, _x)
         return expr.is_super_rational
     
     def _eval_is_extended_real(self):
-        expr = self.expr
+        expr = self.expr                
         for x, domain in self.limits_dict.items():
             if not isinstance(domain, list):
                 _x = x.copy(domain=domain)
                 expr = expr._subs(x, _x)
         return expr.is_extended_real
     
     def _eval_is_hyper_real(self):
-        expr = self.expr
+        expr = self.expr                
         for x, domain in self.limits_dict.items():
             if not isinstance(domain, list):
                 _x = x.copy(domain=domain)
                 expr = expr._subs(x, _x)
         return expr.is_hyper_real
     
     def _eval_is_super_real(self):
-        expr = self.expr
+        expr = self.expr                
         for x, domain in self.limits_dict.items():
             if not isinstance(domain, list):
                 _x = x.copy(domain=domain)
                 expr = expr._subs(x, _x)
         return expr.is_super_real
     
     def _eval_is_extended_complex(self):
-        expr = self.expr
+        expr = self.expr                
         for x, domain in self.limits_dict.items():
             if not isinstance(domain, list):
                 _x = x.copy(domain=domain)
                 expr = expr._subs(x, _x)
         return expr.is_extended_complex
     
     def _eval_is_hyper_complex(self):
         expr = self.expr
         for x, domain in self.limits_dict.items():
             if not isinstance(domain, list):
                 _x = x.copy(domain=domain)
                 expr = expr._subs(x, _x)
         return expr.is_hyper_complex
     
-    def _eval_is_finiteset(self):
-        if self.expr.is_finiteset is None:
-            return
+    
+    def _eval_is_finite(self):
+        if self.expr.is_finite is not None:
+            return self.expr.is_finite
 
-        expr = self.expr
+        expr = self.expr                
         for x, domain in self.limits_dict.items():
-            if not isinstance(domain, list) and not domain.is_bool:
-                if domain.is_infiniteset:
-                    return
+            if not isinstance(domain, list):
                 _x = x.copy(domain=domain, **x.assumptions0)
+                assert _x.type == x.type
                 expr = expr._subs(x, _x)
-        return expr.is_finiteset
+        return expr.is_finite
 
     def __add__(self, other):
         if other.has(*self.variables) or other.is_set:
             raise Exception("could not add %s, %s" % (self, other))
         
         if self.is_ConditionSet:
             cond = self.condition
@@ -830,18 +832,14 @@
                             if fx._subs(x, _x) == _fx:
                                 return S.true
 
     @classmethod
     def identity(cls, self, **_):
         return self.etype.emptySet
 
-    @classmethod
-    def is_identity(cls, self, **_):
-        return self.is_EmptySet
-
     @property
     def is_range_stepped(self):
         expr = self.expr
         if expr.is_FiniteSet:
             limits = self.limits
             if len(limits) == 1 and len(expr) == 1:
                 [(i, *ab)] = limits
@@ -888,19 +886,14 @@
                 if b is None:
                     b = _b
                     
                 if b != _b:
                     return
             return b
 
-    @classmethod
-    def class_key(cls):
-        """Nice order of classes. """
-        return 6, 2, cls.__name__
-
     
 class Cap(Set, ExprWithLimits):
     """
     Represents an intersection of sets as a :class:`Set`.
 
     """
     operator = Intersection
@@ -1038,94 +1031,88 @@
     precondition: this set should not be empty!
     """
 
     def max(self):
         return Minima(self.expr.max(), *self.limits)
 
     # finiteness of intersection set is hard to evaluate
-    def _eval_is_finiteset(self):
-        if self.expr.is_finiteset is None:
-            return
-        
-        if self.expr.is_finiteset == True:
-            return True
-
-        function = self.expr
+    def _eval_is_finite(self):
+        function = self.expr                
         for x, domain in self.limits_dict.items():
-            if not isinstance(domain, list) and not domain.is_bool:
+            if not isinstance(domain, list):
                 _x = x.copy(domain=domain)
                 function = function._subs(x, _x)
-        return function.is_finiteset
+        return function.is_finite
 
     def _eval_is_extended_integer(self):
-        function = self.expr
+        function = self.expr                
         for x, domain in self.limits_dict.items():
             if not isinstance(domain, list):
                 _x = x.copy(domain=domain)
                 function = function._subs(x, _x)
         return function.is_extended_integer
     
     def _eval_is_super_integer(self):
-        function = self.expr
+        function = self.expr                
         for x, domain in self.limits_dict.items():
             if not isinstance(domain, list):
                 _x = x.copy(domain=domain)
                 function = function._subs(x, _x)
         return function.is_super_integer
     
     def _eval_is_extended_rational(self):
-        function = self.expr
+        function = self.expr                
         for x, domain in self.limits_dict.items():
             if not isinstance(domain, list):
                 _x = x.copy(domain=domain)
                 function = function._subs(x, _x)
         return function.is_extended_rational
     
     def _eval_is_hyper_rational(self):
-        function = self.expr
+        function = self.expr                
         for x, domain in self.limits_dict.items():
             if not isinstance(domain, list):
                 _x = x.copy(domain=domain)
                 function = function._subs(x, _x)
         return function.is_hyper_rational
     
     def _eval_is_super_rational(self):
-        function = self.expr
+        function = self.expr                
         for x, domain in self.limits_dict.items():
             if not isinstance(domain, list):
                 _x = x.copy(domain=domain)
                 function = function._subs(x, _x)
         return function.is_super_rational
     
     def _eval_is_extended_real(self):
-        function = self.expr
+        function = self.expr                
         for x, domain in self.limits_dict.items():
             if not isinstance(domain, list):
                 _x = x.copy(domain=domain)
                 function = function._subs(x, _x)
         return function.is_extended_real
     
     def _eval_is_hyper_real(self):
-        function = self.expr
+        function = self.expr                
         for x, domain in self.limits_dict.items():
             if not isinstance(domain, list):
                 _x = x.copy(domain=domain)
                 function = function._subs(x, _x)
         return function.is_hyper_real
     
     def _eval_is_super_real(self):
-        function = self.expr
+        function = self.expr                
         for x, domain in self.limits_dict.items():
             if not isinstance(domain, list):
                 _x = x.copy(domain=domain)
                 function = function._subs(x, _x)
         return function.is_super_real
     
     def _eval_is_extended_complex(self):
-        function = self.expr
+        function = self.expr                
         for x, domain in self.limits_dict.items():
             if not isinstance(domain, list):
                 _x = x.copy(domain=domain)
                 function = function._subs(x, _x)
         return function.is_extended_complex
     
     def _eval_is_hyper_complex(self):
@@ -1260,16 +1247,16 @@
                     i_match = dic[i_]
                     if i_match >= a and i_match <= b:
                         return self
 
     def _sympystr(self, p):
         limits = ','.join([limit._format_ineq(p) for limit in self.limits])
         if limits:
-            return 'Cap[%s](%s)' % (limits, p.doprint(self.expr))
-        return 'Cap(%s)' % p.doprint(self.expr)
+            return '[%s](%s)' % (limits, p.doprint(self.expr))
+        return '(%s)' % p.doprint(self.expr)
 
     @property
     def etype(self):
         return self.expr.etype
 
     def __add__(self, other):
         if other.has(*self.variables) or other.is_set:
@@ -1277,15 +1264,7 @@
         
         return self.func(self.expr + other, *self.limits).simplify()
 
     @classmethod
     def identity(cls, self, **_):
         return self.etype.universalSet
 
-    @classmethod
-    def is_identity(cls, self, **_):
-        return self.is_UniversalSet
-
-    @classmethod
-    def class_key(cls):
-        """Nice order of classes. """
-        return 6, 1, cls.__name__
```

#### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

### Comparing `sympy.keras-1.0.21/sympy/concrete/summations.py` & `sympy.keras-1.0.4/sympy/concrete/summations.py`

 * *Files 2% similar despite different names*

```diff
@@ -19,15 +19,14 @@
 from sympy.sets.sets import Complement, Interval, Union, FiniteSet
 from sympy.simplify import denom
 from sympy.simplify.combsimp import combsimp
 from sympy.simplify.powsimp import powsimp
 from sympy.solvers import solve
 from sympy.solvers.solveset import solveset
 import itertools
-from sympy.core.cache import cacheit
 
 
 class Sum(AddWithLimits, ExprWithIntLimits):
     r"""Represents unevaluated summation.
 
     ``Sum`` represents a finite or infinite series, with the first argument
     being the general form of terms in the series, and the second argument
@@ -151,18 +150,15 @@
             return True
         
         if self.expr.is_extended_positive or self.expr.is_extended_negative:
             return False
 
     def doit(self, **hints):
         if hints.get('deep', True):
-            try:
-                f = self.expr.doit(**hints)
-            except:
-                f = self.expr
+            f = self.expr.doit(**hints)
         else:
             f = self.expr
 
         for n, limit in enumerate(self.limits):
             if len(limit) != 3:
                 return self
             i, a, b = limit
@@ -795,22 +791,22 @@
             x, *ab = limit
 
             if ab:
                 if len(ab) == 1:
                     domain = ab[0]
                     if not old._has(x) or new._has(x):
                         _domain = domain._subs(old, new, **hints)
-                        expr = self.expr._subs(old, new, **hints)
-                        if _domain != domain or expr != self.expr: 
+                        function = self.expr._subs(old, new, **hints)
+                        if _domain != domain or function != self.expr: 
                             if x.is_Indexed or x.is_Sliced:
                                 indices = tuple(index._subs(old, new, **hints) for index in x.indices)
                                 if x.indices != indices:
                                     x = x.func(x.base, *indices)                
 
-                            return self.func(expr, (x, _domain)).simplify()
+                            return self.func(function, (x, _domain)).simplify()
                     else:
                         if domain.is_set:
                             _domain = domain._subs(old, new, **hints)
                             if _domain != domain:
                                 return self.func(self.expr, (x, _domain)).simplify()
 
                     return self
@@ -824,100 +820,106 @@
                 if assumptions:
                     for x, *ab in self.limits:
                         if old._has(x):
                             domain = assumptions.get(x)
                             if domain is False:
                                 return self
                 
-                expr = self.expr._subs(old, new, **hints).simplify()
+                function = self.expr._subs(old, new, **hints).simplify()
+
                 if ab:
-                    hit = expr != self.expr
                     if x.is_Indexed or x.is_Sliced:
                         indices = tuple(index._subs(old, new, **hints) for index in x.indices)
                         if x.indices != indices:
-                            x = x.func(x.base, *indices)
-                            hit = True                
-                    
-                    a = a._subs(old, new, **hints)
-                    b = b._subs(old, new, **hints)
-                    
-                    hit |= a != ab[0]
-                    hit |= b != ab[1]
-                    
-                    if hit:
-                        self = self.func(expr, (x, a, b)).simplify()
-                    return self
-
-                if x.is_Sliced and x.base != old:
-                    try:
-                        x = x._subs(old, new, **hints)
-                    except Exception as e:
-                        if e.args[0] == 'empty slices':
-                            return expr
-                        raise e
+                            x = x.func(x.base, *indices)                
+            
+                    return self.func(function, (x, a._subs(old, new, **hints), b._subs(old, new, **hints))).simplify()
 
-                elif x.is_Indexed and x.base != old:
+                if (x.is_Sliced or x.is_Indexed) and x.base != old:
                     x = x._subs(old, new, **hints)
-
                 domain = self.expr.domain_defined(x)
-                _domain = expr.domain_defined(x)
+                _domain = function.domain_defined(x)
                 if domain != _domain:
                     limit = (x, domain)
                 else:
                     limit = (x,)
-                return self.func(expr, limit)
+                return self.func(function, limit)
 
             if new._has(x):
                 diff = old - new
                 if old != x:
                     if diff.has(x):
                         return self
 
                     alpha = p.coeff_monomial(x)
                     diff /= alpha
 
-                expr = self.expr.subs(x, x - diff)
+                function = self.expr.subs(x, x - diff)
                 if ab:
-                    return self.func(expr, (x, a + diff, b + diff))
+                    return self.func(function, (x, a + diff, b + diff))
                 else:
-                    return self.func(expr, (x,))
+                    return self.func(function, (x,))
 
             if old != x:
                 sol = solve(old - new, x)
                 if len(sol) != 1:
                     return self
                 new = sol[0]
 
             _x = new.free_symbols - old.free_symbols
 
             if len(_x) != 1:
                 return self
             _x, *_ = _x
 
-            expr = self.expr._subs(x, new, **hints)
+            function = self.expr._subs(x, new, **hints)
 
             if ab:
                 a = solve(new - a, _x)
                 b = solve(new - b, _x)
                 if len(a) != 1 or len(b) != 1:
                     return self
                 a, b = a[0], b[0]
 
                 p = new.as_poly(_x)
                 alpha = p.coeff_monomial(_x)
                 if alpha > 0:
-                    return self.func(expr, (_x, a, b))
+                    return self.func(function, (_x, a, b))
                 elif alpha < 0:
-                    return self.func(expr, (_x, b, a))
+                    return self.func(function, (_x, b, a))
                 else:
                     return self
 
-            return self.func(expr, (_x))
+            return self.func(function, (_x))
 
-        return AddWithLimits._subs(self, old, new, **hints)
+        elif len(self.limits) == 0:
+            function = self.expr._subs(old, new, **hints)
+
+            return self.func(function, *self.limits)
+        else:
+            limits = [*self.limits]
+            hit = False
+            
+            for i, limit in enumerate(limits):
+                x, *ab = limit
+#                 p = old.as_poly(x)
+#                 if p is None:
+#                     continue
+#                 
+#                 if p.degree() == 0:
+                limits[i] = (x, *[a._subs(old, new, **hints) for a in ab])
+                hit |= limits[i] != self.limits[i] 
+            
+            function = self.expr._subs(old, new, **hints)
+            hit |= function != self.expr
+            
+            if hit:
+                return self.func(function, *limits)
+
+        return self
 
     def try_sub(self, autre):
         if isinstance(autre, Sum) and self.expr == autre.expr and len(self.limits) == len(autre.limits) == 1 and len(self.limits[0]) == len(autre.limits[0]) == 3:
             (x, a, b), *_ = self.limits
             if a.is_bool:
                 return
             (_x, _a, _b), *_ = autre.limits
@@ -964,24 +966,24 @@
                         if self.expr._subs(i, a) == expr:
                             return self.func(self.expr, (i, a, b))
                     except:
                         ...
 
         return AddWithLimits.__add__(self, expr)        
 
-# precondition: domain.is_Complement
+# precondition: domain.is_Complement        
     def simplify_complement_domain(self, domain): 
         from sympy import Unequal, KroneckerDelta
         from sympy.sets.contains import NotElement, Element
         if not domain.is_Complement:
             return
         A, B = domain.args
         if A.is_FiniteSet:
             if len(A) != 1:
-                return
+                return        
             a, *_ = A
             if B.is_FiniteSet and len(B) == 1:
                 b, *_ = B
                 if a.is_integer and b.is_integer:
     #                     f(a)*(1 - [a, b]) = f(a) - f(b)*[a, b], if f(b) = 0, then f(a) - f(a)*[a, b] = f(a)
                     return ((1 - KroneckerDelta(a, b)) * self.expr._subs(self.variable, a)).simplify()
                 else:
@@ -1017,22 +1019,21 @@
                     function = function._subs(_x, x)
                 if function != self.expr:
                     return self.func(function, *self.limits).simplify()
             
             this = ExprWithIntLimits.simplify(self, deep=True, **kwargs)
             if this is not self:
                 return this
-
         if len(self.limits) >= 2:
             limit0, *limits = self.limits
             if len(limit0) == 1:
-                limit1, *limits = limits
+                limit1, *limits = limits 
                 if len(limit1) == 1 and not limits:
-                    x_slice, = limit0
-                    x, = limit1
+                    x_slice = limit0[0]
+                    x = limit1[0]
                     if x_slice.is_Sliced and x.is_Indexed:
                         start, stop = x_slice.index
                         if len(x.indices) == 1 and x.indices[0] == stop:
                             x_slice = x_slice.base[start: stop + 1]
                             return self.func(self.expr, (x_slice,))
             elif not self.expr._has(limit0[0]):
                 if len(limit0) == 3:
@@ -1041,33 +1042,40 @@
                         function = (b - a) * self.expr
                         return self.func(function, *limits).simplify()
             else:
                 *limits, limit_last = self.limits
                 if len(limit_last) == 2:
                     x, domain = limit_last
                     if domain.is_FiniteSet and len(domain) == 1:
-                        e, = domain
-                        return Sum(self.expr, *limits).simplify()._subs(x, e)
-                    
-            if self.expr.is_Mul:
-                vars = self.variables
-                coeff = []
+                        [e] = domain
+                        return Sum(self.expr, *limits).simplify()._subs(x, e)                        
+            return self
+
+        if not self.limits:
+            if self.expr.is_Lamda:
+                if len(self.expr.limits) == 1 and not self.expr.variable.shape:
+                    function = self.expr.expr
+                    self = self.func(function, *self.expr.limits).simplify(**kwargs)
+            elif self.expr.is_Piecewise:
+                self = self.expr.func(*((self.func(e).simplify(), c) for e, c in self.expr.args)).simplify()
+            elif self.expr.is_Mul:
                 args = []
+                coeff = []
                 for arg in self.expr.args:
-                    if arg.has(*vars):
+                    if arg.shape:
                         args.append(arg)
                     else:
                         coeff.append(arg)
-                        
+                                    
                 if coeff:
-                    return Mul(*coeff) * self.func(Mul(*args), *self.limits)
-                                        
+                    coeff = self.expr.func(*coeff)
+                    function = self.expr.func(*args)
+                    return coeff * self.func(function)
             return self
-
-        limit, = self.limits
+        limit = self.limits[0]
         if len(limit) == 2:
             if self.expr.is_zero:
                 return self.expr
             
             x, domain = limit
             if domain.is_Boolean:
                 if domain.is_Element:
@@ -1133,30 +1141,30 @@
                 if not domain.is_set:
                     domain = x.domain_conditioned(domain)
                 from sympy import Card
                 return self.expr * Card(domain)
             
             if domain_nonzero.is_Complement and domain_nonzero.args[0].is_FiniteSet:
                 if len(domain_nonzero.args[0]) == 1:
-                    e, *_ = domain_nonzero.args[0].args
+                    e, *_ = domain_nonzero.args[0].args 
                     return Piecewise((self.simplify_finiteset(x, domain_nonzero.args[0]), Element(e, limit[1])), (0, True))
                
             if domain.is_FiniteSet:
                 return self.simplify_finiteset(x, domain)
             
             if domain.is_ConditionSet:
                 if x == domain.variable:
                     return Sum[x:domain.condition:domain.base_set](self.expr)
             return self
 
         if len(limit) == 1:
             x = limit[0]
             domain = x.domain & self.expr.domain_defined(x)
             if domain.is_Range: 
-                limit = x, domain.start, domain.stop
+                limit = x, domain.start, domain.stop 
         
         if len(limit) > 1:
             x, a, b = limit
             if a.is_Boolean:
                 if a:
                     limit = (x, b)
                     return self.func(self.expr, limit).simplify()
@@ -1223,15 +1231,15 @@
                     piecewise1 = self.expr.args[1]
                      
                     if not any(c.has(x) for _, c in piecewise0.args):
                         ...
                     elif not any(c.has(x) for _, c in piecewise1.args):
                         tmp = piecewise0
                         piecewise0 = piecewise1
-                        piecewise1 = tmp
+                        piecewise1 = tmp                        
                     else:
                         scope_variables = piecewise0.scope_variables & piecewise1.scope_variables
                         if len(scope_variables) != 1:
                             return self
                         function = piecewise0.mul(piecewise1)
 # this multiplication of piecewise should be unfolded to avoid complications
                         return self.func(function, *self.limits).simplify()
@@ -1256,15 +1264,15 @@
                     return self.func(piecewise, *self.limits).simplify()
  
             domain = self.expr.domain_nonzero(x) & self.expr.domain_defined(x)
 
             domain &= universe
             if not domain:
                 return S.Zero
-            assert domain.etype.is_super_integer, domain
+            assert domain.is_super_integer, domain
 
             if domain.is_Piecewise:
                 domain = Union(*(e for e, _ in domain.args)) & universe
                      
             if domain.is_Complement:
                 if domain.args[0] in universe:
                     domain = domain.args[0]
@@ -1290,22 +1298,22 @@
                     if arg.is_Mul and any(e.is_KroneckerDelta and e._has(x) for e in arg.args):
                         args = [*self.expr.args]
                         del args[i]
                         return self.func(arg, limit).simplify() + self.func(self.expr.func(*args), limit).simplify()
             
             if len(self.limits[0]) > 1:
                 if self.expr.domain_defined(x) in domain:
-                    return self.func(self.expr, (x,)).simplify()
+                    return self.func(self.expr, (x,))
             
             if domain.is_Range:
                 _a, _b = domain.start, domain.stop
                 if not _b.is_Min:
                     b = _b
                 if not _a.is_Max:
-                    a = _a
+                    a = _a                
                 limit = x, a, b
         x = limit[0]
 
         function = self.expr
         independent, dependent = function.as_independent(x, as_Add=False)
         if independent == S.One:
             if len(self.limits[0]) == 1:
@@ -1371,15 +1379,15 @@
     
     def _eval_shape(self):
         return self.expr.shape
 
     def _pretty(self, p):
         from sympy.printing.pretty.stringpict import stringPict, prettyForm
         return prettyForm(self.__str__())
-        ascii_mode = not p._use_unicode
+        ascii_mode = not p._use_unicode        
 
         def asum(hrequired, lower, upper, use_ascii):
 
             def adjust(s, wid=None, how='<^>'):
                 if not wid or len(s) > wid:
                     return s
                 need = wid - len(s)
@@ -1487,100 +1495,62 @@
         prettyF.baseline = max_upper + sign_height // 2 + ascii_adjustment
 
         prettyF.binding = prettyForm.MUL
         return prettyF
 
     def _sympystr(self, p):
         limits = ','.join((limit._format_ineq(p) for limit in self.limits))
-        return 'Sum[%s](%s)' % (limits, p._print(self.expr))
-        #return '\N{N-ARY SUMMATION}[%s](%s)' % (limits, p._print(self.expr))
+        if limits:
+            return '\N{N-ARY SUMMATION}[%s](%s)' % (limits, p._print(self.expr))
+        return '\N{N-ARY SUMMATION}(%s)' % p._print(self.expr)
 
     latex_name_of_operator = 'sum'
     
     def _eval_is_finite(self):
-        function = self.expr
+        function = self.expr                
         for x, domain in self.limits_dict.items():
             if not isinstance(domain, list) and not domain.is_bool:
-                if domain.is_infiniteset:
+                if domain.is_infinite:
                     return
-
+                    
                 _x = x.copy(domain=domain)
                 function = function._subs(x, _x)
         return function.is_finite
 
-    def _eval_is_extended_complex(self):
-        function = self.expr
-        for x, domain in self.limits_dict.items():
-            if not isinstance(domain, list) and not domain.is_bool and not x.shape:
-                _x = x.copy(domain=domain)
-                if _x != x:
-                    function = function._subs(x, _x)
-                
-        return function.is_extended_complex
-        
-    def _eval_is_extended_real(self):
-        function = self.expr
-        for x, domain in self.limits_dict.items():
-            if not isinstance(domain, list) and not domain.is_bool and not x.shape:
-                _x = x.copy(domain=domain)
-                if _x != x:
-                    function = function._subs(x, _x)
-                
-        return function.is_extended_real
-    
-    def _eval_is_extended_positive(self):
-        function = self.expr
-        for x, domain in self.limits_dict.items():
-            if not isinstance(domain, list) and not domain.is_bool and not x.shape:
-                _x = x.copy(domain=domain)
-                if _x != x:
-                    function = function._subs(x, _x)
-        return function.is_extended_positive
-
-    def _eval_is_extended_negative(self):
-        function = self.expr
-        for x, domain in self.limits_dict.items():
-            if not isinstance(domain, list) and not domain.is_bool and not x.shape:
-                _x = x.copy(domain=domain)
-                if _x != x:
-                    function = function._subs(x, _x)
-                    
-        return function.is_extended_negative
-
     def _eval_exp(self):
         from sympy import log
         from sympy.concrete.products import Product
         if isinstance(self.expr, log):
             return Product(self.expr.arg, *self.limits)
 
     @classmethod
     def identity(cls, self, **_):
         from sympy import ZeroMatrix
         return ZeroMatrix(*self.shape)
 
-    @classmethod
-    def is_identity(cls, self, **_):
-        if self.shape:
-            return self.is_ZeroMatrix
-        return self.is_Zero
+    def __iter__(self):
+        raise TypeError
+
+    def __getitem__(self, indices):
+        return self.func(self.expr[indices], *self.limits)
 
     def _eval_torch(self):
         expr = self.expr
         limits = self.limits
         
         ranges = []
         for x, *args in limits:
             assert x.is_integer
             ranges.append([t.torch for t in args])
 
         from sympy.concrete.expr_with_limits import Lamda
         self = Lamda(expr, *limits).torch
         return sum(self[indices] for indices in itertools.product(*(range(*args) for args in ranges)))
     
-        
+    
 def summation(f, *symbols, **kwargs):
     r"""
     Compute the summation of f with respect to symbols.
 
     The notation for symbols is similar to the notation used in Integral.
     summation(f, (i, a, b)) computes the sum of f with respect to i from a to b,
     i.e.,
```

### Comparing `sympy.keras-1.0.21/sympy/conftest.py` & `sympy.keras-1.0.4/sympy/conftest.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/core/__init__.py` & `sympy.keras-1.0.4/sympy/core/__init__.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/core/_print_helpers.py` & `sympy.keras-1.0.4/sympy/core/_print_helpers.py`

 * *Files 4% similar despite different names*

```diff
@@ -21,15 +21,15 @@
     # instances of any subclasses that use slots will not need to have a
     # __dict__.
     __slots__ = ()
 
     # Note, we always use the default ordering (lex) in __str__ and __repr__,
     # regardless of the global setting. See issue 5487.
     def __str__(self):
-        from sympy.printing.string import sstr
+        from sympy.printing.str import sstr
         return sstr(self, order=None)
 
     __repr__ = __str__
 
     def _repr_disabled(self):
         """
         No-op repr function used to disable jupyter display hooks.
```

### Comparing `sympy.keras-1.0.21/sympy/core/add.py` & `sympy.keras-1.0.4/sympy/core/add.py`

 * *Files 2% similar despite different names*

```diff
@@ -672,35 +672,32 @@
         if self.shape:
             if all(arg.is_extended_positive for arg in self.args):
                 return True
                 
             if all(arg.is_extended_negative for arg in self.args):
                 return True
             
-        if self.is_odd:
-            return True
-
         return super(Add, self)._eval_is_nonzero()
          
     def _eval_is_zero(self):
         if self.shape:
             if all(arg.is_extended_positive for arg in self.args):
                 return False
                 
             if all(arg.is_extended_negative for arg in self.args):
                 return False
             
-            return
+            return 
         
         if len(self.args) == 2:
             if self.is_extended_real:
                 if self.min().is_extended_positive:
                     return False
                 if self.max().is_extended_negative:
-                    return False
+                    return False    
 
     def _eval_is_irrational(self):
         for t in self.args:
             a = t.is_irrational
             if a:
                 others = list(self.args)
                 others.remove(t)
@@ -726,15 +723,15 @@
             return True
         f = self.max()
         if f is not self and f.is_extended_nonpositive:
             return False
         
         if all(arg.is_extended_nonnegative for arg in self.args):
             if any(arg.is_extended_positive for arg in self.args):
-                return True
+                return True    
             
         if all(arg.is_extended_nonpositive for arg in self.args):
             return False
     
     def _eval_is_extended_negative(self):
         is_infinitesimal = self.is_infinitesimal
         if is_infinitesimal is True:
@@ -750,25 +747,25 @@
             return True
         f = self.min()
         if f is not self and f.is_extended_nonnegative:
             return False
         
         if all(arg.is_extended_nonpositive for arg in self.args):
             if any(arg.is_extended_negative for arg in self.args):
-                return True
+                return True            
 
         if all(arg.is_extended_nonnegative for arg in self.args):
             return False
 
     def _eval_subs(self, old, new, **hint):
         if not old.is_Add:
             if old is S.Infinity and -old in self.args:
                 # foo - oo is foo + (-oo) internally
                 return self.xreplace({-old:-new})
-            return
+            return None
 
         coeff_self, terms_self = self.as_coeff_Add()
         coeff_old, terms_old = old.as_coeff_Add()
 
         if coeff_self.is_Rational and coeff_old.is_Rational:
             if terms_self == terms_old:  # (2 + a).subs( 3 + a, y) -> -1 + y
                 return self.func(new, coeff_self, -coeff_old)
@@ -903,38 +900,15 @@
         return self.func(*[t.adjoint() for t in self.args])
 
     def _eval_conjugate(self):
         return self.func(*[t.conjugate() for t in self.args])
 
     def _eval_transpose(self, axis=-1):
         if axis == self.default_axis:
-            scalar = []
-            vector = []
-            matrix = []
-            for arg in self.args:
-                if not arg.shape:
-                    scalar.append(arg)
-                elif len(arg.shape) == 1:
-                    vector.append(arg)
-                else:
-                    matrix.append(arg)
-                
-            if not vector:
-                return self.func(*(arg.T for arg in self.args))
-
-            from sympy import OneMatrix
-            one = OneMatrix(*self.shape)
-            vector = [v * one for v in vector]
-            matrix += vector
-
-            matrix = self.func(*(arg.T for arg in matrix))
-            if scalar:
-                matrix += self.func(*scalar)
-
-            return matrix
+            return self.func(*[t.T for t in self.args])
 
     def __neg__(self):
         return self * (-1)
 
     def _sage_(self):
         s = 0
         for x in self.args:
@@ -1186,15 +1160,15 @@
                     return self.func(lhs, rhs).simplify()
 
     def simplify_KroneckerDelta(self): 
         dic = {}
        
         for expr in self.enumerate_KroneckerDelta():
             if expr not in dic:
-                dic[expr] = 0
+                dic[expr] = 0    
             dic[expr] += 1
         
         dic = {key: value for key, value in dic.items() if value > 1}
             
         if not dic:
             return self
         
@@ -1253,15 +1227,15 @@
                     args[i] = _arg
                     return self.func(*args).simplify()
 
         this = self.simplifyPiecewise()
         if this is not self:
             if deep:
                 return this.simplify(deep=deep)
-            return this
+            return this         
 
         this = self.simplify_KroneckerDelta()
         if this != self:
             return this
 
         this = self.simplifySummations()
         if this is not self:
@@ -1271,15 +1245,15 @@
         if this is not self:
             return this
 
         this = self.simplify_OneMatrix()
         if this is not self:
             return this
         
-        return self
+        return self             
             
     def simplifyPiecewise(self): 
         piecewise = [arg for arg in self.args if arg.is_Piecewise]
         if not piecewise:
             return self
         
         if len(piecewise) == 1:
@@ -1319,26 +1293,26 @@
                     args = [*self.args]
                     args[i] = times.squeeze()
                     return self.func(*args).simplify()
                                     
         return self
     
     def simplifySummations(self):
-        from sympy.concrete.summations import Sum
+        from sympy.concrete.summations import Sum 
         from sympy import Wild
         dic = {}
         ceoffs = []
         for arg in self.args:
 
             if isinstance(arg, Sum):
                 if arg.expr._coeff_isneg():
                     arg = arg.func(-arg.expr, *arg.limits)
                     key = S.NegativeOne
                 else:
-                    key = S.One
+                    key = S.One                    
                     
                 if key in dic:
                     dic[key].append(arg)
                 else:
                     dic[key] = [arg]
                 continue
 
@@ -1359,25 +1333,25 @@
                 if arg == S.Infinity:
                     positiveInfinity = True
                 if arg == S.NegativeInfinity:
                     negativeInfinity = True
 
             if negativeInfinity:
                 if positiveInfinity:
-                    return self
+                    return self 
                 return S.NegativeInfinity
             if positiveInfinity:
                 return S.Infinity
 
             return self
 
         hit = False
         for coeff in dic:
             if -coeff not in dic:
-                continue
+                continue            
             if coeff._coeff_isneg():
                 continue
 
             positive = dic[coeff]
             negative = dic[-coeff]
 
             for index, pos in enumerate(positive):
@@ -1439,15 +1413,15 @@
                     continue
                 if positive[i].expr == positive[j].expr:
                     limits = positive[i].limits_intersect(positive[j])
                     if not limits_empty(limits):
                         if positive[i].limits == positive[j].limits:
                             positive[i] *= 2
                             del positive[j]
-                            return True
+                            return True                            
                         continue
                     limits = positive[i].limits_union(positive[j])
                     positive[i] = positive[i].func(positive[i].expr, *limits)
                     del positive[j]
                     return True
 
     @property
@@ -1493,15 +1467,15 @@
         for arg in self.args:
             is_even = arg.is_even
             if is_even:
                 continue
             if is_even == False:
                 even = not even
                 continue
-            return
+            return None
         return even
 
     @property
     def is_infinitesimal(self):
         if self.args[-1].is_Infinitesimal:
             return True
         if self.args[-1].is_NegativeInfinitesimal:
@@ -1542,15 +1516,15 @@
 
     def _sympystr(self, p, order=None):
         if p.order == 'none':
             terms = list(self.args)
         else:
             terms = p._as_ordered_terms(self, order=order)
 
-        from sympy.printing.precedence import precedence
+        from sympy.printing.precedence import precedence 
         PREC = precedence(self)
         l = []
         for term in terms:
             t = p._print(term)
             if t.startswith('-'):
                 sign = "-"
                 t = t[1:]
@@ -1561,26 +1535,26 @@
             else:
                 l.extend([sign, t])
         sign = l.pop(0)
         if sign == '+':
             sign = ""
         return sign + ' '.join(l)
 
-    def _eval_determinant(self, **kwargs):
+    def _eval_determinant(self):
         if self.is_upper or self.is_lower:
             from sympy.concrete.products import Product
             i = self.generate_var(integer=True)
             n = self.shape[-2]
             return Product[i:n](self[i, i].simplify()).doit()
 
     @property
     def is_lower(self):
         for arg in self.args:
             if not arg.shape:
-                return False
+                return False            
             if len(arg.shape) == 1:
                 return False
             if arg.is_lower:
                 continue
             return False
         return True
              
@@ -1597,15 +1571,15 @@
         return True
 
     def _eval_Abs(self):
         if all(arg.is_nonnegative for arg in self.args):
             return self
         
     def of(self, cls):
-        from sympy.core.of import Basic
+        from sympy.core.of import Basic 
         res = Expr.of(self, cls)
         if res is None:
             if cls.is_Add:
                 if len(cls.args) == 2:
                     a, b = cls.args
                     cls = Basic.__new__(Add, b, a)
                     args = Expr.of(self, cls)
@@ -1642,16 +1616,16 @@
                 args = []
                 common_terms = set()
                 for arg in self.args:
                     a, c = arg.of(cls)
                     args.append(a)
                     common_terms.add(c)
                     if len(common_terms) > 1:
-                        return
-                c, = common_terms
+                        return         
+                [c] = common_terms
                 return Add(*args), c
                     
         elif isinstance(res, tuple):
             if isinstance(cls, Basic) and len(res) > 2:
                 if cls.of_subtraction_pattern():
                     negative = []
                     positive = []
@@ -1688,15 +1662,15 @@
                 A += a
             
         return B, A
 
     def monotonicity(self, x):
         '''
         determine the Monotonicity of a function wrt to x
-        (-l + Min(l, n - Min(n, u))).monotonicity(x) = -1
+        (-l + Min(l, n - Min(n, u))).monotonicity(x) = -1 
         (x ** 2).monotonicity(x) = 0
         (a * x + b).monotonicity(x) = 1 if a > 0
         (a * x + b).monotonicity(x) = -1 if a < 0
         '''
         
         monotonic_increasing = []
         monotonic_decreasing = []
@@ -1770,15 +1744,15 @@
                         del monotonic_increasing[i]
                         i = 0
                     else:
                         i += 1
                         
                     continue
                 
-                i += 1
+                i += 1                
                 
         if not monotonic_decreasing:
             return Add(*coeff, *monotonic_increasing, evaluate=False), 1
         
         if not monotonic_increasing:
             return Add(*coeff, *monotonic_decreasing, evaluate=False), -1
         
@@ -1842,15 +1816,11 @@
                 else:
                     unmodified = self.func(Add(*unmodified), *limits)
             else:
                 unmodified = S.Zero
 
             return Add(*modified, *constants, unmodified)
         return self
-
-    @property
-    def is_comparable(self):
-        return all(arg.is_comparable for arg in self.args)
-
+    
     
 from .mul import Mul, _keep_coeff, prod
 from sympy.core.numbers import Rational
```

### Comparing `sympy.keras-1.0.21/sympy/core/assumptions.py` & `sympy.keras-1.0.4/sympy/core/assumptions.py`

 * *Files 2% similar despite different names*

```diff
@@ -288,29 +288,29 @@
     'extended_complex ->  hyper_complex',
     'hyper_complex    ->  super_complex',
     
 # matrix domain:
     'invertible == !singular',
 # random domain:
     'random -> finite',
-    'probable -> random',
     
 # set domain:    
     'empty -> finiteset',
     'infiniteset == !finiteset',
     'nonempty == !empty',
     
     'finiteset -> countable',
     'countable -> measurable',
     'uncountable == !countable',
     'unmeasurable -> !measurable',
 ])
 
 _assume_defined = _assume_rules.defined_facts.copy()
 _assume_defined.add('polar')
+_assume_defined.add('elementwise')
 _assume_defined = frozenset(_assume_defined)
 
 
 def assumptions(expr, _check=None):
     """return the T/F assumptions of ``expr``"""
     n = sympify(expr)
     if n.is_Symbol:
@@ -691,23 +691,20 @@
 # in the form of : Lamda[Tuple[2]], BlockMatrix[1][Identity @ Expr]
 class IndexedOperator:
     is_Basic = False
     is_IndexedOperator = True
     is_Number = False
     is_Wanted = False
     
-    def __init__(self, cls, limits, supIndex=None):
+    def __init__(self, cls, limits):
         self.cls = cls
         self.limits = limits
         self._basic = None
-        self.supIndex = supIndex
-
+        
     def __call__(self, *args, **kwargs):
-        if (supIndex := self.supIndex) is not None:
-            kwargs['supIndex'] = supIndex
         return self.cls(*args, *self.limits, **kwargs)
         
     def has_int_index(self):
         limits = self.limits
         if len(limits) == 1:
             children = limits[0]
             if len(children) == 1:
@@ -748,15 +745,15 @@
                             child = child.basic
                             children = [*child.args]
                             children[-1] = children[-1].func
                             
             else:
                 children = []                
                 for limit in limits: 
-                    assert len(limit) == 1
+                    assert len(limit) == 1  
                     child = limit[0]
                     if isinstance(child, IndexedOperator) and child.has_int_index():
                         child = child.basic
                         child = [*child.args]
                         child[-1] = child[-1].func
                         children.extend(child)
                     else:
@@ -766,14 +763,22 @@
             self._basic = obj
         return self._basic
         
     def __invert__(self):
         from sympy.core.core import Wanted
         return Wanted(self.basic)
     
+#     @property
+#     def func(self):
+#         return self.basic.func
+
+#     @property
+#     def args(self):
+#         return self.basic.args
+
     def __repr__(self):
         return repr(self.basic)
     
     __str__ = __repr__
         
     def __getattr__(self, attr):
         return getattr(self.basic, attr)
@@ -830,40 +835,35 @@
     def __or__(self, other): 
         return BasicMeta.__or__(self.basic, other)
 
     def __and__(self, other): 
         return BasicMeta.__and__(self.basic, other)
 
     def __rsub__(self, lhs):
-        from sympy import sympify
+        from sympy import sympify 
         lhs = sympify(lhs)
         return BasicMeta.__sub__(lhs, self.basic)
     
     def __radd__(self, lhs):
-        from sympy import sympify
+        from sympy import sympify 
         lhs = sympify(lhs)
         return BasicMeta.__add__(lhs, self.basic)
     
     def __rmul__(self, lhs):
-        from sympy import sympify
+        from sympy import sympify 
         lhs = sympify(lhs)
         return BasicMeta.__mul__(lhs, self.basic)
-
+    
     def __rtruediv__(self, lhs):
-        from sympy import sympify
+        from sympy import sympify 
         lhs = sympify(lhs)
         return BasicMeta.__truediv__(lhs, self.basic)
-
+    
     def __rfloordiv__(self, lhs):
-        from sympy import sympify
+        from sympy import sympify 
         lhs = sympify(lhs)
         return BasicMeta.__floordiv__(lhs, self.basic)
 
     def __rmatmul__(self, other): 
         return BasicMeta.__rmatmul__(self.basic, other)
-
-    def __xor__(self, other):
-        limits = self.limits
-        supIndex = len(limits)
-        limits = [*limits, (other,)]
-        return IndexedOperator(self.cls, limits, supIndex)
-
+    
+
```

### Comparing `sympy.keras-1.0.21/sympy/core/backend.py` & `sympy.keras-1.0.4/sympy/core/backend.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/core/basic.py` & `sympy.keras-1.0.4/sympy/core/basic.py`

 * *Files 4% similar despite different names*

```diff
@@ -97,16 +97,14 @@
     
     is_super_complex = True
     
     is_FunctionClass = False
     
     is_elementwise = False
     
-    is_distribution = False
-
     def definition_set(self, dependency):
         from sympy.core.symbol import Symbol
 
         hashset = set()
         for arg in preorder_traversal(self):
             if isinstance(arg, Symbol) and arg.definition is not None:
                 if arg not in hashset:
@@ -126,18 +124,15 @@
         from sympy import preorder_traversal
         return preorder_traversal(self)
     
     def __and__(self, other):
         """Overloading for & operator"""
         if self.is_set:
             return self.intersect(other)
-
-        if not other.is_bool and self.is_random and other.is_random:
-            return self & other.as_boolean()
-
+        
         rhs = None
         if other.is_And:
             rhs = tuple(other._argset)
         elif other.is_Or:
             _self = self.invert()
             if _self in other._argset:
                 args = set(other._argset)
@@ -150,15 +145,15 @@
         from sympy.logic.boolalg import And
         return And(self, *rhs)
 
     __rand__ = __and__
 
     def __or__(self, other):
         if self.is_bool and other.is_bool: 
-            from sympy.logic.boolalg import Or
+            from sympy.logic.boolalg import Or        
             """Overloading for |"""
             return Or(self, other)
         from sympy.stats.rv import given
         return given(self, other)        
 
     def __ror__ (self, other):
         if self.is_bool and other.is_bool:
@@ -381,15 +376,15 @@
         def inner_key(arg):
             if isinstance(arg, Basic):
                 return arg.sort_key(order)
             else:
                 return arg
 
         args = self._sorted_args
-        args = len(args), tuple(arg.class_key() for arg in args), tuple(inner_key(arg) for arg in args)
+        args = len(args), tuple([inner_key(arg) for arg in args])
         return self.class_key(), args, S.One.sort_key(), S.One
 
     def __eq__(self, other):
         """Return a boolean indicating whether a == b on the basis of
         their symbolic trees.
 
         This is the same as a.compare(b) == 0 but faster.
@@ -451,18 +446,15 @@
         for x, y in zip(self.args, other.args):
             if not x.structurally_equal(y):
                 return False
         return True
 
 # precondition, self and other are structurally equal!
     def _dummy_eq(self, other):
-        if len(self.args) == len(other.args) and self.func == other.func:
-            ...
-        else:
-            return False
+        assert len(self.args) == len(other.args) and self.func == other.func
 
         for x, y in zip(self.args, other.args):
             if not x._dummy_eq(y):
                 return False
         return True
 
     def dummy_eq(self, other, symbol=None):
@@ -484,15 +476,15 @@
 
         >>> (u**2 + y).dummy_eq(x**2 + y, x)
         True
         >>> (u**2 + y).dummy_eq(x**2 + y, y)
         False
 
         """
-        return self == other or self.structurally_equal(other) and self._dummy_eq(other)
+        return self.structurally_equal(other) and self._dummy_eq(other)
     
     # Note, we always use the default ordering (lex) in __str__ and __repr__,
     # regardless of the global setting.  See issue 5487.
     def __repr__(self):
         """Method to return the string representation.
 
         Return the expression as a string.
@@ -604,99 +596,14 @@
 
         return result
 
     @property
     def free_symbols(self):
         return self._eval_free_symbols()
 
-    @property
-    def random_symbols(self):
-        return self._eval_random_symbols()
-
-    @staticmethod
-    def merge_random_symbols(v, s):
-        if s:
-            from sympy import Range
-            if v.is_Indexed and v.base not in s:
-                x, *indices = v.args
-                if len(indices) > 1:
-                    ...
-                else:
-                    i, = indices
-                    for t in s:
-                        if t.is_Sliced and t.base == x:
-                            indices = t.indices
-                            if len(indices) > 1:
-                                continue
-                            
-                            (a, b), = indices
-                            if i == a - 1:
-                                a = i
-                            elif i == b:
-                                b += 1
-                            else:
-                                if Range(a, b).conditionally_contains(i):
-                                    return
-                                continue
-    
-                            s.remove(t)
-                            s.add(x[a:b])
-                            return
-                        
-            elif v.is_Sliced and v.base not in s:
-                x, *indices = v.args
-                if len(indices) > 1:
-                    ...
-                else:
-                    (a, b), = indices
-                    for t in s:
-                        if t.is_Indexed and t.base == x:
-                            indices = t.indices
-                            if len(indices) > 1:
-                                continue
-
-                            i, = indices
-                            if i == a - 1:
-                                a = i
-                            elif i == b:
-                                b += 1
-                            else:
-                                if Range(a, b).conditionally_contains(i):
-                                    s.remove(t)
-                                break
-    
-                            s.remove(t)
-                            s.add(x[a:b])
-                            return
-                    
-        s.add(v)
-        
-    @cacheit
-    def _eval_random_symbols(self):
-        s = set()
-        for v in self.yield_random_symbols():
-            Basic.merge_random_symbols(v, s)
-        return s
-    
-    def yield_random_symbols(self):
-        if self.is_symbol:
-            if self.is_random:
-                yield self
-                
-        elif self.is_PDF:
-            ...
-        else:
-            if hasattr(self, '_argset'):
-                args = self._argset
-            else:
-                args = self.args
-
-            for arg in args:
-                yield from arg.yield_random_symbols()
-
     @cacheit
     def _eval_free_symbols(self):
         """Return from the atoms of self those which are free symbols.
 
         For most expressions, all symbols are free symbols. For some classes
         this is not true. e.g. Integrals use Symbols for the dummy variables
         which are bound variables, so Integral has a method to return all
@@ -1300,15 +1207,15 @@
         
         if old == new:
             return self
 
         if old.is_Sliced:
             this = self._subs_sliced(old, new, **hints)
             if this != self:
-                return this
+                return this             
         
         def fallback(self, old, new):
             """
             Try to replace old with new in any of self's arguments.
             """
             hit = False
             args = [*self.args]
@@ -1798,16 +1705,16 @@
             return self.typeof(cls.func)
         
         if isinstance(cls, Printable):
             return self == cls
         return self.typeof(cls.func)
         
     
-    def of(self, cls, **kwargs):
-        return self._extract(cls, **kwargs)
+    def of(self, cls):
+        return self._extract(cls)
     
     def is_wanted(self):
         if self.is_Wanted:
             return True
         for arg in self.args:
             if isinstance(arg, type):
                 continue
@@ -1908,15 +1815,15 @@
                 break
         else:
             raise Exception('wanted not detected!')
         
         
         j = t - 1
 #X[0], X[1], ..., X[t - 2], X[t - 1], X[t], X[t + 1], X[t + 2], ..., X[m - 1], m = len(X)
-#                               j<---------------- start scanning from here
+#                               j<---------------- start scanning from here                                 
 #C[0], C[1], ..., C[w - 2], C[w - 1], C[w], C[w + 1], C[w + 2], ..., C[n - 1], n = len(C)
 #                               i<---------------- start scanning from here
 #scan backward, starting from w - 1
         for i in range(w - 1, -1, -1):
             struct = cls.args[i]
             if j < 0:
                 break
@@ -1940,17 +1847,17 @@
                     break
             
             j -= 1
             
         else:
             j = t + 1
 #X[0], X[1], ..., X[t - 2], X[t - 1], X[t], X[t + 1], X[t + 2], ..., X[m - 1], m = len(X)
-#start scanning from here --------------------->j
+#start scanning from here --------------------->j                                 
 #C[0], C[1], ..., C[w - 2], C[w - 1], C[w], C[w + 1], C[w + 2], ..., C[n - 1], n = len(C)
-#start scanning from here --------------------->i
+#start scanning from here --------------------->i            
 #                 scan forward, starting from w + 1
             for i in range(w + 1, len(cls.args)):
                 if j >= len(self.args):
                     break
 
                 struct = cls.args[i]
                 if isinstance(struct, type):
@@ -2002,15 +1909,15 @@
                         break
                 j += 1
             else:
                 return i == len(cls.args)
             
         return True
     
-    def _extract(self, cls, indices=None):
+    def _extract(self, cls):
         if isinstance(cls, type):
             if isinstance(self, cls):
                 args = self.args
                 if len(args) == 1:
                     return args[0]
                 return args
             else:
@@ -2024,34 +1931,29 @@
         args = []
         while j < len(self.args):
             struct = cls._args[i]
             this = self.args[j]
             arg = this.of(struct)
             if arg is not None:
                 if arg == ():
-                    if not this.is_consistently_of(struct):
+                    from sympy import Symbol
+                    if this.is_Symbol and (struct is Symbol or not struct.is_Symbol) or \
+                    this.is_Number and not struct.is_Number or \
+                    this.is_Pi and not struct.is_Pi:
                         args.append(this)
-                        if indices:
-                            indices[i] = j
                 else:
                     is_abstract = struct.is_abstract if isinstance(struct, type) else False
                     args.append(this if is_abstract else arg)
-                    if indices:
-                        indices[i] = j
                     
                 i += 1
                 if i == len(cls._args):
                     args.extend(self.args[j + 1:])
-                    if indices:
-                        indices.append(slice(j + 1, None))
                     break
             else:
                 args.append(this)
-                if indices:
-                    indices[i] = j
                 
             j += 1
         else:
             if i == len(cls._args):
                 return ()
             else:
                 return
@@ -2187,17 +2089,17 @@
                                                     fetch=fetch,
                                                     output=output + _output,
                                                     **kwargs)
                 else:
                     yield fetch(*output, *_output, **kwargs)
                     
             except GeneratorExit as e:
-                raise e
+                raise e                        
             except: 
-                continue
+                continue    
             
     def count(self, query):
         """Count the number of matching subexpressions. """
         query = _make_find_query(query)
         return sum(bool(query(sub)) for sub in preorder_traversal(self))
 
     def matches(self, expr, repl_dict={}, old=False):
@@ -2309,16 +2211,17 @@
         x**2
 
         >>> (2*Integral(x, x)).doit(deep=False)
         2*Integral(x, x)
 
         """
         if hints.get('deep', True):
-            args = [term.doit(**hints) if isinstance(term, Basic) else term for term in self.args]
-            return self.func(*args, **self.kwargs)
+            terms = [term.doit(**hints) if isinstance(term, Basic) else term
+                                         for term in self.args]
+            return self.func(*terms)
         else:
             return self
 
     def simplify(self, deep=False, **kwargs):
         if deep:
             hit = False
             args = []
@@ -2493,69 +2396,56 @@
     def latex(self):
         from sympy.printing.latex import latex
         return latex(self)
 
     def _eval_domain_defined(self, x, **_):
         if x.dtype.is_set:
             return x.universalSet
-        return x.domain
+        return x.domain            
     
     @property
     def type(self):
         return self.dtype * self.shape
     
-    @staticmethod
-    def yield_vars(sym):
-        if isinstance(sym, set):
-            for sym in sym:
-                yield from Basic.yield_vars(sym)
-                
-        elif sym.is_Symbol:
-            yield sym.name
-            
-        else:
-            for sym in sym.free_symbols - {sym}:
-                yield from Basic.yield_vars(sym)
-                
     def generate_var(self, excludes=None, var=None, **kwargs):
         if excludes is None:
             excludes = set()
         elif not isinstance(excludes, set):
             excludes = {excludes}
             
-        excludes = {*Basic.yield_vars(excludes | self.free_symbols)}
+        excludes = {symbol.name for symbol in excludes | self.free_symbols}
         
         from sympy import Symbol
         if var is not None:
             if isinstance(var, set):
                 for v in var:
                     if isinstance(v, str):
                         if v not in excludes:
                             return Symbol(v, **kwargs)
                     elif v.name not in excludes:
-                        return v
+                        return v 
                 
             else:
                 if isinstance(var, str):
                     var = Symbol(var, **kwargs)
                 else:
                     assert var.is_symbol
                         
                 if var.name not in excludes:
                     return var
                     
         if 'definition' in kwargs:
             definition = kwargs['definition']
             shape = definition.shape
             if shape:
-                kwargs['shape'] = definition.shape
+                kwargs['shape'] = definition.shape            
             elif definition.is_set:
                 kwargs['etype'] = definition.etype
-            elif definition.is_integer:
-                kwargs['integer'] = True
+            else:
+                kwargs['integer'] = definition.is_integer
             
         if 'shape' in kwargs: 
             if len(kwargs['shape']) > 1:
                 symbols = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
             else:
                 symbols = 'abcdefgopqrstuvwxyzhijklmn'
         elif 'etype' in kwargs:
@@ -2704,18 +2594,14 @@
         if extended_negative == False:
             return self.is_extended_real
     
     def _eval_is_infinite(self):
         from sympy.core.logic import fuzzy_not
         return fuzzy_not(self.is_finite)
         
-    def _eval_is_infiniteset(self):
-        from sympy.core.logic import fuzzy_not
-        return fuzzy_not(self.is_finiteset)
-    
     def _eval_is_transcendental(self):
         algebraic = self.is_algebraic
         if algebraic:
             return False
         if algebraic == False:
             if self.is_complex:
                 return self.is_finite
@@ -2746,15 +2632,15 @@
         if self.shape:
             return
             
         zero = self.is_zero
         if zero:
             return False
         if zero == False:
-            return self.is_complex
+            return self.is_complex        
 
     def _eval_shape(self):
         if 'shape' in self._assumptions:
             return self._assumptions['shape']
         return ()
     
     @property
@@ -2790,22 +2676,15 @@
         ...
         
     @classmethod
     def simplify_Relational(cls, self, lhs, rhs):
         ...
         
     def domain_defined(self, x, **kwargs):
-        if x in self.free_symbols:
-            return self._eval_domain_defined(x, **kwargs)
-        else:
-            domain = Basic._eval_domain_defined(self, x)
-            for v in self.variables:
-                if v._has(x):
-                    domain &= v._eval_domain_defined(x, **kwargs)
-            return domain
+        return self._eval_domain_defined(x, **kwargs) if x in self.free_symbols else Basic._eval_domain_defined(self, x)
 
     def domain_defined_for_limits(self, limits):
         domain_defined = {}
         for v, *_ in limits:
             domain_defined[v] = self.domain_defined(v)        
         return domain_defined
     
@@ -2852,17 +2731,18 @@
                 continue
             if i.domain_assumed:
                 continue
             domain = self.domain_defined(i)
             for var, *ab in limits:
                 if i == var:
                     if len(ab) == 2:
-                        domain &= i.range(*ab)
+                        from sympy import Range, Interval
+                        domain &= (Range if i.is_extended_integer else Interval)(*ab)
                     elif len(ab) == 1:
-                        s, = ab
+                        [s] = ab
                         domain &= s
                     break
                 
             yield x._subs(i, i.copy(domain=domain))
         
     def bound_check(self, x, *limits, lower=None, upper=None):
 
@@ -2877,23 +2757,23 @@
                 return True
             
             if not any(x <= upper for x in self.yield_substituent(x, *limits)):
                 return False
 
         return True
       
-    def adjust_domain(self, x, *cond):
+    def delete_from_domain(self, x):
         return self
       
     def max_len_shape(self):
         return max(len(arg.shape) for arg in self.args)    
 
     is_given = True
 
-    @cacheit
+    @cacheit    
     def variables_with_limits(self, excludes=None):
         indices = []
         if excludes is None:
             excludes = set()
         for _ in self.shape:
             i = self.generate_var(excludes=excludes, integer=True)
             indices.append(i)
@@ -2902,15 +2782,15 @@
         limits = []
         for size, i in zip(self.shape, indices):
             limits.append((i, 0, size))
 
         limits.reverse()
         return indices, limits
     
-    @cacheit
+    @cacheit    
     def unsqueeze(self, axis, size):
         indices, limits = self.variables_with_limits()
         from sympy.core.symbol import Symbol
         i = Symbol('', integer=True)
         
         if axis < 0:
             axis += len(limits) + 1
@@ -2921,15 +2801,15 @@
         try:
             S[self], S[axis], S[size] = tensor.of_unsqueeze()
         except Exception as e:
             print(e)
             S[self], S[axis], S[size] = tensor.of_unsqueeze()
         return tensor
         
-    #precondition: self is a boolean matrix
+    #precondition: self is a boolean matrix  
     def where(self, lhs, rhs):
         limits = self._limits
         indices = self._variables
         
         from sympy.concrete.expr_with_limits import Lamda
         from sympy.functions.elementary.piecewise import Piecewise
         
@@ -3002,15 +2882,15 @@
         size = self.shape[axis]
         i = indices[axis]
         i = size - 1 - i
         indices[axis] = i
         from sympy.concrete.expr_with_limits import Lamda
         return Lamda(self[tuple(indices)], *limits)
     
-    def enlarge_indices(self, limits, **kwargs):
+    def enlarge_indices(self, limits):
         return self
     
     @property
     def torch(self):
         data = self._assumptions.get('torch')
         
         if data is not None:
@@ -3027,50 +2907,29 @@
         if data is not None:
             return data
         
         data = self._eval_keras()
         self._assumptions['keras'] = data
         return data
 
+    def _assumptions_clear_cache(self, cacheType, sym):
+        if self._has(sym):
+            try:
+                del self._assumptions[cacheType]
+            except KeyError:
+                ...
+            
+            for arg in self.args:
+                arg._assumptions_clear_cache(cacheType, sym)
+
     @staticmethod
     def simplify_Lamda(self, squeeze=False):
         return self
     
-    def precompile(self, *sym):
-        indices = []
-        vars = []  
-        for i, v in enumerate(sym):
-            if self._has(v):
-                indices.append(i)
-                vars.append(v)
-                
-        if vars:
-            return self.compile(*vars), indices
-        return self, None
-    
-    @cacheit
-    def compile(self, *syms):
-        assert all(self._has(v) for v in syms)
-        from sympy.keras.network import NetWorkMetaClass
-        return NetWorkMetaClass.mapping[self.func.__name__](*(arg.precompile(*syms) for arg in self.args))
-    
-    @property
-    def variables(self):
-        return []
-
-    def conditionally_contains(self, x):
-        return x in self
-
-    def limits_in_context(self, *args):
-        return []
-
-    def is_consistently_of(self, struct):
-        return True
-
-
+        
 class Atom(Basic):
     """
     A parent class for atomic things. An atom is an expression with no subexpressions.
 
     Examples
     ========
 
@@ -3092,15 +2951,15 @@
 
     @classmethod
     def class_key(cls):
         return 2, 0, cls.__name__
 
     @cacheit
     def sort_key(self, order=None):
-        return self.class_key(), (0, (), (str(self),)), S.One.sort_key(), S.One
+        return self.class_key(), (1, (str(self),)), S.One.sort_key(), S.One
 
     def _eval_simplify(self, **kwargs):
         return self
 
     @property
     def _sorted_args(self):
         # this is here as a safeguard against accidentally using _sorted_args
```

### Comparing `sympy.keras-1.0.21/sympy/core/cache.py` & `sympy.keras-1.0.4/sympy/core/cache.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/core/compatibility.py` & `sympy.keras-1.0.4/sympy/core/compatibility.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/core/containers.py` & `sympy.keras-1.0.4/sympy/core/containers.py`

 * *Files 5% similar despite different names*

```diff
@@ -157,15 +157,15 @@
                     return r"%s \in %s \left| %s \right. " % (p._print(x), p._print(b), p._print(a))
                 else:
                     if x.is_integer:
                         if b.is_Add and b.args[0].is_One:
                             return r"%s \leq %s \leq %s" % tuple([p._print(s) for s in (a, x, b - 1)])
                         else:
                             return r"%s \leq %s \lt %s" % tuple([p._print(s) for s in (a, x, b)])
-                    return r"%s \lt %s \lt %s" % tuple([p._print(s) for s in (a, x, b)])
+                    return r"%s \leq %s \leq %s" % tuple([p._print(s) for s in (a, x, b)])
             elif len(self) == 2:
                 x, cond = self
                 if cond.is_set:
                     return r"%s \in %s" % (p._print(x), p._print(cond))
                 else:
                     if cond.is_BinaryCondition and cond.lhs == x:
                         return p._print(cond)
@@ -177,21 +177,16 @@
                 if self[1].is_zero:
                     return r"%s:%s" % tuple([p._print(s) for s in (self[0], self[2])])
                 else:
                     return r"%s:%s:%s" % tuple([p._print(s) for s in (self[0], self[1], self[2])])
             elif len(self) == 2:
                 e, s = self
                 if s.is_Range:
-                    start, stop, *step = s.args
-                    if step:
-                        step, = step
-                    else:
-                        step = 1
-
-                    if step == 1:
+                    start, stop, step = s.args
+                    if step.is_One:
                         if start.is_Zero:
                             return r"%s:%s" % tuple([p._print(s) for s in (e, stop)])
                         return r"%s:%s:%s" % tuple([p._print(s) for s in (e, start, stop)])
                 return r"%s:%s" % tuple([p._print(s) for s in (e, self[1])])
             else:
                 return p._print(self[0])
         else:
@@ -270,20 +265,21 @@
         if hit:
             return self.func(x, *ab)
         return self
 
     @property
     def is_intlimit(self):
         x, *ab = self
-        return x.is_integer and len(ab) == 2 and not x.shape and not x.is_set
-
+        return x.is_integer and len(ab) == 2 and not x.shape and not x.is_set                
+        
     def to_setlimit(self):
         x, *ab = self
         if len(ab) == 2 and not ab[1].is_set:
-            return x, x.range(*ab)
+            from sympy import Interval, Range
+            return (x, (Range if x.is_integer else Interval)(*ab))
         if not ab:
             return x, x.universalSet
         return self
     
     @property
     def slice_args(self):
         start, stop, *step = self
@@ -308,19 +304,19 @@
             
         return cls(start, stop) if step == 1 else cls(start, stop, step)
         
     @classmethod
     def as_setlimit(cls, self):
         x, *ab = self
         if len(ab) == 2 and not ab[1].is_set:
-            return x, x.range(*ab)
+            from sympy import Interval, Range
+            return (x, (Range if x.is_integer else Interval)(*ab))
         return self
-
-    @classmethod
-    def to_coerce_setlimit(cls, self, function=None):
+    
+    def coerce_setlimit(self, function=None):
         x, *ab = self
         if not ab:
             if function is None:
                 domain = x.universalSet
             else:
                 domain = function.domain_defined(x)
         elif len(ab) == 1: 
@@ -328,49 +324,23 @@
             if domain.is_bool:
                 domain = x.domain_conditioned(domain)
         else:
             a, b = ab
             if b.is_set:
                 domain = b & x.domain_conditioned(a)
             else:
-                if x.is_integer:
-                    from sympy import Range
-                    domain = Range(a, b)
-                else:
-                    from sympy import Interval
-                    if a <= b:
-                        return x, Interval.open(a, b), 1
-                    elif a > b:
-                        return x, Interval.open(b, a), -1
-                    else:
-                        return
+                from sympy import Interval, Range
+                domain = (Range if x.is_integer else Interval)(a, b)
         return x, domain
-
-    def coerce_setlimit(self, function=None):
-        return Tuple.to_coerce_setlimit(self, function)
     
     def limit(self, x, xlim, dir=1):
         """ Compute limit x->xlim.
         """
         from sympy.series.limits import limit
         return Tuple(*[limit(f, x, xlim, dir) for f in self.args])
-    
-    @classmethod
-    def is_nonemptyset(cls, limits):
-        for limit in limits:
-            args = Tuple.to_coerce_setlimit(limit)
-            if not args:
-                continue
-
-            x, domain, *dir = args
-            if not domain.is_nonempty:
-                return False
-
-        return True
-    
 
 converter[tuple] = lambda tup: Tuple(*tup)
 
 
 def tuple_wrapper(method):
     """
     Decorator that converts any tuple in the function arguments into a Tuple.
```

### Comparing `sympy.keras-1.0.21/sympy/core/core.py` & `sympy.keras-1.0.4/sympy/core/core.py`

 * *Files 0% similar despite different names*

```diff
@@ -110,15 +110,15 @@
         other = sympify(other)
         if self.is_Boolean:
             from sympy import Or
             obj = Basic.__new__(Or, self, other)
         else:
             from sympy import Union
             obj = Basic.__new__(Union, self, other)
-        return obj
+        return obj            
     
     def __and__(self, other):
         from sympy.core.of import Basic, sympify
         other = sympify(other)
         if self.is_Boolean:
             from sympy import And
             obj = Basic.__new__(And, self, other)
@@ -204,15 +204,15 @@
     def __rtruediv__(self, lhs):
         from sympy.core.of import Basic, sympify
         from sympy import Mul, Pow, S
         lhs = sympify(lhs)
         
         pow = Basic.__new__(Pow, self, S.NegativeOne)
         if lhs == 1:
-            return pow
+            return pow                    
         return Basic.__new__(Mul, lhs, pow)
 
     def __mod__(self, other):
         from sympy.core.of import Basic, sympify
         from sympy import Mod
         other = sympify(other)
         return Basic.__new__(Mod, self, other)
```

### Comparing `sympy.keras-1.0.21/sympy/core/decorators.py` & `sympy.keras-1.0.4/sympy/core/decorators.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/core/evalf.py` & `sympy.keras-1.0.4/sympy/core/evalf.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/core/expr.py` & `sympy.keras-1.0.4/sympy/core/expr.py`

 * *Files 0% similar despite different names*

```diff
@@ -3,14 +3,15 @@
 from .singleton import S
 from .evalf import EvalfMixin, pure_complex
 from .decorators import _sympifyit, call_highest_priority
 from .cache import cacheit
 from .compatibility import reduce, as_int, default_sort_key, Iterable
 from sympy.utilities.misc import func_name
 from mpmath.libmp import mpf_log, prec_to_dps
+
 from collections import defaultdict
 
 
 class Expr(Basic, EvalfMixin):
     """
     Base class for algebraic expressions.
 
@@ -118,17 +119,18 @@
             if expr.is_Add:
                 args = expr.as_ordered_terms(order=order)
             elif expr.is_Mul:
                 args = expr.as_ordered_factors(order=order)
             else:
                 args = expr.args
 
-            args = tuple(default_sort_key(arg, order=order) for arg in args)
+            args = tuple(
+                [ default_sort_key(arg, order=order) for arg in args ])
 
-        args = len(args), tuple(arg.class_key() for arg in self.args), args
+        args = (len(args), tuple(args))
         exp = exp.sort_key(order=order)
 
         return expr.class_key(), args, exp, coeff
 
     def __hash__(self):
         # hash cannot be cached using cache_it because infinite recurrence
         # occurs as hash is needed for setting cache dictionary keys
@@ -403,15 +405,15 @@
             return GreaterEqual(self, other, evaluate=False)
         if isinstance(other, Max):
             bools = [self >= arg for arg in other.args]
             if all(bools):
                 return S.true
             bools = [b.invert() for b in bools]
             if any(bools):
-                return S.false
+                return S.false            
             
             return GreaterEqual(self, other, evaluate=False)
 
         try:
             other = _sympify(other)
         except SympifyError:
             raise TypeError("Invalid comparison %s >= %s" % (self, other))
@@ -450,15 +452,15 @@
         
         if isinstance(other, Min):
             bools = [self <= arg for arg in other.args] 
             if all(bools):
                 return S.true
             bools = [b.invert() for b in bools]
             if any(bools):
-                return S.false
+                return S.false            
             return LessEqual(self, other, evaluate=False)
 
         try:
             other = _sympify(other)
         except SympifyError:
             raise TypeError("Invalid comparison %s <= %s" % (self, other))
         
@@ -495,15 +497,15 @@
 
         if isinstance(other, Max):
             bools = [self > arg for arg in other.args]
             if all(bools):
                 return S.true
             bools = [b.invert() for b in bools]
             if any(bools):
-                return S.false
+                return S.false            
 
             return Greater(self, other, evaluate=False)
 
         try:
             other = _sympify(other)
         except SympifyError:
             raise TypeError("Invalid comparison %s > %s" % (self, other))
@@ -541,15 +543,15 @@
         
         if isinstance(other, Min):
             bools = [self < arg for arg in other.args]
             if all(bools):
                 return S.true
             bools = [b.invert() for b in bools]
             if any(bools):
-                return S.false
+                return S.false            
             
 #             return Less(self, other, evaluate=False)
 
         try:
             other = _sympify(other)
         except SympifyError:
             raise TypeError("Invalid comparison %s < %s" % (self, other))
@@ -1021,22 +1023,22 @@
         extended_negative = self.is_extended_negative
         if finite:
             return extended_negative
         if extended_negative == False:
             return False
 
     def _eval_is_nonnegative(self):
-        negative = self.is_negative
+        negative = self.is_negative        
         if negative:
             return False
         if negative == False:
             return self.is_real
 
     def _eval_is_nonpositive(self):
-        positive = self.is_positive
+        positive = self.is_positive        
         if positive:
             return False
         if positive == False:
             return self.is_real
 
     def _eval_is_extended_positive(self):
         from sympy.polys.numberfields import minimal_polynomial
@@ -1210,50 +1212,40 @@
         return c(self)
 
     def _eval_transpose(self, axis=-1):
         if axis == self.default_axis:
             from sympy.functions.elementary.complexes import conjugate
             if self.is_complex and not self.shape:
                 return self
-            elif len(self.shape) > 1:
-                return
             elif self.is_hermitian:
                 return conjugate(self)
             elif self.is_antihermitian:
                 return -conjugate(self)
-            elif len(self.shape) == 1:
-                return self
 
     @property
     def T(self):
-        from sympy import Transpose
+        from sympy.matrices.expressions.transpose import Transpose
         return Transpose(self)
 
     def _eval_adjoint(self):
+        from sympy.functions.elementary.complexes import conjugate, transpose
         if self.is_hermitian:
             return self
-        
         elif self.is_antihermitian:
             return -self
-        
         obj = self._eval_conjugate()
         if obj is not None:
-            return obj.T
-        
+            return transpose(obj)
         obj = self._eval_transpose()
         if obj is not None:
-            from sympy.functions.elementary.complexes import conjugate
             return conjugate(obj)
 
     def adjoint(self):
-        if ret := self._eval_adjoint():
-            return ret
-
-        from sympy import Adjoint
-        return Adjoint(self)
+        from sympy.functions.elementary.complexes import adjoint
+        return adjoint(self)
 
     @classmethod
     def _parse_order(cls, order):
         """Parse and configure the ordering of terms. """
         from sympy.polys.orderings import monomial_key
 
         startswith = getattr(order, "startswith", None)
@@ -1358,15 +1350,15 @@
             coeff, _term = term.as_coeff_Mul()
 
             coeff = complex(coeff)
             cpart, ncpart = {}, []
 
             if _term is not S.One:
                 for factor in Mul.make_args(_term):
-                    if factor.is_number and factor.is_comparable:
+                    if factor.is_number:
                         try:
                             coeff *= complex(factor)
                         except (TypeError, ValueError):
                             pass
                         else:
                             continue
 
@@ -2607,40 +2599,39 @@
         >>> {i.could_extract_minus_sign() for i in (e, -e)}
         {False, True}
 
         """
         negative_self = -self
         if self == negative_self:
             return False  # e.g. zoo*x == -zoo*x
-        self_has_minus = self.extract_multiplicatively(-1) is not None
-        negative_self_has_minus = negative_self.extract_multiplicatively(-1) is not None
+        self_has_minus = (self.extract_multiplicatively(-1) is not None)
+        negative_self_has_minus = (
+            (negative_self).extract_multiplicatively(-1) is not None)
         if self_has_minus != negative_self_has_minus:
             return self_has_minus
+        else:
+            if self.is_Add:
+                # We choose the one with less arguments with minus signs
+                all_args = len(self.args)
+                negative_args = len([False for arg in self.args if arg.could_extract_minus_sign()])
+                positive_args = all_args - negative_args
+                if positive_args > negative_args:
+                    return False
+                elif positive_args < negative_args:
+                    return True
+            elif self.is_Mul:
+                # We choose the one with an odd number of minus signs
+                num, den = self.as_numer_denom()
+                args = Mul.make_args(num) + Mul.make_args(den)
+                arg_signs = [arg.could_extract_minus_sign() for arg in args]
+                negative_args = list(filter(None, arg_signs))
+                return len(negative_args) % 2 == 1
 
-        if self.is_Add:
-            # We choose the one with less arguments with minus signs
-            all_args = len(self.args)
-            negative_args = len([False for arg in self.args if arg.could_extract_minus_sign()])
-            positive_args = all_args - negative_args
-            if positive_args > negative_args:
-                return False
-            elif positive_args < negative_args:
-                return True
-            return
-
-        elif self.is_Mul:
-            # We choose the one with an odd number of minus signs
-            num, den = self.as_numer_denom()
-            args = Mul.make_args(num) + Mul.make_args(den)
-            arg_signs = [arg.could_extract_minus_sign() for arg in args]
-            negative_args = list(filter(None, arg_signs))
-            return len(negative_args) % 2 == 1
-
-        # As a last resort, we choose the one with greater value of .sort_key()
-        return bool(self.sort_key() < negative_self.sort_key())
+            # As a last resort, we choose the one with greater value of .sort_key()
+            return bool(self.sort_key() < negative_self.sort_key())
 
     def extract_branch_factor(self, allow_half=False):
         """
         Try to write self as ``exp_polar(2*pi*I*n)*z`` in a nice way.
         Return (z, n).
 
         >>> from sympy import exp_polar, I, pi
@@ -3795,15 +3786,15 @@
         from sympy.concrete.expr_with_limits import Maxima
         return self.aggregate(Maxima)
     
     @cacheit
     def aggregate(self, aggregate):
         if self.shape:
             return self
-
+			
         free_symbols = {*self.free_symbols}
         for symbol in self.free_symbols:
             free_symbols -= symbol.free_symbols
             free_symbols.add(symbol)
 
         graph = {x: set() for x in free_symbols }
         for y in free_symbols:
@@ -3813,15 +3804,15 @@
             
             if y.is_Indexed:
 #                 x[k] is always dependent on x
                 if y.base in graph:
                     graph[y.base].add(y)
                 
                 for index in y.indices:
-#                 x[k] is always dependent on k
+#                 x[k] is always dependent on k                    
                     if index in graph:
                         graph[index].add(y)
                 
             for x in domain_assumed.free_symbols:
                 # y is dependent on x, so x is a parent of y
                 if x in graph:
                     graph[x].add(y)
@@ -3890,20 +3881,19 @@
 
         if not shape:
             return interval
         from sympy.sets.sets import CartesianSpace
         return CartesianSpace(interval, *shape)
 
     def domain_nonzero(self, x):
+        from sympy import Interval, Range
+        from sympy.core.numbers import oo
         if self == x:
-            from sympy.core.numbers import oo            
             if x.is_integer:
-                from sympy import Range
                 return Range(-oo, 0) | Range(1, oo)
-            from sympy import Interval
             return Interval(-oo, 0, right_open=True) | Interval(0, oo, left_open=True)
         return self.domain_defined(x)
 
     def as_coeff_Sum(self):
         return None, None
 
     def domain_latex(self, domain=None, baseset=None):
@@ -3949,48 +3939,44 @@
         elif domain.is_bool:
             if baseset is None:
                 if domain.is_BinaryCondition:
                     free_symbols = domain.lhs.free_symbols
                     if len(free_symbols) == 1:
                         free_symbol, = free_symbols
                         if free_symbol == self:
-                            return domain.latex
+                            return domain.latex                
                 return r"%s \left| %s \right." % (self.latex, domain.latex)
             else:
                 return r"%s \in %s \left| %s \right." % (self.latex, baseset.latex, domain.latex)
         else:
             return r"%s \in %s" % (self.latex, domain.latex)
 
-    def __or__(self, expr):
+    def __or__(self, exp):
         if self.is_set:
             from sympy.sets.sets import Union
-            return Union(self, expr)
-        if self.is_bool and expr.is_bool:
+            return Union(self, exp)
+        if self.is_bool and exp.is_bool:
             from sympy.logic import Or
-            return Or(self, expr)
+            return Or(self, exp)
         
-        assert self.is_random or expr.is_random
+        assert self.is_random or exp.is_random
             # overload given operator in probability theorems
-        if expr.is_Surrogate:
-            from sympy import Equal, Conditioned
-            return Conditioned(self, Equal(expr.arg, expr, evaluate=False))
-        else:
-            from sympy.stats.rv import given
-            return given(self, expr)
+        from sympy.stats.rv import given
+        return given(self, exp)
             
     def cup_finiteset(self, var=None):
         from sympy.concrete.sets import Cup
 
         i = self.generate_var(integer=True, var=var)
-#         assert self.shape[0] > 1
+#         assert self.shape[0] > 1         
         return Cup({self[i]}, (i, 0, self.shape[0]))
 
     @property
     def is_square(self):
-        shape = self.shape
+        shape = self.shape        
         return len(shape) >= 2 and shape[0] == shape[1]
     
     def _eval_is_odd(self):
         is_even = self.is_even
         if is_even:
             return False
         if is_even == False:
@@ -4030,15 +4016,15 @@
                         ref = Lamda(Piecewise((self[i, j + 1], i < I), (self[i + 1, j + 1], True)))
                     else: 
                         ref = Lamda(Piecewise(
                             (Piecewise((self[i, j], j < J), (self[i, j + 1], True)), i < I),
                             (Piecewise((self[i + 1, j], j < J), (self[i + 1, j + 1], True)), True)))
         return ref.simplify()
 
-    def _eval_determinant(self, **kwargs):
+    def _eval_determinant(self):
         ...
 
     def generate_int_limit(self, index=-1, excludes=None, generator=None, var=None):
         x = generator.generate_var(excludes, var=var, integer=True)
         domain = x.domain_assumed
         start, end = 0, self.shape[-index - 1] 
         if domain is not None and domain.is_Range and domain.start == start and domain.stop == end:
@@ -4059,19 +4045,15 @@
             return inverse
         if self.shape: 
             from sympy import Inverse
             return Inverse(self)
         return Pow(self, S.NegativeOne)
 
     def det(self): 
-        try:
-            det = self._eval_determinant()
-        except:
-            det = None
-
+        det = self._eval_determinant()
         if det is not None:
             return det
         from sympy import Determinant
         return Determinant(self)
 
     def _eval_inverse(self):
         ...
@@ -4080,63 +4062,34 @@
         assert not self.is_bool
         assert condition.is_bool
         if not condition._has(self):
             return self.domain
         return condition.domain_conditioned(self)
         
     def is_continuous(self, *args):
-        x, *ab = args
-        if not self._has(x):
-            return True
+        ...
 
     def of_simple_poly(self, x):
         '''
         extract the coefficients of a simple polynomial
         (a * x + b).of_simple_poly(x) = [b, a]
         '''
-        if self._has(x):
+        if self._has(x):            
             return None, None
         
         return self, S.Zero
         
     def monotonicity(self, x):
         return None, 0
 
     @property
     def default_axis(self):
         return len(self.shape) - 1
         
-    def outer_product(self, other=None):
-        if other is None:
-            other = self
-            
-        if not self.shape or not other.shape:
-            return self * other
-        
-        if len(self.shape) == 1:
-            if len(other.shape) == 1:
-                from sympy import OneMatrix
-                m, = self.shape
-                n, = other.shape
-                return (self * OneMatrix(n, m)).T * other
-            
-        return self @ other.T
-
-    def __invert__(self):
-        if ret := self._eval_conjugate():
-            return ret
 
-        from sympy import Conjugate
-        return Conjugate(self)
-    
-    def range(self, *ab):
-        from sympy import Range, Interval
-        return (Range if self.is_extended_integer else Interval.open)(*ab)
-
-    
 class AtomicExpr(Atom, Expr):
     """
     A parent class for object which are both atoms and Exprs.
 
     For example: Symbol, Number, Rational, Integer, ...
     But not: Add, Mul, Pow, ...
     """
@@ -4155,27 +4108,26 @@
                     from sympy import Lamda, KroneckerDelta
                     excludes = set()
                     limits_f = []
                     limits_d = []
                     prod = 1
                     for n in self.shape:
                         i = self.generate_var(excludes, integer=True)
-                        excludes.add(i)
                         j = self.generate_var(excludes, integer=True)
-                        excludes.add(j)
                         limits_f.append((i, 0, n))
                         limits_d.append((j, 0, n))
                         prod *= KroneckerDelta(i, j)
-                    return Lamda(prod, *limits_f, *limits_d)
+                    return Lamda(prod, *limits_f, limits_d)
                 
             return S.One
         return S.Zero
 
     def _eval_derivative_n_times(self, s, n):
-        from sympy import Piecewise, Eq, Tuple, MatrixExpr
+        from sympy import Piecewise, Eq
+        from sympy import Tuple, MatrixExpr
         from sympy.matrices.common import MatrixCommon
         if isinstance(s, (MatrixCommon, Tuple, Iterable, MatrixExpr)):
             return super(AtomicExpr, self)._eval_derivative_n_times(s, n)
         if self == s:
             return Piecewise((self, Eq(n, 0)), (1, Eq(n, 1)), (0, True))
         else:
             return Piecewise((self, Eq(n, 0)), (0, True))
```

### Comparing `sympy.keras-1.0.21/sympy/core/exprtools.py` & `sympy.keras-1.0.4/sympy/core/exprtools.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/core/facts.py` & `sympy.keras-1.0.4/sympy/core/facts.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/core/function.py` & `sympy.keras-1.0.4/sympy/core/function.py`

 * *Files 3% similar despite different names*

```diff
@@ -331,19 +331,39 @@
             return -1
         l = [i._prec for i in m if i.is_Float]
         l.append(-1)
         return max(l)
 
     @classmethod
     def class_key(cls):
-        return 5, cls.sub_class_key(), cls.__name__
+        funcs = {
+            'exp': 10,
+            'log': 11,
+            'sin': 20,
+            'cos': 21,
+            'tan': 22,
+            'cot': 23,
+            'sinh': 30,
+            'cosh': 31,
+            'tanh': 32,
+            'coth': 33,
+            'conjugate': 40,
+            're': 41,
+            'im': 42,
+            'arg': 43,
+        }
+        name = cls.__name__
 
-    @classmethod
-    def sub_class_key(cls):
-        return 0
+        try:
+            i = funcs[name]
+        except KeyError:
+            i = 0
+# modified in the case of t log y, to prevent logy t 
+        return 5, i, name
+#         return 4, i, name
 
     @property
     def is_commutative(self):
         """
         Returns whether the function is commutative.
         """
         if all(getattr(t, 'is_commutative') for t in self.args):
@@ -418,43 +438,26 @@
         with mpmath.workprec(prec):
             v = func(*args)
 
         return Expr._from_mpmath(v, prec)
 
     def _eval_derivative(self, s):
         # f(x).diff(s) -> x.diff(s) * f.fdiff(1)(s)
-        if s.is_Indexed:
-            return
-        
         i = 0
         l = []
         for a in self.args:
             i += 1
             da = a.diff(s)
             if da.is_zero:
                 continue
             try:
                 df = self.fdiff(i)
             except ArgumentIndexError:
                 df = Function.fdiff(self, i)
-
-            if s.shape:
-                if len(s.shape) == 1:
-                    if len(df.shape) == 2:
-                        l.append(df * da)
-                    else:
-                        if self.shape:
-                            l.append((da.T * df).T)
-                        else:
-                            return
-                else:
-                    raise Exception('could not determine dimension')
-                    l.append((da.T * df).T)
-            else:
-                l.append(df * da)
+            l.append(df * da)
         return Add(*l)
 
     def _eval_is_commutative(self):
         return fuzzy_and(a.is_commutative for a in self.args)
 
     def _eval_is_complex(self):
         return fuzzy_and(a.is_complex for a in self.args)
@@ -657,29 +660,49 @@
             #      sin(x)        x        <- _eval_as_leading_term needed
             #
             raise NotImplementedError(
                 '%s has no _eval_as_leading_term routine' % self.func)
         else:
             return self.func(*args)
 
+    def _sage_(self):
+        import sage.all as sage
+        fname = self.func.__name__
+        func = getattr(sage, fname, None)
+        args = [arg._sage_() for arg in self.args]
+
+        # In the case the function is not known in sage:
+        if func is None:
+            import sympy
+            if getattr(sympy, fname, None) is None:
+                # abstract function
+                return sage.function(fname)(*args)
+
+            else:
+                # the function defined in sympy is not known in sage
+                # this exception is caught in sage
+                raise AttributeError
+
+        return func(*args)
+
     @cacheit
     def _eval_shape(self):
         if self.is_set:
             return ()
         return self.args[0].shape
 
     @property
     def T(self):
         return self.func(self.arg.T)
 
     @cacheit
-    def _eval_domain_defined(self, x, **kwargs):
+    def _eval_domain_defined(self, x, **_):
         domain = Expr._eval_domain_defined(self, x)
         for arg in self.args:
-            domain &= arg.domain_defined(x, **kwargs)
+            domain &= arg.domain_defined(x)
         return domain
 
     def _sympystr(self, p):
         return self.func.__name__ + "(%s)" % p.stringify(self.args, ", ")
 
     def _pretty(self, p):
         # optional argument func_name for supplying custom names
@@ -695,15 +718,15 @@
         about, (e.g., Li, sech) use \operatorname{} so that the function name
         is rendered in Roman font and LaTeX handles spacing properly.
 
         expr is the expression involving the function
         exp is an exponent
         '''
         func = self.func.__name__
-        func = Symbol.translate_underscore(func)
+        func = func.replace('_quote', "'")
         if hasattr(p, '_print_' + func) and \
                 not isinstance(self, AppliedUndef):
             return getattr(p, '_print_' + func)(self, exp)
         else:
             args = [str(p._print(arg)) for arg in self.args]
             # How inverse trig functions should be displayed, formats are:
             # abbreviated: asin, full: arcsin, power: sin^-1
@@ -755,20 +778,17 @@
                 name += r"{\left(%s \right)}"
 
             if inv_trig_power_case and exp is not None:
                 name += r"^{%s}" % exp
 
             return name % ",".join(args)
         
-    def _eval_is_random(self):
-        return any(arg.is_random for arg in self.args)
-
-    def domain_definition(self):
-        from sympy import And
-        return And(*(arg.domain_definition() for arg in self.args))
+    def __invert__(self):
+        from sympy import Conjugate
+        return Conjugate(self)
 
 
 class AppliedUndef(Function):
     """
     Base class for expressions resulting from the application of an undefined
     function.
     """
@@ -782,37 +802,28 @@
             if isinstance(arg, (tuple, Tuple)):
                 index_of_limits = i
                 break
                 
         limits = args[index_of_limits:]
         if limits:
             args = args[:index_of_limits]
-
-        try:
-            args = list(map(sympify, args))
-        except Exception as e:
-            from types import FunctionType
-            if isinstance(args[0], FunctionType):
-                return UndefinedFunction(cls.name, eval=args[0], **cls._kwargs, **options)
-            raise e
-            
-        supIndex = options.pop('supIndex', None)
+        args = list(map(sympify, args))
         obj = super(AppliedUndef, cls).__new__(cls, *args, limits=limits, evaluate=evaluate, **options)
-        if evaluate:
-            if obj.is_AppliedUndef:
-                if not hasattr(obj, 'supIndex'):
-                    obj.supIndex = supIndex
-        else:
-            obj.supIndex = supIndex
-            
         return obj
 
     def _eval_as_leading_term(self, x, cdir=0):
         return self
 
+    def _sage_(self):
+        import sage.all as sage
+        fname = str(self.func)
+        args = [arg._sage_() for arg in self.args]
+        func = sage.function(fname)(*args)
+        return func
+
     @property
     def _diff_wrt(self):
         """
         Allow derivatives wrt to undefined functions.
 
         Examples
         ========
@@ -836,44 +847,33 @@
     @property
     def limits(self): 
         return self.args[self.index_of_limits():]
         
     @property
     def arg(self):
         inputs = self.inputs
+#         assert len(inputs) == 1, "illegal arg for %s" % type(self)
         return inputs[0]
         
     @property
-    def kwargs(self):
-        if (supIndex := self.supIndex) is not None:
-            return dict(supIndex=supIndex)
-        return {}
-
-    def _hashable_content(self):
-        args = Function._hashable_content(self)
-        if (supIndex := self.supIndex) is not None:
-            args += (supIndex,)
-        return args
-
-    @property
     def inputs(self): 
         return self.args[:self.index_of_limits()]
         
     def _sympystr(self, p):
         limits = self.limits
         if limits: 
             limits = [x for x, *_ in limits]
             return self.func.__name__ + "[%s](%s)" % (p.stringify(limits, ", "), p.stringify(self.inputs, ", "))
         return Function._sympystr(self, p)
 
     def _pretty(self, p):
         limits = self.limits
         if limits: 
             from sympy.printing.pretty.stringpict import prettyForm, stringPict
-            args = self.inputs
+            args = self.inputs            
             func_name = self.func.__name__ + "[%s]" % ", ".join([str(x) for x, *_ in limits])
             
             prettyFunc = p._print(Symbol(func_name))
             prettyArgs = prettyForm(*p._print_seq(args, delimiter=', ').parens())
     
             pform = prettyForm(
                 binding=prettyForm.FUNC, *stringPict.next(prettyFunc, prettyArgs))
@@ -888,42 +888,27 @@
     
     def _latex(self, p, exp=None):
         limits = self.limits
         if limits: 
             limits = [x for x, *_ in limits]
             from sympy.printing.latex import translate
             name = translate(self.func.__name__)
-            name = Symbol.translate_underscore(name)
-            arg = ", ".join(map(p._print, self.inputs))
-            limits = map(p._print, limits)
-            if (supIndex := self.supIndex) is None:
-                return name + "_{%s}(%s)" % ((", ".join(limits)), arg)
-            
-            if supIndex:
-                limits = [*limits]
-                return name + "_{%s}^{%s}(%s)" % (", ".join(limits[:supIndex]), ", ".join(limits[supIndex:]), arg)
-            return name + "^{%s}(%s)" % (", ".join(limits), arg)
+            return name + "_{%s}(%s)" % ((", ".join(map(p._print, limits))), ", ".join(map(p._print, self.inputs)))
         return Function._latex(self, p, exp=exp)
     
     def _eval_is_complex(self):
         return fuzzy_and(a.is_complex for a in self.inputs)
 
     def _eval_is_extended_real(self):
         return fuzzy_and(a.is_extended_real for a in self.inputs)
 
     @cacheit
     def defun(self):
         return self.func(*self.args, evaluate=True)
 
-    @cacheit
-    def compile(self, *syms):
-        assert all(self._has(v) for v in syms)
-        from sympy.keras.network import NetWorkAppliedUndef
-        return NetWorkAppliedUndef(self, *(arg.precompile(*syms)for arg in self.args))
-       
     def __contains__(self, other):
         if self == other:
             return True
     
     def image_set(self):
         if self.is_set:
             definition = self.defun()
@@ -951,88 +936,27 @@
             return dtype.complex
 
         if self.eval.__func__.__code__.co_name == '<lambda>':
             return self.defun().dtype
         
         return super(AppliedUndef, self).dtype
 
+    def _eval_is_random(self):
+        for arg in self.args:
+            if arg.is_random:
+                return True
+        
     @property
     def T(self):
         if len(self.inputs) > 1:
             from sympy.matrices.expressions.transpose import Transpose
             return Transpose(self)
         
         return super(AppliedUndef, self).T
     
-    def _execute_torch_recursion(self, *args):
-        y = self.defun()
-        recursive = [*y.finditer(self.func)]
-        if len(recursive) != 1:
-            return
-        
-        recursive, = recursive
-        if not y.is_Piecewise:
-            return
-        
-        if len(y.args) != 2:
-            return
-        
-        (e1, c1), (e0, S[True]) = y.args
-        vars = c1.free_symbols & set().union(*(arg.free_symbols for arg in self.args))
-        if len(vars) != 1:
-            return
-        
-        N, = vars
-        if not N.is_integer:
-            return
-        
-        index = [i for i, (h_x, x) in enumerate(zip(recursive.args, self.args)) if h_x != x]
-        if len(index) != 1:
-            return
-        
-        index, = index
-        if self.args[index].is_Tuple:
-            initial = self.args[index][0]
-            initial_t = recursive.args[index][0]
-        else:
-            initial = self.args[index]
-            initial_t = recursive.args[index]
-        
-        b, a = initial.of_simple_poly(N)
-        if a != 1:
-            return
-
-        domain = c1.domain_conditioned(N)
-        if not domain.is_Range:
-            return
-        
-        if not domain.stop.is_infinite:
-            return
-        
-        start = domain.start
-        
-        diff = initial_t - initial
-        if diff == -1:
-#                                 forward recursive function
-            h = y.generate_var(var='h', **recursive.type.dict)
-            assert y._has(recursive)
-            y = y._subs(recursive, h)
-            data = e0.torch
-            for i in range(start, N.torch + 1):
-                h._torch = data
-                data = y.torch
-                
-        elif diff == 1:
-#                                 backward recursive function
-            ...
-        else:
-            return
-        
-        return data
-        
     def execute_torch_recursion(self):
         y = self.defun()
         recursive = [*y.finditer(self.func)]
         if len(recursive) != 1:
             return
         
         recursive, = recursive
@@ -1082,17 +1006,18 @@
             h = y.generate_var(var='h', **recursive.type.dict)
             assert y._has(recursive)
             y = y._subs(recursive, h)
             data = e0.torch
             for i in range(start, N.torch + 1):
                 h._torch = data
                 data = y.torch
+                y._assumptions_clear_cache('torch', h)
                 
         elif diff == 1:
-#                                 backward recursive function
+#                                 backward recursive function                                
             ...
         else:
             return
         
         return data
     
     def _eval_torch(self):
@@ -1103,61 +1028,41 @@
     
     def _eval_keras(self):
         data = self.execute_keras_recursion()
         if data is None:
             return self.defun().keras
         return data
     
-    @property
-    def is_aggregate(self):
-        return self.has_property_shape() and self.func.shape.fget.__code__.co_code == (lambda self: self.arg.shape[:-1]).__code__.co_code and self.arg.shape
+        
+class UndefSageHelper:
+    """
+    Helper to facilitate Sage conversion.
+    """
+
+    def __get__(self, ins, typ):
+        import sage.all as sage
+        if ins is None:
+            return lambda: sage.function(typ.__name__)
+        else:
+            args = [arg._sage_() for arg in ins.args]
+            return lambda: sage.function(ins.__class__.__name__)(*args)
 
-    @cacheit
-    def has_property_shape(self):
-        return isinstance(self.func.shape, property) and sum(not arg.is_Tuple for arg in self.args) == 1
-    
-    @property
-    def is_vector_func(self):
-        return self.has_property_shape() and self.func.shape.fget is Basic.shape.fget
-    
-    @staticmethod
-    def simplify_Lamda(self, squeeze=False):
-        expr = self.expr
-        if expr.is_aggregate or expr.is_vector_func:
-            arg, *limits = expr.args
-            lamda = self.func(arg, *self.limits)
-            _lamda = lamda.simplify()
-            if lamda != _lamda:
-                return expr.func(_lamda, *limits, evaluate=False)
-             
-        return self
     
-    def __iter__(self):
-        raise TypeError
-            
-    def __getitem__(self, indices):
-        if len(self.args) == 1:
-            arg = self.arg
-            return self.func(arg[indices], evaluate=False)
-             
-        raise TypeError
+_undef_sage_helper = UndefSageHelper()
+
     
-        
 class UndefinedFunction(ManagedProperties):
     """
     The (meta)class of undefined functions.
     """
 
     def __new__(cls, name=None, bases=(AppliedUndef,), __dict__=None, **kwargs):
         __dict__ = __dict__ or {}
         # put the `is_*` for into __dict__
         __dict__.update({'is_' + arg: val for arg, val in kwargs.items() if arg in _assume_defined})
-
-        if kwargs.get('elementwise'):
-            __dict__['is_elementwise'] = True
         # You can add other attributes, although they do have to be hashable
         # (but seriously, if you want to add anything other than assumptions,
         # just subclass Function)
         if 'etype' in kwargs:
             etype = kwargs['etype']
             if isinstance(etype, property):
                 kwargs['type'] = property(lambda self: self.etype.set * self.shape)
@@ -1198,33 +1103,26 @@
                                 domain = domain * a + b
                             else:
                                 return
                         
                         if domain in continuous:
                             return True
                             
-                kwargs['is_continuous'] = is_continuous
+                kwargs['is_continuous'] = is_continuous 
                 
         if 'integrable' in kwargs:
             integrable = kwargs.pop('integrable')
             if isinstance(integrable, bool):
                 kwargs['is_integrable'] = lambda self, *_: integrable
             else:
                 kwargs['is_integrable'] = integrable
         
-        if (shape := kwargs.get('shape')) and '__getitem__' not in kwargs:
-            def __getitem__(self, index):
-                if self.is_aggregate:
-                    expr, *limits = self.args
-                    return self.func(expr[index], *limits, evaluate=False)
-                    
-                from sympy.tensor.indexed import Indexed
-                return Indexed(self, *index) if isinstance(index, tuple) else Indexed(self, index)
-
-            kwargs['__getitem__'] = __getitem__
+        if kwargs.get('shape') and '__getitem__' not in kwargs:
+            from sympy.tensor.indexed import Indexed
+            kwargs['__getitem__'] = lambda self, index: Indexed(self, *index) if isinstance(index, tuple) else Indexed(self, index)
                 
         # do this for pickling
         __dict__['__module__'] = None
         
         if isinstance(name, types.FunctionType):
             func, name = name, name.__name__
             kwargs['eval'] = func
@@ -1268,18 +1166,14 @@
     def __ne__(self, other):
         return not self == other
 
     @property
     def _diff_wrt(self):
         return False
 
-    def __xor__(self, other):
-        from sympy.core.assumptions import IndexedOperator
-        return IndexedOperator(self, [(other,)], 0)
-
 # XXX: The type: ignore on WildFunction is because mypy complains:
 #
 # sympy/core/function.py:939: error: Cannot determine type of 'sort_key' in
 # base class 'Expr'
 #
 # Somehow this is because of the @cacheit decorator but it is not clear how to
 # fix it.
@@ -1691,28 +1585,23 @@
                         break
                     else:
                         if not free & vfree:
                             # e.g. v is IndexedBase or Matrix
                             zero = True
                             break
             if zero:
-                shape = [*expr.shape]
-                for x, n in variable_count:
-                    for _ in range(n):
-                        shape += [*x.shape]
-                from sympy import ZeroMatrix
-                return ZeroMatrix(*shape)
+                return cls._get_zero_with_shape_like(expr)
 
             # make the order of symbols canonical
             # TODO: check if assumption of discontinuous derivatives exist
             variable_count = cls._sort_variable_count(variable_count)
 
         # denest
         if isinstance(expr, Derivative):
-            variable_count = list(expr.limits) + variable_count
+            variable_count = list(expr.variable_count) + variable_count
             expr = expr.expr
             return _derivative_dispatch(expr, *variable_count, **kwargs)
 
         # we return here if evaluate is False or if there is no
         # _eval_derivative method
         if not evaluate or not hasattr(expr, '_eval_derivative'):
             # return an unevaluated Derivative
@@ -1780,28 +1669,28 @@
         # what we have so far can be made canonical
         expr = expr.replace(
             lambda x: isinstance(x, Derivative),
             lambda x: x.canonical)
 
         if unhandled:
             if isinstance(expr, Derivative):
-                unhandled = list(expr.limits) + unhandled
+                unhandled = list(expr.variable_count) + unhandled
                 expr = expr.expr
             expr = Expr.__new__(cls, expr, *unhandled)
 
         if (nderivs > 1) == True and kwargs.get('simplify', True):
             from sympy.core.exprtools import factor_terms
             from sympy.simplify.simplify import signsimp
             expr = factor_terms(signsimp(expr))
         return expr
 
     @property
     def canonical(cls):
         return cls.func(cls.expr,
-            *Derivative._sort_variable_count(cls.limits))
+            *Derivative._sort_variable_count(cls.variable_count))
 
     @classmethod
     def _sort_variable_count(cls, vc):
         """
         Sort (variable, count) pairs into canonical order while
         retaining order of variables that do not commute during
         differentiation:
@@ -1924,83 +1813,67 @@
     
     def _eval_derivative(self, v):
         # If v (the variable of differentiation) is not in
         # self.variables, we might be able to take the derivative.
         if v not in self.variables:
             dedv = self.expr.diff(v)
             if isinstance(dedv, Derivative):
-                return dedv.func(dedv.expr, *(self.limits + dedv.limits))
+                return dedv.func(dedv.expr, *(self.variable_count + dedv.variable_count))
             # dedv (d(self.expr)/dv) could have simplified things such that the
             # derivative wrt things in self.variables can now be done. Thus,
             # we set evaluate=True to see if there are any other derivatives
             # that can be done. The most common case is when dedv is a simple
             # number so that the derivative wrt anything else will vanish.
             return self.func(dedv, *self.variables, evaluate=True)
         # In this case v was in self.variables so the derivative wrt v has
         # already been attempted and was not computed, either because it
         # couldn't be or evaluate=False originally.
-        variable_count = list(self.limits)
+        variable_count = list(self.variable_count)
         variable_count.append((v, 1))
         return self.func(self.expr, *variable_count, evaluate=False)
 
     def doit(self, **hints):
         expr = self.expr
         if expr.is_AppliedUndef:
             return self
         
         if hints.get('deep', True):
-            try:
-                expr = expr.doit(**hints)
-            except:
-                ...
+            expr = expr.doit(**hints)
         hints['evaluate'] = True
         try:
-            rv = self.func(expr, *self.limits, **hints)
+            rv = self.func(expr, *self.variable_count, **hints)
         except:
             rv = self
             
         if rv != self:
             if rv.has(Derivative):
                 rv = rv.doit(**hints)
         else:
             from sympy import log, Mul
-            if self.expr.is_Mul:
+            if self.expr.is_Log:
+                return 1 / self.expr.arg * Expr.__new__(self.func, self.expr.arg, *self.variable_count)
+            elif self.expr.is_Mul:
                 args = []
                 for i, factor in enumerate(self.expr.args):
-                    args.append(Mul(*self.expr.args[:i] + self.expr.args[i + 1:]) * Expr.__new__(self.func, factor, *self.limits).doit(deep=False))
+                    args.append(Mul(*self.expr.args[:i] + self.expr.args[i + 1:]) * Expr.__new__(self.func, factor, *self.variable_count).doit(deep=False))
                 return Add(*args)
-            
-            if self.expr.is_Pow:
+            elif self.expr.is_Pow:
                 base, exponent = self.expr.args
                 if not exponent.has(*self.variables):
-                    return exponent * base ** (exponent - 1) * Expr.__new__(self.func, base, *self.limits).doit(deep=False)
+                    return exponent * base ** (exponent - 1) * Expr.__new__(self.func, base, *self.variable_count).doit(deep=False)
                 if not base.has(self.variables):
-                    return self.expr * log(base) * Expr.__new__(self.func, exponent, *self.limits)
-                
-            if self.expr.is_Exp:
-                return self.expr * Expr.__new__(self.func, self.expr.arg, *self.limits).doit(deep=False)
-            
-            if self.expr.is_Log:
-                fx = self.expr.arg
-                den = fx
-                if len(self.shape) > len(fx.shape) > 0:
-                    from sympy import OneMatrix
-                    den *= OneMatrix(*self.shape)
-                    den = den.T
-                    
-                return Expr.__new__(self.func, fx, *self.limits) / den
-
-            if self.expr.is_ReducedSum:
+                    return self.expr * log(base) * Expr.__new__(self.func, exponent, *self.variable_count)
+            elif self.expr.is_ReducedSum:
                 expr = self.expr.arg
                 i = expr.generate_var(integer=True)
-                n, = expr.shape
+                [n] = expr.shape
                 from sympy import Sum
-                sgm = Sum[i:n](expr[i])
-                return Expr.__new__(self.func, sgm, *self.limits).doit(deep=False)
-            
+                sgm = Sum[i:n](expr[i])                
+                return Expr.__new__(self.func, sgm, *self.variable_count).doit(deep=False)
+                    
         return rv
 
     @_sympifyit('z0', NotImplementedError)
     def doit_numerically(self, z0):
         """
         Evaluate the derivative at z numerically.
 
@@ -2024,61 +1897,62 @@
     def expr(self):
         return self._args[0]
 
     @property
     def variables(self):
         # return the variables of differentiation without
         # respect to the type of count (int or symbolic)
-        return [i[0] for i in self.limits]
+        return [i[0] for i in self.variable_count]
 
     @property
     def variable(self):
         # return the variables of differentiation without
         # respect to the type of count (int or symbolic)
-        return self.limits[0][0]
+        return self.variable_count[0][0]
 
     def _variables(self):
         # TODO: deprecate?  YES, make this 'enumerated_variables' and
         #       name _wrt_variables as variables
         # TODO: support for `d^n`?
         rv = []
-        for v, count in self.limits:
+        for v, count in self.variable_count:
             if not count.is_Integer:
                 raise TypeError(filldedent('''
                 Cannot give expansion for symbolic count. If you just
                 want a list of all variables of differentiation, use
                 _wrt_variables.'''))
             rv.extend([v] * count)
         return tuple(rv)
 
     @property
-    def limits(self):
+    def variable_count(self):
         return self._args[1:]
-    
+
     @property
     def derivative_count(self):
-        return sum([count for var, count in self.limits], 0)
+        return sum([count for var, count in self.variable_count], 0)
 
     @cacheit
     def _eval_free_symbols(self):
+        ret = self.expr.free_symbols
         # Add symbolic counts to free_symbols
-        return self.expr.free_symbols.union(*(count.free_symbols for var, count in self.limits))        
+        return self.expr.free_symbols.union(*(count.free_symbols for var, count in self.variable_count))        
 
     @property
     def kind(self):
         return self.args[0].kind
 
     def _eval_subs(self, old, new, **hints):
         # The substitution (old, new) cannot be done inside
         # Derivative(expr, vars) for a variety of reasons
         # as handled below.
         if old in self.variables:
             # first handle the counts
             expr = self.func(self.expr, *[(v, c.subs(old, new))
-                for v, c in self.limits])
+                for v, c in self.variable_count])
             if expr != self:
                 return expr._eval_subs(old, new)
             # quick exit case
             if not getattr(new, '_diff_wrt', False) or new.is_given:
                 # case (0): new is not a valid variable of
                 # differentiation
                 if isinstance(old, Symbol):
@@ -2094,16 +1968,16 @@
             if self.canonical == old.canonical:
                 return new
 
             # collections.Counter doesn't have __le__
             def _subset(a, b):
                 return all((a[i] <= b[i]) == True for i in a)
 
-            old_vars = Counter(dict(reversed(old.limits)))
-            self_vars = Counter(dict(reversed(self.limits)))
+            old_vars = Counter(dict(reversed(old.variable_count)))
+            self_vars = Counter(dict(reversed(self.variable_count)))
             if _subset(old_vars, self_vars):
                 return _derivative_dispatch(new, *(self_vars - old_vars).items()).canonical
 
         args = list(self.args)
         newargs = list(x._subs(old, new) for x in args)
         if args[0] == old:
             # complete replacement of self.expr
@@ -2280,52 +2154,54 @@
         sympy.calculus.finite_diff.finite_diff_weights
 
         """
         from ..calculus.finite_diff import _as_finite_diff
         return _as_finite_diff(self, points, x0, wrt)
 
     def simplify(self, **_): 
-        if len(self.limits) > 1:
+        if len(self.variable_count) > 1:
             return self
-        x, n = self.limits[0]
+        x, n = self.variable_count[0]
 
+        import sympy
         function = self.expr
+        if isinstance(function, sympy.exp):
+            function = function.as_Mul()
+
         independent, dependent = function.as_independent(x, as_Add=False)
         if independent == S.One:
             return self
 
         if dependent == S.One:
             if n == 0:
                 return self.expr
-
             if n > 0:
-                from sympy import ZeroMatrix
-                return ZeroMatrix(*self.shape)
+                return S.Zero
          
-        return Expr.__new__(self.func, dependent, *self.limits) * independent
+        return Expr.__new__(self.func, dependent, *self.variable_count) * independent
 
     @property
     def dtype(self):
         from sympy.core.symbol import dtype
         return dtype.real
 
     @cacheit
     def _eval_shape(self):
         shape = self.expr.shape
-        for x, n in self.limits:
+        for x, n in self.variable_count:
             shape += x.shape * n
         return shape
 
     def _sympystr(self, p):
         # \N{NABLA}, \N{BLACK DOWN-POINTING TRIANGLE},  \N{WHITE DOWN-POINTING TRIANGLE}
         dexpr = self.expr
-        dvars = [i[0] if i[1] == 1 else i for i in self.limits]
+        dvars = [i[0] if i[1] == 1 else i for i in self.variable_count]
         return '\N{NABLA}[%s](%s)' % (", ".join(map(lambda arg: p._print(arg), dvars)), p._print(dexpr))
     
-    @classmethod
+    @classmethod  
     def _get_zero_with_shape_like(cls, expr):
         return S.Zero
 
     @classmethod
     def _dispatch_eval_derivative_n_times(cls, expr, v, count):
         # Evaluate the derivative `n` times.  If
         # `_eval_derivative_n_times` is not overridden by the current
@@ -2338,15 +2214,15 @@
         from sympy.printing.conventions import requires_partial
         tex = ""
         dim = 0
         
         if self.variable.shape:
             diff_symbol = r'\nabla'
             
-            for x, num in reversed(self.limits):
+            for x, num in reversed(self.variable_count):
                 dim += num
 
                 if num == 1:
                     tex += p._print(x)
                 else:
                     tex += r"%s^{%s}" % (p._print(x), num)
     
@@ -2355,15 +2231,15 @@
         else:
             if requires_partial(self):
                 diff_symbol = r'\partial'
             else:
                 diff_symbol = r'd'
             
 
-            for x, num in reversed(self.limits):
+            for x, num in reversed(self.variable_count):
                 dim += num
                 if num == 1:
                     tex += r"%s %s" % (diff_symbol, p._print(x))
                 else:
                     tex += r"%s %s^{%s}" % (diff_symbol, p._print(x), num)
     
             if dim == 1:
@@ -2385,178 +2261,106 @@
     def __getitem__(self, indices):
         if (indices := self.simplify_indices(indices)) is None:
             return self
 
         expr = self.expr
         if isinstance(indices, tuple):
             if expr.shape:
-                max_shape_len = len(expr.shape)
-                delta_indices = []
-                if max_shape_len < len(indices):
-                    indices, delta_indices = indices[:max_shape_len], indices[max_shape_len:]
-                else:
-                    delta_indices = []
-                    
-                self = self.func(expr[indices], *self.limits, evaluate=False)
-                if delta_indices:
-                    return self[delta_indices]
-                return self
-            
+                ...
             else:
                 sizeRequired = len(indices)
                 sgm = 0
-                for i, (x, n) in enumerate(self.limits):                    
+                for i, (x, n) in enumerate(self.variable_count):                    
                     sgm += len(x.shape) * n
                     if sgm >= sizeRequired:
                         i += 1
                         break
                 else:
-                    raise Exception('unresolved')
+                    return
                 
-                variableWanted = self.limits[:i]
-                [*variableUnwanted] = self.limits[i:]
+                variableWanted = self.variable_count[:i]
+                [*variableUnwanted] = self.variable_count[i:]
                 if diff := sgm - sizeRequired:
                     *variableWanted, last = variableWanted
                     
                     i = 0
                     x_var_cnt = []
                     for x, n in variableWanted:
                         n *= len(x.shape)
                         x_var_cnt.append((x[indices[i: i + n]], 1))
-                        i += n
+                        i += n 
                         
                     x, n = last
                     n *= len(x.shape)
                     n -= diff
                     x_var_cnt.append((x[indices[i: i + n]], 1))
                     variableUnwanted = [(x, 1)] + variableUnwanted
                     variable_count = x_var_cnt + variableUnwanted
                     return self.func(expr, *variable_count, evaluate=False)
                 else:
                     i = 0
                     x_var_cnt = []
                     for x, n in variableWanted:
                         n *= len(x.shape)
                         x_var_cnt.append((x[indices[i: i + n]], 1))
-                        i += n
+                        i += n 
                         
                     variable_count = x_var_cnt + variableUnwanted
                     return self.func(expr, *variable_count, evaluate=False)
         else:
             
             if expr.shape:
                 expr = expr[indices]
-                return self.func(expr, *self.limits, evaluate=False)
+                return self.func(expr, *self.variable_count, evaluate=False)
             else:
                 x_var_cnt = []
-                for i, (x, n) in enumerate(self.limits):
+                for i, (x, n) in enumerate(self.variable_count):
                     if x.shape:
                         break
                     x_var_cnt.append((x, n))
                 else:
-                    raise Exception('unresolved')
+                    return
                         
-                (x, n), *variable_count = self.limits[i:]
+                (x, n), *variable_count = self.variable_count[i:]
                 n -= 1
                 if n:
                     x_var_cnt += [(x[indices], 1), (x, n)]
                 else:
                     x_var_cnt += [(x[indices], 1)]
                     
                 variable_count = x_var_cnt + variable_count
                 return self.func(expr, *variable_count, evaluate=False)
     
     @staticmethod
     def simplify_Lamda(self, squeeze=False):
-        expr, *limits = self.args
-        if any(any(x._has(i) for x, _ in expr.limits) for i, *_ in limits):
-            if len(expr.limits) > 1:
-                return self
-            
-            x, n = expr.limits[0]
-            if n == 1:
-                if x.is_Indexed:
-                    order = 0
-                    for i, (_i, *_) in zip(x.indices[::-1], limits[::-1]):
-                        if i == _i:
-                            if expr.expr._has(i):
-                                break
-                            order += 1
-                            continue
-                        else:
-                            break
-                    
-                    if order:
-                        x = x.base[x.indices[:-order]]
-                        dfx = expr.func(expr.expr, (x, n))
-                        if expr.expr.shape:
-                            from sympy import Transpose
-                            dfx = Transpose.expand_dims(dfx, dfx.shape, len(x.shape))
-                            
-                        limits = limits[:-order]
-                        if limits:
-                            return self.func(dfx, *limits)
-                        return dfx
-        else:
-            lamda = self.func(expr.expr, *limits)
-            _lamda = lamda.simplify()
-            if lamda != _lamda:
-                return Derivative(_lamda, *expr.limits, evaluate=False)
-            return self
-        return self
+        x, n = self.expr.variable_count[0]
+        order = 0
+        for i, (_i, *_) in zip(x.indices[::-1], self.limits[::-1]):
+            if i == _i:
+                order += 1
+                continue
+            else:
+                break
+        
+        x = x.base[x.indices[:-order]]            
+        expr = self.expr.func(self.expr.expr, (x, n))
+        limits = self.limits[:-order]
+        if limits:
+            return self.func(expr, *limits)
+        return expr
     
-    def _eval_is_random(self):
-        return self.expr.is_random
-
-    @cacheit
-    def _eval_domain_defined(self, x, allow_empty=True, **_): 
-        if x.dtype.is_set:
-            return x.universalSet
         
-        domain = x.domain
-        if x in self.variables:
-            return domain
-
-        for limit in self.limits:
-            var, *ab = limit
-            if var.is_Sliced:
-                domain &= var._eval_domain_defined(x, allow_empty=allow_empty)
-            else:
-                domain &= var.domain_defined(x)
-                
-            for a in ab:
-                domain &= a.domain_defined(x)
-                
-        if self.expr._has(x):
-            bound_domain = self.expr.domain_defined(x)
-            for var in self.variables:
-                bound_domain = bound_domain.adjust_domain(var)
-                
-            domain &= bound_domain
-            if x not in self.expr.free_symbols:
-                v = self.variable
-                if not v.is_Sliced:
-                    v_domain = self.limits_dict[v]
-                    for var in self.expr.free_symbols:
-                        if not var._has(v) or not var.is_Indexed:
-                            continue
-                        from sympy import Wild
-                        pattern = var.subs(v, Wild(v.name, **v.assumptions0))
-                        res = x.match(pattern)
-                        if res: 
-                            t_, *_ = res.values()
-                            if isinstance(v_domain, list) or t_ in v_domain:
-                                function = self.expr._subs(v, t_)
-                                domain &= function.domain_defined(x)
-                                break
-            
-        return domain
-
-
 def _derivative_dispatch(expr, *variables, **kwargs):
+    from sympy.matrices.common import MatrixCommon
+    from sympy import MatrixExpr
+    from sympy import NDimArray
+    array_types = (MatrixCommon, MatrixExpr, NDimArray, list, tuple, Tuple)
+    if isinstance(expr, array_types) or any(isinstance(i[0], array_types) if isinstance(i, (tuple, list, Tuple)) else isinstance(i, array_types) for i in variables):
+        from sympy.tensor.array.array_derivatives import ArrayDerivative
+        return ArrayDerivative(expr, *variables, **kwargs)
     return Derivative(expr, *variables, **kwargs)
     
                  
 class Lambda(Expr):
     """
     Lambda(x, expr) represents a lambda function similar to Python's
     'lambda x: expr'. A function of several variables is written as
@@ -2884,15 +2688,15 @@
                         undone2.append((vi, pi))
                 undone = undone2
                 # differentiate wrt variables that are present
                 wrt = []
                 D = Dummy()
                 expr = e.expr
                 free = expr.free_symbols
-                for vi, ci in e.limits:
+                for vi, ci in e.variable_count:
                     if isinstance(vi, Symbol) and vi in free:
                         expr = expr.diff((vi, ci))
                     elif D in expr.subs(vi, D).free_symbols:
                         expr = expr.diff((vi, ci))
                     else:
                         wrt.append((vi, ci))
                 # inject remaining subs
@@ -2930,15 +2734,16 @@
     @property
     def point(self):
         """The values for which the variables are to be substituted"""
         return self._args[2]
 
     @cacheit
     def _eval_free_symbols(self):
-        return (self.expr.free_symbols - set(self.variables) | set(self.point.free_symbols))
+        return (self.expr.free_symbols - set(self.variables) | 
+            set(self.point.free_symbols))
 
     @property
     def expr_free_symbols(self):
         from sympy.utilities.exceptions import SymPyDeprecationWarning
         SymPyDeprecationWarning(feature="expr_free_symbols method",
                                 issue=21494,
                                 deprecated_since_version="1.9").warn()
@@ -4236,16 +4041,14 @@
             raise ValueError(filldedent('''
                 Since there are no variables in the expression %s,
                 it cannot be differentiated.''' % expr))
 
         # Standardize the variables by sympifying them:
         if isinstance(variable, tuple):
             variable, count = variable
-            if isinstance(count, int):
-                count = sympify(count)
             
         variable = sympify(variable)
 
         # Split the list of variables into a list of the variables we are diff
         # wrt, where each element of the list has the form (s, count) where
         # s is the entity to diff wrt and count is the order of the
         # derivative.
@@ -4360,28 +4163,28 @@
         # what we have so far can be made canonical
         expr = expr.replace(
             lambda x: isinstance(x, Difference),
             lambda x: x.canonical)
 
         if unhandled:
             if isinstance(expr, Difference):
-                unhandled = list(expr.limits) + unhandled
+                unhandled = list(expr.variable_count) + unhandled
                 expr = expr.expr
             expr = Expr.__new__(cls, expr, *unhandled)
 
         if (nderivs > 1) == True and kwargs.get('simplify', True):
             from sympy.core.exprtools import factor_terms
             from sympy.simplify.simplify import signsimp
             expr = factor_terms(signsimp(expr))
         return expr
 
     @property
     def canonical(cls):
         return cls.func(cls.expr,
-            *Difference._sort_variable_count(cls.limits))
+            *Difference._sort_variable_count(cls.variable_count))
 
     @classmethod
     def _sort_variable_count(cls, vc):
         """
         Sort (variable, count) pairs into canonical order while
         retaining order of variables that do not commute during
         differentiation:
@@ -4489,34 +4292,34 @@
 
     def _eval_difference(self, v):
         # If v (the variable of differentiation) is not in
         # self.variables, we might be able to take the derivative.
         if v not in self._wrt_variables:
             dedv = self.expr.diff(v)
             if isinstance(dedv, Difference):
-                return dedv.func(dedv.expr, *(self.limits + dedv.limits))
+                return dedv.func(dedv.expr, *(self.variable_count + dedv.variable_count))
             # dedv (d(self.expr)/dv) could have simplified things such that the
             # derivative wrt things in self.variables can now be done. Thus,
             # we set evaluate=True to see if there are any other derivatives
             # that can be done. The most common case is when dedv is a simple
             # number so that the derivative wrt anything else will vanish.
             return self.func(dedv, *self.variables, evaluate=True)
         # In this case v was in self.variables so the derivative wrt v has
         # already been attempted and was not computed, either because it
         # couldn't be or evaluate=False originally.
-        variable_count = list(self.limits)
+        variable_count = list(self.variable_count)
         variable_count.append((v, 1))
         return self.func(self.expr, *variable_count, evaluate=False)
 
     def doit(self, **hints):
         expr = self.expr
         if hints.get('deep', True):
             expr = expr.doit(**hints)
         hints['evaluate'] = True
-        rv = self.func(expr, *self.limits, **hints)
+        rv = self.func(expr, *self.variable_count, **hints)
         if rv != self and rv.has(Difference):
             rv = rv.doit(**hints)
         return rv
 
     @_sympifyit('z0', NotImplementedError)
     def doit_numerically(self, z0):
         """
@@ -4542,63 +4345,63 @@
     def expr(self):
         return self._args[0]
 
     @property
     def _wrt_variable(self):
         # return the variables of differentiation without
         # respect to the type of count (int or symbolic)
-        return self.limits[0]
+        return self.variable_count[0]
 
     @property
     def variables(self):
         # TODO: deprecate?  YES, make this 'enumerated_variables' and
         #       name _wrt_variables as variables
         # TODO: support for `d^n`?
         rv = []
-        for v, count in self.limits:
+        for v, count in self.variable_count:
             if not count.is_Integer:
                 raise TypeError(filldedent('''
                 Cannot give expansion for symbolic count. If you just
                 want a list of all variables of differentiation, use
                 _wrt_variables.'''))
             rv.extend([v] * count)
         return tuple(rv)
 
     @property
-    def limits(self):
+    def variable_count(self):
         return self._args[1:]
 
     @property
     def derivative_count(self):
-        return sum([count for var, count in self.limits], 0)
+        return sum([count for var, count in self.variable_count], 0)
 
     def _eval_free_symbols(self):
         return self.expr.free_symbols
 
     def _eval_subs(self, old, new, **hints):
         # The substitution (old, new) cannot be done inside
         # Difference(expr, vars) for a variety of reasons
         # as handled below.
         if old == self._wrt_variable:
             # first handle the counts
-            v, c = self.limits
+            v, c = self.variable_count
             return self.func(self.expr.subs(old, new), v, c.subs(old, new))
 
         # If both are Derivatives with the same expr, check if old is
         # equivalent to self or if old is a subderivative of self.
         if old.is_Difference and old.expr == self.expr:
             if self.canonical == old.canonical:
                 return new
 
             # collections.Counter doesn't have __le__
             def _subset(a, b):
                 return all((a[i] <= b[i]) == True for i in a)
 
-            old_vars = Counter(dict(reversed(old.limits)))
-            self_vars = Counter(dict(reversed(self.limits)))
+            old_vars = Counter(dict(reversed(old.variable_count)))
+            self_vars = Counter(dict(reversed(self.variable_count)))
             if _subset(old_vars, self_vars):
                 return Difference(new, *(self_vars - old_vars).items()).canonical
 
         args = list(self.args)
         newargs = list(x._subs(old, new) for x in args)
         if args[0] == old:
             # complete replacement of self.expr
@@ -4752,27 +4555,30 @@
         sympy.calculus.finite_diff.finite_diff_weights
 
         """
         from ..calculus.finite_diff import _as_finite_diff
         return _as_finite_diff(self, points, x0, wrt)
 
     def _latex(self, printer):
-        x, n = self.limits
+        x, n = self.variable_count
         expr = printer._print(self.expr)
         if self.expr.is_Add or self.expr.is_Mul:
             expr = r'\left(%s\right)' % expr
 
         if n == 1:
             return r'{\color{blue} \Delta}_{%s}\ {%s}' % (printer._print(x), expr)
         return r'{\color{blue} \Delta}_{%s}^{%s}\ {%s}' % (printer._print(x), printer._print(n), expr)
 
     def simplify(self, **_):
-        x, n = self.limits
+        x, n = self.variable_count
 
         expr = self.expr
+        if expr.is_Exp:
+            expr = expr.as_Mul()
+
         independent, dependent = expr.as_independent(x, as_Add=False)
         if independent == S.One:
             if expr.is_Difference:
                 expr, _x, _n = expr.args
                 if _x == x:
                     return self.func(expr, x, n + _n)
             return self
@@ -4790,15 +4596,15 @@
         from sympy.core.symbol import dtype
         if self.expr.is_integer:
             return dtype.integer
         return dtype.real
 
     @cacheit
     def _eval_shape(self):
-        x, _ = self.limits
+        x, _ = self.variable_count
         return x.shape
 
     def _sympystr(self, p):
         expr, x, n = self.args
         if n == 1:  # '\N{GREEK CAPITAL LETTER DELTA}',  '\N{BLACK UP-POINTING TRIANGLE}', '\N{WHITE UP-POINTING TRIANGLE}'
             return '\N{INCREMENT}[%s](%s)' % (p._print(x), p._print(expr))
         return '\N{INCREMENT}[%s, %s](%s)' % (p._print(x), p._print(n), p._print(expr))
```

### Comparing `sympy.keras-1.0.21/sympy/core/inference.py` & `sympy.keras-1.0.4/sympy/core/inference.py`

 * *Files 1% similar despite different names*

```diff
@@ -10,42 +10,42 @@
 
 class Inference:
     is_Inference = True
     _op_priority = 20
     
     def __init__(self, cond, **_assumptions):
         self.cond = cond.cond if cond.is_Inference else cond
-        self._assumptions = _assumptions
+        self._assumptions = _assumptions                        
 
     def __getattr__(self, attr):
         return getattr(self.cond, attr) 
 
-    @property
+    @property    
     def T(self):
-        return Inference(self.cond.T, equivalent=self)
+        return Inference(self.cond.T, equivalent=self)        
 
-    @property
+    @property    
     def equivalent(self):
         return self._assumptions.get('equivalent')
     
     @equivalent.setter
     def equivalent(self, eq):
         if eq is not None:
             assert 'equivalent' not in self._assumptions
             assert not self.is_BooleanFalse and not self
-            assert self is not eq
+            assert self is not eq 
             self._assumptions['equivalent'] = eq
             if 'plausible' in self._assumptions:
                 del self._assumptions['plausible']
             return
 
         if 'equivalent' in self._assumptions:
             del self._assumptions['equivalent']
     
-    @property
+    @property    
     def given(self):
         return self._assumptions.get('given')
     
     @given.setter
     def given(self, eq):
         if eq is not None:
             assert self is not eq
@@ -54,30 +54,30 @@
                 del self._assumptions['plausible']
             
             return
 
         if 'given' in self._assumptions:
             del self._assumptions['given']
     
-    @property
+    @property    
     def imply(self):
         return self._assumptions.get('imply')
     
     @imply.setter
     def imply(self, eq):
         if eq is not None:
             assert self is not eq
             self._assumptions['imply'] = eq
             return
 
         if 'imply' in self._assumptions:
             del self._assumptions['imply']
 
-# here we define negation = counterproposition
-    @property
+# here we define negation = counterproposition    
+    @property    
     def negation(self):
         return self._assumptions.get('negation')
     
     @negation.setter
     def negation(self, eq):
         if eq is not None:
             assert 'negation' not in self._assumptions
@@ -87,15 +87,15 @@
         if 'negation' in self._assumptions:
             del self._assumptions['negation']
     
     def plausibles_set(self, clue='given'):
         find_plausibles = self.find_plausibles(clue=clue)        
         result = [*zip(*find_plausibles)]
         if result:
-            plausibles_set, is_equivalent = result
+            plausibles_set, is_equivalent = result       
             return {*plausibles_set}, all(is_equivalent)
         return set(), False
 
     def set_equivalence_relationship(self, other):
         plausibles_set, is_equivalent = self.plausibles_set()
         if len(plausibles_set) == 1:
             if is_equivalent:
@@ -133,37 +133,37 @@
                 eq, *_ = plausibles_set
                 if isinstance(other, list):
                     plausibles_set = set()
                     for other in other:
                         _plausibles_set, is_equivalent = other.plausibles_set()
                         plausibles_set |= _plausibles_set
                         if not is_equivalent:
-                            return
+                            return 
                 else:
                     plausibles_set, is_equivalent = other.plausibles_set()
                     if not is_equivalent:
-                        return
+                        return 
                 
                 assert eq not in plausibles_set, 'cyclic proof detected'
                     
                 equivalent = [*plausibles_set]
                 if len(equivalent) == 1:
                     equivalent, *_ = equivalent
                 elif not equivalent:
                     return
                 
                 del eq._assumptions['plausible']
                 eq.given = equivalent
-                return True
+                return True                
         
     def find_plausibles(self, is_equivalent=True, clue='given'):
         if self._assumptions.get('plausible'): 
             yield self, is_equivalent
         else:
-            equivalent = self.equivalent
+            equivalent = self.equivalent        
             if equivalent is None:
                 given = getattr(self, clue)
                 is_equivalent = False
             else:
                 given = equivalent
     
             if given is not None:
@@ -280,15 +280,15 @@
 #         plausible = False, meaning, the statement is proven False
 #         plausible = None, meaning, the statement is proven True
 
         if 'plausible' in self._assumptions:
             return self._assumptions['plausible']
 
         if self:
-            return
+            return 
         if self.is_BooleanFalse:
             return False
 
         equivalent = self.equivalent
         if equivalent is not None:
             if isinstance(equivalent, (tuple, list)):
                 for parent in equivalent:
@@ -306,15 +306,15 @@
                     if parent.plausible:
                         return True
 
                 return
             if given.plausible is not None:
 #             if self is given by a False / plausible proposition, then self is plausible
                 return True
-            return
+            return 
         
         imply = self.imply
         if imply is not None:
 #             if self implies a False proposition, then self must be False
             plausible = imply._assumptions.get('plausible')
             if plausible is False:
                 return False
@@ -346,15 +346,15 @@
             # this axiom is plausible to be false!
             self._assumptions['plausible'] = False
 
         equivalent = self.equivalent
         if equivalent is not None:
             self.equivalent = None
             process_equivalent(equivalent, value)
-            return
+            return            
 
         imply = self.imply
         if imply is not None:
             self.imply = None
             process_imply(imply, value)
             return
         
@@ -409,15 +409,15 @@
             return Inference(cond, equivalent=self)
         return self
     
     def subs(self, *args, **kwargs): 
         if 'simplify' not in kwargs:
             kwargs['simplify'] = True
 
-        if all(eq.is_Equal or eq.is_Equivalent for eq in args):
+        if all(eq.is_Equal for eq in args):
             for eq in args:
                 old, new = eq.args
                  
                 if self.plausible: 
                     if eq.plausible:
                         cond = self.cond._subs(old, new, **kwargs)
                         if cond == self.cond:
@@ -443,15 +443,15 @@
                         continue
                     
                     if eq.plausible:
                         self = Inference(cond, given=eq)
                     else:
                         self = Inference(cond, plausible=None)
                     
-            return self
+            return self 
             
         old, new = args
         if not old.is_symbol:
             return self
         
         new = sympify(new)
         
@@ -477,37 +477,35 @@
                 cond = self._subs(old, new, **kwargs)
             return Inference(cond, given=self)
         
         assert not old.is_given
         domain = old.domain_bounded
         if domain is not None and new not in domain:
             from sympy import NotElement
-            if self.is_ForAll:
+            if self.is_ForAll:                
                 assert old not in self.variables, 'not supported in built-in axioms, please employ proved theorems: algebra.all.imply.ou.subs'
                 if self.expr._has(old):
                     function = self.expr._subs(old, new) | NotElement(new, domain)
                     cond = self.func(function, *limits)
                 else: 
                     limits = []
                     for limit in self.limits:
                         x, *ab = limit
                         limit = (x, *[a._subs(old, new) for a in ab])
                         limits.append(limit)
                     
                     cond = self.func(self.expr, *limits) | NotElement(new, domain)
             else:
-                _old = old.unbounded
+                _old = old.unbounded                
                 cond = self._subs(old, _old) | NotElement(_old, old.domain)
                 if _old != new:
                     cond = cond._subs(_old, new, **kwargs)
         else:
             cond = self._subs(old, new, **kwargs)
             
-        if self.plausible:
-            return Inference(cond, given=self)
         return Inference(cond, plausible=None)
     
     def set_clause(self, clue, eqs, force=False):
         if clue == 'equivalent':
             if force:
                 self.equivalent = None
             self.equivalent = eqs
@@ -548,15 +546,15 @@
                 return Inference(self.func(self.lhs + other.lhs, self.rhs + other.rhs), equivalent=(self, other))
             if self.func == other.func:
                 return Inference(self.func(self.lhs + other.lhs, self.rhs + other.rhs), given=(self, other))
     
     def __rsub__(self, other):
         other = sympify(other)
         if self.is_Equal:
-            assert not other.is_Relational
+            assert not other.is_Relational 
             return self.func(other - self.lhs, other - self.rhs, equivalent=self).simplify()
     
     def __sub__(self, other):
         if self.is_Quantifier:
             return self.this.expr - other
                 
         if isinstance(other, int):
@@ -668,16 +666,16 @@
                     return self.func(self.lhs / other.lhs, self.rhs / other.rhs, given=(self, other))
                     
                 lhs = (self.lhs / other).ratsimp().simplify()
                 rhs = (self.rhs / other).ratsimp().simplify()
 
                 if other.is_nonzero:
                     return self.func(lhs, rhs, equivalent=self)
-                from sympy import Or, ZeroMatrix
-                return Or(self.func(other, ZeroMatrix(*other.shape)), self.func(lhs, rhs), equivalent=self)
+                from sympy import Or
+                return Or(self.func(other, 0), self.func(lhs, rhs), equivalent=self)
                             
             if other.is_positive:
                 return Inference(self.func(self.lhs / other, self.rhs / other), equivalent=self)
             if other.is_negative:
                 return Inference(self.func.reversed_type(self.lhs / other, self.rhs / other), equivalent=self)
         
     def __rtruediv__(self, other):
@@ -686,16 +684,16 @@
                     
         if self.is_Equal:
             lhs = (other / self.lhs).ratsimp().simplify()
             rhs = (other / self.rhs).ratsimp().simplify()
 
             if other.is_nonzero:
                 return self.func(lhs, rhs, equivalent=self)
-            from sympy import Or, ZeroMatrix
-            return Or(self.func(other, ZeroMatrix(*other.shape)), self.func(lhs, rhs), equivalent=self)
+            from sympy import Or
+            return Or(self.func(other, 0), self.func(lhs, rhs), equivalent=self)
         
     def __iter__(self):
         raise TypeError
             
     def __getitem__(self, indices):
         if self.is_Equal: 
             if isinstance(indices, slice):
@@ -734,15 +732,15 @@
                 return False
             
             if isinstance(equivalent.given, (list, tuple)):
                 for i, g in enumerate(equivalent.given):
                     if g is not given:
                         continue
                     if all(g.plausible is None for j, g in enumerate(equivalent.given) if j != i):
-                        return True
+                        return True                    
             elif equivalent.given is given:
                 return True
             
             self = equivalent
             
     def given_by(self, given):
         if given.imply is self or \
@@ -772,23 +770,14 @@
                     return True
                 if equivalent.given.given_by(given):
                     return True
             
             if equivalent is self:
                 if given.imply is not None:
                     return self.given_by(given.imply)
-
-                equivalent = equivalent_ancestor(given)
-                if len(equivalent) != 1:
-                    return False
-                [equivalent] = equivalent
-                
-                if self == equivalent:
-                    return True
-
                 return False
             self = equivalent
             
 def equivalent_ancestor(a):
     if a is None:
         return a
     while True:
@@ -804,15 +793,15 @@
             return res
 
         a = equivalent
 
             
 from sympy.core.sympify import converter, sympify
 
-converter[Inference] = lambda infer: infer.cond
+converter[Inference] = lambda infer: infer.cond 
 
 from sympy.core.assumptions import IndexedOperator
 converter[IndexedOperator] = lambda op: op.basic
 
 from sympy.core.core import Wanted
 converter[Wanted] = lambda wanted: wanted
 
@@ -834,23 +823,23 @@
 
 def process_equivalent(equivalent, value):
     if value:
         if isinstance(equivalent, (list, tuple)):
             plausibility_array = plausibles(equivalent)
             if len(plausibility_array) == 1:
                 plausibility_array[0].plausible = True
-                return
+                return                 
 
             for eq in plausibility_array:
                 eq.plausible = True
                 
             return
 
         equivalent.plausible = True
-        return
+        return 
     else:
         if isinstance(equivalent, (list, tuple)):
             plausibility_array = plausibles(equivalent)
             if len(plausibility_array) == 1:
                 plausibility_false = plausibles_false(equivalent)
                 if not plausibility_false:
                     plausibility_array[0].plausible = False
@@ -877,15 +866,15 @@
 #                 imply will be true unless all of imply.given is proven true!
             if all(g.plausible is None for g in imply.given):
                 imply.plausible = True
             else:
                 plausibles = [g for g in imply.given if g.plausible]
                 if len(plausibles) == 1:
 #                  imply will be dependent only on the single plausible theorem, so removing given links!
-                    [given] = plausibles
+                    [given] = plausibles                
                     imply.given = None
                     if not imply._assumptions:
                         imply._assumptions['plausible'] = True
                     assert given.imply is imply
         else:
             imply.plausible = True
 
@@ -926,15 +915,15 @@
             given.plausible = False
 
 
 def process_options(value=True, **kwargs):
     equivalent = kwargs.get('equivalent')
     if equivalent is not None:
         process_equivalent(equivalent, value)
-        return
+        return        
 
     given = kwargs.get('given')
     if given is not None:
         process_given(given, value)
         return
 
     imply = kwargs.get('imply')
```

### Comparing `sympy.keras-1.0.21/sympy/core/kind.py` & `sympy.keras-1.0.4/sympy/core/kind.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/core/logic.py` & `sympy.keras-1.0.4/sympy/core/logic.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/core/mod.py` & `sympy.keras-1.0.4/sympy/core/mod.py`

 * *Files 1% similar despite different names*

```diff
@@ -71,15 +71,15 @@
 
             # by ratio
             r = p / q
             if r.is_integer:
                 return S.Zero
             try:
                 d = int(r)
-            except (TypeError, AttributeError):
+            except TypeError:
                 pass
             else:
                 if isinstance(d, int):
                     rv = p - d * q
                     if (rv * q < 0) == True:
                         rv += q
                     return rv
@@ -249,15 +249,15 @@
                                    strict=True), p._print(self.args[1]),
                  self._print(exp))
         return r'%s\%%{%s}' % (p.parenthesize(self.args[0],
                                  PRECEDENCE['Mul'], strict=True),
                                  p._print(self.args[1]))
 
     def _sympystr(self, p):
-        n, d = self.args
+        n, d = self.args 
         if n.is_Add or n.is_Mul:
             n = '(%s)' % p._print(n)
         else:
             n = p._print(n)
             
         if d.is_Add or d.is_Mul:
             d = '(%s)' % p._print(d)
```

### Comparing `sympy.keras-1.0.21/sympy/core/mul.py` & `sympy.keras-1.0.4/sympy/core/mul.py`

 * *Files 1% similar despite different names*

```diff
@@ -87,15 +87,15 @@
     return Mul._from_args(newargs)
 
 
 class Mul(Expr, AssocOp):
 
     __slots__ = ()
 
-    is_commutative = True
+    is_commutative = True    
 
     def __neg__(self):
         c, args = self.as_coeff_mul()
         c = -c
         if c is not S.One:
             if args[0].is_Number:
                 args = list(args)
@@ -320,16 +320,14 @@
                 elif coeff.is_Number or isinstance(coeff, AccumBounds):  # it could be zoo
                     coeff *= o
                     if coeff is S.NaN:
                         # we know for sure the result will be nan
                         return [S.NaN], [], None
                 elif o.is_infinite:
                     c_powers.append((o, S.One))
-                elif o.is_NegativeOne:
-                    coeff = -coeff
                 continue
 
             elif isinstance(o, AccumBounds):
                 coeff = o.__mul__(coeff)
                 continue
 
             elif o is S.ComplexInfinity:
@@ -371,15 +369,15 @@
                 #      e
                 # o = b
                 if not o.shape and coeff.is_infinite:
                     if o.is_positive:
                         continue
                     elif o.is_negative:
                         coeff = -coeff
-                        continue
+                        continue     
                         
                 b, e = o.as_base_exp()
 
                 #  y
                 # 3
                 if o.is_Pow:
                     if b.is_Number:
@@ -680,30 +678,28 @@
         # order commutative part canonically
         _mulsort(c_part)
 
         # current code expects coeff to be always in slot-0
         if coeff.is_One:
             ...
         elif coeff.is_OneMatrix:
-            if not c_part or len(coeff.shape) > max((len(arg.shape) for arg in c_part)):
+            if len(coeff.shape) > max((len(arg.shape) for arg in c_part)):
                 c_part.insert(0, coeff)
-        elif coeff.is_Mul:
-            c_part = [*coeff.args] + c_part
         else:
             c_part.insert(0, coeff)
 
         # we are done
         if (global_parameters.distribute and not nc_part and len(c_part) == 2 and
                 c_part[0].is_Number and c_part[0].is_finite and c_part[1].is_Add):
             # 2*(1+a) -> 2 + 2 * a
             coeff = c_part[0]
             c_part = [Add(*[coeff * f for f in c_part[1].args])]
 
         if infinitesimal:
-            return c_part, nc_part, infinitesimal
+            return c_part, nc_part, infinitesimal 
         return c_part, nc_part, order_symbols
 
     def _eval_power(self, e):
 
         # don't break up NC terms: (A*B)**3 != A**3*B**3, it is A*B*A*B*A*B
         cargs, nc = self.args_cnc(split_1=False)
 
@@ -1006,15 +1002,15 @@
         e, l = (# better to use the multinomial?
             nfact / prod(map(factorial, kvals)) / factorial(klast) * \
             prod([args[t].diff((s, kvals[t])) for t in range(m - 1)]) * \
             args[-1].diff((s, Max(0, klast))),
             [(k, 0, n) for k in kvals])
         return Sum(e, *l)
 
-    def _eval_determinant(self, **kwargs):
+    def _eval_determinant(self):
         if len(self.args) == 2:
             x, A = self.args
             if len(x.shape) == 2 and len(A.shape) == 1:
                 tmp = A
                 A = x
                 x = tmp
             if len(x.shape) == 1 and len(A.shape) == 2:
@@ -1608,15 +1604,15 @@
 
         if is_integer:
             is_even = [t.is_even for t in self.args]
             if any(is_even):
                 return True
             if all(b == False for b in is_even):
                 return False
-            return
+            return 
         # !integer -> !odd
         if is_integer == False:
             return False
 
     def _eval_is_composite(self):
         """
         Here we count the number of arguments that have a minimum value
@@ -1630,42 +1626,22 @@
                 return None
             if (arg - 1).is_positive:
                 number_of_args += 1
 
         if number_of_args > 1:
             return True
 
-    def _eval_is_singular(self):
-        for arg in self.args:
-            if arg.shape:
-                is_singular = arg.is_singular
-                if is_singular:
-                    return True
-
-                if is_singular is None:
-                    return
-                
-            else:
-                is_zero = arg.is_zero
-                if is_zero:
-                    return True
-                
-                if is_zero is None:
-                    return
-                
-        return False
-
     def _eval_subs(self, old, new, **hint):
         from sympy.functions.elementary.complexes import sign
         from sympy.ntheory.factor_ import multiplicity
         from sympy.simplify.powsimp import powdenest
         from sympy.simplify.radsimp import fraction
 
         if not old.is_Mul:
-            return
+            return 
 
         # try keep replacement literal so -2*x doesn't replace 4*x
         if old.args[0].is_Number and old.args[0] < 0:
             if self.args[0].is_Number:
                 if self.args[0] < 0:
                     return self._subs(-old, -new, **hint)
                 return None
@@ -1912,23 +1888,15 @@
         if cdid and not ncdid:
 
             # in case we are replacing commutative with non-commutative,
             # we want the new term to come at the front just like the
             # rest of this routine
 
             margs = [Pow(new, cdid)] + margs
-
-        prod = co_residual
-        for m in margs:
-            prod *= m
-
-        for m in nc:
-            prod *= m
-            
-        return prod
+        return co_residual * self2.func(*margs) * self2.func(*nc)
 
     def _eval_nseries(self, x, n, logx):
         from sympy import Order, powsimp
         terms = [t.nseries(x, n=n, logx=logx) for t in self.args]
         res = powsimp(self.func(*terms).expand(), combine='exp', deep=True)
         if res.has(Order):
             res += Order(x ** n, x)
@@ -1947,15 +1915,15 @@
         from sympy import logcombine, log
         if self.is_number or self.is_Symbol:
             coeff = self.coeff(S.Pi * S.ImaginaryUnit)
             if coeff:
                 if coeff.is_even:
                     return S.One
                 if coeff.is_odd:
-                    return S.NegativeOne
+                    return S.NegativeOne 
                 coeff += S.Half
                 if coeff.is_even:
                     return -S.ImaginaryUnit
                 if coeff.is_odd:
                     return S.ImaginaryUnit
 
         # Warning: code in risch.py will be very sensitive to changes
@@ -2067,15 +2035,15 @@
             return Basic.simplify_Equal(self, lhs, rhs)
 
     def simplify_KroneckerDelta(self):
         for arg in self.args:
             if arg.is_KroneckerDelta:
                 i, j = arg.args
                 if i == 0 and j in self.args or j == 0 and i in self.args:
-                    return S.Zero
+                    return S.Zero                    
 
         coefficient = []
         delta = []
         for i, arg in enumerate(self.args):
             if {*arg.enumerate_KroneckerDelta()}:
                 delta.append(arg)
             else:
@@ -2089,15 +2057,15 @@
         delta = self.func(*delta, evaluate=False).expand()
         
         if coefficient: 
             coefficient = self.func(*coefficient, evaluate=False)
         else:
             coefficient = S.One
              
-        this = delta
+        this = delta   
         if this.is_Add:
             args = [*this.args]
             hit = False
             for i, arg in enumerate(this.args):
                 if arg.is_Mul:
                     _arg = arg.simplify_KroneckerDelta()
                     if arg != _arg:
@@ -2110,28 +2078,16 @@
             if this != delta:
                 return this * coefficient
         else:
             this *= coefficient
             if this != self:
                 return this
             
-        return self
+        return self    
     
-    @staticmethod
-    def can_be_canceled(expr, a):
-        if expr.is_Pow:
-            _a, e = expr.args
-            if e == -1:
-                if _a == a or a == -a:
-                    return True
-        elif expr.is_Rational:
-            q = expr.q
-            if q == a or q == -a:
-                return True
-
     def simplify(self, deep=False, **kwargs):
         if deep:
             return Expr.simplify(self, deep=True, **kwargs)
         
         for i, arg in enumerate(self.args):
             if arg.is_Lamda:
                 _arg = arg.simplify(squeeze=True)
@@ -2141,47 +2097,29 @@
                     return self.func(*args).simplify()
             elif arg.is_Pow:
                 b, e = arg.args
                 if e is S.NegativeOne:
                     try:
                         j = self.args.index(-b)
                         args = [*self.args]
-                        args[i] = -1
+                        args[i] = -1              
                         del args[j]
                         return self.func(*args).simplify()
                     except:
                         ...
                         
         a = self.args[0]
         # dissolve the initial minus sign
         if a.is_Number and a._coeff_isneg():
             b = self.args[1]
-            if b.is_Add:
+            if isinstance(b, Add):
                 if a.is_infinite:
                     return self.func(*(-a, b.func(*(-arg for arg in b.args))) + self.args[2:])
                 else:
-                    if b.args[0]._coeff_isneg():
-                        return self.func(*(b.func(*(arg * a for arg in b.args)),) + self.args[2:])
-                    
-                    for arg in b.args:
-                        if arg.is_Mul:
-                            if any(self.can_be_canceled(arg, a) for arg in arg.args):
-                                hit = True
-                                break
-
-                        elif self.can_be_canceled(arg, a):
-                            hit = True
-                            break
-
-                    else:
-                        hit = False
-                        
-                    if hit:
-                        return self.func(*(b.func(*(arg * a for arg in b.args)),) + self.args[2:])
-                                            
+                    return self.func(*(b.func(*(arg * a for arg in b.args)),) + self.args[2:])
 
         infinity = []
         coeff = []
         for arg in self.args:
             if arg == S.Infinity or arg == S.NegativeInfinity:
                 infinity.append(arg)
             else:
@@ -2263,48 +2201,31 @@
                     continue
                 if positive[i].expr == positive[j].expr:
                     limits = positive[i].limits_intersect(positive[j])
                     if not limits_empty(limits):
                         if positive[i].limits == positive[j].limits:
                             positive[i] *= 2
                             del positive[j]
-                            return True
+                            return True                            
                         continue
                     limits = positive[i].limits_union(positive[j])
                     positive[i] = positive[i].func(positive[i].expr, *limits)
                     del positive[j]
                     return True
 
     def _eval_transpose(self, axis=-1):
         if axis == self.default_axis:
-            scalar = []
-            vector = []
-            matrix = []
-            for arg in self.args:
-                if not arg.shape:
-                    scalar.append(arg)
-                elif len(arg.shape) == 1:
-                    vector.append(arg)
-                else:
-                    matrix.append(arg)
-                
-            if not vector:
+            max_len_shape = self.max_len_shape()
+            if all(not arg.shape or len(arg.shape) == max_len_shape for arg in self.args):
                 return self.func(*(arg.T for arg in self.args))
 
-            if scalar:
-                return self.func(*vector, *matrix).T * self.func(*scalar)
-            
-            if len(matrix) == 1:
-                matrix, = matrix
-                if matrix.is_Identity:
-                    return self
-
     def domain_nonzero(self, x):
-        from sympy.core.numbers import oo
-        domain = x.range(-oo, oo)
+        from sympy import Interval, Range
+        from sympy.core.numbers import oo        
+        domain = Range(-oo, oo) if x.is_integer else Interval(-oo, oo)
         for arg in self.args:
             domain &= arg.domain_nonzero(x)
         return domain
 
     def as_coeff_Sum(self):
         from sympy.concrete import summations
 
@@ -2356,15 +2277,15 @@
                 if arg.is_number:
                     coeff.append(arg)
                     continue
 #                 domain *= arg.domain
             if coeff:
                 if domain:
                     return domain * Mul(*coeff)
-                return domain
+                return domain                
         else:
             for arg in self.args:
                 if len(arg.shape) < max_shape_len:
                     coeff.append(arg)
                     continue
 #                 domain *= arg.domain
             
@@ -2423,15 +2344,15 @@
                         prev = args[i - 1]
                         if prev.is_OneMatrix or \
                         term.is_OneMatrix or \
                         (prev.is_Atom or prev.is_Lamda) and (term.is_Lamda or term.is_Mod) or \
                         prev.is_Product and term.is_ExprWithLimits:
                             _tex += " \cdot "
                         else:
-                            _tex += separator
+                            _tex += separator                                
 
                     _tex += term_tex
                     last_term_tex = term_tex
                 return _tex
 
         if denom is S.One and Pow(1, -1, evaluate=False) not in self.args:
             # use the original expression here, since fraction() may have
@@ -2523,20 +2444,19 @@
 
         # To parenthesize Pow with exp = -1 and having more than one Symbol
         for item in pow_paren:
             if item.base in b:
                 b_str[b.index(item.base)] = "(%s)" % b_str[b.index(item.base)]
 
         if not b:
-            return sign + ' * '.join(a_str)
-
-        if len(b) == 1:
-            return sign + ' * '.join(a_str) + " / " + b_str[0]
-
-        return sign + ' * '.join(a_str) + " / (%s)" % '*'.join(b_str)
+            return sign + '*'.join(a_str)
+        elif len(b) == 1:
+            return sign + '*'.join(a_str) + "/" + b_str[0]
+        else:
+            return sign + '*'.join(a_str) + "/(%s)" % '*'.join(b_str)
 
     def _pretty(self, p):
         from sympy.printing.pretty.stringpict import prettyForm
         a = []  # items in the numerator
         b = []  # items that are in the denominator (if any)
 
         if p.order not in ('old', 'none'):
@@ -2594,15 +2514,15 @@
                 a.append(p._print(S.One))
             return prettyForm.__mul__(*a) / prettyForm.__mul__(*b)
 
     @property
     def is_lower(self):
         for arg in self.args:
             if not arg.shape:
-                continue
+                continue            
             if len(arg.shape) == 1:
                 continue
             if arg.is_lower:
                 continue
             return False
         return True
              
@@ -2651,36 +2571,29 @@
         return super(Mul, self).dtype
 
     def squeeze(self):
         return self.func(*[t for t in self.args if not t.is_OneMatrix])
 
     def of(self, cls):
         from sympy.core.of import Basic
-        if isinstance(cls, Basic):
-            indices = [None] * len(cls.args)
-            res = Expr.of(self, cls, indices=indices)
-        else:
-            res = Expr.of(self, cls)
-
-        if isinstance(res, tuple):
+        res = Expr.of(self, cls)
+        if isinstance(res, tuple): 
             if cls.is_Mul:
                 if not isinstance(cls, type):
                     try:
                         if cls.of_LinearPattern():
                             return Mul(*res)
                         
                         if len(cls.args) == 2:
                             if len(res) > 2:
                                 a, b = cls.args
                                 if a is Expr and (b is not Expr):
-                                    index = indices[1]
-                                    b = res[index]
-                                    res = res[:index] + res[index + 1:]
+                                    *res, b = res
                                     a = Mul(*res)
-                                    return a, b
+                                    return (a, b)
                         elif len(cls.args) == 1:
                             for i, r in enumerate(res):
                                 if isinstance(r, tuple):
                                     first = res[i]
                                     rest = res[:i] + res[i + 1:]
                                     res = (first, *rest)  
                                     break
@@ -2729,15 +2642,15 @@
                         return args
                     
                 for i, Ty in enumerate(cls.args):
                     args = [*self.args]
                     Ty_indices = [t for t, arg in enumerate(args) if isinstance(Ty, type) and isinstance(arg, Ty) or isinstance(Ty.func, type) and isinstance(arg, Ty.func)]
                     if len(Ty_indices) == 1:
                         types = [*cls.args]
-                        j, = Ty_indices
+                        [j] = Ty_indices
                         del types[i]
                         
                         Ty_value = args.pop(j)
                         Ty_value = Ty_value.of(Ty)
                         if Ty_value is None:
                             break
                         args = self.func(*args).of(Basic.__new__(Mul, *types))
@@ -2818,92 +2731,53 @@
         return prod(arg.torch for arg in self.args)
 
     @staticmethod
     def simplify_Lamda(self, squeeze=False):
         vars = self.variables
         limits = self.limits
         modified = []
-        deformed = []
         unmodified = []
         constants = []
         for arg in self.expr.args:
             if arg.has(*vars):
                 if arg.is_Add:
                     unmodified.append(arg)
                 else:
                     lamda = self.func(arg, *limits)
                     _lamda = lamda.simplify()
                     if _lamda != lamda:
-                        if len(_lamda.shape) < len(self.shape):
-                            deformed.append(_lamda)
-                        else:
-                            modified.append(_lamda)
+                        modified.append(_lamda)
                     else:
                         unmodified.append(arg)
             else:
                 constants.append(arg)
     
-        if deformed or modified or constants:
-            
+        if modified or constants:
             if unmodified:
                 if max(len(expr.shape) for expr in unmodified) < len(self.expr.shape):
-                    from sympy import OneMatrix
+                    from sympy.matrices.expressions.matexpr import OneMatrix
                     one = OneMatrix(*self.expr.shape)
                     try:
                         del constants[constants.index(one)]
                         if not constants and not modified:
                             return self
                         
                     except ValueError:
                         ...
                         
                     unmodified.append(one)
                     
                 unmodified = self.func(Mul(*unmodified), *limits)
-                unmodified = [unmodified]
-
-            if deformed:
-                deformed = Mul(*deformed)
-                from sympy import Transpose
-                deformed = Transpose.expand_dims(deformed, self.shape, len(self.limits))
-                deformed = [deformed]
+            else:
+                unmodified = S.One
 
-            return Mul(*constants, *modified, *unmodified, *deformed)
+            return Mul(*modified, *constants, unmodified)
         
         return self
     
-    @cacheit
-    def sort_key(self, order=None):
-        coeff, expr = self.as_coeff_Mul()
-
-        if expr.is_Pow:
-            expr, exp = expr.args
-        else:
-            expr, exp = expr, S.One
-
-        if expr.is_Dummy:
-            args = (expr.sort_key(),)
-        elif expr.is_Atom:
-            args = (str(expr),)
-        else:
-            if expr.is_Add:
-                args = expr.as_ordered_terms(order=order)
-            elif expr.is_Mul:
-                args = expr.as_ordered_factors(order=order)
-            else:
-                args = expr.args
-
-            args = tuple(arg.sort_key(order=order) for arg in args)
-
-        args = len(args), tuple(arg.class_key() for arg in self.args), args
-        exp = exp.sort_key(order=order)
-
-        class_key = expr.class_key()
-        return (*class_key, *coeff.sort_key()), args, exp, coeff
-
 
 mul = AssocOpDispatcher('mul')
 
     
 def prod(a, start=1):
     """Return product of elements of a. Start with int 1 so if only
        ints are included then an int result is returned.
```

### Comparing `sympy.keras-1.0.21/sympy/core/multidimensional.py` & `sympy.keras-1.0.4/sympy/core/multidimensional.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/core/numbers.py` & `sympy.keras-1.0.4/sympy/core/numbers.py`

 * *Files 0% similar despite different names*

```diff
@@ -730,15 +730,15 @@
 
     @classmethod
     def class_key(cls):
         return 1, 0, 'Number'
 
     @cacheit
     def sort_key(self, order=None):
-        return self.class_key(), (0, (), ()), (1 if self < 0 else -1,), self
+        return self.class_key(), (0, ()), (), self
 
     @_sympifyit('other', NotImplemented)
     def __add__(self, other):
         if isinstance(other, Number) and global_parameters.evaluate:
             if other is S.NaN:
                 return S.NaN
             elif other is S.Infinity:
@@ -941,17 +941,14 @@
                 a, b = v.domain.of(Range)
                 size = b - a
             shape.append(size)
         shape.reverse()
         from sympy.matrices.expressions.matexpr import OneMatrix
         return self.expr * OneMatrix(*shape)
     
-    def is_consistently_of(self, struct):
-        return struct.is_Number
-
     
 class Float(Number):
     """Represent a floating-point number of arbitrary precision.
 
     Examples
     ========
 
@@ -1775,15 +1772,15 @@
     def _eval_is_extended_positive(self):
         return self.p > 0
 
     def _eval_is_zero(self):
         return self.p == 0
 
     def _eval_is_extended_negative(self):
-        return self.p < 0
+        return self.p < 0 
 
     def __neg__(self):
         return Rational(-self.p, self.q)
 
     @_sympifyit('other', NotImplemented)
     def __add__(self, other):
         if isinstance(other, (Infinitesimal, NegativeInfinitesimal)):
@@ -2153,15 +2150,15 @@
             else:
                 return
             
         if cls.is_Pow:
             b, e = cls.args
             if e == -1:
                 if b is Expr or b is Basic:
-                    p, q = self.p, self.q
+                    p, q = self.p, self.q                
                     if p == 1:
                         return sympify(q)
             elif e == 2:
                 if b is Expr or b is Basic:
                     p, q = self.p, self.q
                     from sympy import sqrt
                     p = sqrt(p)                    
@@ -2194,14 +2191,17 @@
                         if den_ == den:
                             return Integer(num)
             return
             
         if self == cls:
             return ()        
 
+    def __invert__(self):
+        return self
+    
     @property
     def numpy(self):
         import numpy as np
         return np.array(self.p / self.q, dtype=np.float32)
 
 
 class Integer(Rational):
@@ -2586,17 +2586,15 @@
 
     def as_numer_denom(self):
         return self, S.One
 
     def __floordiv__(self, other):
         if isinstance(other, Integer):
             return Integer(self.p // other)
-
-        from sympy import Floor
-        return Floor(self / other)
+        return Integer(divmod(self, other)[0])
 
     def __rfloordiv__(self, other):
         return Integer(Integer(other).p // self.p)
 
     @property
     def numpy(self):
         import numpy as np
@@ -4213,17 +4211,14 @@
 
     def as_coeff_mmul(self):
         return 1, self
 
     def _sympystr(self, _):
         return '\N{GREEK SMALL LETTER PI}'
 
-    def is_consistently_of(self, struct):
-        return struct.is_Pi
-
 
 pi = S.Pi
 
 
 class GoldenRatio(with_metaclass(Singleton, NumberSymbol)):
     r"""The golden ratio, `\phi`.
 
@@ -4641,15 +4636,15 @@
     is_prime = False
 
     __slots__ = []
     is_infinitesimal = True
 
     @classmethod
     def class_key(cls):
-        # this value should be big enough, bigger than ExprWithLimits, so that Infinitesimal will be put at the rear of the _argset
+        # this value should be big enough, bigger than ExprWithLimits, so that Infinitesimal will be put at the rear of the _argset        
         return 6, 1, 'Number'
 
     def clear_infinitesimal(self):
         return S.Zero, self
 
     def __new__(cls):
         return AtomicExpr.__new__(cls)
@@ -4743,26 +4738,26 @@
         See Also
         ========
         Pow
         NaN
         NegativeInfinity
 
         """
+        from sympy.functions import re
 
         if expt.is_extended_positive:
             return self
         if expt.is_extended_negative:
             return S.Infinity
         if expt is S.NaN:
             return S.NaN
         if expt is S.ComplexInfinity:
             return S.NaN
         if expt.is_extended_real == False and expt.is_number:
-            from sympy.functions import Re
-            expt_real = Re(expt)
+            expt_real = re(expt)
             if expt_real.is_positive:
                 return S.ComplexInfinity
             if expt_real.is_negative:
                 return S.Zero
             if expt_real.is_zero:
                 return S.NaN
 
@@ -4841,17 +4836,14 @@
 
     def ceiling(self):
         return S.One
 
     def __neg__(self):
         return S.NegativeInfinitesimal
 
-    def _eval_exp(self):
-        return S.One + self
-
 
 epsilon = S.Infinitesimal
 
 
 class NegativeInfinitesimal(with_metaclass(Singleton, Number)):
     r"""Positive Infinitesimal
 
@@ -5067,12 +5059,9 @@
 
     def ceiling(self):
         return S.One
 
     def __neg__(self):
         return S.Infinitesimal
 
-    def _eval_exp(self):
-        return S.One + self
-
 
 _register_classes()
```

### Comparing `sympy.keras-1.0.21/sympy/core/of.py` & `sympy.keras-1.0.4/sympy/core/of.py`

 * *Files 1% similar despite different names*

```diff
@@ -433,15 +433,15 @@
         if cls.is_Wanted: 
             if isinstance(cls.func, type):
                 return isinstance(self, cls.func)
             
             cls = cls.func
                 
         if not isinstance(self, cls.func):
-            return False
+            return False        
         j = 0
         i = 0
         while j < len(self.args):
             struct = cls.args[i]
             if self.args[j].instanceof(struct):
                 i += 1
                 if i == len(cls.args):
@@ -459,15 +459,15 @@
                 if len(args) == 1:
                     return args[0]
                 return args
             else:
                 return
         
         if not isinstance(self, cls.func):
-            return
+            return        
         j = 0
         i = 0
         
         args = []
         while j < len(self.args):
             struct = cls._args[i]
             this = self.args[j]
@@ -544,15 +544,15 @@
                         continue
                     if arg.is_wanted():
                         break
                 else:
                     raise Exception('not wanted??')
                 s = s.args[i]
             
-        return query, struct
+        return query, struct                                   
         
     def find(self, *query): 
         query, struct = Basic.make_query(*query)
             
         return self.yield_one([(q, []) for q in query],
                             foreach=Basic.find_path,
                             func=Basic.fetch_from_path,
@@ -619,15 +619,15 @@
                     yield from func(self, *_output).yield_all(limits,
                                                     foreach=foreach,
                                                     func=func,
                                                     fetch=fetch,
                                                     output=output + _output,
                                                     **kwargs)
             except GeneratorExit as e:
-                raise e
+                raise e                        
             except: 
                 continue
 
         
     def __add__(self, other):
         from sympy import Add
         other = sympify(other)
@@ -705,32 +705,29 @@
                 args = (S.NegativeOne,) + self.args
         else:
             args = (S.NegativeOne, self)
             
         return Basic.__new__(Mul, *args)
     
     def __invert__(self):
-        from sympy.core.core import Wanted
+        from sympy.core.core import Wanted         
         return Wanted(self)
     
     def __floordiv__(self, other):
-        from sympy import Floor
+        from sympy import Floor   
         other = sympify(other)     
         return Basic.__new__(Floor, self / other)
     
     def __truediv__(self, other):
         from sympy import Mul, Pow, S
         other = sympify(other)
         if other.is_Integer:
             other = 1 / other
             if self.is_Mul:
-                if self.args[0].is_Number:
-                    args = (other * self.args[0],) + self.args[1:]
-                else:
-                    args = (other,) + self.args
+                args = (other,) + self.args 
             else:
                 args = (other, self)
         else:
             other = Basic.__new__(Pow, other, S.NegativeOne)
             if self.is_Mul:
                 args = self.args + (other,)
             else:
@@ -739,19 +736,19 @@
     
     def __rtruediv__(self, lhs):
         from sympy import Mul, Pow, S
         lhs = sympify(lhs)
         
         pow = Basic.__new__(Pow, self, S.NegativeOne)
         if lhs == 1:
-            return pow
+            return pow                    
         return Basic.__new__(Mul, lhs, pow)
 
     def __mod__(self, other):
-        from sympy import Mod
+        from sympy import Mod        
         other = sympify(other)
         return Basic.__new__(Mod, self, other)
     
     def __pow__(self, other):
         from sympy import Pow
         other = sympify(other)
         return Basic.__new__(Pow, self, other)
```

### Comparing `sympy.keras-1.0.21/sympy/core/operations.py` & `sympy.keras-1.0.4/sympy/core/operations.py`

 * *Files 1% similar despite different names*

```diff
@@ -4,15 +4,15 @@
 
 from sympy.utilities.exceptions import SymPyDeprecationWarning
 
 from sympy.core.sympify import _sympify as _sympify_, sympify
 from sympy.core.basic import Basic
 from sympy.core.cache import cacheit
 from sympy.core.compatibility import ordered, default_sort_key
-from sympy.core.logic import _fuzzy_group
+from sympy.core.logic import fuzzy_and, _fuzzy_group
 from sympy.core.parameters import global_parameters
 from sympy.utilities.iterables import sift
 from sympy.multipledispatch.dispatcher import (Dispatcher,
     ambiguity_register_error_ignore_dup,
     str_signature, RaiseNotImplementedError)
 
 
@@ -522,30 +522,14 @@
             elif isinstance(indices, tuple):
                 args.append(arg[indices[len_shape - shape_length:]])
             else:
                 args.append(arg[indices])
 
         return self.func(*args)
 
-    @property
-    def variables(self):
-        s = set()
-        for a in self.args:
-            s |= {*a.variables}
-            
-        return s
-    
-    def yield_random_symbols(self):    
-        for arg in self.args:
-            yield from arg.yield_random_symbols()
-        
-    def domain_definition(self):
-        from sympy import And
-        return And(*(arg.domain_definition() for arg in self.args))
-
 
 class ShortCircuit(Exception):
     pass
 
 
 class LatticeOp(AssocOp):
     """
@@ -673,40 +657,35 @@
             return frozenset([sympify(expr)])
 
     # XXX: This should be cached on the object rather than using cacheit
     # Maybe _argset can just be sorted in the constructor?
     @property  # type: ignore
     @cacheit
     def args(self):
-        return tuple(sorted(self._argset, key=lambda x: x.sort_key()))
+#         print('possible disorder!', __file__)
+#         print('possible bugs here!', __file__)
+#         return tuple(ordered(self._argset))
+        return tuple(sorted(self._argset, key=lambda x: str(x)))
 
     @staticmethod
     def _compare_pretty(a, b):
         return (str(a) > str(b)) - (str(a) < str(b))
 
     def of(self, cls):
         res = AssocOp.of(self, cls)
         if res is None:
             if cls.is_LatticeOp:
+                a, b = cls.args
                 from sympy.core.of import Basic
-                if isinstance(cls, Basic) or cls.is_IndexedOperator:
-                    a, b = cls.args
-                    cls = Basic.__new__(cls.func, b, a)
-                    res = AssocOp.of(self, cls)
-                    if isinstance(res, tuple):
-                        b, a = res
-                        return a, b
-        return res
-
-    @cacheit
-    def sort_key(self, order=None):
-        args = self._sorted_args
-        args = len(args), tuple(arg.class_key() for arg in args), tuple(arg.sort_key(order=order) for arg in args)
-        from sympy import S
-        return self.class_key(), args, S.One.sort_key(), S.One
+                cls = Basic.__new__(cls.func, b, a)
+                res = AssocOp.of(self, cls)
+                if isinstance(res, tuple):
+                    b, a = res
+                    return (a, b)
+        return res 
 
 
 class AssocOpDispatcher:
     """
     Handler dispatcher for associative operators
 
     .. notes::
```

### Comparing `sympy.keras-1.0.21/sympy/core/parameters.py` & `sympy.keras-1.0.4/sympy/core/parameters.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/core/power.py` & `sympy.keras-1.0.4/sympy/core/power.py`

 * *Files 2% similar despite different names*

```diff
@@ -340,15 +340,15 @@
 
         b = _sympify(b)
         e = _sympify(e)
         if evaluate:
             if e is S.ComplexInfinity:
                 return S.NaN
             if e is S.Zero:
-                from sympy import OneMatrix
+                from sympy import OneMatrix                
                 return OneMatrix(*b.shape)
             elif e is S.One:
                 return b
             elif e == -1 and not b:
                 return S.ComplexInfinity
             # Only perform autosimplification if exponent or base is a Symbol or number
             elif (b.is_Symbol or b.is_number) and (e.is_Symbol or e.is_number) and\
@@ -376,15 +376,15 @@
                         if s.is_Number and s and den == \
                                 log(-factor_terms(b, sign=False)) + s * S.ImaginaryUnit * S.Pi:
                             return S.Exp1 ** (c * numer(ex))
 
                 try:
                     obj = b._eval_power(e)
                 except (AttributeError, TypeError):
-                    from sympy import sympify, Basic
+                    from sympy import sympify, Basic  
                     if isinstance(e, int):
                         e = sympify(e)
                     return Basic.__new__(Pow, b, e)
                 
                 if obj is not None:
                     return obj
         obj = Expr.__new__(cls, b, e)
@@ -432,16 +432,14 @@
         from sympy import arg, exp, floor, Im, log, Re, sign
         b, e = self.as_base_exp()
         if b is S.NaN:
             return (b ** e) ** other  # let __new__ handle it
 
         s = None
         if other.is_integer:
-            if b.is_NegativeOne and other.is_odd:
-                return self
             s = 1
         elif b.is_polar:  # e.g. exp_polar, besselj, var('p', polar=True)...
             s = 1
         elif e.is_extended_real is not None:
 
             # helper functions ===========================
             def _half(e):
@@ -918,24 +916,24 @@
 
         b, e = self.args
         if b.is_Rational and b.p == 1 and b.q != 1:
             return Integer(b.q), -e
         return b, e
 
     def _eval_adjoint(self):
-        from sympy import Adjoint
+        from sympy.functions.elementary.complexes import adjoint
         i, p = self.exp.is_integer, self.base.is_positive
         if i:
-            return Adjoint(self.base) ** self.exp
+            return adjoint(self.base) ** self.exp
         if p:
-            return self.base ** Adjoint(self.exp)
+            return self.base ** adjoint(self.exp)
         if i is False and p is False:
             expanded = expand_complex(self)
             if expanded != self:
-                return Adjoint(expanded)
+                return adjoint(expanded)
 
     def _eval_conjugate(self):
         from sympy.functions.elementary.complexes import conjugate as c
         i, p = self.exp.is_integer, self.base.is_positive
         if i:
             return c(self.base) ** self.exp
         if p:
@@ -945,23 +943,24 @@
             if expanded != self:
                 return c(expanded)
         if self.is_extended_real:
             return self
 
     def _eval_transpose(self, axis=-1):
         if axis == self.default_axis:
+            from sympy.functions.elementary.complexes import transpose
             i, p = self.exp.is_integer, self.base.is_complex
             if p:
-                return self.base.T ** self.exp
+                return self.base ** self.exp
             if i:
-                return self.base.T ** self.exp
+                return transpose(self.base) ** self.exp
             if i is False and p is False:
                 expanded = expand_complex(self)
                 if expanded != self:
-                    return expanded.T
+                    return transpose(expanded)
 
     def _eval_expand_power_exp(self, **hints):
         """a**(n + m) -> a**n*a**m"""
         b = self.base
         e = self.exp
 #         if e.is_Add and e.is_commutative:
         if e.is_Add:
@@ -1289,38 +1288,17 @@
                 else:
                     return (Re(expanded), Im(expanded))
             else:
                 return (Re(self), Im(self))
 
     def _eval_derivative(self, s):
         from sympy import log
-        base, exp = self.args
-        if s.shape:
-            if exp.shape:
-                dbase = base.diff(s)
-                dexp = exp.diff(s)
-                return self * (dexp * log(base) + dbase * exp / base)
-            elif base.shape:
-                dbase = base.diff(s)
-                dexp = exp.diff(s)
-                if len(self.shape) < len(dbase.shape):
-                    from sympy import Transpose
-                    self = Transpose.expand_dims(self, dbase.shape, len(s.shape))
-                    base = Transpose.expand_dims(base, dbase.shape, len(s.shape))
-
-                return self * (dexp * log(base) + dbase * exp / base)
-            else:
-                dbase = base.diff(s)
-                dexp = exp.diff(s)
-                return self * (dexp * log(base) + dbase * exp / base)
-                
-        else:
-            dbase = base.diff(s)
-            dexp = exp.diff(s)
-            return self * (dexp * log(base) + dbase * exp / base)
+        dbase = self.base.diff(s)
+        dexp = self.exp.diff(s)
+        return self * (dexp * log(self.base) + dbase * self.exp / self.base)
 
     def _eval_evalf(self, prec):
         base, exp = self.as_base_exp()
         base = base._evalf(prec)
         if not exp.is_Integer:
             exp = exp._evalf(prec)
         if exp.is_negative and base.is_number and base.is_extended_real == False:
@@ -1931,37 +1909,39 @@
     def _sympystr(self, p, rational=False):
         from sympy.printing.precedence import precedence
         PREC = precedence(self)
 
         import re
         if self.exp is S.Half and not rational:
             arg = p._print(self.base)
-            # return "\N{SQUARE ROOT}(%s)" % arg
-            return "sqrt(%s)" % arg
+            if re.compile('\w+').fullmatch(arg):
+                return "\N{SQUARE ROOT}" + arg
+            return "\N{SQUARE ROOT}(%s)" % arg
 
 #         if self.is_commutative:
         if -self.exp is S.Half and not rational:
             # Note: Don't test "self.exp == -S.Half" here, because that will
             # match -0.5, which we don't want.
             arg = p._print(self.base)
-            # return "1/\N{SQUARE ROOT}(%s)" % arg
-            return "1 / sqrt(%s)" % arg
+            if re.compile('\w+').fullmatch(arg):
+                return "1/\N{SQUARE ROOT}" + arg
+            return "1/\N{SQUARE ROOT}(%s)" % arg
         
         if self.exp is -S.One:
             # Similarly to the S.Half case, don't test with "==" here.
-            return '%s / %s' % (p._print(S.One),
+            return '%s/%s' % (p._print(S.One),
                               p.parenthesize(self.base, PREC, strict=False))
 
         e = p.parenthesize(self.exp, PREC, strict=False)
         if p.printmethod == '_sympyrepr' and self.exp.is_Rational and self.exp.q != 1:
             # the parenthesized exp should be '(Rational(a, b))' so strip parens,
             # but just check to be sure.
             if e.startswith('(Rational'):
-                return '%s ** %s' % (p.parenthesize(self.base, PREC, strict=False), e[1:-1])
-        return '%s ** %s' % (p.parenthesize(self.base, PREC, strict=False), e)
+                return '%s**%s' % (p.parenthesize(self.base, PREC, strict=False), e[1:-1])
+        return '%s**%s' % (p.parenthesize(self.base, PREC, strict=False), e)
     
     def _pretty(self, p):
         from sympy.simplify.simplify import fraction
         b, e = self.as_base_exp()
         from sympy.printing.pretty.stringpict import prettyForm
         
         if e is S.NegativeOne:
@@ -2039,94 +2019,15 @@
             return Conjugate(b) ** e
         return Conjugate(self)
 
     def _eval_torch(self):
         b, e = self.args
         return b.torch ** e.torch
     
-    @staticmethod
-    def simplify_Lamda(self, squeeze=False):
-        expr, *limits = self.args
-        b, e = expr.args
-        if e.shape:
-            if not b.shape:
-                if e.has(*self.variables):
-                    lamda = self.func(e, *self.limits)
-                    _lamda = lamda.simplify()
-                    if lamda != _lamda:
-                        return expr.func(b, _lamda, evaluate=False)
-                
-        else:
-            if b.has(*self.variables):
-                lamda = self.func(b, *self.limits)
-                _lamda = lamda.simplify()
-                if lamda != _lamda:
-                    return expr.func(_lamda, e, evaluate=False)
-
-        return self
     
-    def monotonicity(self, x):
-        b, e = self.args
-        if e < 0:
-            if e._has(x):
-                ...
-            else:
-                if e.is_integer:
-                    if b > 0 or b < 0:
-                        expr, monotonicity = b.monotonicity(x)
-                        if not monotonicity:
-                            return None, 0
-                        
-                        return expr ** e, -monotonicity
-
-        elif e > 0:
-            if e._has(x):
-                if b > 0:
-                    if b._has(x):
-                        ...
-                    else:
-                        expr, monotonicity = e.monotonicity(x)
-                        if not monotonicity:
-                            return None, 0
-                        
-                        return b ** expr, monotonicity
-            else:
-                if b > 0:
-                    expr, monotonicity = b.monotonicity(x)
-                    if not monotonicity:
-                        return None, 0
-                    
-                    return expr ** e, monotonicity
-
-        return None, 0
-
-    @cacheit
-    def sort_key(self, order=None):
-        expr, exp = self.args
-
-        if expr.is_Dummy:
-            args = (expr.sort_key(),)
-        elif expr.is_Atom:
-            args = (str(expr),)
-        else:
-            if expr.is_Add:
-                args = expr.as_ordered_terms(order=order)
-            elif expr.is_Mul:
-                args = expr.as_ordered_factors(order=order)
-            else:
-                args = expr.args
-
-            args = tuple(arg.sort_key(order=order) for arg in args)
-
-        args = len(args), tuple(arg.class_key() for arg in self.args), args
-        exp = exp.sort_key(order=order)
-
-        return expr.class_key(), args, exp, S.One
-
-
 from .add import Add
 from .numbers import Integer
 from .mul import Mul, _keep_coeff
 from .symbol import Symbol, Dummy, symbols
 
 
 def cbrt(arg, evaluate=None):
@@ -2312,15 +2213,15 @@
 
     sympy.polys.rootoftools.rootof
     sympy.core.power.integer_nthroot
     root, sqrt
     """
     from sympy.functions.elementary.complexes import Abs, Im, sign
     from sympy.functions.elementary.piecewise import Piecewise
-    from sympy import Or, Eq, And, Mod, sympify
+    from sympy import Or, Eq, And, Mod, sympify 
     from sympy.core.rules import Transform
     if n is not None:
         return Piecewise(
             (root(arg, n, evaluate=evaluate), Or(Eq(n, S.One), Eq(n, S.NegativeOne))),
             (Mul(sign(arg), root(Abs(arg), n, evaluate=evaluate), evaluate=evaluate),
             And(Eq(Im(arg), S.Zero), Eq(Mod(n, 2), S.One))),
             (root(arg, n, evaluate=evaluate), True))
```

### Comparing `sympy.keras-1.0.21/sympy/core/relational.py` & `sympy.keras-1.0.4/sympy/core/relational.py`

 * *Files 1% similar despite different names*

```diff
@@ -7,14 +7,20 @@
 from .sympify import _sympify
 from .parameters import global_parameters
 from sympy.core.logic import fuzzy_bool, fuzzy_xor, fuzzy_and, fuzzy_not
 from sympy.logic.boolalg import Boolean, BooleanAtom, BinaryCondition
 from sympy.core.sympify import sympify, SympifyError
 from sympy.core.cache import cacheit
 
+__all__ = (
+    'Rel', 'Eq', 'Ne', 'Lt', 'Le', 'Gt', 'Ge',
+    'Relational', 'Equal', 'Unequal', 'Less', 'LessEqual',
+    'Greater', 'GreaterEqual',
+)
+
 from .expr import Expr
 from sympy.multipledispatch import dispatch
 from .containers import Tuple
 from .symbol import Symbol
 
 
 def _nontrivBool(side):
@@ -302,23 +308,14 @@
             return BinaryCondition.simplify(self, deep=True, wrt=wrt)        
 
         lhs, rhs = self.args
         this = self.lhs.func.simplify_Relational(self, lhs, rhs)
         if this is not None:
             return this
         
-        if rhs.is_Mul:
-            if rhs.args[0].is_OneMatrix:
-                if lhs.shape == rhs.shape:
-                    rhs = rhs.func(*rhs.args[1:])
-                    return self.func(lhs, rhs, evaluate=False)
-        elif rhs.is_OneMatrix:
-            if lhs.shape == rhs.shape:
-                return self.func(lhs, S.One, evaluate=False)
-                
         return self
 
     def doit(self, *args, **kwargs):
         return self.func(self.lhs.doit(*args, **kwargs), self.rhs.doit(*args, **kwargs))
 
     def __add__(self, other):
         other = sympify(other)
@@ -336,15 +333,15 @@
         other = sympify(other)
         if other.is_Equal: 
             return self.func(self.lhs - other.lhs, self.rhs - other.rhs, **other.add_sub_assumptions(self))
         elif other.is_Quantifier:
             return self.bfn(self.__sub__, other)
         else: 
             assert not other.is_set
-            assert other.is_complex, 'try to prove %s is complex' % other
+            assert other.is_complex, 'try to prove %s is complex' % other 
             return self.func((self.lhs - other).simplify(), (self.rhs - other).simplify())
 
     def __mul__(self, other):
         if isinstance(other, Equal):
             if other.lhs.is_nonzero or other.rhs.is_nonzero:
                 return self.func(self.lhs * other.lhs, self.rhs * other.rhs)
             return self.func(self.lhs * other.lhs, self.rhs * other.rhs, given=[self, other])
@@ -430,28 +427,51 @@
             ">=": r"\geq",
             "<=": r"\leq",
             "!=": r"\neq",
         }
 
         return "%s %s %s" % (p._print(self.lhs), charmap[self.rel_op], p._print(self.rhs))
 
-    def domain_conditioned_utility(self, var):
-        if self.lhs.is_set or var.shape or var.is_set:
-            return
+    def domain_conditioned(self, var):
+        from sympy.sets.sets import FiniteSet
+        domain = var.domain & self.domain_defined(var)
+        if var.shape or var.is_set:
+            return BinaryCondition.domain_conditioned(self, var)
         
         equation = self.lhs - self.rhs
+        
         p = equation.as_poly(var)
         if not p or p.degree() != 1:
-            return
+            return BinaryCondition.domain_conditioned(self, var)
          
         a = p.nth(1)
         if a.is_nonzero:
             b = p.nth(0)
             solution = -b / a
-            return a, solution, var.domain & self.domain_defined(var)
+            op = type(self)
+            if a.is_extended_negative:
+                a = -a
+                dic = {Equal: Equal, Greater: Less, GreaterEqual: LessEqual, Less: Greater, LessEqual: GreaterEqual, Unequal: Unequal}
+                op = dic[op]
+                            
+            from sympy import Interval
+            if op == LessEqual:
+                domain &= Interval(S.NegativeInfinity, solution)
+            elif op == GreaterEqual:
+                domain &= Interval(solution, S.Infinity)
+            elif op == Less:
+                domain &= Interval(S.NegativeInfinity, solution, right_open=True)
+            elif op == Greater:
+                domain &= Interval(solution, S.Infinity, left_open=True)
+            elif op == Unequal:
+                domain -= FiniteSet(solution)
+            elif op == Equal:
+                domain &= FiniteSet(solution)
+
+        return domain
 
     @cacheit
     def _eval_domain_defined(self, x, **_):
         return self.lhs.domain_defined(x, real=True) & self.rhs.domain_defined(x, real=True)
 
     def invert(self):
         lhs, rhs = self.args
@@ -487,21 +507,15 @@
                 lhs, rhs = lhs[indices], rhs[indices]
             
             eq = Boolean.__new__(self.invert_type, lhs, rhs)
             from sympy.concrete.exists import Any
             return Any(eq, *limits[::-1])
         
         return BinaryCondition.invert(self)
-
-    @classmethod
-    def class_key(cls):
-        """Nice order of classes. """
-        return 5, cls.sub_class_key(), cls.__name__
-
-
+                    
 Rel = Relational
 
 
 class Equal(Relational):
     """An equal relation between two objects.
 
     Explanation
@@ -708,15 +722,15 @@
             return Or(self.func(other, 0), self.func(lhs, rhs))
 
     def __rmul__(self, lhs):
         return self.__mul__(lhs)
         
     def __mod__(self, other):
         other = sympify(other)
-        assert other.is_integer
+        assert other.is_integer        
         return Eq(self.lhs % other, self.rhs % other, given=self)
      
     def __mul__(self, other):
         other = sympify(other)
         if isinstance(other, Equal):
             if other.lhs.is_nonzero or other.rhs.is_nonzero:
                 return Eq(self.lhs * other.lhs, self.rhs * other.rhs)
@@ -770,15 +784,15 @@
     def __rpow__(self, other):
         if other.is_positive:
             return self.func(other ** self.lhs, other ** self.rhs)
         
         if self.lhs.is_positive or self.rhs.is_positive:
             return self.func(other ** self.lhs, other ** self.rhs, given=self)
         
-        return self
+        return self    
 
     def __pow__(self, other):
         other = sympify(other)
         if other.is_positive:
             return self.func(self.lhs ** other, self.rhs ** other, given=self)
         return self
         
@@ -929,15 +943,15 @@
 
         if x is not None and not y._has(x):
             domain = limits_dict[x]
             if isinstance(domain, Boolean):
                 function = domain._subs(x, y)
                 if function == False:
                     function = self.limits_cond.invert()
-                    return function
+                    return function                
 
     def simplify_Intersection(self, lhs):
         if len(lhs.args) == 2:
             A, B = lhs.args
             if A.is_FiniteSet and B.is_FiniteSet:
                 if len(A) == len(B) == 1:
                     return Unequal(A.arg, B.arg)
@@ -962,50 +976,36 @@
                     return self
                 if eq == False:
                     return S.false
                 
         elif isinstance(other, (Less, Greater)):
             if set(self.args) == set(other.args):
                 return S.false
-
         elif other.is_GreaterEqual or other.is_LessEqual:
             if set(self.args) == set(other.args):
                 return self
-            
-        elif other.is_Unequal:
-            return other.__and__(self)
-
         elif other.is_NotElement:
             if self.lhs == other.lhs:
                 if self.rhs in other.rhs:
                     return S.false
             elif self.rhs == other.lhs:
                 if self.lhs in other.rhs:
                     return S.false
         elif other.is_Element:
             from sympy import Element
-            if self.lhs == other.lhs:
-                cond = Element(self.rhs, other.rhs) 
-                if cond == False:
+            if self.lhs == other.lhs: 
+                if Element(self.rhs, other.rhs).is_BooleanFalse:
                     return S.false
-                
-                if cond:
-                    return self
             elif self.rhs == other.lhs:
-                cond = Element(self.lhs, other.rhs)
-                if cond == False:
+                if Element(self.lhs, other.rhs).is_BooleanFalse:
                     return S.false
-
-                if cond:
-                    return self
-
         return Relational.__and__(self, other)
 
     def _sympystr(self, p):
-        return 'Equal(%s, %s)' % tuple(p._print(arg) for arg in self.args)
+        return '%s == %s' % tuple(p._print(arg) for arg in self.args)
 
     def add_sub_assumptions(self, other):
         kwargs = {}
         if other.lhs.is_set:
             if self.plausible is None:
                 if other.plausible is None:
                     kwargs['equivalent'] = self
@@ -1053,75 +1053,57 @@
             if self.lhs == other.lhs and self.lhs.is_integer and self.rhs == other.rhs + 1:
 #                 x == 3 and x <= 2 => x <= 3
                 return LessEqual(*self.args)
         elif other.is_GreaterEqual:
             if {*other.args} == {*self.args}:
                 return other
             if self.lhs == other.lhs and self.lhs.is_integer and self.rhs + 1 == other.rhs:
-#                 x == 3 and x >= 2 => x >= 3
+#                 x == 3 and x >= 2 => x >= 3                
                 return GreaterEqual(*self.args)
             
         return Relational.__or__(self, other)
 
     def simplify_condition_on_random_variable(self):
         lhs, rhs = self.args
         from sympy.stats.rv import pspace
         if lhs.is_symbol and pspace(lhs).symbol == rhs:
             return lhs
-        return self
+        return self             
 
     def _latex(self, p):
         lhs = self.lhs
         rhs = self.rhs
-
+                    
         if lhs.is_random and lhs.is_symbol:
             from sympy.stats.rv import pspace
             if rhs == pspace(lhs).symbol:
-                return lhs._latex(p)
-            if rhs.is_Surrogate and rhs.arg == lhs:
-                return rhs._latex(p)
+                return p._print(lhs)
             
-        if lhs.is_Conditioned or rhs.is_Conditioned:
-            lex = r"{%s}{\color{blue}{\ =\ }}{%s}"
-        else:
-            lex = "{%s}={%s}"
-        return lex % (p._print(lhs), p._print(rhs))
+        return "%s = %s" % (p._print(lhs), p._print(rhs))
 
     def domain_conditioned(self, var):
-        lhs, rhs = self.args
         if var.shape:
-            if lhs == var:
-                return rhs.set
+            if self.lhs == var:
+                return self.rhs.set
             
-            if rhs == var:
-                return lhs.set
+            if self.rhs == var:
+                return self.lhs.set
             
             return BinaryCondition.domain_conditioned(self, var)
         
         if var.is_set:
             if self._has(var):
                 from sympy.sets.sets import conditionset
                 return conditionset(var, self, var.domain)
-            from sympy import Piecewise
-            return Piecewise((var.domain, self), (var.emptySet, True))
-
-        if ret := self.domain_conditioned_utility(var):
-            a, solution, domain = ret
-            return domain & {solution}
-
-        if lhs.is_Mod:
-            if lhs.args[0] == var:
-                d = lhs.args[1]
-                if d > 0 and rhs >= 0 and rhs < d:
-                    # x % d == t => x in Range(t, oo, d)
-                    from sympy import Range, oo
-                    domain = var.domain & self.domain_defined(var)
-                    return domain & (Range(rhs, oo, d) | Range(rhs - d, -oo, -d))
-                
-        return BinaryCondition.domain_conditioned(self, var)
+            else:
+                from sympy.functions.elementary.piecewise import Piecewise
+                return Piecewise((var.domain, self), (var.emptySet, True))
+        else:
+            if not self.lhs.is_set:
+                return Relational.domain_conditioned(self, var)
 
     def of(self, cls):
         res = Boolean.of(self, cls)
         if res is None:
             if cls.is_Equal and len(cls.args) == 2:
                 a, b = cls.args
                 cls = Basic.__new__(Equal, b, a)
@@ -1136,72 +1118,23 @@
                 args = cls.args
                 if isinstance(args, tuple) and len(args) == 1:
                     _a, _b = res
                     a, b = self.args
                     if a is _a:
                         return (_b, _a)
             
-        return res
+        return res 
 
     invert = BinaryCondition.invert
     
     def _eval_torch(self):
         import torch
         return torch.eq(self.lhs.torch, self.rhs.torch)
     
-    def _subs_sliced(self, old, new, **hints):        
-        lhs, rhs = self.args
-        if lhs.is_random and lhs.is_symbol and not rhs.is_random and old.is_random and old.is_symbol and not new.is_random:
-            if lhs == old:
-                return self
-
-        return Relational._subs_sliced(self, old, new, **hints)
     
-    def _subs(self, old, new, **kwargs):
-        lhs, rhs = self.args
-        if lhs.is_random and lhs.is_symbol:
-            if new == lhs and rhs == old:
-                if old == lhs.var or not rhs.is_random:
-                    new = new.surrogate
-                    return self.func(lhs, new, evaluate=False)
-            elif old == lhs:
-                if not rhs.is_random and not rhs.is_Surrogate:
-                    return self
-
-        try:
-            return super(Equal, self)._subs(old, new, **kwargs)
-        except Exception as e:
-            if e.args[0] == 'empty slices':
-                if lhs.is_Sliced and rhs.is_Sliced:
-                    if lhs.catch_exception(old, new) and rhs.catch_exception(old, new):
-                        return S.true
-            raise e
-
-    def _try_to_substitute(self, other, new):
-        if not other.is_Equal:
-            return
-        
-        if self.lhs != other.lhs:
-            return
-        
-        rhs = self.rhs
-        _rhs = other.rhs
-        
-        if rhs == _rhs:
-            ...
-        
-        if rhs.is_Surrogate:
-            if rhs.arg.var == _rhs:
-                return new._subs(_rhs, rhs)
-
-    @classmethod
-    def sub_class_key(cls):
-        return -6
-
-
 Eq = Equal
 
 
 class Unequal(Relational):
     """An unequal relation between two objects.
 
     Explanation
@@ -1236,16 +1169,15 @@
     """
     rel_op = '!='
 
     invert_type = Equal
     __slots__ = ()
 
     def _sympystr(self, p):
-        # return '%s \N{NOT EQUAL TO} %s' % tuple(p._print(arg) for arg in self.args)
-        return 'Unequal(%s, %s)' % tuple(p._print(arg) for arg in self.args)
+        return '%s \N{NOT EQUAL TO} %s' % tuple(p._print(arg) for arg in self.args)
 
     def __new__(cls, lhs, rhs, **options):
         lhs = _sympify(lhs)
         rhs = _sympify(rhs)
         evaluate = options.pop('evaluate', global_parameters.evaluate)
         if evaluate:
             is_equal = Equal(lhs, rhs)
@@ -1320,57 +1252,55 @@
         
         return super(Unequal, self).simplify()
 
     def __and__(self, other):
         """Overloading for & operator"""
         if other.is_Or:
             return other.__and__(self)
-
         if isinstance(other, LessEqual):
             if set(self.args) == set(other.args):
                 return Less(other.lhs, other.rhs)
 
         if isinstance(other, GreaterEqual):
             if set(self.args) == set(other.args):
                 return Greater(other.lhs, other.rhs)
 
         if isinstance(other, (Less, Greater)):
             if set(self.args) == set(other.args):
                 return other
 
-        if other.is_Equal:
-            if self.lhs == other.lhs:
-                cond = Equal(self.rhs, other.rhs)
-                if cond:
-                    return S.false
-                
-                if cond == False:
-                    return other
-
-            elif self.lhs == other.rhs:
-                cond = Equal(self.rhs, other.lhs)
-                if cond:
-                    return S.false
-
-                if cond == False:
+        if isinstance(other, Equal):
+            argset = {*self.args}
+            _argset = {*other.args}
+            x = argset & _argset
+            if len(x) == 2:
+                return S.false
+            elif len(x) == 1:
+                x, *_ = x
+                argset.remove(x)
+                _argset.remove(x)
+                lhs, *_ = argset
+                rhs, *_ = _argset
+                eq = Equal(lhs, rhs).simplify()
+                if eq.is_BooleanFalse: 
                     return other
                 
         return Relational.__and__(self, other)
 
     def __truediv__(self, other):
         if other.is_Equal:
             if other.lhs.is_nonzero or other.rhs.is_nonzero:
                 return self.func(self.lhs / other.lhs, self.rhs / other.rhs)
             return self
         else:
             if other.is_nonzero:
                 return self.func((self.lhs / other).ratsimp(), (self.rhs / other).ratsimp())
             if other.is_zero:
                 return self
-            from sympy import Or
+            from sympy import Or 
             return Or(Equal(other, 0), self.func((self.lhs / other).ratsimp(), (self.rhs / other).ratsimp()))
 
     def __mul__(self, other):
         if isinstance(other, Unequal):
             return self.func(self.lhs * other.lhs, self.rhs * other.rhs, given=[self, other])
         
         return Relational.__mul__(self, other)
@@ -1384,54 +1314,30 @@
                 return S.true
         elif isinstance(other, GreaterEqual):
             if self.lhs == other.lhs and self.rhs >= other.rhs or \
             self.lhs == other.rhs and other.rhs >= self.rhs or \
             self.rhs == other.lhs and self.lhs >= other.rhs or \
             self.rhs == other.rhs and other.lhs >= self.rhs:
                 return S.true
-        elif other.is_Or:
-            for cond in other.args:
-                if cond.is_NotElement:
-                    e, s = cond.args
-                    if e == self.rhs and s._contains(self.lhs) == False or \
-                    e == self.lhs and s._contains(self.rhs) == False:
-                        return S.true
             
         return Relational.__or__(self, other)
 
     def domain_conditioned(self, var):
-        if ret := self.domain_conditioned_utility(var):
-            a, solution, domain = ret
-            return domain - {solution}
-
-        lhs, rhs = self.args
-        if lhs.is_Mod:
-            if lhs.args[0] == var:
-                d = lhs.args[1]
-                if d > 0 and rhs >= 0 and rhs < d:
-                    # x % d == t => x in Range(t, oo, d)
-                    from sympy import Range, oo
-                    domain = var.domain & self.domain_defined(var)
-                    return domain - (Range(rhs, oo, d) | Range(rhs - d, -oo, -d))
-
+        if not self.lhs.is_set: 
+            return Relational.domain_conditioned(self, var)
         return BinaryCondition.domain_conditioned(self, var)
     
     of = Equal.of
 
     invert = BinaryCondition.invert
 
     def _eval_torch(self):
-        import torch
+        import torch 
         return torch.ne(self.lhs.torch, self.rhs.torch)
 
-    @classmethod
-    def sub_class_key(cls):
-        return -5
-
-
 Ne = Unequal
 Equal.invert_type = Unequal
 
 
 class Inequality(Relational):
     """Internal base class for all *Than types.
 
@@ -1569,18 +1475,18 @@
     @property
     def lts(self):
         return self._args[0]
 
     def __and__(self, other):
         if isinstance(other, _Greater):
             if self.rhs == other.rhs: 
-                left = self.lhs
+                left = self.lhs 
                 left_open = isinstance(self, Less)
                 
-                right = other.lhs
+                right = other.lhs 
                 right_open = isinstance(other, Greater)
                 
                 if left_open:
                     if right_open:
                         ...
                     else:
                         if left >= right:
@@ -1889,37 +1795,37 @@
                 if self.rhs == other.rhs:
                     return Equal(*self.args)
                 if other.rhs < self.rhs:
                     return S.false
         if isinstance(other, Less):
             if self.lhs == other.lhs:
                 if self.rhs >= other.rhs:
-                    return S.false
+                    return S.false            
         elif isinstance(other, Greater):
             if self.lhs == other.lhs:
                 if self.rhs <= other.rhs:
                     return other
 #                 x >= 1 and x > 0
                 if self.rhs > other.rhs:
                     return self
         elif isinstance(other, Unequal):
             if {*self.args} == {*other.args}:
                 return Greater(self.lhs, self.rhs)            
         elif isinstance(other, Equal):
             if {*self.args} == {*other.args}:
-                return other
+                return other            
         elif other.is_Element:
             if other.rhs.is_Range or other.rhs.is_Interval:
                 if self.lhs == other.lhs:
                     if other.rhs.right_open:
                         if self.rhs >= other.rhs.stop:
-                            return S.false
+                            return S.false           
                     else:
                         if self.rhs > other.rhs.stop:
-                            return S.false
+                            return S.false           
         elif other.is_NotElement:
             if other.rhs.is_Range or other.rhs.is_Interval:
                 if self.lhs == other.lhs:
                     if other.rhs.left_open and self.rhs > other.rhs.start or \
                     not other.rhs.left_open and self.rhs >= other.rhs.start:
                         if other.rhs.right_open:
                             if self.lhs < other.rhs.stop:
@@ -1975,39 +1881,31 @@
                 if self.rhs <= other.rhs:
                     return S.true
                 
         elif other.is_LessEqual:
             if self.lhs == other.lhs:
                 if self.rhs <= other.rhs:
                     return S.true
-                # x >= 1 and x <= 0
+                # x >= 1 and x <= 0  
                 if self.lhs.is_integer and self.rhs <= other.rhs + 1:
                     return S.true
             
         elif other.is_GreaterEqual:
             if self.lhs == other.lhs:
                 # x >= a or x >= a + 1
                 if self.rhs >= other.rhs:
                     return other
                 if self.rhs <= other.rhs:
                     return self
             
-        elif other.is_Greater:
-            if self.lhs == other.lhs:
-                # x >= 1 or x > 2
-                if self.rhs > other.rhs:
-                    return other
-                if self.rhs <= other.rhs:
-                    return self
-                
         return Relational.__or__(self, other)
 
     def simplify(self, deep=False, wrt=None):
         if self.lhs.is_Maxima:
-            maximize = self.lhs
+            maximize = self.lhs 
             if maximize.expr == self.rhs:
                 if all(len(limit) == 1 for limit in maximize.limits):
                     return S.true
         return Relational.simplify(self, deep=deep, wrt=wrt)
     
     def _sympystr(self, p):
         # GREATER-THAN OVER EQUAL TO
@@ -2031,37 +1929,20 @@
                 res = Boolean.of(self, cls)
                 if b.is_Number:
                     return res
                 if isinstance(res, tuple):
                     b, a = res
                     return (a, b)         
             
-        return res
+        return res 
 
     def _eval_torch(self):
-        import torch
+        import torch 
         return torch.ge(self.lhs.torch, self.rhs.torch)
 
-    def domain_conditioned(self, var):
-        if ret := self.domain_conditioned_utility(var):
-            a, solution, domain = ret
-            from sympy import Interval
-            if a.is_extended_negative:
-                return domain & Interval(S.NegativeInfinity, solution)
-            
-            if a.is_extended_positive:
-                return domain & Interval(solution, S.Infinity)
-
-        return BinaryCondition.domain_conditioned(self, var)
-
-    @classmethod
-    def sub_class_key(cls):
-        return -1
-
-
 Ge = GreaterEqual
 
 
 class LessEqual(_Less):
     __doc__ = GreaterEqual.__doc__
     __slots__ = ()
 
@@ -2151,26 +2032,26 @@
 
     def __and__(self, other):
         if other.is_LessEqual:
             if self.lhs == other.rhs:
                 if other.lhs == self.rhs:
                     return Equal(self.lhs, self.rhs)
                 if other.lhs > self.rhs:
-                    return S.false
+                    return S.false   
             elif self.lhs == other.lhs:
                 # x <= a, x <= b
                 if self.rhs <= other.rhs:
                     return self
                 
                 if self.rhs >= other.rhs:
                     return other
                 
         elif other.is_Less:
             if self.lhs == other.lhs:
-#                 x <= 1 and x < 0
+#                 x <= 1 and x < 0                
                 if self.rhs >= other.rhs:
                     return other
 #                 x <= 0 and x < 1
                 if self.rhs < other.rhs:
                     return self
 
             elif self.lhs == other.rhs:
@@ -2197,18 +2078,18 @@
                         return S.false
 
                     return other.func(self.lhs, other.rhs.func(S.NegativeInfinity, self.rhs + 1) & other.rhs).simplify()
             elif other.rhs.is_Interval:
                 if self.lhs == other.lhs:
                     if other.rhs.left_open:
                         if self.rhs <= other.rhs.start:
-                            return S.false
+                            return S.false           
                     else:
                         if self.rhs < other.rhs.start:
-                            return S.false
+                            return S.false           
 
                     return other.func(self.lhs, other.rhs.func(S.NegativeInfinity, self.rhs) & other.rhs).simplify()
                 
         elif other.is_Unequal:
             if {*self.args} == {*other.args}:
                 return Less(*self.args)
             
@@ -2253,53 +2134,43 @@
                 return self.func(*other.args)
             
         elif other.is_Unequal:
             if other.lhs == self.lhs and other.rhs <= self.rhs or \
             other.lhs == self.rhs and self.rhs <= other.rhs or \
             other.rhs == self.lhs and other.lhs <= self.rhs or \
             other.rhs == self.rhs and self.lhs <= other.rhs:
-                return S.true
+                return S.true 
             
         elif other.is_Greater:
 #             x <= 1 | x > 0
             if self.lhs == other.lhs:
                 if self.rhs >= other.rhs:
                     return S.true
-
         elif other.is_GreaterEqual:
 #             x <= 1 | x > 0
             if self.lhs == other.lhs:
                 if self.rhs >= other.rhs:
                     return S.true
                 # x <= 0 and x >= 1
                 if self.lhs.is_integer:
                     if self.rhs + 1 >= other.rhs:
                         return S.true
-                    
         elif other.is_LessEqual:
             if self.lhs == other.lhs:
-                # x <= a or x < a + 1
+                # x < a or x < a + 1
                 if self.rhs <= other.rhs:
                     return other
                 if self.rhs >= other.rhs:
                     return self
-                
-        elif other.is_Less:
-            if self.lhs == other.lhs:
-                # x <= a or x < a + 1
-                if self.rhs < other.rhs:
-                    return other
-                if self.rhs >= other.rhs:
-                    return self
             
         return Relational.__or__(self, other)
 
     def simplify(self, deep=False, wrt=None):
         if self.lhs.is_Minima:
-            minimize = self.lhs
+            minimize = self.lhs 
             if minimize.expr == self.rhs:
                 if all(len(limit) == 1 for limit in minimize.limits):
                     return S.true
         return Relational.simplify(self, deep=deep, wrt=wrt)
 
     def _sympystr(self, p):
         # LESS-THAN OVER EQUAL TO
@@ -2323,36 +2194,19 @@
                 res = Boolean.of(self, cls)
                 if b.is_Number:
                     return res
                 if isinstance(res, tuple):
                     b, a = res
                     return (a, b)         
             
-        return res
+        return res 
 
     def _eval_torch(self):
-        import torch
-        return torch.le(self.lhs.torch, self.rhs.torch)
-    
-    def domain_conditioned(self, var):
-        if ret := self.domain_conditioned_utility(var):
-            a, solution, domain = ret
-            from sympy import Interval
-            if a.is_extended_negative:
-                return domain & Interval(solution, S.Infinity)
-            
-            if a.is_extended_positive:
-                return domain & Interval(S.NegativeInfinity, solution)
-
-        return BinaryCondition.domain_conditioned(self, var)
-    
-    @classmethod
-    def sub_class_key(cls):
-        return -2
-
+        import torch 
+        return torch.lt(self.lhs.torch, self.rhs.torch)
 
 Le = LessEqual
 
 
 class Greater(_Greater):
     __doc__ = GreaterEqual.__doc__
     __slots__ = ()
@@ -2466,20 +2320,20 @@
 
     def __or__(self, other):
         if isinstance(other, Unequal):
             if self.lhs == other.lhs:
                 if self.rhs == other.rhs: 
                     return other
                 if self.lhs <= other.rhs:
-                    return (self.lhs < other.rhs) | self
+                    return (self.lhs < other.rhs) | self 
             elif self.lhs == other.rhs:
                 if self.rhs == other.lhs:
                     return other
                 if self.lhs <= other.lhs:
-                    return (self.lhs < other.lhs) | self
+                    return (self.lhs < other.lhs) | self                
         elif isinstance(other, Equal):
             if set(self.args) == set(other.args):
                 return GreaterEqual(self.lhs, self.rhs)
             
         elif isinstance(other, Less):
             if self.lhs == other.lhs:
                 if other.rhs > self.rhs:
@@ -2509,29 +2363,22 @@
                 
         elif isinstance(other, LessEqual):
             if self.lhs == other.lhs:
                 if self.rhs <= other.rhs:
                     return S.true
             if self.rhs == other.rhs:
                 if other.lhs <= self.lhs:
-                    return S.true
+                    return S.true                              
         elif isinstance(other, GreaterEqual):
             if self.lhs == other.rhs:
                 if self.rhs <= other.lhs:
                     return S.true
             if self.rhs == other.lhs:
                 if other.rhs <= self.lhs:
-                    return S.true
-            if self.lhs == other.lhs:
-#                 x > 2 or x >= 1
-                if self.rhs >= other.rhs:
-                    return other
-                
-                if self.rhs < other.rhs:
-                    return self
+                    return S.true                              
             
         return _Greater.__or__(self, other)
 
     def __mul__(self, other):
         if isinstance(other, Greater):
             if self.rhs.is_extended_nonnegative: 
                 if other.rhs.is_extended_nonnegative:
@@ -2580,36 +2427,20 @@
                 res = Boolean.of(self, cls)
                 if b.is_Number:
                     return res
                 if isinstance(res, tuple):
                     b, a = res
                     return (a, b)         
             
-        return res
+        return res 
 
     def _eval_torch(self):
-        import torch
+        import torch 
         return torch.gt(self.lhs.torch, self.rhs.torch)
 
-    def domain_conditioned(self, var):
-        if ret := self.domain_conditioned_utility(var):
-            a, solution, domain = ret
-            from sympy import Interval
-            if a.is_extended_negative:
-                return domain & Interval(S.NegativeInfinity, solution, right_open=True)
-            elif a.is_extended_positive:
-                return domain & Interval(solution, S.Infinity, left_open=True)
-
-        return BinaryCondition.domain_conditioned(self, var)
-
-    @classmethod
-    def sub_class_key(cls):
-        return -3
-
-
 Gt = Greater
 LessEqual.invert_type = Greater
 
 
 class Less(_Less):
     __doc__ = GreaterEqual.__doc__
     __slots__ = ()
@@ -2683,20 +2514,20 @@
             if set(self.args) == set(other.args):
                 return self
         elif isinstance(other, Equal):
             if set(self.args) == set(other.args):
                 return S.false
         elif isinstance(other, _Less):
             if self.lhs == other.lhs:
-#                 x < 0 and x <= 1
+#                 x < 0 and x <= 1                
                 if self.rhs <= other.rhs:
                     return self
 #                 x < 1 and x <= 0
                 if self.rhs > other.rhs:
-                    return other
+                    return other 
             if self.rhs == other.lhs:
 #                 x < a and a < x - 1
                 if self.lhs >= other.rhs:
                     return S.false
         
         elif other.is_Element:
             if other.rhs.is_Range or other.rhs.is_Interval:
@@ -2718,15 +2549,15 @@
 
     def __or__(self, other):
         if isinstance(other, Unequal):
             if self.lhs == other.lhs:
                 if self.rhs == other.rhs: 
                     return other
                 if self.lhs >= other.rhs:
-                    return (self.lhs > other.rhs) | self
+                    return (self.lhs > other.rhs) | self 
             elif self.lhs == other.rhs:
                 if self.rhs == other.lhs:
                     return other
                 if self.lhs >= other.lhs:
                     return (self.lhs > other.lhs) | self
         elif isinstance(other, Equal):
             if set(self.args) == set(other.args):
@@ -2736,56 +2567,47 @@
             if self.lhs == other.lhs:
                 if self.rhs > other.rhs:
                     return S.true
                 if other.rhs == self.rhs:
                     return Unequal(*self.args)
             if self.rhs == other.rhs:
                 if other.lhs > self.lhs:
-                    return S.true
+                    return S.true                              
         elif isinstance(other, Less):
             if self.lhs == other.rhs:
                 if self.rhs > other.lhs:
                     return S.true
                 if other.lhs == self.rhs:
                     return Unequal(*self.args)
                 
             if self.rhs == other.lhs:
                 if other.rhs > self.lhs:
-                    return S.true
+                    return S.true                            
             
             if self.lhs == other.lhs:
                 # x < a or x < a + 1
                 if self.rhs <= other.rhs:
                     return other
                 if self.rhs >= other.rhs:
                     return self
             
         elif isinstance(other, GreaterEqual):
             if self.lhs == other.lhs:
                 if self.rhs >= other.rhs:
                     return S.true
             if self.rhs == other.rhs:
                 if other.lhs >= self.lhs:
-                    return S.true
-
+                    return S.true                              
         elif isinstance(other, LessEqual):
             if self.lhs == other.rhs:
                 if self.rhs >= other.lhs:
                     return S.true
             if self.rhs == other.lhs:
                 if other.rhs >= self.lhs:
                     return S.true
-
-            if self.lhs == other.lhs:
-#                 t < 1, t <= 2
-                if self.rhs <= other.rhs:
-                    return other
-                if self.rhs > other.rhs:
-                    return self
-                
                                               
         return _Less.__or__(self, other)
 
     def __mul__(self, other):
         other = sympify(other)
         if isinstance(other, Less):
             if self.lhs.is_extended_nonnegative: 
@@ -2839,35 +2661,19 @@
                 res = Boolean.of(self, cls)
                 if b.is_Number:
                     return res
                 if isinstance(res, tuple):
                     b, a = res
                     return (a, b)         
             
-        return res
+        return res 
 
     def _eval_torch(self):
-        import torch
-        return torch.lt(self.lhs.torch, self.rhs.torch)
-
-    def domain_conditioned(self, var):
-        if ret := self.domain_conditioned_utility(var):
-            a, solution, domain = ret
-            from sympy import Interval
-            if a.is_extended_negative:
-                return domain & Interval(solution, S.Infinity, left_open=True)
-            elif a.is_extended_positive:
-                return domain & Interval(S.NegativeInfinity, solution, right_open=True)
-
-        return BinaryCondition.domain_conditioned(self, var)
-
-    @classmethod
-    def sub_class_key(cls):
-        return -4
-
+        import torch 
+        return torch.le(self.lhs.torch, self.rhs.torch)
 
 Lt = Less
 GreaterEqual.invert_type = Less
 
 Ge.reversed_type = Le
 Lt.reversed_type = Gt
 Le.reversed_type = Ge
```

### Comparing `sympy.keras-1.0.21/sympy/core/rules.py` & `sympy.keras-1.0.4/sympy/core/rules.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/core/singleton.py` & `sympy.keras-1.0.4/sympy/core/singleton.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/core/symbol.py` & `sympy.keras-1.0.4/sympy/core/symbol.py`

 * *Files 6% similar despite different names*

```diff
@@ -220,15 +220,15 @@
 
     @staticmethod
     def process_assumptions(assumptions, integer):
         domain = assumptions.get('domain')
         if domain is not None:
             from sympy import Interval, Range
             if isinstance(domain, list):
-                domain = (Range if integer else Interval.open)(*domain)
+                domain = (Range if integer else Interval)(*domain)
                
             if isinstance(domain, set):
                 assumptions['domain'] = sympify(domain) 
             elif domain.is_Range:
                 if domain.start is S.NegativeInfinity:
                     if domain.stop is S.Infinity:
                         assumptions.pop('domain')
@@ -258,31 +258,27 @@
                 elif domain.start is S.Zero:
                     if domain.stop is S.Infinity:
                         assumptions.pop('domain')
                         if domain.left_open:
                             assumptions['positive'] = True
                         else:
                             assumptions['nonnegative'] = True
-            elif domain.is_ComplexRegion:
-                if domain == S.Complexes:
-                    assumptions.pop('domain')
-                    assumptions['complex'] = True
-
+            
             if 'domain' not in assumptions:
-                assumptions['integer'] = integer
+                assumptions['integer'] = integer            
         
     def copy(self, **kwargs):
         if not kwargs:
             return self
         
         if 'domain' in kwargs and len(kwargs) == 1 and kwargs['domain'] is not None:
             domain = kwargs['domain']
             kwargs.update(self.assumptions_hashable())
             kwargs['domain'] = domain
-            return self.func(self.name, **kwargs)
+            return self.func(self.name, **kwargs)        
         
         integer, rational, real, shape, dtype = self.is_integer, self.is_rational, self.is_real, self.shape, self.etype
         kwargs['integer'] = integer
         kwargs['rational'] = rational
         kwargs['real'] = real
         kwargs['shape'] = shape if shape else None
         kwargs['etype'] = dtype
@@ -317,14 +313,16 @@
 
     def condition_set(self):
         definition = self.definition
         if definition is None:
             return
         return definition.condition_set()
 
+    predefined_attributes = {'domain', 'definition', 'etype', 'shape', 'distribution'}
+        
     @staticmethod
     def _sanitize(assumptions, obj=None):
         """Remove None, covert values to bool, check commutativity *in place*.
         """
         # sanitize other assumptions so 1 -> True and 0 -> False
         for key in list(assumptions.keys()):
             from collections import defaultdict
@@ -338,30 +336,41 @@
                     issue=8071,
                     deprecated_since_version="0.7.6").warn()
                 assumptions[keymap[key]] = assumptions[key]
                 assumptions.pop(key)
                 key = keymap[key]
 
             v = assumptions[key]
-            if v is None:
+            if v is None or (key != 'definition' and 'definition' in assumptions):
                 assumptions.pop(key)
                 continue
 
-            if key == 'shape':
-                assumptions[key] = tuple(sympify(s) for s in v)
-            elif key not in {'domain', 'definition', 'etype', 'distribution'}:
+            if key not in Symbol.predefined_attributes:
                 assumptions[key] = bool(v)
-
         integer = assumptions.get('integer')
         if integer is None:
             domain = assumptions.get('domain')
             if domain is None:
                 return
+                keys = [*assumptions]
+                for key in keys:
+                    if key == 'nonzero':
+#                     if key.startswith('non'):
+                        value = assumptions.pop(key)                        
+                        key = key[3:]
+                        if value == True:
+                            value = False
+                        elif value == False:
+                            value = True                        
+                            
+                        assumptions[key] = value
+                        
+                return
             else:
-                integer = domain.etype.is_integer
+                integer = domain.is_integer
                          
         Symbol.process_assumptions(assumptions, integer)
         
     def __new__(cls, *args, **assumptions):
         """Symbols are identified by name and assumptions::
 
         >>> from sympy import Symbol
@@ -382,17 +391,17 @@
         elif len(args) == 2:
             name, definition = args
             assumptions['definition'] = definition
         else:
             name = None
             
         if name is None:
-            import traceback
+            import traceback, re
             line = traceback.extract_stack()[-2].line
-            name = _re.match('(.+?) *= *Symbol\(.+ *$', line)[1]
+            name = re.match('(.+?) *= *Symbol\(.+ *$', line)[1]
             if ',' in name:
                 return (Symbol(name.strip(), **assumptions) for name in name.split(','))
             
         return Symbol.__xnew__(cls, name, **assumptions)
 #         return Symbol.__xnew_cached_(cls, name, **assumptions)
 
     def __new_stage2__(cls, name, **assumptions):
@@ -458,15 +467,15 @@
     @cacheit
     def sort_key(self, order=None):
         if self.domain_assumed:
             # to distinguish symbols with the same literals but different domains
             args = (str(self), True)
         else:
             args = (str(self),)
-        return self.class_key(), (0, (), args), S.One.sort_key(), S.One
+        return self.class_key(), (1, args), S.One.sort_key(), S.One
 
     def as_dummy(self):
         return Dummy(self.name)
 
     def as_real_imag(self, deep=True, **hints): 
         if hints.get('ignore') == self:
             return None
@@ -484,19 +493,15 @@
         return not self in wrt
     
     @cacheit
     def _eval_free_symbols(self):
         definition = self.definition
         if definition is None:
             return {self}
-        
-        free_symbols = definition.free_symbols
-        if self.is_bounded:
-            return free_symbols | {self}
-        return free_symbols
+        return definition.free_symbols
 
     @property
     def binary_symbols(self):
         return self.free_symbols  # in this case, not always
 
     def as_set(self):
         return self.universalSet
@@ -524,24 +529,24 @@
             return True
         if  self._assumptions.get('even') is not None:
             return True
         if  self._assumptions.get('prime') is not None:
             return True
 
     @property
-    def domain_assumed(self):        
-        if domain := self._assumptions.get('domain'):
-            return domain
-        if distribution := self._assumptions.get('distribution'):
-            return distribution.domain
+    def domain_assumed(self):
+        if 'domain' in self._assumptions:
+            return self._assumptions['domain']
+        if 'distribution' in self._assumptions:
+            return self._assumptions['distribution'].domain
         
     @property
     def domain_bounded(self):
-        if domain := self._assumptions.get('domain'):
-            return domain
+        if 'domain' in self._assumptions:
+            return self._assumptions['domain']
         from sympy import Interval, oo, Range
         if self.is_positive:
             if self.is_integer:
                 return Range(1, oo)
             return Interval(0, oo, left_open=True)
         if self.is_negative:
             if self.is_integer:
@@ -562,26 +567,27 @@
             return Expr.domain_defined(self, x)
         return definition.domain_defined(x)
         
     @property
     def domain(self):
         from sympy import Interval, Range, CartesianSpace
 
-        if domain := self._assumptions.get('domain'):
+        if 'domain' in self._assumptions:
+            domain = self._assumptions['domain']
             if self.is_integer and domain.is_Interval: 
                 domain = domain.copy(integer=True)
             if self.shape:
                 domain = CartesianSpace(domain, *self.shape)
             return domain
          
         if self.dtype.is_set:
             return self.universalSet
         
-        if distribution := self._assumptions.get('distribution'):
-            return distribution.domain
+        if 'distribution' in self._assumptions:
+            return self._assumptions['distribution'].domain
                          
         if self.is_extended_real:
             assumptions = self.assumptions0
             if 'integer' in assumptions:
                 integer = assumptions.pop('integer')
             else:
                 integer = self.is_integer
@@ -601,75 +607,57 @@
             from sympy import HyperComplexes
             domain = HyperComplexes
         elif self.is_super_real:
             from sympy import SuperReals
             domain = SuperReals
         else:
             from sympy import SuperComplexes
-            domain = SuperComplexes
+            domain = SuperComplexes 
             
         shape = self.shape
         if not shape:
             return domain
         return CartesianSpace(domain, *shape)        
 
     @property
     def definition(self):
-        if definition := self._assumptions.get('definition'):
-            return definition
-
-    @property
-    def var(self):
-        from sympy.stats.rv import pspace
-        return pspace(self).symbol
-
-    @property
-    def surrogate(self):
-        assert self.is_random
-        from sympy.stats.symbolic_probability import Surrogate
-        return Surrogate(self)
-
-    def __and__(self, other):
-        """Overloading for & operator"""
-        if self.is_random and other.is_random:
-            if not other.is_bool:
-                other = other.as_boolean()
-            return self.as_boolean() & other
-
-        return super(Symbol, self).__and__(other)
+        if 'definition' in self._assumptions:
+            return self._assumptions['definition']
 
     @cacheit
     def defun(self):
-        if definition := self._assumptions.get('definition'):
-            return definition
+        if 'definition' in self._assumptions:
+            return self._assumptions['definition']
                 
     def domain_nonzero(self, x):
         if self == x:
             return x.domain - {0}
         return Expr.domain_nonzero(self, x)
 
     @property
     def is_set(self):
         if self.shape:
             return False
-        if etype := self._assumptions.get('etype'):
-            return True
+        if 'etype' in self._assumptions:
+            dtype = self._assumptions['etype']
+            if dtype is not None:
+                return True
         definition = self.definition
         if definition is not None:
             return definition.is_set
         return False
 
     @property
     def dtype(self):
         definition = self.definition
         if definition is not None:
             return definition.dtype
 
-        if etype := self._assumptions.get('etype'):
-            return etype.set
+        if 'etype' in self._assumptions:
+            return self._assumptions['etype'].set
         
         assumptions = {}
         if self._assumptions.get('positive'):
             assumptions['positive'] = True
         elif self._assumptions.get('nonnegative'):
             assumptions['nonnegative'] = True
         elif self._assumptions.get('negative'):
@@ -701,54 +689,55 @@
             if self.is_real:
                 return dtype.real
             elif self.is_extended_real:
                 return dtype.extended_real
             elif self.is_hyper_real:
                 return dtype.hyper_real
             else:
-                return dtype.super_real
+                return dtype.super_real                      
 
         else:
             if self.is_complex:
                 return dtype.complex
             elif self.is_extended_complex:
                 return dtype.extended_complex
             elif self.is_hyper_complex:
-                return dtype.hyper_complex
+                return dtype.hyper_complex            
             else:
                 return dtype.super_complex
             
     @cacheit
     def _has(self, pattern):
         """Helper for .has()"""
         if Expr._has(self, pattern):
             return True
 
-        if pattern.is_Sliced:
-            if pattern.base == self:
-                return True
-
         if not (isinstance(pattern, ManagedProperties) or pattern.is_FunctionClass):
-            if definition := self._assumptions.get('definition'):
+            if 'definition' in self._assumptions:
+                definition = self._assumptions['definition']
                 return definition._has(pattern)
 
-            if domain := self._assumptions.get('domain'):
+            if 'domain' in self._assumptions:
                 from sympy.core.numbers import Infinity, NegativeInfinity
                 if isinstance(pattern, (Infinity, NegativeInfinity)):  # excludes oo, -oo, because these are not variables;
                     return False
+                domain = self._assumptions['domain']
                 return domain._has(pattern)
+        if pattern.is_Sliced:
+            if pattern.base == self:
+                return True
         return False
 
     @property
     def etype(self):
-        if etype := self._assumptions.get('etype'):
-            return etype
+        if 'etype' in self._assumptions:
+            return self._assumptions['etype']
         definition = self.definition
         if definition is not None:
-            return definition.etype
+            return definition.etype        
 
     def element_symbol(self, excludes=set(), var=None):
         etype = self.etype
         if etype is None:
             return
 
         return self.generate_var(excludes=excludes, var=var, **etype.dict)
@@ -779,23 +768,24 @@
     def _eval_shape(self):
         return self.get_shape()
     
     def get_shape(self):
         if 'shape' in self._assumptions:
             return self._assumptions['shape']
         
-        if domain := self._assumptions.get('domain'):
+        if 'domain' in self._assumptions:
+            domain = self._assumptions['domain']
             dtype = domain.etype
             shape = dtype.shape
         elif self.definition is not None:
-            shape = self.definition.shape
+            shape = self.definition.shape            
         else:
             shape = ()
             
-        return shape
+        return shape        
 
     @property
     def cols(self):
         if self.shape:
             return self.shape[-1]
         return 1
 
@@ -825,15 +815,15 @@
                     if _start is None:
                         _start = 0
                          
                     _stop = index.stop
                     if _stop is None:
                         _stop = value.shape[i]
                         
-                    assert _start == start
+                    assert _start == start 
                     assert _stop == stop
                     
                 indices = indices[:-size]
                 self[indices] = value
             else:
                 args = value.of(Indexed)
                 assert self == args[0]
@@ -846,15 +836,15 @@
             if _start is None:
                 _start = 0
                  
             _stop = indices.stop
             if _stop is None:
                 _stop = value.shape[0]
                 
-            assert _start == start
+            assert _start == start 
             assert _stop == stop
         else:
             base, index = value.of(Indexed)
             assert self == base
             assert index == indices
         
     def __getitem__(self, indices, **kw_args):
@@ -910,23 +900,27 @@
             return Sliced(self, Tuple(start, stop, step), **kw_args)
         
         else:
             definition = self.definition
             if definition is not None and definition.is_Lamda:
                 if len(definition.limits) == 1 and definition.expr.is_RandomSymbol:
                     return definition[indices]
-
+                    
             boolean = indices < self.shape[0]
             assert boolean is True or boolean != False
             return Indexed(self, indices, **kw_args)
     
+    def __invert__(self):
+        from sympy import Conjugate
+        return Conjugate(self)
+    
     #return exp._has(self)
     def has_match(self, exp):
         if exp == self:
-            return True
+            return True 
         
         from sympy.matrices.expressions.matexpr import MatrixElement
         if isinstance(exp, MatrixElement) and exp.parent == self:
             return True
         
         if exp.is_Indexed and exp.base == self:
             return True
@@ -962,113 +956,109 @@
         return False
     
     def _eval_transpose(self, axis=-1):
         if axis == self.default_axis:
             if len(self.shape) < 2:
                 return self
 
-    underscores = dict(_quote="'", _star='_*', _dquote='"')
-    @classmethod
-    def translate_underscore(cls, name):
-        try:
-            i = name.rindex('_')
-            strUnderscore = name[i:]
-            if strUnderscore := cls.underscores.get(strUnderscore):
-                return name[:i] + strUnderscore
-        except:
-            ...
-
-        return name
+    @staticmethod
+    def ascii2greek(x):
+        if x.lower() in {'alpha', 'beta', 'gamma', 'delta', 'epsilon', 'zeta', 'eta', 'theta', 'iota', 'kappa', 'lamda', 'mu', 'nu', 'xi', 'omicron', 'pi', 'rho', 'sigma', 'tau', 'upsilon', 'phi', 'chi', 'psi', 'omega'}:
+            if x[0].isupper():
+                x = eval("'\\N{GREEK CAPITAL LETTER %s}'" % x)
+            else:
+                x = eval("'\\N{GREEK SMALL LETTER %s}'" % x)
+        return x
         
     @staticmethod
     def sympystr(name):
         m = _re.compile("([a-zA-Z]+)(?:(\d+)|_(\w+))?").fullmatch(name)
         if m: 
-            from std.unicode import ascii2greek
             x = m[1]
-            x = ascii2greek(x)
+            x = Symbol.ascii2greek(x)
             d = m[2]
             if d is not None:
                 x += d
             else:
                 a = m[3]
                 if a is not None:
-                    a = ascii2greek(a)
-                    x += '_' + a
+                    a = Symbol.ascii2greek(a)
+                    x += '_' + a                    
                 
             return x
-        return name
+        return name  
         
     def _sympystr(self, _): 
         return Symbol.sympystr(self.name)     
 
-    def _latex(self, p, **kwargs):
+    def _latex(self, p):
         if self in p._settings['symbol_names']:
             return p._settings['symbol_names'][self]
 
         name = self.name
-        name = Symbol.translate_underscore(name)
+        name = name.replace('_quote', "'")
         result = p._deal_with_super_sub(name) if '\\' not in name else name
 
         if self.is_random:
-            color = kwargs.get('color', 'red')
-            return r'{\color{%s} {%s}}' % (color, result)
-        
-        if self.definition is not None:
-            return r"{\color{blue} {%s}}" % result
-
-        if self.is_given == False:
-            return r"{\color{purple} {%s}}" % result
+            return r'{\color{red} {%s}}' % result
         
         if self.domain_assumed:
             return r"{\color{green} {%s}}" % result
         
+        if self.definition is not None:
+            return r"{\color{blue} {%s}}" % result
+
         return result
 
     def _eval_is_extended_positive(self):
-        if domain := self._assumptions.get('domain'):
-            return domain.is_extended_positive
-        if definition := self._assumptions.get('definition'):
-            return definition.is_extended_positive
-        if distribution := self._assumptions.get('distribution'):
+        if 'domain' in self._assumptions:
+            return self._assumptions['domain'].is_extended_positive
+        if 'definition' in self._assumptions:
+            return self._assumptions['definition'].is_extended_positive        
+        if 'distribution' in self._assumptions:
+            distribution = self._assumptions['distribution']
             return distribution.is_extended_positive
-        if etype := self._assumptions.get('etype'):
-            return etype.is_extended_positive
+        if 'etype' in self._assumptions:
+            dtype = self._assumptions['etype']
+            return dtype.is_extended_positive
                  
     def _eval_is_extended_negative(self):
-        if domain := self._assumptions.get('domain'):
-            return domain.is_extended_negative
-        if definition := self._assumptions.get('definition'):
-            return definition.is_extended_negative
-        if distribution := self._assumptions.get('distribution'):
+        if 'domain' in self._assumptions:
+            return self._assumptions['domain'].is_extended_negative
+        if 'definition' in self._assumptions:
+            return self._assumptions['definition'].is_extended_negative
+        if 'distribution' in self._assumptions:
+            distribution = self._assumptions['distribution']
             return distribution.is_extended_negative
-        if etype := self._assumptions.get('etype'):
-            return etype.is_extended_negative
+        if 'etype' in self._assumptions:
+            dtype = self._assumptions['etype']
+            return dtype.is_extended_negative
 
     def _eval_is_nonzero(self):
         if self.get_shape():
             return
             
         zero = self.is_zero
         if zero:
             return False
         
         if zero == False:
-            return self.is_complex
+            return self.is_complex                
 
     def _eval_is_zero(self):
-        if domain := self._assumptions.get('domain'):
-            return domain.is_zero
-        if definition := self._assumptions.get('definition'):
-            return definition.is_zero
-        if distribution := self._assumptions.get('distribution'):
+        if 'domain' in self._assumptions:
+            return self._assumptions['domain'].is_zero
+        if 'definition' in self._assumptions:
+            return self._assumptions['definition'].is_zero
+        if 'distribution' in self._assumptions:
+            distribution = self._assumptions['distribution']
             return distribution.is_zero
         
     def _eval_is_finite(self):
-        if domain := self._assumptions.get('domain'):
+        if 'domain' in self._assumptions:
             domain_assumed = self.domain_assumed
             if domain_assumed.is_Range or domain_assumed.is_Interval: 
                 return True
             if domain_assumed.is_FiniteSet:
                 if all(arg.is_finite for arg in domain_assumed.args):
                     return True
                 if all(arg.is_infinite for arg in domain_assumed.args):
@@ -1080,159 +1070,161 @@
             return definition.is_finite
         
         for key in self._assumptions.keys() & {'integer', 'real', 'complex', 'rational', 'prime', 'even', 'odd', 'composite', 'irrational', 'finite'}:
             if self._assumptions[key]:
                 return True
 
     def _eval_is_extended_integer(self):
-        if domain := self._assumptions.get('domain'):
-            return domain.is_extended_integer
-        if definition := self._assumptions.get('definition'):
-            return definition.is_extended_integer
-        if distribution := self._assumptions.get('distribution'):
+        if 'domain' in self._assumptions:
+            return self._assumptions['domain'].is_extended_integer
+        if 'definition' in self._assumptions:
+            return self._assumptions['definition'].is_extended_integer        
+        if 'distribution' in self._assumptions:
+            distribution = self._assumptions['distribution']
             return distribution.is_extended_integer
-        if etype := self._assumptions.get('etype'):
-            return etype.is_extended_integer
+        if 'etype' in self._assumptions:
+            dtype = self._assumptions['etype']            
+            return dtype.is_extended_integer
 
     def _eval_is_super_integer(self):
-        if domain := self._assumptions.get('domain'):
-            return domain.is_super_integer
-        if definition := self._assumptions.get('definition'):
-            return definition.is_super_integer
-        if distribution := self._assumptions.get('distribution'):
+        if 'domain' in self._assumptions:
+            return self._assumptions['domain'].is_super_integer
+        if 'definition' in self._assumptions:
+            return self._assumptions['definition'].is_super_integer        
+        if 'distribution' in self._assumptions:
+            distribution = self._assumptions['distribution']
             return distribution.is_super_integer
-        if etype := self._assumptions.get('etype'):
-            return etype.is_super_integer
+        if 'etype' in self._assumptions:
+            dtype = self._assumptions['etype']            
+            return dtype.is_super_integer
         
     def _eval_is_extended_rational(self):
-        if domain := self._assumptions.get('domain'):
-            return domain.is_extended_rational
-        if definition := self._assumptions.get('definition'):
-            return definition.is_extended_rational
-        if distribution := self._assumptions.get('distribution'):
+        if 'domain' in self._assumptions:
+            return self._assumptions['domain'].is_extended_rational
+        if 'definition' in self._assumptions:
+            return self._assumptions['definition'].is_extended_rational        
+        if 'distribution' in self._assumptions:
+            distribution = self._assumptions['distribution']
             return distribution.is_extended_rational
-        if etype := self._assumptions.get('etype'):
-            return etype.is_extended_rational
+        if 'etype' in self._assumptions:
+            dtype = self._assumptions['etype']            
+            return dtype.is_extended_rational
 
     def _eval_is_hyper_rational(self):
-        if domain := self._assumptions.get('domain'):
-            return domain.is_hyper_rational
-        if definition := self._assumptions.get('definition'):
-            return definition.is_hyper_rational
-        if distribution := self._assumptions.get('distribution'):
+        if 'domain' in self._assumptions:
+            return self._assumptions['domain'].is_hyper_rational
+        if 'definition' in self._assumptions:
+            return self._assumptions['definition'].is_hyper_rational        
+        if 'distribution' in self._assumptions:
+            distribution = self._assumptions['distribution']
             return distribution.is_hyper_rational
-        if etype := self._assumptions.get('etype'):
-            return etype.is_hyper_rational
+        if 'etype' in self._assumptions:
+            dtype = self._assumptions['etype']            
+            return dtype.is_hyper_rational
 
     def _eval_is_super_rational(self):
-        if domain := self._assumptions.get('domain'):
-            return domain.is_super_rational
-        if definition := self._assumptions.get('definition'):
-            return definition.is_super_rational
-        if distribution := self._assumptions.get('distribution'):
+        if 'domain' in self._assumptions:
+            return self._assumptions['domain'].is_super_rational
+        if 'definition' in self._assumptions:
+            return self._assumptions['definition'].is_super_rational        
+        if 'distribution' in self._assumptions:
+            distribution = self._assumptions['distribution']
             return distribution.is_super_rational
-        if etype := self._assumptions.get('etype'):
-            return etype.is_super_rational
+        if 'etype' in self._assumptions:
+            dtype = self._assumptions['etype']            
+            return dtype.is_super_rational
 
     def _eval_is_extended_real(self):
-        if domain := self._assumptions.get('domain'):
-            return domain.is_extended_real
-        if definition := self._assumptions.get('definition'):
-            return definition.is_extended_real
-        if distribution := self._assumptions.get('distribution'):
+        if 'domain' in self._assumptions:
+            return self._assumptions['domain'].is_extended_real
+        if 'definition' in self._assumptions:
+            return self._assumptions['definition'].is_extended_real
+        if 'distribution' in self._assumptions:
+            distribution = self._assumptions['distribution']
             return distribution.is_extended_real
-        if etype := self._assumptions.get('etype'):
-            return etype.is_extended_real
+        if 'etype' in self._assumptions:
+            dtype = self._assumptions['etype']
+            return dtype.is_extended_real
 
     def _eval_is_hyper_real(self):
-        if domain := self._assumptions.get('domain'):
-            return domain.is_hyper_real
-        if definition := self._assumptions.get('definition'):
-            return definition.is_hyper_real
-        if distribution := self._assumptions.get('distribution'):
+        if 'domain' in self._assumptions:
+            return self._assumptions['domain'].is_hyper_real
+        if 'definition' in self._assumptions:
+            return self._assumptions['definition'].is_hyper_real        
+        if 'distribution' in self._assumptions:
+            distribution = self._assumptions['distribution']
             return distribution.is_hyper_real
-        if etype := self._assumptions.get('etype'):
-            return etype.is_hyper_real
+        if 'etype' in self._assumptions:
+            dtype = self._assumptions['etype']            
+            return dtype.is_hyper_real
         
     def _eval_is_super_real(self):
-        if domain := self._assumptions.get('domain'):
-            return domain.is_super_real
-        if definition := self._assumptions.get('definition'):
-            return definition.is_super_real
-        if distribution := self._assumptions.get('distribution'):
+        if 'domain' in self._assumptions:
+            return self._assumptions['domain'].is_super_real
+        if 'definition' in self._assumptions:
+            return self._assumptions['definition'].is_super_real        
+        if 'distribution' in self._assumptions:
+            distribution = self._assumptions['distribution']
             return distribution.is_super_real
-        if etype := self._assumptions.get('etype'):
-            return etype.is_super_real
+        if 'etype' in self._assumptions:
+            dtype = self._assumptions['etype']            
+            return dtype.is_super_real
 
     def _eval_is_extended_complex(self):
-        if domain := self._assumptions.get('domain'):
-            return domain.is_extended_complex
-        if definition := self._assumptions.get('definition'):
-            return definition.is_extended_complex
-        if distribution := self._assumptions.get('distribution'):
+        if 'domain' in self._assumptions:
+            return self._assumptions['domain'].is_extended_complex
+        if 'definition' in self._assumptions:
+            return self._assumptions['definition'].is_extended_complex
+        if 'distribution' in self._assumptions:
+            distribution = self._assumptions['distribution']
             return distribution.is_extended_complex
-        if etype := self._assumptions.get('etype'):
-            return etype.is_extended_complex
+        if 'etype' in self._assumptions:
+            dtype = self._assumptions['etype']
+            return dtype.is_extended_complex
 
     def _eval_is_hyper_complex(self):
-        if domain := self._assumptions.get('domain'):
-            return domain.is_hyper_complex
-        if definition := self._assumptions.get('definition'):
-            return definition.is_hyper_complex
-        if distribution := self._assumptions.get('distribution'):
+        if 'domain' in self._assumptions:
+            return self._assumptions['domain'].is_hyper_complex
+        if 'definition' in self._assumptions:
+            return self._assumptions['definition'].is_hyper_complex        
+        if 'distribution' in self._assumptions:
+            distribution = self._assumptions['distribution']
             return distribution.is_hyper_complex
-        if etype := self._assumptions.get('etype'):
-            return etype.is_hyper_complex
+        if 'etype' in self._assumptions:
+            dtype = self._assumptions['etype']            
+            return dtype.is_hyper_complex
 
     def _eval_is_algebraic(self):
-        if domain := self._assumptions.get('domain'):
-            return domain.is_algebraic
-        if definition := self._assumptions.get('definition'):
-            return definition.is_algebraic
+        if 'domain' in self._assumptions:
+            return self._assumptions['domain'].is_algebraic
+        if 'definition' in self._assumptions:
+            return self._assumptions['definition'].is_algebraic
     
     def _eval_is_hermitian(self):
-        if domain := self._assumptions.get('domain'):
-            return domain.is_hermitian
-        if definition := self._assumptions.get('definition'):
-            return definition.is_hermitian
+        if 'domain' in self._assumptions:
+            return self._assumptions['domain'].is_hermitian
+        if 'definition' in self._assumptions:
+            return self._assumptions['definition'].is_hermitian
     
     def _eval_is_imaginary(self):
-        if domain := self._assumptions.get('domain'):
-            return domain.is_imaginary
-        if definition := self._assumptions.get('definition'):
-            return definition.is_imaginary
+        if 'domain' in self._assumptions:
+            return self._assumptions['domain'].is_imaginary
+        if 'definition' in self._assumptions:
+            return self._assumptions['definition'].is_imaginary
 
     def _eval_is_random(self):
         if 'distribution' in self._assumptions:
             return True
-        if definition := self._assumptions.get('definition'):
-            return definition.is_random
-
-    def _eval_is_even(self):
-        if domain := self._assumptions.get('domain'):
-            if domain.is_Range:
-                if domain.step.is_even:
-                    if domain.start.is_even:
-                        return True
-                    if domain.start.is_odd:
-                        return False
-
-    def _eval_is_odd(self):
-        if domain := self._assumptions.get('domain'):
-            if domain.is_Range:
-                if domain.step.is_even:
-                    if domain.start.is_odd:
-                        return True
-                    if domain.start.is_even:
-                        return False
-
+        if 'definition' in self._assumptions:
+            return self._assumptions['definition'].is_random
+            
     @property
     def distribution(self):
-        if distribution := self._assumptions.get('distribution'): 
-            return distribution
+        if 'distribution' in self._assumptions: 
+            return self._assumptions['distribution']
     
 #    given = True, for counter-proposition purposes;
 #    given = False, for mathematical-induction purposes;
 #    given = None, for others cases;
     @property
     def is_given(self):
         given = self._assumptions.get('given')
@@ -1284,24 +1276,19 @@
 
         return True
       
     def is_independent_of(self, y, **kwargs):
         from sympy.core.relational import Equal
         return Equal(self | y, self, **kwargs)
 
-    def as_boolean(self, **kwargs):
-        if self.is_random:            
-            if kwargs.get('surrogate'):
-                rhs = self.surrogate
-            else:
-                from sympy.stats.rv import pspace
-                rhs = pspace(self).symbol
-
+    def as_boolean(self):
+        if self.is_random:
             from sympy import Equal
-            return Equal(self, rhs)
+            from sympy.stats.rv import pspace
+            return Equal(self, pspace(self).symbol)
 
     def _subs(self, old, new, **hints):
         """Substitutes an expression old -> new. when self is a Symbol
         """        
         assert old != new
         
         if old.is_Symbol:
@@ -1325,36 +1312,32 @@
                             if old in var.free_symbols:
                                 return self
                     _definition = definition._subs(old, new)
                     if _definition != definition:
                         assumptions = self.assumptions_hashable()
                         if 'shape' in assumptions:
                             del assumptions['shape']
-        # rgb values for colors
+        # rgb values for colors                 
         #                 https://www.917118.com/tool/color_3.html
-        # darkyellow
+        # darkyellow                
                         assumptions.pop('definition')
                         return self.func(r"{\color{ADAD00} %s}" % self.name, _definition, **assumptions)
         return self
         
     def is_continuous(self, *args):
         definition = self.definition
         if definition is None:
             return True
         return definition.is_continuous(*args)
         
     def of(self, cls):
         from sympy import Set
         if cls is Set and self.is_set:
             return self
-
-        if isinstance(cls, Symbol):
-            if self != cls:
-                return
-
+        
         return AtomicExpr.of(self, cls)
     
     def of_simple_poly(self, x):
         '''
         extract the coefficients of a simple polynomial
         (a * x + b).of_simple_poly(x) = [b, a]
         '''
@@ -1416,139 +1399,34 @@
                     data = data.cuda()
 
                 self._torch = data
                 return data
         
         return definition.torch
 
-    @cacheit
-    def compile(self, *syms):
-        assert all(self._has(v) for v in syms)
-        definition = self.definition
-        if definition is None:
-            from sympy.keras.network import NetWorkSymbol
-            return NetWorkSymbol(self)
-        
-        return definition.compile(*syms)
-
     def find_path(self, cls, path, **kwargs):
         for attr in kwargs:
             value = getattr(self, attr)
             if value is not None:
                 path.append(attr)
                 yield from value.find_path(cls, path, **kwargs)
                 path.pop()
-                
-# performing other.indices in self.indices
-    def index_contains(self, other):
-        if other.is_Sliced:
-            base = other.base
-            if base.is_Indexed:
-                base = other.base
-
-            return self.index_contains(base)
-
-        if other.is_Indexed:
-            return other.base == self
-
-        if other.is_SlicedIndexed:
-            return other.base == self
-        
-        if other.is_Symbol:
-            return self == other
-
-# performing indices intersection
-    def index_intersect(self, other):
-        if other.is_Sliced:
-            base = other.base
-            if base.is_Indexed:
-                base = other.base
-
-            if self.index_contains(base):
-                return other
-            else:
-                return
-
-        if other.is_Indexed:
-            if other.base == self:
-                return other
-            return
-
-        if other.is_SlicedIndexed:
-            if other.base == self:
-                return other
-            return
-        
-        if other.is_Symbol:
-            if self == other:
-                return other
-            return
-
-# performing indices complement
-    def index_complement(self, other):
-        if other.is_Sliced:
-            base = other.base
-            if base.is_Indexed:
-                base = other.base
-            else:
-                if self == base:
-                    (start, stop), *slices = other.indices
-                    if stop.is_Infinity:
-                        rest = {self[:start]}
-                    elif start == 0:
-                        rest = {self[stop:]}
-                    else:
-                        rest = {self[:start], self[stop:]}
-                        
-                    if slices:
-                        rest |= self[start:stop].index_complement(other)
-                    
-                    if len(rest) == 1:
-                        rest, = rest
-                    return rest
-
-            return self
-
-        if other.is_Indexed:
-            if other.base == self:
-                b, index, *indices = other.args
-                rest = {self[:index], self[index + 1:]}
-                if indices:
-                    rest |= self[index].index_complement(other)
-                return rest
             
-            return self
-
-        if other.is_SlicedIndexed:
-            if other.base == self:
-                return
-            return self
-        
-        if other.is_Symbol:
-            if self == other:
-                return
-            return self
-
-    def indexOf(self, indexed):
-        if indexed.is_Indexed:
-            if indexed.base == self:
-                return indexed.indices
-            
-        if indexed.is_Sliced:
-            if indexed.base == self:
-                return indexed.indices
-
-        if indexed.is_SlicedIndexed:
-            if indexed.base == self:
-                return indexed.indices
-
-    def is_consistently_of(self, struct):
-        return struct is not Symbol and struct.is_Symbol
-
-
+    def _assumptions_clear_cache(self, cacheType, sym):
+        if self._has(sym):
+            try:
+                self.__delattr__(cacheType)
+            except AttributeError:
+                ...
+            
+            definition = self.definition
+            if definition is not None:
+                definition._assumptions_clear_cache(cacheType, sym)
+            
+    
 class Dummy(Symbol):
     """Dummy symbols are each unique, even if they have the same name:
 
     >>> from sympy import Dummy
     >>> Dummy("x") == Dummy("x")
     False
 
@@ -1597,15 +1475,16 @@
         return obj
 
     def __getstate__(self):
         return {'_assumptions': self._assumptions, 'dummy_index': self.dummy_index}
 
     @cacheit
     def sort_key(self, order=None):
-        return self.class_key(), (0, (), (str(self), self.dummy_index)), S.One.sort_key(), S.One
+        return self.class_key(), (
+            2, (str(self), self.dummy_index)), S.One.sort_key(), S.One
 
     def _hashable_content(self):
         return Symbol._hashable_content(self) + (self.dummy_index,)
 
 
 class Wild(Symbol):
     """
@@ -2092,22 +1971,22 @@
     is_rational = None
     is_extended_rational = None
     is_hyper_rational = None
     is_super_rational = None
     
     is_real = None
     is_extended_positive = None
-    is_extended_negative = None
+    is_extended_negative = None    
     is_extended_real = None
     is_hyper_real = None
     is_super_real = None
     
     is_complex = True
     is_extended_complex = None
-    is_hyper_complex = None
+    is_hyper_complex = None    
     is_super_complex = True
     
     is_DtypeInteger = None
     
     def as_Set(self):
         from sympy.sets.sets import UniversalSet
         return UniversalSet(etype=self)
@@ -2194,15 +2073,15 @@
     @property
     def emptySet(self):
         from sympy import EmptySet
         return EmptySet(etype=self)
     
     @property
     def universalSet(self):
-        from sympy.sets.sets import Set, UniversalSet
+        from sympy.sets.sets import Set, UniversalSet        
         return Set.__new__(UniversalSet, etype=self)
 
     def __mul__(self, length):
         if isinstance(length, (tuple, Tuple, list)):
             if not length:
                 return self
             return DtypeMatrix(self, tuple(length))
@@ -2254,17 +2133,14 @@
             return self
         return DtypeSuperComplexConditional(**kwargs)
 
     @property
     def universalSet(self):
         from sympy.sets.sets import Set, UniversalSet
         return Set.__new__(UniversalSet, etype=self.super_complex)
-    
-    def extended_type(self):
-        return self
 
 
 class DtypeSuperReal(DtypeSuperComplex):
     
     is_super_real = True
     
     @property
@@ -2361,15 +2237,15 @@
 
 class DtypeHyperComplex(DtypeSuperComplex):
     
     is_hyper_complex = True
 
     def as_Set(self):
         from sympy import HyperComplexes
-        return HyperComplexes
+        return HyperComplexes        
 
     def __str__(self):
         return 'hyper_complex'
     
     @property
     def dict(self):
         return {'hyper_complex': True}
@@ -2393,19 +2269,19 @@
 
 class DtypeHyperReal(DtypeSuperReal, DtypeHyperComplex):
     
     is_hyper_real = True
     
     @property
     def universalSet(self):
-        from sympy.sets.sets import Set, UniversalSet
+        from sympy.sets.sets import Set, UniversalSet 
         return Set.__new__(UniversalSet, etype=dtype.hyper_real)
     
     def as_Set(self):
-        from sympy import HyperReals
+        from sympy import HyperReals 
         return HyperReals
 
     def __str__(self):
         return 'hyper_real'
     
     @property
     def dict(self):
@@ -2425,19 +2301,19 @@
 
 class DtypeHyperRational(DtypeSuperRational, DtypeHyperReal):
     
     is_hyper_rational = True
     
     @property
     def universalSet(self):
-        from sympy.sets.sets import Set, UniversalSet
+        from sympy.sets.sets import Set, UniversalSet 
         return Set.__new__(UniversalSet, etype=dtype.hyper_rational)
     
     def as_Set(self):
-        from sympy import HyperRationals
+        from sympy import HyperRationals 
         return HyperRationals
 
     def __str__(self):
         return 'hyper_rational'
     
     @property
     def dict(self):
@@ -2491,19 +2367,19 @@
 
 class DtypeExtendedReal(DtypeHyperReal, DtypeExtendedComplex):
     
     is_extended_real = True
     
     @property
     def universalSet(self):
-        from sympy import Interval, oo
+        from sympy import Interval, oo 
         return Interval(-oo, oo, left_open=False, right_open=False)
     
     def as_Set(self):
-        from sympy import Interval, oo
+        from sympy import Interval, oo 
         return Interval(-oo, oo, left_open=False, right_open=False)
 
     def __str__(self):
         return 'extended_real'
     
     @property
     def dict(self):
@@ -2523,19 +2399,19 @@
 
 class DtypeExtendedRational(DtypeHyperRational, DtypeExtendedReal):
     
     is_extended_rational = True
     
     @property
     def universalSet(self):
-        from sympy import Interval, oo
+        from sympy import Interval, oo 
         return Interval(-oo, oo, left_open=False, right_open=False, rational=True)
     
     def as_Set(self):
-        from sympy import Interval, oo
+        from sympy import Interval, oo 
         return Interval(-oo, oo, left_open=False, right_open=False, rational=True)
 
     def __str__(self):
         return 'extended_rational'
     
     @property
     def dict(self):
@@ -2555,19 +2431,19 @@
 
 class DtypeExtendedInteger(DtypeSuperInteger, DtypeExtendedRational):
     
     is_extended_integer = True
     
     @property
     def universalSet(self):
-        from sympy import Range, oo
+        from sympy import Range, oo 
         return Range(-oo, oo, left_open=False, right_open=False)
     
     def as_Set(self):
-        from sympy import Range, oo
+        from sympy import Range, oo 
         return Range(-oo, oo, left_open=False, right_open=False)
 
     def __str__(self):
         return 'extended_integer'
     
     @property
     def dict(self):
@@ -2587,15 +2463,15 @@
 
 class DtypeComplex(DtypeExtendedComplex):
     
     is_complex = True
     is_finite = True
 
     def as_Set(self):
-        return S.Complexes
+        return S.Complexes        
 
     def __str__(self):
         return 'complex'
     
     @property
     def dict(self):
         return {'complex': True}
@@ -2611,17 +2487,14 @@
             return self
         return DtypeComplexConditional(**kwargs)
 
     @property
     def universalSet(self): 
         return S.Complexes
 
-    def extended_type(self):
-        return self.extended_complex
-
 
 class DtypeComplexConditional(DtypeComplex):
     
     def as_Set(self):
         return S.Complexes
 
     def __init__(self, **assumptions):
@@ -2629,15 +2502,15 @@
     
     def __str__(self):
         return Dtype.__str__(self, 'complex')
     
     @property
     def dict(self):
         assumptions = {**self.assumptions}
-        assumptions['complex'] = True
+        assumptions['complex'] = True        
         return assumptions
 
     def __eq__(self, other):
         return isinstance(other, DtypeComplexConditional)
 
     def __hash__(self):
         return hash(type(self).__name__)
@@ -2646,15 +2519,15 @@
 class DtypeReal(DtypeExtendedReal, DtypeComplex):
     
     is_real = True
     is_finite = True
     
     @property
     def universalSet(self):
-        from sympy.sets.fancysets import Reals
+        from sympy.sets.fancysets import Reals 
         return Reals
     
     def as_Set(self):
         from sympy.sets.fancysets import Reals
         return Reals
 
     def __str__(self):
@@ -2671,17 +2544,14 @@
         return hash(type(self).__name__)
 
     def __call__(self, **kwargs):
         if not kwargs:
             return self
         return DtypeRealConditional(**kwargs)
 
-    def extended_type(self):
-        return self.extended_real
-
 
 class DtypeRealConditional(DtypeReal):
 
     def as_Set(self):
         if self.assumptions.get('positive') is True:
             ...
         from sympy import Interval
@@ -2692,15 +2562,15 @@
     
     def __str__(self):
         return Dtype.__str__(self, 'real')
     
     @property
     def dict(self):
         assumptions = {**self.assumptions}
-        assumptions['real'] = True
+        assumptions['real'] = True        
         return assumptions
 
     def __eq__(self, other):
         return isinstance(other, DtypeRealConditional)
 
     def __hash__(self):
         return hash(type(self).__name__)
@@ -2731,15 +2601,15 @@
 class DtypeRational(DtypeExtendedRational, DtypeReal):
 
     is_rational = True
     is_finite = True
     
     @property
     def universalSet(self):
-        from sympy import Interval
+        from sympy import Interval        
         return Interval(S.NegativeInfinity, S.Infinity, rational=True)
 
     def as_Set(self):
         return S.Rationals
 
     def __str__(self):
         return 'rational'
@@ -2754,17 +2624,14 @@
     def __hash__(self):
         return hash(type(self).__name__)
 
     def __call__(self, **kwargs):
         if not kwargs:
             return self
         return DtypeRationalConditional(**kwargs)
-    
-    def extended_type(self):
-        return self.extended_rational
 
 
 class DtypeRationalConditional(DtypeRational):
 
     def as_Set(self):
         if self.assumptions.get('positive') is True:
             ...
@@ -2775,33 +2642,33 @@
     
     def __str__(self):
         return Dtype.__str__(self, 'rational')
     
     @property
     def dict(self):
         assumptions = {**self.assumptions}
-        assumptions['rational'] = True
+        assumptions['rational'] = True        
         return assumptions
 
     def __eq__(self, other):
         return isinstance(other, DtypeRationalConditional)
 
     def __hash__(self):
         return hash(type(self).__name__)
 
 
 class DtypeInteger(DtypeExtendedInteger, DtypeRational):
     
-    is_DtypeInteger = True
+    is_DtypeInteger = True    
     is_integer = True
     is_finite = True
     
     @property
     def universalSet(self):
-        from sympy import Range
+        from sympy import Range        
         return Range(S.NegativeInfinity, S.Infinity)
     
     def as_Set(self):
         from sympy.sets import Integers
         return Integers
 
     def __str__(self):
@@ -2818,18 +2685,15 @@
         return hash(type(self).__name__)
 
     def __call__(self, **kwargs):
         if not kwargs:
             return self
         return DtypeIntegerConditional(**kwargs)
 
-    def extended_type(self):
-        return self.extended_integer
-
-
+        
 class DtypeIntegerConditional(DtypeInteger):
 
     def as_Set(self):
         positive = self.assumptions.get('positive')
         if positive:
             from sympy.sets import PositiveIntegers
             return PositiveIntegers
@@ -2860,15 +2724,15 @@
     
     def __str__(self):
         return Dtype.__str__(self, 'integer')
     
     @property
     def dict(self):
         assumptions = {**self.assumptions}
-        assumptions['integer'] = True
+        assumptions['integer'] = True        
         return assumptions
 
     def __eq__(self, other):
         return isinstance(other, DtypeIntegerConditional)
 
     def __hash__(self):
         return hash(type(self).__name__)
@@ -3076,15 +2940,15 @@
         if dtype is not self.dtype:
             hit = True
             
         lengths = []
         for l in self.lengths:
             _l = l._subs(old, new)
             if _l != l:
-                hit = True
+                hit = True            
             lengths.append(_l)
             
         if hit:
             return type(self)(dtype, tuple(lengths))
         
         return self
```

### Comparing `sympy.keras-1.0.21/sympy/core/sympify.py` & `sympy.keras-1.0.4/sympy/core/sympify.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/core/trace.py` & `sympy.keras-1.0.4/sympy/core/trace.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/crypto/__init__.py` & `sympy.keras-1.0.4/sympy/crypto/__init__.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/crypto/crypto.py` & `sympy.keras-1.0.4/sympy/crypto/crypto.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/deprecated/class_registry.py` & `sympy.keras-1.0.4/sympy/deprecated/class_registry.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/diffgeom/diffgeom.py` & `sympy.keras-1.0.4/sympy/diffgeom/diffgeom.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/diffgeom/rn.py` & `sympy.keras-1.0.4/sympy/diffgeom/rn.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/discrete/__init__.py` & `sympy.keras-1.0.4/sympy/discrete/__init__.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/discrete/convolutions.py` & `sympy.keras-1.0.4/sympy/discrete/convolutions.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/discrete/recurrences.py` & `sympy.keras-1.0.4/sympy/discrete/recurrences.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/discrete/transforms.py` & `sympy.keras-1.0.4/sympy/discrete/transforms.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/external/__init__.py` & `sympy.keras-1.0.4/sympy/external/__init__.py`

 * *Files 10% similar despite different names*

```diff
@@ -11,8 +11,10 @@
 If the resulting library is not installed, or if the installed version
 is less than a given minimum version, the function will return None.
 Otherwise, it will return the library. See the docstring of
 import_module() for more information.
 
 """
 
-from sympy.external.importtools import import_module
+from sympy.external.importtools import import_module
+
+__all__ = ['import_module']
```

### Comparing `sympy.keras-1.0.21/sympy/external/gmpy.py` & `sympy.keras-1.0.4/sympy/external/gmpy.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,13 +1,44 @@
 import os
 
 import mpmath.libmp as mlib
 
 from sympy.external import import_module
 
+__all__ = [
+    # GROUND_TYPES is either 'gmpy' or 'python' depending on which is used. If
+    # gmpy is installed then it will be used unless the environment variable
+    # SYMPY_GROUND_TYPES is set to something other than 'auto', 'gmpy', or
+    # 'gmpy2'.
+    'GROUND_TYPES',
+
+    # If HAS_GMPY is 0, no supported version of gmpy is available. Otherwise,
+    # HAS_GMPY will be 2 for gmpy2 if GROUND_TYPES is 'gmpy'. It used to be
+    # possible for HAS_GMPY to be 1 for gmpy but gmpy is no longer supported.
+    'HAS_GMPY',
+
+    # SYMPY_INTS is a tuple containing the base types for valid integer types.
+    # This is either (int,) or (int, type(mpz(0))) depending on GROUND_TYPES.
+    'SYMPY_INTS',
+
+    # MPQ is either gmpy.mpq or the Python equivalent from
+    # sympy.external.pythonmpq
+    'MPQ',
+
+    # MPZ is either gmpy.mpz or int.
+    'MPZ',
+
+    # Either the gmpy or the mpmath function
+    'factorial',
+
+    # isqrt from gmpy or mpmath
+    'sqrt',
+]
+
+
 #
 # SYMPY_GROUND_TYPES can be gmpy, gmpy2, python or auto
 #
 GROUND_TYPES = os.environ.get('SYMPY_GROUND_TYPES', 'auto').lower()
 
 
 #
```

### Comparing `sympy.keras-1.0.21/sympy/external/importtools.py` & `sympy.keras-1.0.4/sympy/external/importtools.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/external/pythonmpq.py` & `sympy.keras-1.0.4/sympy/external/pythonmpq.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/functions/__init__.py` & `sympy.keras-1.0.4/sympy/functions/__init__.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,25 +2,25 @@
 
 Combinatorial - factorial, fibonacci, harmonic, bernoulli...
 Elementary - hyperbolic, trigonometric, exponential, floor and ceiling, sqrt...
 Special - gamma, zeta,spherical harmonics...
 """
 
 from sympy.functions.combinatorial.factorials import (factorial, factorial2,
-        rf, ff, binomial, RisingFactorial, FallingFactorial, subfactorial, Factorial, Factorial2)
+        rf, ff, binomial, RisingFactorial, FallingFactorial, subfactorial, Factorial)
 
-from sympy.functions.combinatorial.factorials import Binomial
+from sympy.functions.combinatorial.factorials import Binomial 
 
 from sympy.functions.combinatorial.numbers import (carmichael, fibonacci, lucas, tribonacci,
         harmonic, bernoulli, bell, euler, catalan, genocchi, partition, Stirling)
 from sympy.core.power import sqrt, cbrt, root, real_root
 from sympy.functions.elementary.miscellaneous import (Min, Max, Id)
-from sympy.functions.elementary.complexes import (Re, Im, sign, Sign, Abs, Norm,
+from sympy.functions.elementary.complexes import (Re, Im, sign, Abs, Norm,
         Conjugate, conjugate, Arg, arg, polar_lift, periodic_argument, unbranched_argument,
-        principal_branch, polarify, unpolarify)
+        principal_branch, transpose, adjoint, polarify, unpolarify)
 from sympy.functions.elementary.trigonometric import (sin, cos, tan, 
         sec, csc, cot, sinc, asin, acos, atan, asec, acsc, acot, atan2)
 
 from sympy.functions.elementary.trigonometric import Sin, Cos, Tan, Sec, Csc, Cot, ArcSin, ArcCos, ArcTan, ArcSec, ArcCsc, ArcCot
 
 from sympy.functions.elementary.exponential import (exp_polar, exp, log, Exp, Log,
         LambertW)
```

### Comparing `sympy.keras-1.0.21/sympy/functions/combinatorial/factorials.py` & `sympy.keras-1.0.4/sympy/functions/combinatorial/factorials.py`

 * *Files 2% similar despite different names*

```diff
@@ -270,15 +270,17 @@
     def _eval_is_rational(self):
         if self.args[0].is_integer and self.args[0].is_nonnegative:
             return True
 
     def _sympystr(self, p):
         n = self.arg
         latex = p._print(n)
-        return 'Factorial(%s)' % latex
+        if n.is_symbol:
+            return '%s!' % latex
+        return '(%s)!' % latex
 
     def _latex(self, p, exp=None):
         from sympy.printing.precedence import PRECEDENCE
         tex = r"%s!" % p.parenthesize(self.args[0], PRECEDENCE["Func"])
 
         if exp is not None:
             return r"%s^{%s}" % (tex, exp)
@@ -368,15 +370,15 @@
         return uppergamma(arg + 1, -1) / S.Exp1
 
     def _eval_is_extended_negative(self):
         if self.args[0].is_integer and self.args[0].is_extended_negative:
             return True
 
 
-class Factorial2(CombinatorialFunction):
+class factorial2(CombinatorialFunction):
     r"""The double factorial `n!!`, not to be confused with `(n!)!`
 
     The double factorial is defined for nonnegative integers and for odd
     negative integers as:
 
     .. math:: n!! = \begin{cases} 1 & n = 0 \\
                     n(n-2)(n-4) \cdots 1 & n\ \text{positive odd} \\
@@ -468,29 +470,14 @@
                 return ((n + 1) / 2).is_even
 
     def _eval_rewrite_as_gamma(self, n, **kwargs):
         from sympy import gamma, Piecewise, sqrt
         return 2 ** (n / 2) * gamma(n / 2 + 1) * Piecewise((1, Eq(Mod(n, 2), 0)),
                 (sqrt(2 / pi), Eq(Mod(n, 2), 1)))
 
-    def _sympystr(self, p):
-        n = self.arg
-        latex = p._print(n)
-        return 'Factorial2(%s)' % latex
-
-    def _latex(self, p, exp=None):
-        from sympy.printing.precedence import PRECEDENCE
-        tex = r"%s!!" % p.parenthesize(self.args[0], PRECEDENCE["Func"])
-
-        if exp is not None:
-            return r"%s^{%s}" % (tex, exp)
-        else:
-            return tex
-
-factorial2 = Factorial2
 ###############################################################################
 ######################## RISING and FALLING FACTORIALS ########################
 ###############################################################################
 
 
 class RisingFactorial(CombinatorialFunction):
     r"""
@@ -622,15 +609,15 @@
 
     def _sage_(self):
         import sage.all as sage
         return sage.rising_factorial(self.args[0]._sage_(),
                                      self.args[1]._sage_())
 
     def _latex(self, p, exp=None):
-        n, k = self.args
+        n, k = self.args        
         if n.is_Add or n.is_Mul:
             base = r"\left(%s\right)" % p._print(n)
         else:
             base = p._print(n)
 
         tex = r"{%s}^\overline{%s}" % (base, p._print(k))
```

### Comparing `sympy.keras-1.0.21/sympy/functions/combinatorial/numbers.py` & `sympy.keras-1.0.4/sympy/functions/combinatorial/numbers.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/functions/elementary/complexes.py` & `sympy.keras-1.0.4/sympy/functions/elementary/complexes.py`

 * *Files 0% similar despite different names*

```diff
@@ -128,18 +128,14 @@
         if p._settings['gothic_re_im']:
             tex = r"\Re{%s}" % p.parenthesize(self.args[0], PRECEDENCE['Atom'])
         else:
             tex = r"\operatorname{{Re}}{{{}}}".format(p.parenthesize(self.args[0], PRECEDENCE['Atom']))
 
         return p._do_exponent(tex, exp)
 
-    @classmethod
-    def sub_class_key(cls):
-        return 41
-
 
 class Im(Function):
     """
     Returns imaginary part of expression. This function performs only
     elementary analysis and so it will fail to decompose properly more
     complicated expressions. If completely simplified result is needed then
     use Basic.as_real_imag() or perform complex expansion on instance of
@@ -254,24 +250,21 @@
         if p._settings['gothic_re_im']:
             tex = r"\Im{%s}" % p.parenthesize(self.args[0], PRECEDENCE['Atom'])
         else:
             tex = r"\operatorname{{Im}}{{{}}}".format(p.parenthesize(self.args[0], PRECEDENCE['Atom']))
 
         return p._do_exponent(tex, exp)
 
-    @classmethod
-    def sub_class_key(cls):
-        return 42
 
 ###############################################################################
 ############### SIGN, ABSOLUTE VALUE, ARGUMENT and CONJUGATION ################
 ###############################################################################
 
 
-class Sign(Function):
+class sign(Function):
     """
     Returns the complex sign of an expression:
 
     If the expression is real the sign will be:
 
         * 1 if expression is positive
         * 0 if expression is equal to zero
@@ -385,24 +378,21 @@
             return True
 
     def _eval_is_extended_positive(self):
         if self.args[0].is_extended_positive:
             return True
 
     def _eval_is_imaginary(self):
-        return self.arg.is_imaginary
-
-    def _eval_is_finite(self):
-        return self.arg.is_finite
+        return self.args[0].is_imaginary
 
-    def _eval_is_extended_integer(self):
-        return self.arg.is_extended_real
+    def _eval_is_integer(self):
+        return self.args[0].is_extended_real
 
     def _eval_is_zero(self):
-        return self.arg.is_zero
+        return self.args[0].is_zero
 
     def _eval_power(self, other):
         if (
             fuzzy_not(self.args[0].is_zero) and
             other.is_integer and
             other.is_even
         ):
@@ -420,28 +410,14 @@
         from sympy.functions.special.delta_functions import Heaviside
         if arg.is_extended_real:
             return Heaviside(arg) * 2 - 1
 
     def _eval_simplify(self, ratio, measure, rational, inverse):
         return self.func(self.args[0].factor())
 
-    def _latex(self, p, exp=None):
-        tex = r"sign\left({%s}\right)" % p._print(self.args[0])
-        if exp is not None:
-            return r"%s^{%s}" % (tex, exp)
-        else:
-            return tex
-
-    def __iter__(self):
-        raise TypeError
-
-    def __getitem__(self, index):
-        return self.func(self.arg[index])
-
-sign = Sign
 
 class Abs(Function):
     """
     Return the absolute value of the argument.
 
     This is an extension of the built-in function abs() to accept symbolic
     values.  If you pass a SymPy expression to the built-in abs(), it will
@@ -551,25 +527,22 @@
     def _eval_is_integer(self):
         if self.args[0].is_extended_real:
             return self.args[0].is_integer
 
     def _eval_is_zero(self):
         return self._args[0].is_zero
 
-    def _eval_is_extended_integer(self):
-        return self.arg.is_extended_integer
-
     def _eval_is_extended_positive(self):
         is_z = self.is_zero
         if is_z is not None:
             return not is_z
 
     def _eval_is_rational(self):
         if self.arg.is_set:
-            return True
+            return True                
         return self.args[0].is_rational
 
     def _eval_is_finite(self):
         return self.arg.is_finite
 
     def _eval_is_even(self):
         if self.args[0].is_extended_real:
@@ -601,15 +574,15 @@
                     if e % q:
                         break
                     
                     t = b ** (e / q)
                     args.append(t)
                 else:
                     x = Mul(*args)
-                    return abs(x) ** exponent.p
+                    return abs(x) ** exponent.p 
         return
 
     def _eval_nseries(self, x, n, logx):
         direction = self.args[0].leadterm(x)[0]
         s = self.args[0]._eval_nseries(x, n=n, logx=logx)
         when = Eq(direction, 0)
         return Piecewise(
@@ -666,15 +639,14 @@
 
     def __iter__(self):
         raise TypeError
 
     def __getitem__(self, index):
         return self.func(self.arg[index])
 
-
 class Norm(Function):
     """
     Return the norm value of a vector.
 
     """
 
     is_extended_real = True
@@ -725,15 +697,15 @@
     def _eval_is_extended_positive(self):
         is_z = self.is_zero
         if is_z is not None:
             return not is_z
 
     def _eval_is_rational(self):
         if self.arg.is_set:
-            return True
+            return True                
         return self.args[0].is_rational
 
     def _eval_is_finite(self):
         return self.arg.is_finite
 
     def _eval_is_even(self):
         if self.args[0].is_extended_real:
@@ -845,26 +817,22 @@
     def simplify(self, deep=False, **kwargs):
         expri = self.arg
         if expri.is_Exp:
             i_exp = expri.arg
             if i_exp.is_Mul:
                 args = i_exp.args
                 if len(args) == 2:
-                    i, arg = args
+                    i, arg = args                 
                     if i.is_ImaginaryUnit:
                         if arg.is_Arg:
 #                             Arg(exp(i * Arg(z))) = Arg(z)
                             return arg
             
         return Function.simplify(self, deep, **kwargs)
     
-    @classmethod
-    def sub_class_key(cls):
-        return 43
-
 arg = Arg
 
 class Conjugate(Function):
     """
     Returns the `complex conjugate` Ref[1] of an argument.
     In mathematics, the complex conjugate of a complex number
     is given by changing the sign of the imaginary part.
@@ -911,16 +879,15 @@
         if x.is_real:
             return conjugate(Derivative(self.args[0], x, evaluate=True))
         elif x.is_imaginary:
             return -conjugate(Derivative(self.args[0], x, evaluate=True))
 
     def _eval_transpose(self, axis=-1):
         if axis == self.default_axis:
-            from sympy import Adjoint
-            return Adjoint(self.args[0])
+            return adjoint(self.args[0])
 
     def _eval_is_algebraic(self):
         return self.args[0].is_algebraic
 
     def _eval_is_finite(self):
         return self.arg.is_finite
     
@@ -966,36 +933,87 @@
         x = self.arg
         
         s = p._print(x)
         if x.is_AssocOp or x.is_MatMul:
             s = "(%s)" % s
         return "~%s" % s
 
-    def __iter__(self):
-        raise TypeError
+conjugate = Conjugate
 
-    def __getitem__(self, indices):
-        return self.func(self.arg[indices])
+class transpose(Function):
+    """
+    Linear map transposition.
+    """
+
+    @classmethod
+    def eval(cls, arg):
+        obj = arg._eval_transpose()
+        if obj is not None:
+            return obj
+
+    @property
+    def dtype(self):
+        return self.arg.dtype
+
+    def _sympystr(self, p):
+        return p.parenthesize(self.arg, 0) + ".T"
+
+    def _latex(self, p): 
+        return r"{%s}^{\color{red} T}" % p._print(self.arg)
+
+    def _eval_adjoint(self):
+        return conjugate(self.args[0])
+
+    def _eval_conjugate(self):
+        return adjoint(self.args[0])
+
+    def _eval_transpose(self, axis=-1):
+        if axis == self.default_axis:
+            return self.args[0]
 
-    @staticmethod
-    def simplify_Lamda(self, squeeze=False):
-        expr = self.expr
-        arg, *limits = expr.args
-        lamda = self.func(arg, *self.limits)
-        _lamda = lamda.simplify()
-        if lamda != _lamda:
-            return expr.func(_lamda, *limits, evaluate=False)
-             
-        return self
+
+class adjoint(Function):
+    """
+    Conjugate transpose or Hermite conjugation.
+    """
 
     @classmethod
-    def sub_class_key(cls):
-        return 40
+    def eval(cls, arg):
+        obj = arg._eval_adjoint()
+        if obj is not None:
+            return obj
+        obj = arg._eval_transpose()
+        if obj is not None:
+            return conjugate(obj)
 
-conjugate = Conjugate
+    def _eval_adjoint(self):
+        return self.args[0]
+
+    def _eval_conjugate(self):
+        return transpose(self.args[0])
+
+    def _eval_transpose(self, axis=-1):
+        if axis == self.default_axis:
+            return conjugate(self.args[0])
+
+    def _latex(self, printer, exp=None, *args):
+        arg = printer._print(self.args[0])
+        tex = r'%s^{\dagger}' % arg
+        if exp:
+            tex = r'\left(%s\right)^{%s}' % (tex, printer._print(exp))
+        return tex
+
+    def _pretty(self, printer, *args):
+        from sympy.printing.pretty.stringpict import prettyForm
+        pform = printer._print(self.args[0], *args)
+        if printer._use_unicode:
+            pform = pform ** prettyForm(u'\N{DAGGER}')
+        else:
+            pform = pform ** prettyForm('+')
+        return pform
 
 ###############################################################################
 ############### HANDLING OF POLAR NUMBERS #####################################
 ###############################################################################
 
 
 class polar_lift(Function):
```

### Comparing `sympy.keras-1.0.21/sympy/functions/elementary/exponential.py` & `sympy.keras-1.0.4/sympy/functions/elementary/exponential.py`

 * *Files 0% similar despite different names*

```diff
@@ -466,20 +466,15 @@
     @staticmethod
     def simplify_Lamda(self, squeeze=False):
         simplified = self.func(self.expr.arg, *self.limits).simplify()
         if not simplified.is_Lamda:
             return Exp(simplified)
 
         return self
-           
-    @classmethod
-    def sub_class_key(cls):
-        return 10
-
-
+            
 exp = Exp
     
 def match_real_imag(expr):
     """
     Try to match expr with a + b*I for real a and b.
 
     ``match_real_imag`` returns a tuple containing the real and imaginary
@@ -926,20 +921,15 @@
         arg = p._print(self.arg)
         if self.arg.is_AssocOp or self.arg.is_MatMul:
             return r"\log \left(%s\right)" % arg
         return r"\log {%s}" % arg
 
     def domain_definition(self):
         from sympy import Unequal
-        arg = self.arg
-        if arg.shape:
-            indices, limits = arg.variables_with_limits()
-            from sympy import ForAll
-            return ForAll(Unequal(arg[tuple(indices)], 0), *limits)
-        return Unequal(arg, 0)
+        return Unequal(self.arg, 0)
     
     @cacheit
     def _eval_domain_defined(self, x, **kwargs):
         real = kwargs.get('real')
         arg = self.arg
         if x == arg:
             if real:
@@ -949,20 +939,16 @@
                 return x.domain - {0}
             
         if real:
             return arg._eval_domain_defined(x, positive=True)
         else:
             return arg._eval_domain_defined(x, zero=False)
     
-    @classmethod
-    def sub_class_key(cls):
-        return 11
-
 
-log = Log
+log = Log    
 
 
 class LambertW(Function):
     r"""
     The Lambert W function `W(z)` is defined as the inverse
     function of `w \exp(w)` [1]_.
```

### Comparing `sympy.keras-1.0.21/sympy/functions/elementary/hyperbolic.py` & `sympy.keras-1.0.4/sympy/functions/elementary/hyperbolic.py`

 * *Files 1% similar despite different names*

```diff
@@ -241,20 +241,15 @@
             return self.args[0].is_extended_negative
 
     def _eval_is_finite(self):
         arg = self.args[0]
         if arg.is_imaginary:
             return True
 
-    @classmethod
-    def sub_class_key(cls):
-        return 30
-
 sinh = Sinh
-
 class Cosh(HyperbolicFunction):
     r"""
     The hyperbolic cosine function, `\frac{e^x + e^{-x}}{2}`.
 
     * cosh(x) -> Returns the hyperbolic cosine of x
 
     See Also
@@ -399,18 +394,14 @@
             return True
 
     def _eval_is_finite(self):
         arg = self.args[0]
         if arg.is_imaginary:
             return True
 
-    @classmethod
-    def sub_class_key(cls):
-        return 31
-
 cosh = Cosh
 
 class Tanh(HyperbolicFunction):
     r"""
     The hyperbolic tangent function, `\frac{\sinh(x)}{\cosh(x)}`.
 
     * tanh(x) -> Returns the hyperbolic tangent of x
@@ -559,18 +550,14 @@
             return self.args[0].is_extended_negative
 
     def _eval_is_finite(self):
         arg = self.args[0]
         if arg.is_extended_real:
             return True
 
-    @classmethod
-    def sub_class_key(cls):
-        return 32
-
 tanh = Tanh
 
 class Coth(HyperbolicFunction):
     r"""
     The hyperbolic cotangent function, `\frac{\cosh(x)}{\sinh(x)}`.
 
     * coth(x) -> Returns the hyperbolic cotangent of x
@@ -705,18 +692,14 @@
         arg = self.args[0].as_leading_term(x)
 
         if x in arg.free_symbols and Order(1, x).contains(arg):
             return 1/arg
         else:
             return self.func(arg)
 
-    @classmethod
-    def sub_class_key(cls):
-        return 33
-
 coth = Coth
 
 class ReciprocalHyperbolicFunction(HyperbolicFunction):
     """Base class for reciprocal functions of hyperbolic functions. """
 
     #To be defined in class
     _reciprocal_of = None
@@ -762,15 +745,15 @@
 
     def _eval_rewrite_as_tanh(self, arg, **kwargs):
         return self._rewrite_reciprocal("_eval_rewrite_as_tanh", arg)
 
     def _eval_rewrite_as_coth(self, arg, **kwargs):
         return self._rewrite_reciprocal("_eval_rewrite_as_coth", arg)
 
-    def as_real_imag(self, deep=True, **hints):
+    def as_real_imag(self, deep = True, **hints):
         return (1 / self._reciprocal_of(self.args[0])).as_real_imag(deep, **hints)
 
     def _eval_conjugate(self):
         return self.func(self.args[0].conjugate())
 
     def _eval_expand_complex(self, deep=True, **hints):
         re_part, im_part = self.as_real_imag(deep=True, **hints)
```

### Comparing `sympy.keras-1.0.21/sympy/functions/elementary/integers.py` & `sympy.keras-1.0.4/sympy/functions/elementary/integers.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/functions/elementary/miscellaneous.py` & `sympy.keras-1.0.4/sympy/functions/elementary/miscellaneous.py`

 * *Files 1% similar despite different names*

```diff
@@ -9,15 +9,14 @@
 from sympy.core.relational import Relational
 from sympy.core.singleton import Singleton
 from sympy.core.symbol import Dummy
 from sympy.core.compatibility import with_metaclass
 from sympy.core.logic import fuzzy_and, fuzzy_or, _torf
 from sympy.logic.boolalg import And
 from builtins import isinstance
-from sympy.core.cache import cacheit
 
 
 def _minmax_as_Piecewise(op, *args):
     # helper for Min/Max rewrite as Piecewise
     from sympy.functions.elementary.piecewise import Piecewise
     ec = []
     for i, a in enumerate(args):
@@ -188,17 +187,16 @@
 
         # remove redundant symbolic args
         def do(ai, a):
             if not isinstance(ai, (Min, Max)):
                 return ai
             cond = a in ai.args
             if not cond:
-                args = [do(i, a) for i in ai.args]
-                return ai.func(*args, 
-                               evaluate=len(args) < len(ai.args) or ai._has(ai.negated_type) and not any(arg._has(ai.negated_type) for arg in args))
+                return ai.func(*[do(i, a) for i in ai.args],
+                    evaluate=False)
             if isinstance(ai, cls):
                 return ai.func(*[do(i, a) for i in ai.args if i != a],
                     evaluate=False)
             return a
 
         for i, a in enumerate(args):
             args[i + 1:] = [do(ai, a) for ai in args[i + 1:]]
@@ -312,18 +310,18 @@
         if r is not None:
             return r
 #         r = hit(y >= x, Min, Max)
 #         if r is not None:
 #             return r
             # simplification can be expensive, so be conservative
             # in what is attempted
-#             from sympy.core.exprtools import factor_terms
+#             from sympy.core.exprtools import factor_terms            
 #             x = factor_terms(x - y)
 #             if i:
-#                 break
+#                 break 
 #             x = x - y
 #             y = S.Zero
 
         return False
 
     def _eval_derivative(self, s):
         # f(x).diff(s) -> x.diff(s) * f.fdiff(1)(s)
```

### Comparing `sympy.keras-1.0.21/sympy/functions/elementary/piecewise.py` & `sympy.keras-1.0.4/sympy/functions/elementary/piecewise.py`

 * *Files 2% similar despite different names*

```diff
@@ -70,26 +70,14 @@
     @cacheit
     def _eval_domain_defined(self, x, **_):
         domain = Basic._eval_domain_defined(self, x)
         for arg in self.args:
             domain &= arg.domain_defined(x)
         return domain
 
-    def limits_in_context(self, has_args=None, parent=None):
-        cond = self.cond
-        for e, c in parent.args:
-            if e == self.expr:
-                break
-            cond &= c.invert()
-
-        if cond.is_And:
-            return [(eq.wrt, eq) for eq in cond.args]
-        else: 
-            return [(cond.wrt, cond)]
-
 
 class Piecewise(Function):
     """
     Represents a piecewise function.
 
     Usage:
 
@@ -154,15 +142,15 @@
                 free_symbols = c.lhs.free_symbols
             else:
                 free_symbols = c.free_symbols
             if s is None:
                 s = free_symbols
             else:
                 s = s & free_symbols
-        return s
+        return s 
         
     @property
     def set(self):
         newargs = []
         for e, c in self.args:
             newargs.append((e.set, c))
         return self.func(*newargs, evaluate=False)
@@ -947,28 +935,28 @@
         for e, c in self.args:
             # l in (j; i], old = l in [0; n), new = l in [0; j)(i; n)
             _c = c._subs(old, new)
             if _c.is_BooleanFalse:
                 hit = True
                 continue
             if not _aresame(_c, c):
-                hit = True
-                c = _c
+                hit = True  
+                c = _c    
                       
             _e = e._subs(old, new)
             if not _aresame(_e, e):
-                hit = True
-                e = _e
+                hit = True  
+                e = _e    
                      
             args.append((e, c))
             if c:
                 break
         if hit:
             return self.func(*args)
-        return self
+        return self        
 
     def _eval_transpose(self, axis=-1):
         if axis == self.default_axis:
             return self.func(*[(e.transpose(), c) for e, c in self.args])
 
     def _eval_template_is_attr(self, is_attr):
         b = None
@@ -1129,15 +1117,15 @@
             (e0, c0), (e1, _) = lhs.args
             if e0 == rhs:
                 if Equal(e1, rhs) == False:
                     return c0
             elif e1 == rhs:
                 if Equal(e0, rhs) == False:
                     c1 = c0.invert()
-                    return c1
+                    return c1                
                 
         elif rhs.is_Add and lhs in rhs.args:
             cls = rhs.func
             args = [*rhs.args]
             args.remove(lhs)
             return self.func(0, cls(*args)).simplify()
                  
@@ -1161,55 +1149,43 @@
             args = [*rhs.args]
             args.remove(lhs)
             return self.func(0, cls(*args)).simplify()
         
     @staticmethod
     def simplify_Equality(e0, e1, lhs, rhs):
         from sympy.functions.special.tensor_functions import KroneckerDelta
-        hit = False
         if lhs.is_integer and rhs.is_integer:
             eq = KroneckerDelta(lhs, rhs)
-            _e1 = e1._subs(eq, S.Zero)
-            hit = _e1 != e1
-            e1 = _e1
-            
-            _e0 = e0._subs(eq, S.One)
-            hit |= _e0 != e0
-            e0 = _e0
+            e1 = e1._subs(eq, S.Zero)
+            e0 = e0._subs(eq, S.One)
 
         _e0 = e0._subs(lhs, rhs)
         __e0 = e0._subs(rhs, lhs)
 
         if {e1, e1._subs(lhs, rhs), e1._subs(rhs, lhs)} & {e0, _e0, __e0}:
             return e1
         
         if not e0.is_set and lhs.is_integer and rhs.is_integer:
-            e_diff = e0 - e1
+            e_diff = e0 - e1                   
             if lhs.is_symbol: 
 #                 precautious usage of domain_defined
                 domain_defined = e_diff.domain_defined(lhs)
                 from sympy import Element
                 if Element(rhs, domain_defined) == False:
                     return
                 
             delta = KroneckerDelta(lhs, rhs)
             if not lhs.is_Number:
                 if e_diff.is_infinite:
                     return
-                _e_diff = e_diff._subs(lhs, rhs)
-                hit |= _e_diff != e_diff
-                delta *= _e_diff
-
+                
+                delta *= e_diff._subs(lhs, rhs)
+                
             delta += e1
-            _delta = delta.simplify()
-            hit |= _delta != delta
-            if hit:
-                return _delta
-            return
-
+            return delta.simplify()
         from sympy import Complement
         
         if e1.is_Complement:
             _A, B = e1.args
             if _e0 == e0:
                 has_lhs, has_rhs = B._has(lhs), B._has(rhs)
                 if has_lhs and not has_rhs:
@@ -1238,44 +1214,44 @@
         if hit:
             return Piecewise((e0, Equal(lhs, rhs)), (e1, True))
         
     def simplifyComplement(self, i):
         if not i:
             return self
         ei, ci = self.args[i]
-        x, domain = ci.args
+        x, domain = ci.args        
         
         union = self.union_domain(i) 
 
         A, B = domain.args
         if B in union:
             domain = A
             args = [*self.args]
             args[i] = (ei, ci.func(x, domain))
             return self.func(*args).simplify()
             
         return self
         
     def union_domain(self, i):
         _, ci = self.args[i]
-        x, _ = ci.args
+        x, _ = ci.args        
         
-        union = x.emptySet
+        union = x.emptySet 
         for j in range(i):
             _, condition = self.args[j]
             union |= x.domain_conditioned(condition)
         return union
         
     def simplifyIntersection(self, i):
         if not i:
             return self
         ei, ci = self.args[i]
-        x, domain = ci.args
+        x, domain = ci.args        
         
-        universe = x.domain
+        universe = x.domain        
         union = self.union_domain(i)
         
         for j, s in enumerate(domain.args):
             hit = False
             if universe in s | union:
                 args = [*domain.args]
                 del args[j]                
@@ -1354,15 +1330,15 @@
                                 _f = arglist[0][0].simplify(deep=deep)
                             else:
                                 _f = Piecewise(*arglist).simplify(deep=deep)
                         else:
                             _f = f._subs(wrt, _x).simplify(deep=deep)._subs(_x, wrt)
                                                         
                         if _f != f:
-                            hit = True
+                            hit = True 
                             f = _f
                     args.append((f, cond))
                             
                 if need_swap:
                     e_last, _ = args[-1]
                     e_second_last, _ = args[-2]
                     args[-2] = (e_last, Equal(wrt, _x))
@@ -1373,19 +1349,19 @@
                         
             args = []
             hit = False
             for i, (e, c) in enumerate(self.args):
                 _e = e.simplify(deep=deep)
                 if _e != e:
                     e = _e
-                    hit = True
+                    hit = True                    
                 _c = c.simplify(deep=deep)
                 if _c != c:
                     c = _c
-                    hit = True
+                    hit = True                                    
                 args.append((e, c))
                 
             if hit:
                 return self.func(*args).simplify()
             
         expr, _ = self.args[-1]
         e, c = self.args[-2]
@@ -1402,20 +1378,20 @@
             e1, c1 = self.args[1]
             if deep:
                 e0 = e0.simplify(deep=deep)
                 e1 = e1.simplify(deep=deep)
             if c0.is_Equal:
                 res = Piecewise.simplify_Equality(e0, e1, *c0.args)
                 if res is not None:
-                    return res
+                    return res                
                                          
             if c0.is_Unequal:
                 res = Piecewise.simplify_Equality(e1, e0, *c0.args)
                 if res is not None:
-                    return res
+                    return res     
                 
             from sympy.sets.contains import NotElement, Element
             if c0.is_Element:
                 x, A = c0.args
                 if A.is_FiniteSet:
                     args = []
                     for y in A.args:
@@ -1482,15 +1458,15 @@
         cond = cond.invert()
         U = S.true
         for e, c in self.args:
             _c = c & U | cond
             if _c:
                 return e
             U &= c.invert()
-        return self
+        return self 
     
     def select_cond(self, expr):
         u = S.true
         for e, c in self.args: 
             eq = Equal(expr, e)                   
             if eq.is_BooleanFalse:
                 ...
@@ -1526,16 +1502,16 @@
         return self.func(*tuples)
 
     def _eval_is_integer(self): 
         for e, _ in self.args:
             if e.is_EmptySet:
                 continue
             if e.is_integer:
-                continue
-            return
+                continue            
+            return                
         return True
 
     def _complement(self, universe):
         if universe.is_Piecewise: 
             return
         
         tuples = []
@@ -1544,18 +1520,18 @@
         return self.func(*tuples)
 
     def mul(self, other, simplify=True):
         piece = []
         u = S.true
         for e, c in self.args:
             args = []
-            _u = S.true
-            c_ = c & u
+            _u = S.true            
+            c_ = c & u            
             for _e, _c in other.args:
-                _c_ = _c & _u
+                _c_ = _c & _u                
                 _c_ = c_ & _c_
                 
                 if _c_.is_BooleanFalse:
                     continue
                 args.append([(e * _e).simplify(), _c])
                 _u &= _c.invert()
             if len(args) == 1:
@@ -1683,15 +1659,15 @@
             ecpairs.append(r"{%s} & {\color{blue} {\text{if}}}\ \: {%s}" % (p._print(self.args[-1].expr), p._print(self.args[-1].cond)))
         tex = r"\begin{cases} %s \end{cases}"
         return tex % r" \\".join(ecpairs)
 
     def as_multiple_terms(self, x, domain, cls):
         universalSet = x.universalSet
         args = []
-        union = x.emptySet
+        union = x.emptySet 
         assert x in self.scope_variables
         for f, condition in self.args:
             _domain = (universalSet - union) & x.domain_conditioned(condition) & domain
             if not condition:
                 union |= _domain
     
             if _domain.is_FiniteSet:
@@ -1793,27 +1769,15 @@
                 
                 args.append((this, c))
                 
             return self.expr.func(*args)
         
         return self
                 
-    @cacheit
-    def sort_key(self, order=None):
-        args = self.args
-        args = tuple(arg.sort_key(order=order) for arg in args)
-        args = len(args), tuple(arg.class_key() for arg in self.args), args
-        
-        return self.class_key(), args, S.One.sort_key(order=order), S.One
-
-    @classmethod
-    def class_key(cls):
-        return 5, 100, cls.__name__
-
-
+    
 def piecewise_fold(expr):
     """
     Takes an expression containing a piecewise function and returns the
     expression in piecewise form. In addition, any ITE conditions are
     rewritten in negation normal form and simplified.
 
     Examples
```

### Comparing `sympy.keras-1.0.21/sympy/functions/elementary/trigonometric.py` & `sympy.keras-1.0.4/sympy/functions/elementary/trigonometric.py`

 * *Files 1% similar despite different names*

```diff
@@ -516,15 +516,15 @@
             a -= diff
         elif b < 0:
 #             b + 2k >0 => k > -b /2 =>
             diff = ceiling(-b / 2) * 2
             b += diff
             a += diff
 
-            return
+            return 
         if b <= 1 and a >= 0:
             return self
         if b <= 2 and a >= 1:
             return -self
 
     def _eval_is_extended_negative(self):
         from sympy import Interval
@@ -549,20 +549,17 @@
 
             return
         if b <= 1 and a >= 0:
             return False
         if b < 2 and a > 1:
             return True
 
-    @classmethod
-    def sub_class_key(cls):
-        return 20
-
 
 sin = Sin
+
         
 class Cos(TrigonometricFunction):
     """
     The cosine function.
 
     Returns the cosine of x (measured in radians).
 
@@ -1042,17 +1039,14 @@
 
             return
         if b <= 1 and a >= -1:
             return False
         if b < 3 and a > 1:
             return True
 
-    @classmethod
-    def sub_class_key(cls):
-        return 21
 
 cos = Cos
 
 
 class Tan(TrigonometricFunction):
     """
     The tangent function.
@@ -1348,17 +1342,14 @@
     def _eval_is_finite(self):
         arg = self.args[0]
 
         if arg.is_imaginary:
             return True
         return fuzzy_not((arg / pi - S.Half).is_integer)
 
-    @classmethod
-    def sub_class_key(cls):
-        return 22
 
 tan = Tan
 
 
 class Cot(TrigonometricFunction):
     """
     The cotangent function.
@@ -1646,18 +1637,14 @@
             return new
         arg = self.args[0]
         argnew = arg.subs(old, new)
         if arg != argnew and (argnew / S.Pi).is_integer:
             return S.ComplexInfinity
         return cot(argnew)
 
-    @classmethod
-    def sub_class_key(cls):
-        return 23
-
 cot = Cot
 
 class ReciprocalTrigonometricFunction(TrigonometricFunction):
     """Base class for reciprocal functions of trigonometric functions. """
 
     _reciprocal_of = None  # mandatory, to be defined in subclass
```

### Comparing `sympy.keras-1.0.21/sympy/functions/special/bessel.py` & `sympy.keras-1.0.4/sympy/functions/special/bessel.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/functions/special/beta_functions.py` & `sympy.keras-1.0.4/sympy/functions/special/beta_functions.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/functions/special/bsplines.py` & `sympy.keras-1.0.4/sympy/functions/special/bsplines.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/functions/special/delta_functions.py` & `sympy.keras-1.0.4/sympy/functions/special/delta_functions.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/functions/special/elliptic_integrals.py` & `sympy.keras-1.0.4/sympy/functions/special/elliptic_integrals.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/functions/special/error_functions.py` & `sympy.keras-1.0.4/sympy/functions/special/error_functions.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/functions/special/gamma_functions.py` & `sympy.keras-1.0.4/sympy/functions/special/gamma_functions.py`

 * *Files 0% similar despite different names*

```diff
@@ -20,15 +20,15 @@
     except ValueError:
         return False
 
 ###############################################################################
 ############################ COMPLETE GAMMA FUNCTION ##########################
 ###############################################################################
 
-class Gamma(Function):
+class gamma(Function):
     r"""
     The gamma function
 
     .. math::
         \Gamma(x) := \int^{\infty}_{0} t^{x-1} e^{-t} \mathrm{d}t.
 
     Explanation
@@ -223,15 +223,14 @@
 
     def _sympystr(self, p):
         return '(%s)' % p._print(self.arg)
 ###############################################################################
 ################## LOWER and UPPER INCOMPLETE GAMMA FUNCTIONS #################
 ###############################################################################
 
-gamma = Gamma
 
 class lowergamma(Function):
     r"""
     The lower incomplete gamma function.
 
     Explanation
     ===========
```

### Comparing `sympy.keras-1.0.21/sympy/functions/special/hyper.py` & `sympy.keras-1.0.4/sympy/functions/special/hyper.py`

 * *Files 1% similar despite different names*

```diff
@@ -275,26 +275,26 @@
             return oo
         else:
             return S(0)
 
     @property
     def convergence_statement(self):
         """ Return a condition on z under which the series converges. """
-        from sympy import And, Or, Re, Ne, oo
+        from sympy import And, Or, re, Ne, oo
         R = self.radius_of_convergence
         if R == 0:
             return False
         if R == oo:
             return True
         # The special functions and their approximations, page 44
         e = self.eta
         z = self.argument
-        c1 = And(Re(e) < 0, abs(z) <= 1)
-        c2 = And(0 <= Re(e), Re(e) < 1, abs(z) <= 1, Ne(z, 1))
-        c3 = And(Re(e) >= 1, abs(z) < 1)
+        c1 = And(re(e) < 0, abs(z) <= 1)
+        c2 = And(0 <= re(e), re(e) < 1, abs(z) <= 1, Ne(z, 1))
+        c3 = And(re(e) >= 1, abs(z) < 1)
         return Or(c1, c2, c3)
 
     def _eval_simplify(self, ratio, measure, rational, inverse):
         from sympy.simplify.hyperexpand import hyperexpand
         return hyperexpand(self)
 
     def _sage_(self):
```

### Comparing `sympy.keras-1.0.21/sympy/functions/special/mathieu_functions.py` & `sympy.keras-1.0.4/sympy/functions/special/mathieu_functions.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/functions/special/polynomials.py` & `sympy.keras-1.0.4/sympy/functions/special/polynomials.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/functions/special/singularity_functions.py` & `sympy.keras-1.0.4/sympy/functions/special/singularity_functions.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/functions/special/spherical_harmonics.py` & `sympy.keras-1.0.4/sympy/functions/special/spherical_harmonics.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/functions/special/tensor_functions.py` & `sympy.keras-1.0.4/sympy/functions/special/tensor_functions.py`

 * *Files 0% similar despite different names*

```diff
@@ -179,15 +179,15 @@
                 return S.Zero
             
             if i.is_Add and j.is_Add:
                 i_args = set(i.args)
                 j_args = set(j.args)
                 intersect = i_args & j_args
                 if intersect:
-                    i_args -= intersect
+                    i_args -= intersect 
                     j_args -= intersect
                     i = i.func(*i_args)
                     j = j.func(*j_args)                        
                     return cls(i, j)
                 
             if j.is_KroneckerDelta:
                 if i == 1:
@@ -527,15 +527,15 @@
             return self.func.invert_type(*lhs.args)
         elif rhs.is_One:
             return self.func(*lhs.args)
 
 
 class Bool(Function):
     """IversonBracket function
-    https://en.wikipedia.org/wiki/Iverson_bracket
+    https://en.wikipedia.org/wiki/Iverson_bracket     
     """
 
     def __new__(cls, arg):
         obj = Function.__new__(cls, arg)
         if not arg.is_bool:
             if 'super_complex' in obj._assumptions:
                 del obj._assumptions['super_complex']
@@ -604,15 +604,15 @@
         return '|%s|' % p._print(self.arg)        
         
     def _latex(self, p, exp=None):
         cond = p._print(self.arg)
         cond = r'\left|%s\right|' % cond
         if exp is not None:
             cond = "{%s}^{%s}" % (cond, p._print(exp))
-        return cond
+        return cond        
         
     @property
     def domain(self):
         from sympy.sets.sets import FiniteSet
         if self.arg.is_bool:
             return FiniteSet(S.Zero, S.One)
         else:
```

### Comparing `sympy.keras-1.0.21/sympy/functions/special/zeta_functions.py` & `sympy.keras-1.0.4/sympy/functions/special/zeta_functions.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/geometry/__init__.py` & `sympy.keras-1.0.4/sympy/geometry/__init__.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/geometry/curve.py` & `sympy.keras-1.0.4/sympy/geometry/curve.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/geometry/ellipse.py` & `sympy.keras-1.0.4/sympy/geometry/ellipse.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/geometry/entity.py` & `sympy.keras-1.0.4/sympy/geometry/entity.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/geometry/line.py` & `sympy.keras-1.0.4/sympy/geometry/line.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/geometry/parabola.py` & `sympy.keras-1.0.4/sympy/geometry/parabola.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/geometry/plane.py` & `sympy.keras-1.0.4/sympy/geometry/plane.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/geometry/point.py` & `sympy.keras-1.0.4/sympy/geometry/point.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/geometry/polygon.py` & `sympy.keras-1.0.4/sympy/geometry/polygon.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/geometry/util.py` & `sympy.keras-1.0.4/sympy/geometry/util.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/holonomic/__init__.py` & `sympy.keras-1.0.4/sympy/holonomic/__init__.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/holonomic/holonomic.py` & `sympy.keras-1.0.4/sympy/holonomic/holonomic.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/holonomic/holonomicerrors.py` & `sympy.keras-1.0.4/sympy/holonomic/holonomicerrors.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/holonomic/linearsolver.py` & `sympy.keras-1.0.4/sympy/holonomic/linearsolver.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/holonomic/numerical.py` & `sympy.keras-1.0.4/sympy/holonomic/numerical.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/holonomic/recurrence.py` & `sympy.keras-1.0.4/sympy/holonomic/recurrence.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/integrals/__init__.py` & `sympy.keras-1.0.4/sympy/integrals/__init__.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/integrals/deltafunctions.py` & `sympy.keras-1.0.4/sympy/integrals/deltafunctions.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/integrals/heurisch.py` & `sympy.keras-1.0.4/sympy/integrals/heurisch.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/integrals/integrals.py` & `sympy.keras-1.0.4/sympy/integrals/integrals.py`

 * *Files 4% similar despite different names*

```diff
@@ -30,20 +30,14 @@
 from sympy.utilities.exceptions import SymPyDeprecationWarning
 
 
 class Integral(AddWithLimits):
     """Represents unevaluated integral."""    
     __slots__ = ('is_commutative',)
 
-    operator = Add
-
-    @property
-    def is_comparable(self):
-        return False
-
     def __new__(cls, function, *symbols, **assumptions):
         """Create an unevaluated integral.
 
         Arguments are an integrand followed by one or more limits.
 
         If no limits are given and there is only one free symbol in the
         expression, that symbol will be used, otherwise an error will be
@@ -537,18 +531,15 @@
                         function, xab[0], **eval_kwargs)
                     if antideriv is None and meijerg is True:
                         ret = try_meijerg(function, xab)
                         if ret is not None:
                             function = ret
                             continue
 
-            final = hints.get('final', True)
-            # dotit may be iterated but floor terms making atan and acot
-            # continuous should only be added in the final round
-            if final and not isinstance(antideriv, Integral) and antideriv is not None:
+            if not isinstance(antideriv, Integral) and antideriv is not None:
                 for atan_term in antideriv.atoms(atan):
                     atan_arg = atan_term.args[0]
                     # Checking `atan_arg` to be linear combination of `tan` or `cot`
                     for tan_part in atan_arg.atoms(tan):
                         x1 = Dummy('x1')
                         tan_exp1 = atan_arg.subs(tan_part, x1)
                         # The coefficient of `tan` should be constant
@@ -977,17 +968,14 @@
 
                 # g(x) has at least a Singularity Function term
                 h = singularityintegrate(g, x)
                 if h is not None:
                     parts.append(coeff * h)
                     continue
 
-                if g.is_Probability:
-                    return
-
                 # Try risch again.
                 if risch is not False:
                     try:
                         h, i = risch_integrate(g, x,
                             separate_integral=True, conds=conds)
                     except NotImplementedError:
                         h = None
@@ -1001,15 +989,15 @@
                 # fall back to heurisch
                 if heurisch is not False:
                     try:
                         if conds == 'piecewise':
                             h = heurisch_wrapper(g, x, hints=[])
                         else:
                             h = heurisch_(g, x, hints=[])
-                    except (PolynomialError, AttributeError):
+                    except PolynomialError:
                         # XXX: this exception means there is a bug in the
                         # implementation of heuristic Risch integration
                         # algorithm.
                         h = None
             else:
                 h = None
 
@@ -1118,113 +1106,176 @@
     def simplify(self, **_):
         if len(self.limits) != 1:
             return self
         limit = self.limits[0]
         if len(limit) == 3:
             x, a, b = limit
             domain = self.expr.domain_nonzero(x)
-            
-            if a <= b:
-                from sympy.sets.sets import Interval
-                domain &= Interval(a, b, right_open=True)
-    
-                if self.expr.is_Piecewise:
-                    sgm = []
-                    for f, condition in self.expr.args:
-                        _domain = x.domain_conditioned(condition)
-                        _domain &= domain
-                        if f:
-                            if _domain.is_Interval:
-                                a, b = _domain.args
-                                if a <= b:
-                                    sgm.append(self.func(f, (x, a, b)).simplify())
-                                else:
-                                    sgm.append(self.func(f, (x, _domain)).simplify())
-                            else:
-                                sgm.append(self.func(f, (x, _domain)))
+            from sympy.sets.sets import Interval
+            domain &= Interval(a, b)
 
-                        domain -= _domain
-    
-                    return Add(*sgm)
-                try:
-                    limit = x, domain.start, domain.stop
-                except AttributeError:
-                    return self
-                
+            if isinstance(self.expr, Piecewise):
+                sgm = []
+                for f, condition in self.expr.args:
+                    if f == 0:
+                        continue
+                    _domain = x.domain_conditioned(condition) & domain
+                    sgm.append(self.func(f, (x, domain.start, domain.stop)).simplify())
+
+                return Add(*sgm)
+            try:
+                limit = x, domain.start, domain.stop
+            except AttributeError:
+                return self
         var = limit[0]
 
         function = self.expr
         independent, dependent = function.as_independent(var, as_Add=False)
         if independent == S.One:
             if limit != self.limits[0]:
                 return self.func(function, limit)
             return self
 
         if dependent == S.One:
             if len(limit) > 1:
-                if len(limit) == 3:
-                    x, a, b = limit
-                    return self.expr * (b - a)
-                else:
-                    return self
+                x, a, b = limit
+                return self.expr * (b - a)
             else:
                 return self.expr * var.dimension
-            
         return self.func(dependent, limit) * independent
 
     def _subs(self, old, new, **hints):
-        this = self._subs_utility(old, new, **hints)
-        if this is not None:
-            return this
-
-        if old in self.variables_set:
-            limits = []
-            for x, *ab in self.limits:
-                ab = [t._subs(old, new) for t in ab]
-                limits.append((x, *ab))
+        if self == old:
+            return new
 
-            return self.func(self.expr, *limits)
+        if len(self.limits) == 1:
 
-        return AddWithLimits._subs(self, old, new, **hints)        
+            limit = self.limits[0]
+            if len(limit) == 1:
+                # deal with indefinite integrals
+                x = limit[0]
+
+                function = self.expr.subs(old, new)
+                return self.func(function, (x,))
+
+            if old in self.variables_set:
+                limits = []
+                for x, *ab in self.limits:
+                    ab = [t._subs(old, new) for t in ab]
+                    limits.append((x, *ab))
+                
+                return self.func(self.expr, *limits)
+            function = self.expr._subs(old, new)
+
+            if len(limit) == 3:
+                x, a, b = limit
+                return self.func(function, (x, a.subs(old, new), b.subs(old, new))).simplify()
+            elif len(limit) == 2:
+                x, cond = limit
+                return self.func(function, (x, cond._subs(old, new))).simplify()
+            else:
+                x = limit[0]
+                return self.func(function, (x.subs(old, new)))
+        elif len(self.limits) == 0:
+            function = self.expr.subs(old, new)
+
+            return self.func(function, *self.limits)
+
+        return self
 
     def limits_subs(self, old, new, simplify=True):
+        from sympy.solvers.solvers import solve
+
         if len(self.limits) == 1:
             limit = self.limits[0]
-            expr = self.expr._subs(old, new)
+            from sympy import sin, cos
+            function = self.expr._subs(old, new)
+
+            if isinstance(new, (Mul, Add)):
+                function = function.expand()
+            if new.has(sin, cos):
+                function = function.trigsimp()
 
             if len(limit) == 3:
                 x, a, b = limit
                 if not old.has(x):
-                    self = self.func(expr, (x, a.subs(old, new), b.subs(old, new)))
+                    self = self.func(function, (x, a.subs(old, new), b.subs(old, new)))
                     return self.simplify() if simplify else self
 
-                if not new._has(x):
+                if old != x:
+
+                    g = Dummy('g')
+                    try:
+                        res = solve(old - g, x)
+                    except:
+                        res = []
+
+                    if not res:
+                        self = self.func(function, *self.limits)
+                        return self.simplify() if simplify else self
+                    if len(res) != 1:
+                        assert new.is_symbol
+                        
+                        d_old = diff(old, x)
+                        function /= d_old
+                        if not function._has(x):
+                            return self.func(function, (new, new.domain)).simplify()
+                        return self
+
+                    new = res[0].subs(g, new)
+
+                dg = diff(new, x)
+                if dg == 0:
                     _x = new.free_symbols - self.free_symbols
                     if len(_x) != 1:
                         return self
-                    _x, = _x
+                    _x, *_ = _x
+
+                    if new != _x:
+                        x_domain = _x.domain
+                        a = solve(new - a, _x)
+                        b = solve(new - b, _x)
+
+                        a = [e for e in a if e in x_domain]
+                        b = [e for e in b if e in x_domain]
+                        if len(a) != 1 or len(b) != 1:
+                            return self
+                        a, b = a[0], b[0]
+
+                        if 'domain' in _x._assumptions:
+                            __x = _x.func(_x.name, real=_x.is_real)
+                            function = function.subs(_x, __x)
+                            new = new.subs(_x, __x)
+                            _x = __x
 
-                    assert new == _x
-                    if 'domain' in _x._assumptions:
-                        domain = _x.domain
-                        if domain.is_Interval and domain.is_open:
-                            _a, _b = domain.args
-                            if a == _a and b == _b:
-                                return self.func(expr, (_x,))
-                        __x = _x.func(_x.name, real=_x.is_real)
-                        expr = expr.subs(_x, __x)
-                        _x = __x
+                        function *= diff(new, _x)
+                    else:
+                        if 'domain' in _x._assumptions:
+                            domain = _x.domain
+                            if domain.is_Interval:
+                                _a, _b = domain.min(), domain.max()
+                                if a == _a and b == _b:
+                                    return self.func(function, (_x,))
+                            __x = _x.func(_x.name, real=_x.is_real)
+                            function = function.subs(_x, __x)
+                            _x = __x
 
-                    self = self.func(expr, (_x, a, b))
+                    self = self.func(function, (_x, a, b))
                     return self.simplify() if simplify else self
-                
-                return self
+
+                self = self.func(dg * function, (x, new.subs(x, a).simplify(), new.subs(x, b).simplify()))
+                return self.simplify() if simplify else self
+
             else:
                 x = limit[0]
-                return self.func(expr, (x.subs(old, new)))
+                return self.func(function, (x.subs(old, new)))
+        elif len(self.limits) == 0:
+            function = self.expr.subs(old, new)
+
+            return self.func(function, *self.limits)
 
         return self
 
     def as_sum(self, n=None, method="midpoint", evaluate=True):
         """
         Approximates a definite integral by a sum.
 
@@ -1435,81 +1486,18 @@
         else:
             I = limit(F, x, b, False) - limit(F, x, a, True)
         for s in singularities_list:
             I += limit(((F.subs(x, s - r)) - F.subs(x, s + r)), r, 0, True)
         return I
 
     def _eval_is_finite(self):
-        expr, *limits = self.args
-        if expr.is_Probability:
-            cond = expr.arg
-            if cond.is_Conditioned:
-                cond, given = cond.args
-
-            vars = set()
-            if cond.is_Equal:
-                x, x_var = cond.args
-                vars.add(x_var)
-            elif cond.is_And:
-                for cond in cond.args:
-                    if cond.is_Equal:
-                        x, x_var = cond.args
-                        vars.add(x_var)
-                    else:
-                        return
-            else:
-                return
-            
-            if len(vars) < len(limits):
-                return
-
-            for x, *cond in limits:
-                if x not in vars:
-                    return
-
-            return True
-
-    def _eval_is_extended_complex(self):
-        function = self.expr
-        for x, domain in self.limits_dict.items():
-            if not isinstance(domain, list) and not domain.is_bool and not x.shape:
-                _x = x.copy(domain=domain)
-                if _x != x:
-                    function = function._subs(x, _x)
-                
-        return function.is_extended_complex
-        
-    def _eval_is_extended_real(self):
-        function = self.expr
-        for x, domain in self.limits_dict.items():
-            if not isinstance(domain, list) and not domain.is_bool and not x.shape:
-                _x = x.copy(domain=domain)
-                if _x != x:
-                    function = function._subs(x, _x)
-                
-        return function.is_extended_real
-    
-    def _eval_is_extended_positive(self):
-        function = self.expr
-        for x, domain in self.limits_dict.items():
-            if not isinstance(domain, list) and not domain.is_bool and not x.shape:
-                _x = x.copy(domain=domain)
-                if _x != x:
-                    function = function._subs(x, _x)
-        return function.is_extended_positive
+        ...
 
-    def _eval_is_extended_negative(self):
-        function = self.expr
-        for x, domain in self.limits_dict.items():
-            if not isinstance(domain, list) and not domain.is_bool and not x.shape:
-                _x = x.copy(domain=domain)
-                if _x != x:
-                    function = function._subs(x, _x)
-                    
-        return function.is_extended_negative
+    def _eval_is_integer(self):
+        ...
 
     def _sympystr(self, p):
         limits = ','.join([':'.join([p._print(arg) for arg in limit]) for limit in self.limits])
         return '\N{INTEGRAL}[%s](%s)' % (limits, p._print(self.expr))
 
     def _latex(self, p):
         tex, symbols = "", []
@@ -1536,31 +1524,15 @@
                                                p._print(lim[2]))
                     if len(lim) == 2:
                         tex += "_{%s}" % (p._print(lim[1]))
 
                 symbols.insert(0, r"\, d%s" % p._print(symbol))
 
         from sympy.printing.precedence import PRECEDENCE
-        expr = p.parenthesize(self.expr, PRECEDENCE["Mul"], strict=True)
-        symbols = "".join(symbols)
-        if self.expr.is_Integral:
-            return r"%s %s%s" % (tex, symbols, expr)
-        else:
-            return r"%s %s%s" % (tex, expr, symbols)
-
-    @classmethod
-    def identity(cls, self, **assumptions):
-        from sympy import ZeroMatrix
-        return ZeroMatrix(*self.shape)
-
-    @classmethod
-    def is_identity(cls, self, **_):
-        if self.shape:
-            return self.is_ZeroMatrix
-        return self.is_Zero
+        return r"%s %s%s" % (tex, p.parenthesize(self.expr, PRECEDENCE["Mul"], strict=True), "".join(symbols))
 
 
 def integrate(*args, meijerg=None, conds='piecewise', risch=None, heurisch=None, manual=None, **kwargs):
     """integrate(f, var, ...)
 
     Compute definite or indefinite integral of one or more variables
     using Risch-Norman algorithm and table lookup. This procedure is
```

### Comparing `sympy.keras-1.0.21/sympy/integrals/intpoly.py` & `sympy.keras-1.0.4/sympy/integrals/intpoly.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/integrals/manualintegrate.py` & `sympy.keras-1.0.4/sympy/integrals/manualintegrate.py`

 * *Files 0% similar despite different names*

```diff
@@ -1003,19 +1003,15 @@
 def trig_substitution_rule(integral):
     integrand, symbol = integral
     A = sympy.Wild('a', exclude=[0, symbol])
     B = sympy.Wild('b', exclude=[0, symbol])
     theta = sympy.Dummy("theta")
     target_pattern = A + B * symbol ** 2
 
-    try:
-        matches = integrand.find(target_pattern)
-    except:
-        return
-
+    matches = integrand.find(target_pattern)
     for expr in matches:
         match = expr.match(target_pattern)
         a = match.get(A, ZERO)
         b = match.get(B, ZERO)
 
         a_positive = ((a.is_number and a > 0) or a.is_positive)
         b_positive = ((b.is_number and b > 0) or b.is_positive)
@@ -1481,15 +1477,15 @@
         (_manualintegrate(substep).subs(substitution).trigsimp(), restriction)
     )
 
 
 @evaluates(DerivativeRule)
 def eval_derivativerule(integrand, symbol):
     # isinstance(integrand, Derivative) should be True
-    variable_count = list(integrand.limits)
+    variable_count = list(integrand.variable_count)
     for i, (var, count) in enumerate(variable_count):
         if var == symbol:
             variable_count[i] = (var, count - 1)
             break
     return sympy.Derivative(integrand.expr, *variable_count)
```

### Comparing `sympy.keras-1.0.21/sympy/integrals/meijerint.py` & `sympy.keras-1.0.4/sympy/integrals/meijerint.py`

 * *Files 0% similar despite different names*

```diff
@@ -320,15 +320,15 @@
     >>> _get_coeff_exp(x**3, x)
     (1, 3)
     """
     from sympy import powsimp
     (c, m) = expand_power_base(powsimp(expr)).as_coeff_mul(x)
     if not m:
         return c, S(0)
-    m, = m
+    [m] = m
     if m.is_Pow:
         if m.base != x:
             raise _CoeffExpValueError('expr not of form a*x**b')
         return c, m.exp
     elif m == x:
         return c, S(1)
     else:
```

### Comparing `sympy.keras-1.0.21/sympy/integrals/meijerint_doc.py` & `sympy.keras-1.0.4/sympy/integrals/meijerint_doc.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/integrals/prde.py` & `sympy.keras-1.0.4/sympy/integrals/prde.py`

 * *Files 0% similar despite different names*

```diff
@@ -1141,15 +1141,15 @@
     lhs = Matrix([E_part + L_part])
     rhs = Matrix([dfa.as_expr()/dfd.as_expr()])
 
     A, u = constant_system(lhs, rhs, DE)
     if not A:
         return
     if not u.shape and not derivation(u, DE, basic=True).is_zero:
-        return
+        return            
     if not all(derivation(i, DE, basic=True).is_zero for i in u._mat):
         # If the elements of u are not all constant
         # Note: See comment in constant_system
 
         # Also note: derivation(basic=True) calls cancel()
         return None
     else:
```

### Comparing `sympy.keras-1.0.21/sympy/integrals/quadrature.py` & `sympy.keras-1.0.4/sympy/integrals/quadrature.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/integrals/rationaltools.py` & `sympy.keras-1.0.4/sympy/integrals/rationaltools.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/integrals/rde.py` & `sympy.keras-1.0.4/sympy/integrals/rde.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/integrals/risch.py` & `sympy.keras-1.0.4/sympy/integrals/risch.py`

 * *Files 0% similar despite different names*

```diff
@@ -907,15 +907,15 @@
 def get_case(d, t):
     """
     Returns the type of the derivation d.
 
     Returns one of {'exp', 'tan', 'base', 'primitive', 'other_linear',
     'other_nonlinear'}.
     """
-    if not d.expr.has(t):
+    if not d.has(t):
         if d.is_one:
             return 'base'
         return 'primitive'
     if d.rem(Poly(t, t)).is_zero:
         return 'exp'
     if d.rem(Poly(1 + t**2, t)).is_zero:
         return 'tan'
```

### Comparing `sympy.keras-1.0.21/sympy/integrals/rubi/__init__.py` & `sympy.keras-1.0.4/sympy/integrals/rubi/__init__.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/integrals/rubi/constraints.py` & `sympy.keras-1.0.4/sympy/integrals/rubi/constraints.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/integrals/rubi/parsetools/generate_rules.py` & `sympy.keras-1.0.4/sympy/integrals/rubi/parsetools/generate_rules.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/integrals/rubi/parsetools/generate_tests.py` & `sympy.keras-1.0.4/sympy/integrals/rubi/parsetools/generate_tests.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/integrals/rubi/parsetools/parse.py` & `sympy.keras-1.0.4/sympy/integrals/rubi/parsetools/parse.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/integrals/rubi/rubimain.py` & `sympy.keras-1.0.4/sympy/integrals/rubi/rubimain.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/integrals/rubi/rules/binomial_products.py` & `sympy.keras-1.0.4/sympy/integrals/rubi/rules/binomial_products.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/integrals/rubi/rules/exponential.py` & `sympy.keras-1.0.4/sympy/integrals/rubi/rules/exponential.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/integrals/rubi/rules/hyperbolic.py` & `sympy.keras-1.0.4/sympy/integrals/rubi/rules/hyperbolic.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/integrals/rubi/rules/integrand_simplification.py` & `sympy.keras-1.0.4/sympy/integrals/rubi/rules/integrand_simplification.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/integrals/rubi/rules/inverse_hyperbolic.py` & `sympy.keras-1.0.4/sympy/integrals/rubi/rules/inverse_hyperbolic.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/integrals/rubi/rules/inverse_trig.py` & `sympy.keras-1.0.4/sympy/integrals/rubi/rules/inverse_trig.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/integrals/rubi/rules/linear_products.py` & `sympy.keras-1.0.4/sympy/integrals/rubi/rules/linear_products.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/integrals/rubi/rules/logarithms.py` & `sympy.keras-1.0.4/sympy/integrals/rubi/rules/logarithms.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/integrals/rubi/rules/miscellaneous_algebraic.py` & `sympy.keras-1.0.4/sympy/integrals/rubi/rules/miscellaneous_algebraic.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/integrals/rubi/rules/miscellaneous_integration.py` & `sympy.keras-1.0.4/sympy/integrals/rubi/rules/miscellaneous_integration.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/integrals/rubi/rules/miscellaneous_trig.py` & `sympy.keras-1.0.4/sympy/integrals/rubi/rules/miscellaneous_trig.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/integrals/rubi/rules/piecewise_linear.py` & `sympy.keras-1.0.4/sympy/integrals/rubi/rules/piecewise_linear.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/integrals/rubi/rules/quadratic_products.py` & `sympy.keras-1.0.4/sympy/integrals/rubi/rules/quadratic_products.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/integrals/rubi/rules/secant.py` & `sympy.keras-1.0.4/sympy/integrals/rubi/rules/secant.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/integrals/rubi/rules/sine.py` & `sympy.keras-1.0.4/sympy/integrals/rubi/rules/sine.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/integrals/rubi/rules/special_functions.py` & `sympy.keras-1.0.4/sympy/integrals/rubi/rules/special_functions.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/integrals/rubi/rules/tangent.py` & `sympy.keras-1.0.4/sympy/integrals/rubi/rules/tangent.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/integrals/rubi/rules/trinomial_products.py` & `sympy.keras-1.0.4/sympy/integrals/rubi/rules/trinomial_products.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/integrals/rubi/symbol.py` & `sympy.keras-1.0.4/sympy/integrals/rubi/symbol.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/integrals/rubi/utility_function.py` & `sympy.keras-1.0.4/sympy/integrals/rubi/utility_function.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/integrals/singularityfunctions.py` & `sympy.keras-1.0.4/sympy/integrals/singularityfunctions.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/integrals/transforms.py` & `sympy.keras-1.0.4/sympy/integrals/transforms.py`

 * *Files 0% similar despite different names*

```diff
@@ -70,15 +70,16 @@
 
     @cacheit
     def _eval_free_symbols(self):
         """
         This method returns the symbols that will exist when the transform
         is evaluated.
         """
-        return self.function.free_symbols.union({self.transform_variable}) - {self.function_variable}
+        return self.function.free_symbols.union({self.transform_variable}) \
+            -{self.function_variable}
 
     def _compute_transform(self, f, x, s, **hints):
         raise NotImplementedError
 
     def _as_integral(self, f, x, s):
         raise NotImplementedError
```

### Comparing `sympy.keras-1.0.21/sympy/integrals/trigonometry.py` & `sympy.keras-1.0.4/sympy/integrals/trigonometry.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/interactive/ipythonprinting.py` & `sympy.keras-1.0.4/sympy/interactive/ipythonprinting.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/interactive/printing.py` & `sympy.keras-1.0.4/sympy/interactive/printing.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/interactive/session.py` & `sympy.keras-1.0.4/sympy/interactive/session.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/keras/linalg.py` & `sympy.keras-1.0.4/sympy/keras/linalg.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/keras/nn/__init__.py` & `sympy.keras-1.0.4/sympy/keras/nn/__init__.py`

 * *Files 11% similar despite different names*

```diff
@@ -18,37 +18,30 @@
     is_nonnegative = True
      
     def _eval_is_extended_positive(self):
         return self.arg.is_finite
         
     def _eval_is_zero(self):
         if self.arg.is_finite:
-            return False
+            return False            
     
     @classmethod
     def eval(cls, arg):
         ...
  
     def simplify(self, **_):
         return self
  
     def __getitem__(self, indices):
         if len(self.shape) == 1:
             x = self.arg
             return exp(x[indices]) / ReducedSum(exp(x))
         if isinstance(indices, tuple):
-            i, *rest = indices
-            if isinstance(i, slice):
-                if len(self.shape) == 2:
-                    from sympy import Lamda, Basic
-                    j = self.generate_var(integer=True, excludes={j for j in indices if isinstance(j, Basic)})
-                    self = Lamda[j:self.shape[0]](self.func(self.arg[j]))
-                    return self[indices]
-            else:
-                return self.func(self.arg[i])[rest]
+            i, *indices = indices
+            return self.func(self.arg[i])[indices]
         else:
             return self.func(self.arg[indices])
  
     def __iter__(self):
         raise TypeError
  
     def _latex(self, p):
```

### Comparing `sympy.keras-1.0.21/sympy/keras/nn/convolutional/same.py` & `sympy.keras-1.0.4/sympy/keras/nn/convolutional/same.py`

 * *Files 2% similar despite different names*

```diff
@@ -65,15 +65,15 @@
         (r,), *_ = limits
     else:
         r = (1, 1)
         
     l0, l1, in_channels, out_channels = w.shape
     * batch_size, n0, n1, _in_channels = x.shape
     
-    assert in_channels == _in_channels
+    assert in_channels == _in_channels        
     
     def conv2d(x, w):
         i = Symbol(integer=True)
         di = Symbol('d_i', integer=True)
         
         j = Symbol(integer=True)
         dj = Symbol('d_j', integer=True)
@@ -100,15 +100,15 @@
         (r,), *_ = limits
     else:
         r = (1, 1, 1)
         
     l0, l1, l2, in_channels, out_channels = w.shape
     * batch_size, n0, n1, n2, _in_channels = x.shape
     
-    assert in_channels == _in_channels
+    assert in_channels == _in_channels        
     
     def conv3d(x, w):
         i = Symbol(integer=True)
         di = Symbol('d_i', integer=True)
         
         j = Symbol(integer=True)
         dj = Symbol('d_j', integer=True)
```

### Comparing `sympy.keras-1.0.21/sympy/keras/nn/functional.py` & `sympy.keras-1.0.4/sympy/keras/nn/functional.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/keras/nn/modules/classifier.py` & `sympy.keras-1.0.4/sympy/keras/nn/modules/classifier.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/keras/nn/modules/container.py` & `sympy.keras-1.0.4/sympy/keras/nn/modules/container.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/keras/nn/modules/conv.py` & `sympy.keras-1.0.4/sympy/keras/nn/modules/conv.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/keras/nn/modules/module.py` & `sympy.keras-1.0.4/sympy/keras/nn/modules/module.py`

 * *Files 2% similar despite different names*

```diff
@@ -22,28 +22,25 @@
             assert 'definition' not in sym._assumptions
             sym._assumptions['definition'] = definition
         
         for module in self._modules.values():
             module.make_substitutions()            
     
     def load_weights(self, h5):
-        state_dict = {}
         import numpy as np
         for name, weight in self._weights.items():
             try:
-                state_dict[weight] = np.array(h5[name])
+                weight.numpy = np.array(h5[name])
             except KeyError:
                 print(weight, "is not initialized properly")
-                state_dict[weight] = np.random.rand(*weight.shape)
+                weight.numpy = np.random.rand(*weight.shape)
                 
         for name, module in self._modules.items():
-            state_dict |= module.load_weights(h5[name])
-            
-        return state_dict
-    
+            module.load_weights(h5[name])
+
     def _hook_for_profile(self):
         def profile_hook_forward(func):
 
             @functools.wraps(func)
             def wrapper(self, *args, **kwargs):
                 y = func(self, *args, **kwargs)
                 if isinstance(y, tuple):
@@ -63,15 +60,15 @@
         if hasattr(self.__class__, 'forward'):
             hooked = getattr(self.__class__.forward, "hooked", None)
             if not hooked:
                 self.__class__.forward = profile_hook_forward(self.__class__.forward)
                 self.__class__.forward.hooked = True
 
 
-    @staticmethod
+    @staticmethod        
     def _addindent(s_, numSpaces):
         s = s_.split('\n')
         # don't do anything for single-line stuff
         if len(s) == 1:
             return s_
         first = s.pop(0)
         s = [(numSpaces * ' ') + line for line in s]
```

### Comparing `sympy.keras-1.0.21/sympy/keras/nn/modules/normalization.py` & `sympy.keras-1.0.4/sympy/keras/nn/modules/normalization.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/keras/nn/modules/rnn.py` & `sympy.keras-1.0.4/sympy/keras/nn/modules/rnn.py`

 * *Files 0% similar despite different names*

```diff
@@ -1166,23 +1166,23 @@
         if self.use_boundary:
             self.E_start = Symbol(real=True, shape=(self.units,)) #start emission
             self.E_end = Symbol(real=True, shape=(self.units,)) #end emission
             
     def to_tailing_padded(self, mask):
         batch_size, seq_length = mask.shape
         indices = arange(0, seq_length).unsqueeze(0, batch_size)
-        mask_invert = ~mask
+        mask_invert = ~mask 
         indices = indices + ReducedSum(mask_invert).unsqueeze(1, seq_length) #number_of_padding_zeros
         indices -= mask_invert * seq_length
         return indices
         
     def to_leading_padded(self, mask):
         batch_size, seq_length = mask.shape
         indices = arange(0, seq_length).unsqueeze(0, batch_size)
-        mask_invert = ~mask
+        mask_invert = ~mask 
         indices = indices - ReducedSum(mask_invert).unsqueeze(1, seq_length) #number_of_padding_zeros
         
         mask_invert = TensorLess(indices, 0)
         indices += mask_invert * seq_length
         return ~mask_invert, indices
 
     @staticmethod
@@ -1289,15 +1289,15 @@
         
         nloglik = logsumexp(minus_x) + energy
         nloglik /= seq_length if mask is None else ReducedSum(mask)
         return nloglik
 
     @staticmethod
     def accuracy(y_true, y_pred):
-        y_pred, x, mask = y_pred
+        y_pred, x, mask = y_pred        
         judge = y_pred == y_true
         if mask is not None:
             judge |= ~mask
 
         return ReducedMean(judge)
 
     def add_left_boundary(self, x):
```

### Comparing `sympy.keras-1.0.21/sympy/keras/nn/modules/sparse.py` & `sympy.keras-1.0.4/sympy/keras/nn/modules/sparse.py`

 * *Files 1% similar despite different names*

```diff
@@ -19,9 +19,9 @@
         if mask is None:
             return embedding
         
         mask = TensorUnequal(indices, 0) if mask else None
         
         from sympy.core.singleton import S
         S[self.W], S[indices] = embedding.of_embedding()
-        return embedding, mask
+        return embedding, mask
```

### Comparing `sympy.keras-1.0.21/sympy/keras/nn/recurrent/gru.py` & `sympy.keras-1.0.4/sympy/keras/nn/recurrent/gru.py`

 * *Files 4% similar despite different names*

```diff
@@ -44,14 +44,14 @@
     z = sigmoid(xt @ Wxz + h @ Whz + bz) 
     r = sigmoid(xt @ Wxr + h @ Whr + br)     
     gh = tanh(xt @ Wxh + (r * h) @ Whh + bh)
     
     return Piecewise(((1 - z) * gh + z * h, t > 0), (ZeroMatrix(*h.shape), True))
 
 
-@Function(real=True, shape=shape)
+@Function(real=True, shape=shape)    
 def GRU(x, *limits):
     (Wx,), (Wh,), (b,) = limits
     n = x.shape[0]
     t = Symbol(integer=True)
     return Lamda[t:n](gru[Wx, Wh, b, t](x))
```

### Comparing `sympy.keras-1.0.21/sympy/keras/nn/recurrent/lstm.py` & `sympy.keras-1.0.4/sympy/keras/nn/recurrent/lstm.py`

 * *Files 1% similar despite different names*

```diff
@@ -22,15 +22,15 @@
     if len(x_shape) > 2:
         shape = (x[0],) + shape
     return shape
 
 
 @Function(real=True, integer=None, shape=shape)
 def lstm(x, *limits):
-    (W,), (Wh,), (b,), (t,) = limits
+    (W,), (Wh,), (b,), (t,) = limits 
     hc = lstm[W, Wh, b, t - 1](x)
     
     xt = x[t]
     
     d = hc.shape[0] / 2
     
     h = Sliced(hc, Tuple(0, d))
```

### Comparing `sympy.keras-1.0.21/sympy/keras/tensorflow/optimization.py` & `sympy.keras-1.0.4/sympy/utilities/misc.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,296 +1,511 @@
-# coding=utf-8
-# Copyright 2018 The Google AI Language Team Authors.
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-import regex as re
-from keras.optimizers.schedules.learning_rate_schedule import LearningRateSchedule
-"""Functions and classes related to optimization (weight updates)."""
-from keras.optimizers.optimizer_experimental import optimizer
-import tensorflow as tf
-# from keras.optimizers.optimizer_experimental.adamw import AdamW
-
-class AdamW(optimizer.Optimizer):
-    r"""Optimizer that implements the AdamW algorithm.
-
-    AdamW optimization is a stochastic gradient descent method that is based on
-    adaptive estimation of first-order and second-order moments with an added
-    method to decay weights per the techniques discussed in the paper,
-    'Decoupled Weight Decay Regularization' by
-    [Loshchilov, Hutter et al., 2019](https://arxiv.org/abs/1711.05101).
-
-    According to
-    [Kingma et al., 2014](http://arxiv.org/abs/1412.6980),
-    the underying Adam method is "*computationally
-    efficient, has little memory requirement, invariant to diagonal rescaling of
-    gradients, and is well suited for problems that are large in terms of
-    data/parameters*".
-
-    Args:
-      learning_rate: A `tf.Tensor`, floating point value, a schedule that is a
-        `tf.keras.optimizers.schedules.LearningRateSchedule`, or a callable
-        that takes no arguments and returns the actual value to use. The
-        learning rate. Defaults to 0.001.
-      weight_decay: A `tf.Tensor`, floating point value. The weight decay.
-        Defaults to 0.004.
-      beta_1: A float value or a constant float tensor, or a callable
-        that takes no arguments and returns the actual value to use. The
-        exponential decay rate for the 1st moment estimates. Defaults to 0.9.
-      beta_2: A float value or a constant float tensor, or a callable
-        that takes no arguments and returns the actual value to use. The
-        exponential decay rate for the 2nd moment estimates. Defaults to 0.999.
-      epsilon: A small constant for numerical stability. This epsilon is
-        "epsilon hat" in the Kingma and Ba paper (in the formula just before
-        Section 2.1), not the epsilon in Algorithm 1 of the paper. Defaults to
-        1e-7.
-      amsgrad: Boolean. Whether to apply AMSGrad variant of this algorithm from
-        the paper "On the Convergence of Adam and beyond". Defaults to `False`.
-      {{base_optimizer_keyword_args}}
-
-    Reference:
-      - [Loshchilov et al., 2019](https://arxiv.org/abs/1711.05101)
-      - [Kingma et al., 2014](http://arxiv.org/abs/1412.6980) for `adam`
-      - [Reddi et al., 2018](
-          https://openreview.net/pdf?id=ryQu7f-RZ) for `amsgrad`.
-
-    Notes:
-
-    The default value of 1e-7 for epsilon might not be a good default in
-    general. For example, when training an Inception network on ImageNet a
-    current good choice is 1.0 or 0.1. Note that since Adam uses the
-    formulation just before Section 2.1 of the Kingma and Ba paper rather than
-    the formulation in Algorithm 1, the "epsilon" referred to here is "epsilon
-    hat" in the paper.
-
-    The sparse implementation of this algorithm (used when the gradient is an
-    IndexedSlices object, typically because of `tf.gather` or an embedding
-    lookup in the forward pass) does apply momentum to variable slices even if
-    they were not used in the forward pass (meaning they have a gradient equal
-    to zero). Momentum decay (beta1) is also applied to the entire momentum
-    accumulator. This means that the sparse behavior is equivalent to the dense
-    behavior (in contrast to some momentum implementations which ignore momentum
-    unless a variable slice was actually used).
-    """
-
-    def __init__(
-        self,
-        learning_rate=5e-5,
-        weight_decay=0.005,
-        beta_1=0.9,
-        beta_2=0.999,
-        epsilon=1e-7,
-        amsgrad=False,
-        clipnorm=None,
-        clipvalue=None,
-        global_clipnorm=True,
-        use_ema=False,
-        ema_momentum=0.99,
-        ema_overwrite_frequency=None,
-        jit_compile=False,
-        name="AdamW",
-        **kwargs
-    ):
-        super().__init__(
-            name=name,
-            clipnorm=clipnorm,
-            clipvalue=clipvalue,
-            global_clipnorm=global_clipnorm,
-            use_ema=use_ema,
-            ema_momentum=ema_momentum,
-            ema_overwrite_frequency=ema_overwrite_frequency,
-            jit_compile=jit_compile,
-            **kwargs
-        )
-        self._learning_rate = self._build_learning_rate(learning_rate)
-        self.weight_decay = weight_decay
-        self.beta_1 = beta_1
-        self.beta_2 = beta_2
-        self.epsilon = epsilon
-        self.amsgrad = amsgrad
-
-        if self.weight_decay is None:
-            raise ValueError(
-                "Missing value of `weight_decay` which is required and"
-                " must be a float value."
-            )
-
-    def build(self, var_list):
-        """Initialize optimizer variables.
-
-        AdamW optimizer has 3 types of variables: momentums, velocities and
-        velocity_hat (only set when amsgrad is applied),
-
-        Args:
-          var_list: list of model variables to build AdamW variables on.
-        """
-        super().build(var_list)
-        if hasattr(self, "_built") and self._built:
-            return
-        self._built = True
-        self._momentums = []
-        self._velocities = []
-        for var in var_list:
-            self._momentums.append(
-                self.add_variable_from_reference(
-                    model_variable=var, variable_name="m"
-                )
-            )
-            self._velocities.append(
-                self.add_variable_from_reference(
-                    model_variable=var, variable_name="v"
-                )
-            )
-        if self.amsgrad:
-            self._velocity_hats = []
-            for var in var_list:
-                self._velocity_hats.append(self.add_variable_from_reference(
-                    model_variable=var, 
-                    variable_name="vhat"))
-
-    def _use_weight_decay(self, variable):
-        exclude_from_weight_decay = getattr(
-            self, "_exclude_from_weight_decay", []
-        )
-        exclude_from_weight_decay_names = getattr(
-            self, "_exclude_from_weight_decay_names", []
-        )
-        if variable in exclude_from_weight_decay:
-            return False
-        for name in exclude_from_weight_decay_names:
-            if re.search(name, variable.name) is not None:
-                return False
-        return True
-
-    def update_step(self, gradient, variable):
-        """Update step given gradient and the associated model variable."""
-        lr = tf.cast(self.learning_rate, variable.dtype)
-        local_step = tf.cast(self.iterations + 1, variable.dtype)
-        beta_1_power = tf.pow(tf.cast(self.beta_1, variable.dtype), local_step)
-        beta_2_power = tf.pow(tf.cast(self.beta_2, variable.dtype), local_step)
-
-        var_key = self._var_key(variable)
-        m = self._momentums[self._index_dict[var_key]]
-        v = self._velocities[self._index_dict[var_key]]
-
-        alpha = lr * tf.sqrt(1 - beta_2_power) / (1 - beta_1_power)
-
-        # Apply step weight decay
-        if len(variable.shape) > 1 and self._use_weight_decay(variable):
-            wd = tf.cast(self.weight_decay, variable.dtype)
-            variable.assign_sub(variable * wd * lr)
-
-        if isinstance(gradient, tf.IndexedSlices):
-            # Sparse gradients.
-            m.assign_add(-m * (1 - self.beta_1))
-            m.scatter_add(
-                tf.IndexedSlices(
-                    gradient.values * (1 - self.beta_1), gradient.indices
-                )
-            )
-            v.assign_add(-v * (1 - self.beta_2))
-            v.scatter_add(
-                tf.IndexedSlices(
-                    tf.square(gradient.values) * (1 - self.beta_2),
-                    gradient.indices,
-                )
-            )
+"""Miscellaneous stuff that doesn't really fit anywhere else."""
+
+import sys
+import os
+import re as _re
+import struct
+from textwrap import fill, dedent
+from sympy.core.compatibility import get_function_name, as_int
+
+
+class Undecidable(ValueError):
+    # an error to be raised when a decision cannot be made definitively
+    # where a definitive answer is needed
+    pass
+
+
+def filldedent(s, w=70):
+    """
+    Strips leading and trailing empty lines from a copy of `s`, then dedents,
+    fills and returns it.
+
+    Empty line stripping serves to deal with docstrings like this one that
+    start with a newline after the initial triple quote, inserting an empty
+    line at the beginning of the string.
+
+    See Also
+    ========
+    strlines, rawlines
+    """
+    return '\n' + fill(dedent(str(s)).strip('\n'), width=w)
+
+
+def strlines(s, c=64, short=False):
+    """Return a cut-and-pastable string that, when printed, is
+    equivalent to the input.  The lines will be surrounded by
+    parentheses and no line will be longer than c (default 64)
+    characters. If the line contains newlines characters, the
+    `rawlines` result will be returned.  If ``short`` is True
+    (default is False) then if there is one line it will be
+    returned without bounding parentheses.
+
+    Examples
+    ========
+
+    >>> from sympy.utilities.misc import strlines
+    >>> q = 'this is a long string that should be broken into shorter lines'
+    >>> print(strlines(q, 40))
+    (
+    'this is a long string that should be b'
+    'roken into shorter lines'
+    )
+    >>> q == (
+    ... 'this is a long string that should be b'
+    ... 'roken into shorter lines'
+    ... )
+    True
+
+    See Also
+    ========
+    filldedent, rawlines
+    """
+    if type(s) not in string_types:
+        raise ValueError('expecting string input')
+    if '\n' in s:
+        return rawlines(s)
+    q = '"' if repr(s).startswith('"') else "'"
+    q = (q,) * 2
+    if '\\' in s:  # use r-string
+        m = '(\nr%s%%s%s\n)' % q
+        j = '%s\nr%s' % q
+        c -= 3
+    else:
+        m = '(\n%s%%s%s\n)' % q
+        j = '%s\n%s' % q
+        c -= 2
+    out = []
+    while s:
+        out.append(s[:c])
+        s = s[c:]
+    if short and len(out) == 1:
+        return (m % out[0]).splitlines()[1]  # strip bounding (\n...\n)
+    return m % j.join(out)
+
+
+def rawlines(s):
+    """Return a cut-and-pastable string that, when printed, is equivalent
+    to the input. Use this when there is more than one line in the
+    string. The string returned is formatted so it can be indented
+    nicely within tests; in some cases it is wrapped in the dedent
+    function which has to be imported from textwrap.
+
+    Examples
+    ========
+
+    Note: because there are characters in the examples below that need
+    to be escaped because they are themselves within a triple quoted
+    docstring, expressions below look more complicated than they would
+    be if they were printed in an interpreter window.
+
+    >>> from sympy.utilities.misc import rawlines
+    >>> from sympy import TableForm
+    >>> s = str(TableForm([[1, 10]], headings=(None, ['a', 'bee'])))
+    >>> print(rawlines(s))
+    (
+        'a bee\\n'
+        '-----\\n'
+        '1 10 '
+    )
+    >>> print(rawlines('''this
+    ... that'''))
+    dedent('''\\
+        this
+        that''')
+
+    >>> print(rawlines('''this
+    ... that
+    ... '''))
+    dedent('''\\
+        this
+        that
+        ''')
+
+    >>> s = \"\"\"this
+    ... is a triple '''
+    ... \"\"\"
+    >>> print(rawlines(s))
+    dedent(\"\"\"\\
+        this
+        is a triple '''
+        \"\"\")
+
+    >>> print(rawlines('''this
+    ... that
+    ...     '''))
+    (
+        'this\\n'
+        'that\\n'
+        '    '
+    )
+
+    See Also
+    ========
+    filldedent, strlines
+    """
+    lines = s.split('\n')
+    if len(lines) == 1:
+        return repr(lines[0])
+    triple = ["'''" in s, '"""' in s]
+    if any(li.endswith(' ') for li in lines) or '\\' in s or all(triple):
+        rv = []
+        # add on the newlines
+        trailing = s.endswith('\n')
+        last = len(lines) - 1
+        for i, li in enumerate(lines):
+            if i != last or trailing:
+                rv.append(repr(li + '\n'))
+            else:
+                rv.append(repr(li))
+        return '(\n    %s\n)' % '\n    '.join(rv)
+    else:
+        rv = '\n    '.join(lines)
+        if triple[0]:
+            return 'dedent("""\\\n    %s""")' % rv
         else:
-            # Dense gradients.
-            m.assign_add((gradient - m) * (1 - self.beta_1))
-            #equivalently: m_t = (self.beta_1 * m) + (1 - self.beta_1) * g
-            v.assign_add((tf.square(gradient) - v) * (1 - self.beta_2))
-            #equivalently: v_t = (self.beta_2 * v) + (1 - self.beta_2) * K.square(g)
-            
-        if self.amsgrad:
-            v_hat = self._velocity_hats[self._index_dict[var_key]]
-            v_hat.assign(tf.maximum(v_hat, v))
-            v = v_hat
-                
-        variable.assign_sub((m * alpha) / (tf.sqrt(v) + self.epsilon))
-
-    def exclude_from_weight_decay(self, var_list=None, var_names=None):
-        """Exclude variables from weight decays.
-
-        This method must be called before the optimizer's `build` method is
-        called. You can set specific variables to exclude out, or set a list of
-        strings as the anchor words, if any of which appear in a variable's
-        name, then the variable is excluded.
-
-        Args:
-            var_list: A list of `tf.Variable`s to exclude from weight decay.
-            var_names: A list of strings. If any string in `var_names` appear
-                in the model variable's name, then this model variable is
-                excluded from weight decay. For example, `var_names=['bias']`
-                excludes all bias variables from weight decay.
-        """
-        if hasattr(self, "_built") and self._built:
-            raise ValueError(
-                "`exclude_from_weight_decay()` can only be configued before "
-                "the optimizer is built."
-            )
-
-        self._exclude_from_weight_decay = var_list or []
-        self._exclude_from_weight_decay_names = var_names or []
-
-
-class WarmupPolynomialDecay(LearningRateSchedule):
-    """PolynomialDecay with Warmup trick
-    """
-
-    def __init__(
-        self,
-        initial_learning_rate,
-        train_steps,
-        warmup_proportion=0.05,
-        power=1.0,
-        cycle=False,
-        name=None,
-    ):
-        """Applies a polynomial decay with warm-up to the learning rate.
-
-        Args:
-          initial_learning_rate: A scalar `float32` or `float64` `Tensor` or a
-            Python number.  The initial learning rate.
-          train_steps: A scalar `int32` or `int64` `Tensor` or a Python number.
-            Must be positive.  See the decay computation above.
-          end_learning_rate: A scalar `float32` or `float64` `Tensor` or a
-            Python number.  The minimal end learning rate.
-          power: A scalar `float32` or `float64` `Tensor` or a
-            Python number. The power of the polynomial. Defaults to linear, 1.0.
-          cycle: A boolean, whether or not it should cycle beyond train_steps.
-          name: String.  Optional name of the operation. Defaults to
-            'PolynomialDecay'.
-        """
-        super().__init__()
-
-        self.initial_learning_rate = initial_learning_rate
-        self.train_steps = train_steps
-        self.end_learning_rate = initial_learning_rate / 20
-        self.power = power
-        self.cycle = cycle
-        self.name = name
-        self.warmup_steps = int(train_steps * warmup_proportion)
-
-    def __call__(self, step):
-        with tf.name_scope(self.name or "WarmupPolynomialDecay") as _:
-            initial_learning_rate = tf.convert_to_tensor(self.initial_learning_rate, name="initial_learning_rate")
-            dtype = initial_learning_rate.dtype
-            end_learning_rate = tf.cast(self.end_learning_rate, dtype)
-            power = tf.cast(self.power, dtype)
-            step = tf.cast(step, dtype)
-            train_steps = tf.cast(self.train_steps, dtype)
-
-            learning_rate = (initial_learning_rate - end_learning_rate) * (1 - step / train_steps) ** power + end_learning_rate
-            #warm-up trick:
-            warmup_steps = tf.constant(self.warmup_steps, dtype=dtype)
-            return tf.where(step < warmup_steps, learning_rate * (step / warmup_steps), learning_rate)
+            return "dedent('''\\\n    %s''')" % rv
+
+
+ARCH = str(struct.calcsize('P') * 8) + "-bit"
+
+# XXX: PyPy doesn't support hash randomization
+HASH_RANDOMIZATION = getattr(sys.flags, 'hash_randomization', False)
+
+_debug_tmp = []
+_debug_iter = 0
+
+
+def debug_decorator(func):
+    """If SYMPY_DEBUG is True, it will print a nice execution tree with
+    arguments and results of all decorated functions, else do nothing.
+    """
+    from sympy import SYMPY_DEBUG
+
+    if not SYMPY_DEBUG:
+        return func
+
+    def maketree(f, *args, **kw):
+        global _debug_tmp
+        global _debug_iter
+        oldtmp = _debug_tmp
+        _debug_tmp = []
+        _debug_iter += 1
+
+        def tree(subtrees):
+
+            def indent(s, type=1):
+                x = s.split("\n")
+                r = "+-%s\n" % x[0]
+                for a in x[1:]:
+                    if a == "":
+                        continue
+                    if type == 1:
+                        r += "| %s\n" % a
+                    else:
+                        r += "  %s\n" % a
+                return r
+
+            if len(subtrees) == 0:
+                return ""
+            f = []
+            for a in subtrees[:-1]:
+                f.append(indent(a))
+            f.append(indent(subtrees[-1], 2))
+            return ''.join(f)
+
+        # If there is a bug and the algorithm enters an infinite loop, enable the
+        # following lines. It will print the names and parameters of all major functions
+        # that are called, *before* they are called
+        # from sympy.core.compatibility import reduce
+        # print("%s%s %s%s" % (_debug_iter, reduce(lambda x, y: x + y, \
+        #    map(lambda x: '-', range(1, 2 + _debug_iter))), get_function_name(f), args))
+
+        r = f(*args, **kw)
+
+        _debug_iter -= 1
+        s = "%s%s = %s\n" % (get_function_name(f), args, r)
+        if _debug_tmp != []:
+            s += tree(_debug_tmp)
+        _debug_tmp = oldtmp
+        _debug_tmp.append(s)
+        if _debug_iter == 0:
+            print((_debug_tmp[0]))
+            _debug_tmp = []
+        return r
+
+    def decorated(*args, **kwargs):
+        return maketree(func, *args, **kwargs)
+
+    return decorated
+
+
+def debug(*args):
+    """
+    Print ``*args`` if SYMPY_DEBUG is True, else do nothing.
+    """
+    from sympy import SYMPY_DEBUG
+    if SYMPY_DEBUG:
+        print(*args, file=sys.stderr)
+
+
+def find_executable(executable, path=None):
+    """Try to find 'executable' in the directories listed in 'path' (a
+    string listing directories separated by 'os.pathsep'; defaults to
+    os.environ['PATH']).  Returns the complete filename or None if not
+    found
+    """
+    if path is None:
+        path = os.environ['PATH']
+    paths = path.split(os.pathsep)
+    extlist = ['']
+    if os.name == 'os2':
+        (base, ext) = os.path.splitext(executable)
+        # executable files on OS/2 can have an arbitrary extension, but
+        # .exe is automatically appended if no dot is present in the name
+        if not ext:
+            executable = executable + ".exe"
+    elif sys.platform == 'win32':
+        pathext = os.environ['PATHEXT'].lower().split(os.pathsep)
+        (base, ext) = os.path.splitext(executable)
+        if ext.lower() not in pathext:
+            extlist = pathext
+    for ext in extlist:
+        execname = executable + ext
+        if os.path.isfile(execname):
+            return execname
+        else:
+            for p in paths:
+                f = os.path.join(p, execname)
+                if os.path.isfile(f):
+                    return f
+
+    return None
+
+
+def func_name(x, short=False):
+    """Return function name of `x` (if defined) else the `type(x)`.
+    If short is True and there is a shorter alias for the result,
+    return the alias.
+
+    Examples
+    ========
+
+    >>> from sympy.utilities.misc import func_name
+    >>> from sympy import Matrix
+    >>> from sympy.abc import x
+    >>> func_name(Matrix.eye(3))
+    'MutableDenseMatrix'
+    >>> func_name(x < 1)
+    'Less'
+    >>> func_name(x < 1, short=True)
+    'Lt'
+
+    See Also
+    ========
+    sympy.core.compatibility get_function_name
+    """
+    alias = {
+    'GreaterEqual': 'Ge',
+    'Greater': 'Gt',
+    'LessEqual': 'Le',
+    'Less': 'Lt',
+    'Equal': 'Eq',
+    'Unequal': 'Ne',
+    }
+    typ = type(x)
+    if str(typ).startswith("<type '"):
+        typ = str(typ).split("'")[1].split("'")[0]
+    elif str(typ).startswith("<class '"):
+        typ = str(typ).split("'")[1].split("'")[0]
+    rv = getattr(getattr(x, 'func', x), '__name__', typ)
+    if '.' in rv:
+        rv = rv.split('.')[-1]
+    if short:
+        rv = alias.get(rv, rv)
+    return rv
+
+
+def _replace(reps):
+    """Return a function that can make the replacements, given in
+    ``reps``, on a string. The replacements should be given as mapping.
+
+    Examples
+    ========
+
+    >>> from sympy.utilities.misc import _replace
+    >>> f = _replace(dict(foo='bar', d='t'))
+    >>> f('food')
+    'bart'
+    >>> f = _replace({})
+    >>> f('food')
+    'food'
+    """
+    if not reps:
+        return lambda x: x
+    D = lambda match: reps[match[0]]
+    pattern = _re.compile("|".join([_re.escape(k) for k, v in reps.items()]), _re.M)
+    return lambda string: pattern.sub(D, string)
+
+
+def replace(string, *reps):
+    """Return ``string`` with all keys in ``reps`` replaced with
+    their corresponding values, longer strings first, irrespective
+    of the order they are given.  ``reps`` may be passed as tuples
+    or a single mapping.
+
+    Examples
+    ========
+
+    >>> from sympy.utilities.misc import replace
+    >>> replace('foo', {'oo': 'ar', 'f': 'b'})
+    'bar'
+    >>> replace("spamham sha", ("spam", "eggs"), ("sha","md5"))
+    'eggsham md5'
+
+    There is no guarantee that a unique answer will be
+    obtained if keys in a mapping overlap (i.e. are the same
+    length and have some identical sequence at the
+    beginning/end):
+
+    >>> reps = [
+    ...     ('ab', 'x'),
+    ...     ('bc', 'y')]
+    >>> replace('abc', *reps) in ('xc', 'ay')
+    True
+
+    References
+    ==========
+
+    .. [1] https://stackoverflow.com/questions/6116978/python-replace-multiple-strings
+    """
+    if len(reps) == 1:
+        kv = reps[0]
+        if type(kv) is dict:
+            reps = kv
+        else:
+            return string.replace(*kv)
+    else:
+        reps = dict(reps)
+    return _replace(reps)(string)
+
+
+def translate(s, a, b=None, c=None):
+    """Return ``s`` where characters have been replaced or deleted.
+
+    SYNTAX
+    ======
+
+    translate(s, None, deletechars):
+        all characters in ``deletechars`` are deleted
+    translate(s, map [,deletechars]):
+        all characters in ``deletechars`` (if provided) are deleted
+        then the replacements defined by map are made; if the keys
+        of map are strings then the longer ones are handled first.
+        Multicharacter deletions should have a value of ''.
+    translate(s, oldchars, newchars, deletechars)
+        all characters in ``deletechars`` are deleted
+        then each character in ``oldchars`` is replaced with the
+        corresponding character in ``newchars``
+
+    Examples
+    ========
+
+    >>> from sympy.utilities.misc import translate
+    >>> from sympy.core.compatibility import unichr
+    >>> abc = 'abc'
+    >>> translate(abc, None, 'a')
+    'bc'
+    >>> translate(abc, {'a': 'x'}, 'c')
+    'xb'
+    >>> translate(abc, {'abc': 'x', 'a': 'y'})
+    'x'
+
+    >>> translate('abcd', 'ac', 'AC', 'd')
+    'AbC'
+
+    There is no guarantee that a unique answer will be
+    obtained if keys in a mapping overlap are the same
+    length and have some identical sequences at the
+    beginning/end:
+
+    >>> translate(abc, {'ab': 'x', 'bc': 'y'}) in ('xc', 'ay')
+    True
+    """
+    from sympy.core.compatibility import maketrans, PY3
+
+    mr = {}
+    if a is None:
+        assert c is None
+        if not b:
+            return s
+        c = b
+        a = b = ''
+    else:
+        if type(a) is dict:
+            short = {}
+            for k in list(a.keys()):
+                if len(k) == 1 and len(a[k]) == 1:
+                    short[k] = a.pop(k)
+            mr = a
+            c = b
+            if short:
+                a, b = [''.join(i) for i in list(zip(*short.items()))]
+            else:
+                a = b = ''
+        else:
+            assert len(a) == len(b)
+    if PY3:
+        if c:
+            s = s.translate(maketrans('', '', c))
+        s = replace(s, mr)
+        return s.translate(maketrans(a, b))
+    else:
+        # when support for Python 2 is dropped, this if-else-block
+        # can be replaced with the if-clause
+        if c:
+            c = list(c)
+            rem = {}
+            for i in range(-1, -1 - len(c), -1):
+                if ord(c[i]) > 255:
+                    rem[c[i]] = ''
+                    c.pop(i)
+            s = s.translate(None, ''.join(c))
+            s = replace(s, rem)
+            if a:
+                a = list(a)
+                b = list(b)
+                for i in range(-1, -1 - len(a), -1):
+                    if ord(a[i]) > 255 or ord(b[i]) > 255:
+                        mr[a.pop(i)] = b.pop(i)
+                a = ''.join(a)
+                b = ''.join(b)
+        s = replace(s, mr)
+        table = maketrans(a, b)
+        # s may have become unicode which uses the py3 syntax for translate
+        if isinstance(table, str) and isinstance(s, str):
+            s = s.translate(table)
+        else:
+            s = s.translate(dict(
+                [(i, ord(c)) for i, c in enumerate(table)]))
+        return s
+
+
+def ordinal(num):
+    """Return ordinal number string of num, e.g. 1 becomes 1st.
+    """
+    # modified from https://codereview.stackexchange.com/questions/41298/producing-ordinal-numbers
+    n = as_int(num)
+    k = abs(n) % 100
+    if 11 <= k <= 13:
+        suffix = 'th'
+    elif k % 10 == 1:
+        suffix = 'st'
+    elif k % 10 == 2:
+        suffix = 'nd'
+    elif k % 10 == 3:
+        suffix = 'rd'
+    else:
+        suffix = 'th'
+    return str(n) + suffix
+
+
```

### Comparing `sympy.keras-1.0.21/sympy/liealgebras/cartan_matrix.py` & `sympy.keras-1.0.4/sympy/liealgebras/cartan_matrix.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/liealgebras/cartan_type.py` & `sympy.keras-1.0.4/sympy/liealgebras/cartan_type.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/liealgebras/dynkin_diagram.py` & `sympy.keras-1.0.4/sympy/liealgebras/dynkin_diagram.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/liealgebras/root_system.py` & `sympy.keras-1.0.4/sympy/liealgebras/root_system.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/liealgebras/type_a.py` & `sympy.keras-1.0.4/sympy/liealgebras/type_a.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/liealgebras/type_b.py` & `sympy.keras-1.0.4/sympy/liealgebras/type_b.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/liealgebras/type_c.py` & `sympy.keras-1.0.4/sympy/liealgebras/type_c.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/liealgebras/type_d.py` & `sympy.keras-1.0.4/sympy/liealgebras/type_d.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/liealgebras/type_e.py` & `sympy.keras-1.0.4/sympy/liealgebras/type_e.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/liealgebras/type_f.py` & `sympy.keras-1.0.4/sympy/liealgebras/type_f.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/liealgebras/type_g.py` & `sympy.keras-1.0.4/sympy/liealgebras/type_g.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/liealgebras/weyl_group.py` & `sympy.keras-1.0.4/sympy/liealgebras/weyl_group.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/logic/algorithms/dpll.py` & `sympy.keras-1.0.4/sympy/logic/algorithms/dpll.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/logic/algorithms/dpll2.py` & `sympy.keras-1.0.4/sympy/logic/algorithms/dpll2.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/logic/algorithms/pycosat_wrapper.py` & `sympy.keras-1.0.4/sympy/logic/algorithms/pycosat_wrapper.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/logic/boolalg.py` & `sympy.keras-1.0.4/sympy/logic/boolalg.py`

 * *Files 2% similar despite different names*

```diff
@@ -66,15 +66,15 @@
     plausible = None
     __slots__ = ()
 
     def simplify_condition_on_random_variable(self):
         return self
         
     def sanctity_check(self, *limits):
-        from sympy.concrete.expr_with_limits import limits_dict
+        from sympy.concrete.expr_with_limits import limits_dict        
         for x, domain in limits_dict(limits).items():
             if isinstance(domain, list):
                 continue
             if domain not in self.domain_defined(x):
                 return False
         return True
         
@@ -126,15 +126,15 @@
                 free_symbols.add(symbol)
 
         deletes = set()
         for y in free_symbols:
             deletes |= y.domain.free_symbols
             
         free_symbols -= deletes
-        return free_symbols
+        return free_symbols        
 
     def limits_exists(self):
         return [(s,) for s in self.existent_symbols()]
         
     def __invert__(self):
         """Return the negated relationship.
 
@@ -289,15 +289,15 @@
         return origin
 
     def _eval_is_random(self):
         for arg in self.args:
             if arg.is_random:
                 return True
 
-    @property
+    @property    
     def wrt(self):
         return next(iter(self.free_symbols))
 
     def subs_assumptions_for_equality(self, eq, result, simplify=True):
         if eq.plausible:
             if self.plausible: 
                 assumptions = {'given': [self, eq]}
@@ -311,33 +311,20 @@
         self = result.copy(**assumptions)
         if simplify:
             self = self.simplify()
         return self
 
     def domain_conditioned(self, x):
         if self._has(x):
-            from sympy.sets import conditionset
+            from sympy.sets import conditionset       
             return conditionset(x, self, x.domain)
         return x.domain
         from sympy.functions.elementary.piecewise import Piecewise
         return Piecewise((x.domain, self), (x.emptySet, True))
-
-    @classmethod
-    def unnest(cls, expr, limits, symbols, **assumptions):
-    # unnest any nested calls
-        while cls == type(expr):
-            limits = list(expr.limits) + limits
-            expr = expr.expr
-
-        if not limits and symbols:
-            return expr.copy(**assumptions)
-
-        return Boolean.__new__(cls, expr, *limits, **assumptions)
-
-
+        
 class BinaryCondition(Boolean):
     """Base class for all binary relation types.
     """
     __slots__ = ()
     
     @property
     def lhs(self):
@@ -429,28 +416,14 @@
         new = sympify(new)
         domain = old.domain_bounded
         if domain is not None and new not in domain:
             return self
 
         return self.func(self.lhs._subs(*args, **kwargs).simplify(), self.rhs._subs(*args, **kwargs).simplify())
 
-    @property
-    def variables(self):
-        return {*self.lhs.variables} | {*self.rhs.variables}
-
-    @cacheit
-    def sort_key(self, order=None):
-        args = self.args
-        args = len(args), tuple(arg.class_key() for arg in args), tuple(arg.sort_key(order=order) for arg in args)
-        
-        exp = S.One
-        exp = exp.sort_key(order=order)
-
-        return self.class_key(), args, exp, 1
-
 
 class BooleanAssumption(BinaryCondition):
     ...
         
 
 class BooleanAtom(Boolean):
     """
@@ -501,21 +474,16 @@
     __le__ = __lt__
     __gt__ = __lt__
     __ge__ = __lt__
 
     def _pretty(self, p):
         return p._print(self.func.__name__)
 
-    def _eval_torch(self):
-        import torch
-        data = torch.from_numpy(self.numpy)
-        if torch.cuda.is_available():
-            data = data.cuda()
-        return data
 
+    # \\\
 
 class BooleanTrue(with_metaclass(Singleton, BooleanAtom)):
     """
     SymPy version of True, a singleton that can be accessed via S.true.
 
     This is the SymPy version of True, for use in the logic module. The
     primary advantage of using true instead of True is that shorthand boolean
@@ -711,15 +679,15 @@
         Examples
         ========
 
         >>> from sympy import false
         >>> false.as_set()
         EmptySet()
         """
-        from sympy import EmptySet
+        from sympy import EmptySet 
         return EmptySet()
 
     def copy(self, **kwargs):
         if kwargs:
             from sympy.core.inference import Inference
             return Inference(self, **kwargs)
         return self
@@ -1035,19 +1003,19 @@
 
     @classmethod
     def connected_equations(cls, args):
         child = {}
         parent = {}
         for lhs, rhs in args:
             if lhs in child:
-                break
+                break                
             child[lhs] = rhs
             
             if rhs in parent:
-                break
+                break                
             parent[rhs] = lhs
         else:
             root = lhs
             while root in parent:
                 root = parent[root]
                 
             next = root
@@ -1068,113 +1036,76 @@
                 x = p._print(x)
                 return r"%s \%s %s \%s %s" % (a, op1, x, op2, b)
             
             eq1, eq2 = self.args
             if eq1.is_Less:
                 a, x = eq1.args
                 if eq2.is_Less:
-                    _x, b = eq2.args
+                    _x, b = eq2.args                        
                     if x == _x: 
                         return render('lt', 'lt', a, x, b)
-                    if a == b:
-                        x, b, a = a, x, _x
-                        return render('lt', 'lt', a, x, b)
-                        
                 if eq2.is_LessEqual:
                     _x, b = eq2.args
                     if x == _x:
                         return render('lt', 'le', a, x, b)
-                    if a == b:
-                        x, b, a = a, x, _x
-                        return render('le', 'lt', a, x, b)
-                    
             elif eq1.is_LessEqual:
                 a, x = eq1.args
                 if eq2.is_Less:
-                    _x, b = eq2.args
+                    _x, b = eq2.args                        
                     if x == _x:
                         return render('le', 'lt', a, x, b)
-                    if a == b:
-                        x, b, a = a, x, _x
-                        return render('lt', 'le', a, x, b)
-                    
                 if eq2.is_LessEqual:
                     _x, b = eq2.args
                     if x == _x:
                         return render('le', 'le', a, x, b)
-                    if a == b:
-                        x, b, a = a, x, _x
-                        return render('le', 'le', a, x, b)
-                    
             elif eq1.is_Greater:
                 a, x = eq1.args
                 if eq2.is_Greater:
                     _x, b = eq2.args
                     if x == _x:
                         return render('gt', 'gt', a, x, b)
-                    if a == b:
-                        x, b, a = a, x, _x
-                        return render('gt', 'gt', a, x, b)
-                    
                 if eq2.is_GreaterEqual:
                     _x, b = eq2.args
                     if x == _x:
                         return render('gt', 'ge', a, x, b)
-                    if a == b:
-                        x, b, a = a, x, _x
-                        return render('ge', 'gt', a, x, b)
-                    
             elif eq1.is_GreaterEqual:
                 a, x = eq1.args
                 if eq2.is_Greater:
                     _x, b = eq2.args
                     if x == _x:
                         return render('ge', 'gt', a, x, b)
-                    if a == b:
-                        x, b, a = a, x, _x
-                        return render('gt', 'ge', a, x, b)
-                    
                 if eq2.is_GreaterEqual:
                     _x, b = eq2.args
                     if x == _x:
                         return render('ge', 'ge', a, x, b)
-                    if a == b:
-                        x, b, a = a, x, _x
-                        return render('ge', 'ge', a, x, b)
-
+    
         args = []
         is_all_eq = True
         for arg in self.args:
             if arg.is_Or or arg.is_Conditioned:
                 args.append(r"\left(%s\right)" % p._print(arg))
                 is_all_eq = False
             else:
                 args.append(p._print(arg))
                 if not arg.is_Equal:
                     is_all_eq = False
 
-        wedge = r'\wedge '
         if is_all_eq:
-            conds = [eq.args for eq in self.args]
-            children = And.connected_equations(conds)
+            children = And.connected_equations([eq.args for eq in self.args])
             if children:
-                return " = ".join([p._print(next) for next in children])
-            if all(lhs.is_random and lhs.is_symbol and (rhs == lhs.var or rhs.is_Surrogate and rhs.arg == lhs) for lhs, rhs in conds):
-                wedge = ','
+                return " = ".join([p._print(next) for next in children])    
             
-        return wedge.join(args)
+        return r"\wedge ".join(args)
 
     def invert(self):
         return self.invert_type(*(arg.invert() for arg in self.args))
 
     def apply(self, axiom, *args, split=True, **kwargs):
-        token = axiom.__name__.split(sep='.')
-        i, type = inference_type(token)
-        
-        if token[2][:3] == 'et' or type in ('imply', 'given') and i == 3:
+        token = axiom.__name__.split(sep='.', maxsplit=4)
+        if token[2][:3] in ('et', 'et_') or token[-2] in ('imply', 'given'):
             split = False
             
         if split: 
             funcs = []
             
             depth = kwargs.pop('depth', None)
             if not depth:
@@ -1197,35 +1128,30 @@
                         else: 
                             funcs = _funcs
                         function = instantiate(eq)
                         _args.append(function)
                     else:
                         _args.append(eq)
                         
-            cond = axiom.apply(*_args, *args, **kwargs)
-            if isinstance(cond, tuple): 
-                clue = {f.clue for f in cond}
+            function = axiom.apply(*_args, *args, **kwargs)
+            if isinstance(function, tuple): 
+                clue = {f.clue for f in function}
                 assert len(clue) == 1
                 [clue] = clue
-                cond = And(*cond, **{clue: self})
-
+                function = And(*function, **{clue: self})
             else:
-                if cond.is_Equivalent and type == 'to':
-                    if cond.clue is None:
-                        return cond.rhs
+                clue = function.clue
+                function.set_clause(clue, self, force=True)
                 
-                clue = cond.clue
-                cond.set_clause(clue, self, force=True)
-                
-            if cond.is_BooleanAtom:
-                return cond.copy(**{clue: self})
+            if function.is_BooleanAtom:
+                return function.copy(**{clue: self})
             
             if kwargs.get('simplify', True):
-                cond = cond.simplify()
-            return cond
+                function = function.simplify()
+            return function
         else:
             return Boolean.apply(self, axiom, *args, **kwargs)
 
     def subs(self, *args, **kwargs):
         if all(isinstance(arg, Boolean) for arg in args):
             result = LatticeOp.subs(self, *args, **kwargs)
             if result.is_BooleanAtom:
@@ -1265,34 +1191,38 @@
                 return eq.func(*eq.args, **options)
             return eq
 
         if set(v.invert() for v in args) & args:
             return S.BooleanFalse.copy(**options)
 
         if options: 
-            from sympy.core.inference import Inference
+            from sympy.core.inference import Inference   
             return Inference(LatticeOp.__new__(cls, *args), **options)
 
         return LatticeOp.__new__(cls, *args, **options)
 
+    zero = false
+    
+    identity = S.true
+
     nargs = None
 
     @classmethod
     def _need_to_be_raised(cls, self):
         return self == S.false
 
     @classmethod
     def _need_to_be_filtered(cls, self):
         return self == S.true
 
     @classmethod
     def _new_args_filter(cls, args):
         newargs = []
         rel = []
-
+#         args = BooleanFunction.binary_check_and_simplify(*args)
         for x in reversed(args):
             if x.is_Relational:
                 c = x.canonical
                 if c in rel:
                     continue
                 nc = c.invert()
                 nc = nc.canonical
@@ -1417,17 +1347,14 @@
                     return self
                 return self.func(*argset, eq).simplify()
                             
         return self
 
     def __and__(self, other):
         """Overloading for & operator"""
-        if not other.is_bool and self.is_random and other.is_random:
-            return self & other.as_boolean()
-
         lhs = tuple(self._argset)
         
         rhs = None
         if other.is_And:
             rhs = tuple(other._argset)
         elif other.is_Or:
             _self = self.invert()
@@ -1455,18 +1382,14 @@
                         argset |= ou._argset
                     else:
                         argset.add(ou)                     
         
         return And(*argset)
 
     def __or__(self, other):
-        if not other.is_bool and self.is_random and other.is_random:
-            from sympy import Conditioned
-            return Conditioned(self, other.as_boolean())
-
         if other.is_And:
             intersect = other._argset & self._argset
             if intersect:
                 return And(*intersect, And(*self._argset - intersect) | And(*other._argset - intersect))
         return BooleanFunction.__or__(self, other)        
 
     def domain_conditioned(self, x):
@@ -1504,20 +1427,15 @@
         if old.is_And:
             if not old._argset - self._argset:
                 complement = self._argset - old._argset
                 complement |= {new}
                 return And(*complement)
         return LatticeOp._subs(self, old, new, **hints)
 
-    @classmethod
-    def class_key(cls):
-        """Nice order of classes. """
-        return 6, 0, cls.__name__
-
-
+        
 class Or(LatticeOp, BooleanFunction):
     """
     Logical OR function
 
     It evaluates its arguments in order, giving True immediately
     if any of them are True, and False if they are all False.
 
@@ -1538,14 +1456,18 @@
     or. Hence, ``Or(a, b)`` and ``a | b`` will return different things if
     ``a`` and ``b`` are integers.
 
     >>> Or(x, y).subs(x, 0)
     y
 
     """
+    zero = true
+    
+    identity = S.false
+
     @classmethod
     def _need_to_be_raised(cls, self):
         return self == S.true
 
     @classmethod
     def _need_to_be_filtered(cls, self):
         return self == S.false
@@ -1584,15 +1506,15 @@
         if set(v.invert() for v in args) & args:
             if 'plausible' in options:
                 options['plausible'] = None
             else:
                 return S.BooleanTrue.copy(**options)
 
         if options: 
-            from sympy.core.inference import Inference
+            from sympy.core.inference import Inference   
             return Inference(LatticeOp.__new__(cls, *args, evaluate=False), **options)
         return LatticeOp.__new__(cls, *args, **options)
 
     def invert(self):
         return self.invert_type(*(arg.invert() for arg in self.args))
 
     @classmethod
@@ -1801,23 +1723,14 @@
 
     def copy(self, **kwargs):
         if kwargs:
             from sympy.core.inference import Inference
             return Inference(self, **kwargs)
         return self
 
-    def domain_definition(self):
-        from sympy import Or
-        return Or(*(arg.domain_definition() for arg in self.args))
-
-    @classmethod
-    def class_key(cls):
-        """Nice order of classes. """
-        return 6, 1, cls.__name__
-
 
 And.invert_type = Or
 Or.invert_type = And
 
 
 class Not(BooleanFunction):
     """
@@ -2200,33 +2113,33 @@
     >>> from sympy import true, false
     >>> True >> False
     1
     >>> true >> false
     False
 
     """
-    # check if p => q holds?
+
     def __new__(cls, p, q, **assumptions):
         if assumptions.get('plausible') and p.is_Inference and q.is_Inference:
-            if q.given_by(p):
+            if q.given_by(p): 
                 from sympy.core.inference import Inference
                 return Inference(BinaryCondition.__new__(cls, p, q), plausible=None)
             
         return BinaryCondition.eval(cls, p, q, **assumptions)
 
     @classmethod
     def eval(cls, *args):
         try:
             newargs = []
             for x in args:
                 if isinstance(x, Number) or x in (0, 1):
                     newargs.append(True if x else False)
                 else:
                     newargs.append(x)
-            A, B = newargs
+            A, B = newargs                            
         except ValueError:
             raise ValueError(
                 "%d operand(s) used for an Infer "
                 "(pairs are required): %s" % (len(args), str(args)))
             
         if B.is_BooleanFalse:
             return A.invert()
@@ -2318,15 +2231,15 @@
             for eq in q.args: 
                 if eq in p_set:
                     continue
                 if eq.is_Or:
                     or_eqs = []
                     for e in eq.args:
                         if e in p_set:
-                            continue
+                            continue                        
                         or_eqs.append(e)
                     if len(or_eqs) == len(eq.args):
                         eqs.append(eq)
                         continue
                     
                     if not or_eqs:
                         continue
@@ -2351,17 +2264,17 @@
                             continue
                 eqs.append(eq)
             return Infer(p, Or(*eqs))
             
         return self
 
     def inference_status(self, child):
-        return child == 0
-
+        return child == 0       
 
+# http://www.frdic.com/dicts/fr/quand        
 class Assuming(BooleanAssumption):
     """
     Logical implication.
 
     A is Assuming for B is equivalent to A v !B
 
     Accepts two Boolean arguments; A and B.
@@ -2402,15 +2315,15 @@
         elif other.is_Assuming:
             if self.lhs == other.lhs: 
                 return Assuming(self.lhs, self.rhs | other.rhs)
 
         return BinaryCondition.__and__(self, other)
 
     def inference_status(self, child):
-        return child == 1
+        return child == 1       
 
 
 class Equivalent(BooleanAssumption):
     """
     Equivalence relation.
 
     Equivalent(A, B) is True iff A and B are both True or both False
@@ -2557,15 +2470,15 @@
 Unnecessary.reversed_type = NotInfer
 Inequivalent.reversed_type = Inequivalent
 
 Infer.invert_type = NotInfer
 Assuming.invert_type = Unnecessary
 Equivalent.invert_type = Inequivalent
 
-NotInfer.invert_type = Infer
+NotInfer.invert_type = Infer 
 Unnecessary.invert_type = Assuming
 Inequivalent.invert_type = Equivalent
 
 
 class ITE(BooleanFunction):
     """
     If then else clause.
@@ -3836,14 +3749,7 @@
                      (Xor(Le(a, b), Lt(a, c)),
                       ITE(b < c, And(Lt(a, c), Gt(a, b)),
                           And(Le(a, b), Ge(a, c)))),
                      (Xor(Lt(a, b), Lt(a, c)),
                       And(Lt(a, Max(b, c)), Ge(a, Min(b, c)))),
                      )
     return _matchers_xor
-
-def inference_type(tokens):
-    for i, token in enumerate(tokens):
-        if token in ('imply', 'given', 'to'):
-            return i, token
-        
-    return -1, 'to'
```

### Comparing `sympy.keras-1.0.21/sympy/logic/inference.py` & `sympy.keras-1.0.4/sympy/logic/inference.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/logic/invoker.py` & `sympy.keras-1.0.4/sympy/logic/invoker.py`

 * *Files 3% similar despite different names*

```diff
@@ -16,16 +16,15 @@
     
     @property
     def target(self):
         return self._objs[-1]
     
     @property
     def parent(self):
-        if len(self._objs) > 1:
-            return self._objs[-2]
+        return self._objs[-2]
     
     @property
     def source(self):
         return self._objs[0]
 
     def inference_status(self, boolean):
         for i in range(len(self.index)):
@@ -40,99 +39,77 @@
                 if isinstance(equivalent, (list, tuple)):
                     clue = equivalent[0].clue
                     if clue == 'given':
                         return self.inference_status(False)
                     elif clue == 'imply':
                         return self.inference_status(True)
                 else:
-                    # in case of result of simplify
+                    # in case of result of simplify                    
                     if equivalent is not self.target:
                         clue = equivalent.clue
                         if clue is not None:
                             if clue == 'given':
                                 return self.inference_status(False)
                             if clue == 'imply':
                                 return self.inference_status(True)
                             return clue
             elif obj.given is not None: 
                 return self.inference_status(False) 
             elif obj.imply is not None:
                 return self.inference_status(True)
         return 'equivalent'
         
-    def result(self, obj, simplify=-1, evaluate=None):
+    def result(self, obj, simplify=True, evaluate=None):
         assumptions = {self.determine_assumptions(obj): self.source}
-        from sympy.core.sympify import _sympify
+        from sympy.core.sympify import _sympify        
         obj = _sympify(obj)
         for i in range(-1, -len(self.index) - 1, -1):
             this = self._objs[i - 1]
             args = [*this.args]
             
             index = self.index[i]
-            if isinstance(index, slice):
-                assert this.is_And or this.is_Or or this.is_Mul or this.is_Add or this.is_MatMul
-                start, stop, step = index.start, index.stop, index.step
-                if start is None:
-                    start = 0
-                elif start < 0:
-                    start += len(args)
-
-                if stop is None:
-                    stop = len(args)
-                elif stop < 0:
-                    stop += len(args)
-                    
-                if step is None:
-                    step = 1
-                    
-                if step > 0:
-                    index, *indices = range(start, stop, step)
-                    indices.reverse()
-                else:
-                    *indices, index = range(start, stop, step)
-                    
-                for j in indices:
+            try:
+                args[index] = obj
+            except TypeError:
+                assert this.is_And or this.is_Or
+                for j in index[::-1]:
                     del args[j]
-                
-            args[index] = obj
+                args.append(obj)
             
             stop = i == -len(self.index)
+            
             if stop:
                 kwargs = assumptions
             else:
                 kwargs = this.kwargs
                 
             if evaluate is not None:
                 kwargs['evaluate'] = evaluate
             
             if self._domain_defined and this.func.is_ExprWithLimits:
                 _, *limits = args
                 for i, limit in enumerate(limits):
                     if limit[0] in self._domain_defined:
-                        x, domain, *dir = limit.coerce_setlimit()
-                        if dir:
-                            continue
+                        x, domain = limit.coerce_setlimit() 
                         domain_defined = self._domain_defined.pop(x)
                         if domain != domain_defined:
                             if domain_defined in domain: 
                                 args[i + 1] = (x, domain_defined)
                                 break
                 else:
                     if this.is_ForAll:
                         for x in set(self._domain_defined):
                             if this._has(x): 
                                 args.append((x, self._domain_defined.pop(x)))                    
 
             obj = this.func(*args, **kwargs)
             
-            if simplify:
+            if simplify and (not obj.is_ForAll or stop or not self._objs[i - 2].is_Exists):
                 # exclude case Exists[C](All[x](f(x) == C))
-                if not obj.is_ForAll or stop or not self._objs[i - 2].is_Exists:
-                    obj = obj.simplify()
-                simplify -= 1
+                obj = obj.simplify()
                 
             if stop:
                 break
         else:
             assert not len(self.index)
             obj = obj.copy(**assumptions)
              
@@ -172,73 +149,55 @@
         obj = self.invoke(*args, **kwargs)
         
         if self.callable.__name__ == 'subs':
             if not this.is_Quantifier:
                 assert all(arg.is_Equal for arg in args)
                 assert all(arg.plausible is None for arg in args)                
             self.watch_domain_defined(obj)
-        else:
-            for i in range(-2, -len(self._objs), -1):
-                parent = self._objs[i]
-                if parent.is_ExprWithLimits and not (parent.is_Expectation or parent.is_Variance or parent.is_Lamda):
-                    self.watch_domain_defined(obj, *parent.limits)
-                    
-        simplify = kwargs.get('simplify', True)
-        if simplify is None:
-            simplify = 0
-        elif isinstance(simplify, bool):
-            simplify = -1
-        else:
-            #warning: isinstance(True, int) or isinstance(False, int) is always True
-            if simplify:
-                simplify -= 1
-
-        return self.result(obj, simplify=simplify, evaluate=evaluate)
+                
+        return self.result(obj,
+                           simplify=kwargs.get('simplify', True) is not None,
+                           evaluate=evaluate)
 
     def invoke(self, *args, **kwargs):
         if self._context:
             this = self.this
             reps = []
+            from sympy import Interval, Range
             outer_context = {}
-            for expr, limits in self._context:
+            for _, limits in self._context:
                 for x, *ab in limits:
-                    if x.shape or not ab:
+                    if x.shape:
                         continue
-                    
                     if len(ab) == 1:
-                        domain, = ab
+                        domain, *_ = ab
                         if domain.is_Boolean:
                             domain = x.domain_conditioned(domain)
                         elif domain.is_ConditionSet:
                             domain = domain.base_set
-                    elif len(ab) == 2 and not ab[1].is_set:
+                    else:
                         for i, t in enumerate(ab):
                             for outer_var in outer_context:
                                 if t._has(outer_var):
                                     t = t._subs(outer_var, outer_context[outer_var][0])
                             ab[i] = t
                                 
-                        domain = x.range(*ab)
+                        domain = (Range if x.is_integer else Interval)(*ab)
                         
                     if x in outer_context:
                         x, _domain = outer_context[x]
                         keys = domain.free_symbols & outer_context.keys()
                         if keys:
                             for key in keys:
                                 domain = domain._subs(key, outer_context[key][0])
                         domain &= _domain
                             
                     _x = x.copy(domain=domain)
                     if x != _x:
-                        this = this._subs(x, _x)
-                        if this.is_ExprWithLimits and len(this.limits) > 1 and kwargs.get('simplify') is False:
-                            ...
-                        else:
-                            this = this.simplify()
-
+                        this = this._subs(x, _x).simplify()
                         reps.append((x, _x))
                         outer_context[x] = (_x, domain)
             
             obj = getattr(this, self.callable.__name__)(*args, **kwargs)
             if obj.is_BooleanAtom:
                 return obj
             
@@ -249,30 +208,25 @@
                     if _obj.is_BooleanAtom:
                         _obj = _obj.copy(equivalent=obj)
                 obj = _obj
         else: 
             if self.callable.__func__.__code__.co_name == 'apply':
                 axiom = args[0]
                 __kwdefaults__ = axiom.apply.__closure__[0].cell_contents.__kwdefaults__
-                if __kwdefaults__:
-                    if 'assumptions' in __kwdefaults__:
-                        assumptions = {}
-                        for obj in self._objs:
-                            if obj.is_ExprWithLimits:
-                                if obj.is_Exists:
-                                    for x in obj.variables:
-                                        assumptions[x] = False
-                                else:
-                                    for x, *ab in obj.limits:
-                                        assumptions[x] = ab
-                        kwargs['assumptions'] = assumptions
-                    elif 'simplify' in __kwdefaults__:
-                        simplify = __kwdefaults__['simplify']
-                        if not kwargs and not simplify:
-                            kwargs['simplify'] = simplify
+                if __kwdefaults__ and 'assumptions' in __kwdefaults__:
+                    assumptions = {}
+                    for obj in self._objs:
+                        if obj.is_ExprWithLimits:
+                            if obj.is_Exists:
+                                for x in obj.variables:
+                                    assumptions[x] = False 
+                            else:
+                                for x, *ab in obj.limits:
+                                    assumptions[x] = ab
+                    kwargs['assumptions'] = assumptions
                 
             obj = self.callable(*args, **kwargs)
         return obj
         
     def append(self, obj):
         self._objs.append(obj)
 
@@ -307,63 +261,50 @@
     method2index = {'rhs': 1,
                     'lhs': 0,
                     'arg': 0,
                     'cond': 1,
                     'expr': 0,
                     'base': 0}
 
-    def watch_domain_defined(self, obj, *limits):
+    def watch_domain_defined(self, obj):
         # beware that application of definition may cause the domain definition to be altered, thus causing logic error!
         target = self.target
-        if not limits:
-            from sympy import Tuple
-            limits = [Tuple(v) for v in target.free_symbols]
-
-        for limit in limits:
-            x, *ab = limit
-            original_domain = target.domain_defined(x)
-            altered_domain = obj.domain_defined(x)
+        target_keys = target.free_symbols
+
+        for key in target_keys:
+            original_domain = target.domain_defined(key)
+            altered_domain = obj.domain_defined(key)
             if original_domain != altered_domain:
-                if original_domain in altered_domain:
-                    ...
-                else:
-                    x, domain = limit.coerce_setlimit()
-                    assert original_domain & domain in altered_domain & domain, "original domain of definition must lie in transformed domain of definition!"                    
-                assert x not in self._domain_defined
-                self._domain_defined[x] = original_domain
+                assert original_domain in altered_domain, "original domain of definition must lie in transformed domain of definition!"                    
+                assert key not in self._domain_defined                    
+                self._domain_defined[key] = original_domain
         
     def __getattr__(self, method): 
         target = self.target
         if method == 'T':
             if len(target.shape) > 1:
                 return self
             
         obj = getattr(target, method)
         
         if method == 'definition':
             self.watch_domain_defined(obj)
-            return self.result(obj)
             
         if isinstance(obj, MethodType):
             self.callable = obj
             return self
 
         if isinstance(obj, tuple):
             self.append(obj)
             return self
         
         index = self.method2index.get(method)
         if index is None:
             return self.result(obj)
             
-        if obj is not target.args[index]:
-            assert method in ('lhs', 'rhs')
-            self.index.append(0)
-            self.append(target.args[0])
-        
         self.index.append(index)
         self.append(obj)
 
         return self
 
     def __neg__(self):
         if self.target.is_Relational:
@@ -403,39 +344,32 @@
     def __str__(self):
         return str(self.target)
 
     __repr__ = __str__
     
     @property
     def latex(self):
-        target = self.target
-        try:
-            return target.latex
-        except AttributeError:
-            if isinstance(target, tuple):
-                return r"\left[\begin{array}{%s}%s\end{array}\right]" % ('c', r'\\'.join(t.latex for t in target))
-        except Exception as e:
-            raise
+        return self.target.latex
 
     def _pretty(self, p):
         return p._print(self.target)
 
     def __getitem__(self, indices):
         target = self.target
         
         if isinstance(target, tuple):
             obj = target[indices]
              
             parent = self.parent
-            if isinstance(indices, slice):
-                assert parent.is_And or parent.is_Or or parent.is_Mul or parent.is_Add or parent.is_MatMul and isinstance(indices, slice) and (indices.step is None or indices.step == 1)
-                index = indices
-                obj = parent.func(*obj)
-            else:
+            try:
                 index = parent.args.index(obj)
+            except ValueError:
+                assert parent.is_And or parent.is_Or
+                index = tuple(parent.args.index(o) for o in obj)
+                obj = parent.func(*obj)
                 
             self.index.append(index)
             self._objs[-1] = obj
         elif target.is_Tuple:
             self.index.append(indices)
             self._objs.append(target[indices])
         elif target.is_Matrix:
@@ -453,16 +387,40 @@
         return self
 
     def __iter__(self):
         return iter(self.obj)
 
     def enter(self, *args, **kwargs):
         target = self.target
-        limits = target.limits_in_context(args or kwargs, self.parent)
-
+        limits = []
+        
+        if target.is_ExprWithLimits: 
+            if not args and not kwargs:
+                for limit in target.limits:
+                    x, *ab = limit
+                    if not ab and x.is_integer:
+                        limit = (x, target.expr.domain_defined(x))
+                    limits.append(limit)
+                limits.reverse()      
+            else:
+                limits = [*target.limits]
+            
+        elif target.is_ExprCondPair:
+            piecewise = self.parent
+            cond = target.cond
+            for e, c in piecewise.args:
+                if e == target.expr:
+                    break
+                cond &= c.invert()
+                
+            if cond.is_And:
+                limits = [(eq.wrt, eq) for eq in cond.args]
+            else: 
+                limits = [(cond.wrt, cond)]
+                
         if args:
             for x in args:
                 if target.is_ExprWithLimits and x in target.variables:
                     if target.is_Lamda:
                         continue
                     else:
                         expr = target.expr
```

### Comparing `sympy.keras-1.0.21/sympy/logic/utilities/dimacs.py` & `sympy.keras-1.0.4/sympy/logic/utilities/dimacs.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/matrices/__init__.py` & `sympy.keras-1.0.4/sympy/matrices/__init__.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/matrices/common.py` & `sympy.keras-1.0.4/sympy/matrices/common.py`

 * *Files 0% similar despite different names*

```diff
@@ -133,17 +133,17 @@
 
     def _eval_row_del(self, row):
         def entry(i, j):
             return self[i, j] if i < row else self[i + 1, j]
         return self._new(self.rows - 1, self.cols, entry)
 
     def _eval_row_insert(self, pos, other):
-        entries = [*self.args]
+        entries = list(self)
         insert_pos = pos * self.cols
-        entries[insert_pos:insert_pos] = [*other.args]
+        entries[insert_pos:insert_pos] = list(other)
         return self._new(self.rows + other.rows, self.cols, entries)
 
     def _eval_row_join(self, other):
         cols = self.cols
 
         def entry(i, j):
             if j < cols:
@@ -1635,17 +1635,17 @@
         return self.transpose().conjugate()
 
     def _eval_applyfunc(self, f):
         out = self._new(self.rows, self.cols, [f(x) for x in self._args])
         return out
 
     def _eval_as_real_imag(self):
-        from sympy.functions.elementary.complexes import Re, Im
+        from sympy.functions.elementary.complexes import re, im
 
-        return (self.applyfunc(Re), self.applyfunc(Im))
+        return (self.applyfunc(re), self.applyfunc(im))
 
     def _eval_conjugate(self):
         return self.applyfunc(lambda x: x.conjugate())
 
     def _eval_permute_cols(self, perm):
         # apply the permutation to a list
         mapping = list(perm)
@@ -1667,14 +1667,18 @@
     def _eval_trace(self):
         return sum(self[i, i] for i in range(self.rows))
 
     def _eval_transpose(self, axis=-1):
         if axis == self.default_axis:
             return self._new(self.cols, self.rows, lambda i, j: self[j, i])
 
+    def adjoint(self):
+        """Conjugate transpose or Hermitian conjugation."""
+        return self._eval_adjoint()
+
     def applyfunc(self, f):
         """Apply a function to each element of the matrix.
 
         Examples
         ========
 
         >>> from sympy import Matrix
@@ -1690,15 +1694,15 @@
 
         """
         if not callable(f):
             raise TypeError("`f` must be callable.")
 
         return self._eval_applyfunc(f)
 
-    def as_real_imag(self, **_):
+    def as_real_imag(self):
         """Returns a tuple containing the (real, imaginary) part of matrix."""
         return self._eval_as_real_imag()
 
     def conjugate(self):
         """Return the by-element conjugation.
 
         Examples
```

### Comparing `sympy.keras-1.0.21/sympy/matrices/decompositions.py` & `sympy.keras-1.0.4/sympy/matrices/decompositions.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/matrices/dense.py` & `sympy.keras-1.0.4/sympy/matrices/dense.py`

 * *Files 0% similar despite different names*

```diff
@@ -189,15 +189,15 @@
         # cache attributes for faster access
         self_rows, self_cols = self.rows, self.cols
         other_rows, other_cols = other.rows, other.cols
         other_len = other_rows * other_cols
         new_mat_rows = self_rows
         if other.rows == 1:
             new_mat_cols = other.rows
-            other_rows, other_cols = other_cols, other_rows
+            other_rows, other_cols = other_cols, other_rows 
         else:
             new_mat_cols = other.cols
 
         # preallocate the array
         new_mat = [self.zero] * new_mat_rows * new_mat_cols
 
         # if we multiply an n x 0 with a 0 x m, the
@@ -1225,15 +1225,15 @@
     else:
         f = lambda i, j: seqs[j].subs(n, i)
 
     k = len(seqs)
 
     mat = Matrix(k, k, f)
     if not mat.shape:
-        return mat
+        return mat 
     return mat.det()
 
 
 def eye(*args, **kwargs):
     """Create square identity matrix n x n
 
     See Also
```

### Comparing `sympy.keras-1.0.21/sympy/matrices/densearith.py` & `sympy.keras-1.0.4/sympy/matrices/densearith.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/matrices/densesolve.py` & `sympy.keras-1.0.4/sympy/matrices/densesolve.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/matrices/densetools.py` & `sympy.keras-1.0.4/sympy/matrices/densetools.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/matrices/determinant.py` & `sympy.keras-1.0.4/sympy/matrices/determinant.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/matrices/eigen.py` & `sympy.keras-1.0.4/sympy/matrices/eigen.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/matrices/expressions/__init__.py` & `sympy.keras-1.0.4/sympy/matrices/expressions/__init__.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/matrices/expressions/adjoint.py` & `sympy.keras-1.0.4/sympy/matrices/expressions/adjoint.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,9 +1,9 @@
 from sympy.core import Basic
-from sympy.functions import conjugate
+from sympy.functions import adjoint, conjugate
 from sympy.matrices.expressions.transpose import transpose
 from sympy.matrices.expressions.matexpr import MatrixExpr
 from sympy.core.cache import cacheit
 
 
 class Adjoint(MatrixExpr):
     """
@@ -25,64 +25,40 @@
     >>> adjoint(A*B)
     Adjoint(B)*Adjoint(A)
     >>> adjoint(A*B) == Adjoint(A*B)
     False
     >>> adjoint(A*B) == Adjoint(A*B).doit()
     True
     """
-    def __new__(cls, arg, **kwargs):
-        if kwargs.get('evaluate', True):
-            if (ret := arg._eval_adjoint()) is not None:
-                return ret
+    is_Adjoint = True
 
-        return MatrixExpr.__new__(cls, arg)
-    
-    @property
-    def dtype(self):
-        return self.arg.dtype
-    
     def doit(self, **hints):
         arg = self.arg
         if hints.get('deep', True) and isinstance(arg, Basic):
-            arg = arg.doit(**hints)
-            if arg != self.arg:
-                return self.func(arg)
-        
-        return self
+            return adjoint(arg.doit(**hints))
+        else:
+            return adjoint(self.arg)
 
     @property
     def arg(self):
         return self.args[0]
 
     @cacheit
     def _eval_shape(self):
-        shape = self.arg.shape 
-        if len(shape) > 1:
-            [*shape] = shape
-            axis = -1
-            shape[-1], shape[-2] = shape[-2], shape[-1]
-            return tuple(shape)
-        return shape
+        return self.arg.shape[::-1]
 
     def _entry(self, i, j, **kwargs):
-        return conjugate(self.arg[j, i])
+        return conjugate(self.arg._entry(j, i, **kwargs))
 
     def _eval_adjoint(self):
         return self.arg
 
     def _eval_conjugate(self):
         return transpose(self.arg)
 
     def _eval_trace(self):
         from sympy.matrices.expressions.trace import Trace
         return conjugate(Trace(self.arg))
 
     def _eval_transpose(self, axis=-1):
         if axis == self.default_axis:
             return conjugate(self.arg)
-
-    def _latex(self, printer, exp=None, *args):
-        arg = printer._print(self.args[0])
-        tex = r'%s^{\color{magenta} {\dagger}}' % arg
-        if exp:
-            tex = r'\left(%s\right)^{%s}' % (tex, printer._print(exp))
-        return tex
```

### Comparing `sympy.keras-1.0.21/sympy/matrices/expressions/applyfunc.py` & `sympy.keras-1.0.4/sympy/matrices/expressions/applyfunc.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/matrices/expressions/blockmatrix.py` & `sympy.keras-1.0.4/sympy/matrices/expressions/blockmatrix.py`

 * *Files 12% similar despite different names*

```diff
@@ -55,17 +55,14 @@
     _eval_is_extended_rational = lambda self: self._eval_template_is_attr('is_extended_rational')
     _eval_is_extended_real = lambda self: self._eval_template_is_attr('is_extended_real')
     _eval_is_extended_complex = lambda self: self._eval_template_is_attr('is_extended_complex')
     _eval_is_finite = lambda self: self._eval_template_is_attr('is_finite')
     _eval_is_extended_positive = lambda self: self._eval_template_is_attr('is_extended_positive')
     _eval_is_extended_negative = lambda self: self._eval_template_is_attr('is_extended_negative')
 
-    def _eval_is_random(self):
-        return any(arg.is_random for arg in self.args)
-
     @property
     def dtype(self):
         dtype = None
         for arg in self.args:
             _dtype = arg.dtype
             if dtype is None or dtype in _dtype:
                 dtype = _dtype
@@ -104,33 +101,37 @@
                 
             if all(arg.is_DenseMatrix for arg in args):
                 return Matrix([arr.tolist() for arr in args])
         
         from sympy import sympify
         args = [*map(sympify, args)]
         length = max(len(arg.shape) for arg in args)
-#         shape = kwargs.get('shape')
+        
         if axis == 1:
             hit = False
             for i, arg in enumerate(args):
-                if len(arg.shape) == length:
-                    if isinstance(arg, BlockMatrix):
-                        if arg.axis == 0:
+                if isinstance(arg, BlockMatrix):
+                    if arg.axis == 0:
+                        if len(arg.shape) == length:
                             blocks = arg.blocks
                             if blocks is None:
                                 blocks = [(arg,) for arg in arg.args]
 
                             for j in range(i + 1, len(args)):
                                 arg = args[j]
                                 if isinstance(arg, BlockMatrix) and arg.axis == 0:
                                     continue
                                 else:
                                     break
                             else:
                                 hit = True
+                            break
+                    else:
+                        break                    
+                else:
                     break
                         
             if hit:
                 former = args[:i]
                 latter = args[i + 1:]
                 
                 hit = False
@@ -223,177 +224,134 @@
                 Add.broadcast(shapes)
                 rows = sum(s[0] for s in shapes)
                 if len(shapes[0]) > 1:
                     return (rows, *shapes[0][1:])
                 else:
                     return (rows,)
                 
-    def get_slice(self, key):
-        axis = int(self.axis)
-        #key is indexing at position axis
-        if isinstance(key, slice):
-            start, stop, step = key.start, key.stop, key.step
-        else:
-            start, stop, step = key.slice_args
-
-        if start is None:
-            start = 0
-        if stop is None:
-            stop = self.shape[axis]
-            
-        if start == 0 and stop == self.shape[axis]:
-            return self
-        
-        from sympy import Piecewise
-        assert step is None or step == 1
-        
-        index_stop = 0
-        args = []
-        len_shape = len(self.shape)
-        index_start = [0] * len(self.args)
-        
-        for i, arg in enumerate(self.args):
-            if i:
-                index_start[i] = index_start[i - 1] + size
-                
-            if len(arg.shape) < len_shape:
-                size = 1
-            else:
-                size = arg.shape[axis]
-                
-            index_stop += size
-                
-            cond = stop <= index_stop
-            if cond == False:
-                continue
-            
-            args_inner = []
-            for j in range(i, -1, -1):
-                cond_inner = index_start[j] <= start
-                if cond_inner == False:
-                    continue
-                
-                blocks = []
-                for k in range(j, i + 1):
-                    arg = self.args[k]
-                    if len(arg.shape) < len_shape:
-                        blocks.append(arg)
-                    else:
-                        if k == j:
-                            if k == i:
-                                slices = [slice(None, None)] * axis + [slice(start - index_start[k], stop - index_start[k])]
-                                blocks.append(arg[tuple(slices)])
-                            else:
-                                slices = [slice(None, None)] * axis + [slice(start - index_start[k], None)]
-                                blocks.append(arg[tuple(slices)])
-                        else:
-                            if k == i:
-                                slices = [slice(None, None)] * axis + [slice(None, stop - index_start[k])]
-                                blocks.append(arg[tuple(slices)])
-                            else:
-                                blocks.append(arg)
-                            
-                if len(blocks) == 1:
-                    blocks, = blocks
-                else:
-                    blocks = self.func(blocks, axis=axis)
-
-                args_inner.append([blocks, cond_inner])
-                if cond_inner:
-                    break
-                
-            args_inner[-1][1] = True
-            args.append([Piecewise(*args_inner), cond])
-
-            if cond:
-                break
-
-        args[-1][1] = True
-        return Piecewise(*args)
-        
     def __getitem__(self, key):
+        from sympy.functions.elementary.piecewise import Piecewise
         if isinstance(key, tuple) and len(key) == 1:
             key, = key
             
         from sympy.core.containers import Tuple
         if isinstance(key, slice) or isinstance(key, Tuple):
-            axis = self.axis
-            if axis != 0:
-                args = [arg[key] for arg in self.args]
-                return self.func(*args, axis=axis)
+            if isinstance(key, slice):
+                start, stop, step = key.start, key.stop, key.step
+            else:
+                start, stop, step = key.slice_args
+                
+            if start is None:
+                start = 0
+            if stop is None:
+                stop = self.shape[0]
+                
+            if start == 0 and stop == self.shape[0]:
+                return self
             
-            return self.get_slice(key)
+            rows = 0
+            args = []
+            
+            len_self_shape = len(self.shape)
+            for arg in self.args:
+                if start >= stop:
+                    break
+                index = rows
+                if len(arg.shape) < len_self_shape:
+                    rows += 1
+                else:
+                    rows += arg.shape[0]
 
+                if start < rows:
+                    if len(arg.shape) < len_self_shape:
+                        args.append(arg)
+                        start += 1
+                    elif rows <= stop:
+                        if rows - start < arg.shape[0]:
+                            args.append(arg[start:])
+                        else:
+                            args.append(arg)
+                        start = rows
+                    else:
+                        args.append(arg[start - index: stop - index])
+                        start = stop
+            if len(args) == 1:
+                return args[0]
+            if len(args) == 0:
+                return ZeroMatrix(*self.shape)
+            return self.func(*args)
+        
         if isinstance(key, tuple):
             if len(key) == 1:
                 key = key[0]
                 j = None
                 
-            elif len(key) >= 2:
-                if key[self.axis] == slice(None, None, None):
-                    if self.axis == 0:
-                        args = []
-                        for v in self.args:
-                            if len(v.shape) < len(self.shape):
-                                indexed = v[key[1:]]
-                            else:
-                                indexed = v[key]
-                            args.append(indexed)
+            elif len(key) == 2:
+                i, j = key
+                if isinstance(i, slice):
+                    if isinstance(j, slice):
+                        raise Exception('unimplemented method')
                     else:
-                        args = [arg[key] for arg in self.args]
-                    return self.func(*args, axis=self.axis)
-
-                key, j = key
-                if isinstance(j, slice):
-                    assert key == slice(None, None, None)
-                    assert self.axis == 1
-                    return self.get_slice(j)
-                    
+                        assert i.step is None, 'unimplemented slice object %s' % i
+                        start, stop = i.start, i.stop                        
+                        if start is None:
+                            if stop is None:
+                                # v have the same columns
+                                args = []
+                                for v in self.args:
+                                    if len(v.shape) > 1:
+                                        indexed = v[:, j]
+                                    else:
+                                        indexed = v[j]
+                                    args.append(indexed)
+                                return self.func(*args)
+
+                        raise Exception('unimplemented slice object %s' % i)
+                elif isinstance(j, slice):
+                    raise Exception('unimplemented method') 
+                from sympy.core.sympify import _sympify
+                key, j = _sympify(i), _sympify(j) 
         else:
             j = None
                   
         assert isinstance(key, int) or key.is_Integer or key.is_Symbol or key.is_Expr
         
-        if self.axis == 0:
-            from sympy import Piecewise 
+        if self.axis == 0: 
             rows = 0
             args = []
             len_shape = len(self.shape)
             for arg in self.args:
                 index = rows
                 if len(arg.shape) < len_shape:
                     rows += 1
                 else:
                     rows += arg.shape[0]
                     
                 cond = key < rows
-                if cond == False:
+                if cond.is_BooleanFalse:
                     continue
                 
                 if len(arg.shape) < len_shape:
                     args.append([arg, cond])
                 else:
                     args.append([arg[key - index], cond])
                     
-                if cond:
-                    break
-
             if j is not None:
                 for arg in args:
                     arg[0] = arg[0][j]
                      
             args[-1][-1] = True
             return Piecewise(*args)
         else:
             self = self.func(*(a[key] for a in self.args), axis=self.axis - 1)
             if j is not None:
                 self = self[j]
             return self
 
-    def _eval_determinant(self, **kwargs):
+    def _eval_determinant(self):
         from sympy.concrete.products import Product
         if self.is_upper or self.is_lower:
             i = self.generate_var(integer=True)
             return Product(self[i, i], (i, 0, self.cols)).doit()
 
     @property
     def is_lower(self):
@@ -516,15 +474,15 @@
                             start = diff
                         else:
                             if start != diff:
                                 return self
                     elif arg.is_DenseMatrix:
                         mat.append(arg)
                     else:
-                        return self
+                        return self 
                     
                 if start is not None:
                     return arg.base[start:len(self.args)]
                 
                 if len(mat) == len(self.args):
                     return self.to_DenseMatrix()
                 else:
@@ -666,15 +624,15 @@
                 latex = "%s_%s" % (latex, p._print(self.axis))
                 
             return latex
             
         array = []
         for X in self.args: 
             if X.is_Transpose and X.arg.is_BlockMatrix: 
-                X = X.arg
+                X = X.arg       
                 latex = r"{\left(\begin{array}{%s}%s\end{array}\right)}" % ('c' * len(X.args), ' & '.join('{%s}' % p._print(arg.T) for arg in X.args))
             else:
                 latex = '{%s}' % p._print(X)   
             array.append(latex)
 
         if len(self.shape) == 1 or self.axis:
             delimiter = ' & '
```

### Comparing `sympy.keras-1.0.21/sympy/matrices/expressions/cofactor.py` & `sympy.keras-1.0.4/sympy/matrices/expressions/cofactor.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/matrices/expressions/companion.py` & `sympy.keras-1.0.4/sympy/matrices/expressions/companion.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/matrices/expressions/determinant.py` & `sympy.keras-1.0.4/sympy/matrices/expressions/determinant.py`

 * *Files 3% similar despite different names*

```diff
@@ -32,21 +32,21 @@
 
         return Basic.__new__(cls, mat)
 
     @property
     def arg(self):
         return self.args[0]
 
-    def doit(self, **kwargs):
-        if kwargs.get('deep'):
+    def doit(self, deep=False, **_):
+        if deep:
             arg = self.arg.doit(deep=True)
             if arg != self.arg:
                 return self.func(arg).doit()
             
-        det = self.arg._eval_determinant(**kwargs)
+        det = self.arg._eval_determinant()
         if det is not None:
             return det
         _, n = self.arg.shape
         if n == 1:
             return self.arg[0, 0]
         return self
```

### Comparing `sympy.keras-1.0.21/sympy/matrices/expressions/diagonal.py` & `sympy.keras-1.0.4/sympy/matrices/expressions/diagonal.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/matrices/expressions/dotproduct.py` & `sympy.keras-1.0.4/sympy/matrices/expressions/dotproduct.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/matrices/expressions/factorizations.py` & `sympy.keras-1.0.4/sympy/matrices/expressions/factorizations.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/matrices/expressions/fourier.py` & `sympy.keras-1.0.4/sympy/matrices/expressions/fourier.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/matrices/expressions/funcmatrix.py` & `sympy.keras-1.0.4/sympy/matrices/expressions/funcmatrix.py`

 * *Files 2% similar despite different names*

```diff
@@ -42,10 +42,10 @@
         return self.lamda(i, j)
 
     def _eval_trace(self):
         from sympy.matrices.expressions.trace import Trace
         from sympy import Sum
         return Trace(self).rewrite(Sum).doit()
 
-    def as_real_imag(self, **_):
+    def as_real_imag(self):
         from sympy.functions.elementary.complexes import Re, Im
         return (Re(Matrix(self)), Im(Matrix(self)))
```

### Comparing `sympy.keras-1.0.21/sympy/matrices/expressions/hadamard.py` & `sympy.keras-1.0.4/sympy/matrices/expressions/hadamard.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/matrices/expressions/inverse.py` & `sympy.keras-1.0.4/sympy/matrices/expressions/inverse.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,16 +1,16 @@
 from sympy.core.sympify import _sympify
 from sympy.core import S, Basic
 
-from sympy.matrices.expressions.matexpr import ShapeError, MatrixExpr
+from sympy.matrices.expressions.matexpr import ShapeError
 from sympy.matrices.expressions.matpow import MatPow
 from sympy.core.cache import cacheit
 
 
-class Inverse(MatrixExpr):
+class Inverse(MatPow):
     """
     The multiplicative inverse of a matrix expression
 
     This is a symbolic object that simply stores its argument without
     evaluating it. To actually compute the inverse, use the ``.inverse()``
     method of matrices.
 
@@ -48,15 +48,15 @@
 
     def _eval_shape(self):
         return self.arg.shape
 
     def _eval_inverse(self):
         return self.arg
 
-    def _eval_determinant(self, **kwargs):
+    def _eval_determinant(self):
         from sympy.matrices.expressions.determinant import det
         return 1 / det(self.arg)
 
     def doit(self, **hints):
         if 'inv_expand' in hints and hints['inv_expand'] == False:
             return self
         if hints.get('deep', True):
```

### Comparing `sympy.keras-1.0.21/sympy/matrices/expressions/kronecker.py` & `sympy.keras-1.0.4/sympy/matrices/expressions/kronecker.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,11 +1,12 @@
 """Implementation of the Kronecker product"""
 
-from sympy.core import Mul, prod, sympify
+from sympy.core import Add, Mul, Pow, prod, sympify
 
+from sympy.functions import adjoint
 from sympy.matrices.expressions.matexpr import MatrixExpr, ShapeError, Identity
 from sympy.matrices.expressions.transpose import transpose
 from sympy.matrices.matrices import MatrixBase
 from sympy.strategies import (
     canon, condition, distribute, do_one, exhaust, flatten, typed, unpack)
 from sympy.strategies.traverse import bottom_up
 from sympy.utilities import sift
@@ -127,32 +128,31 @@
         for mat in reversed(self.args):
             i, m = divmod(i, mat.rows)
             j, n = divmod(j, mat.cols)
             result *= mat[m, n]
         return result
 
     def _eval_adjoint(self):
-        from sympy import Adjoint
-        return KroneckerProduct(*list(map(Adjoint, self.args))).doit()
+        return KroneckerProduct(*list(map(adjoint, self.args))).doit()
 
     def _eval_conjugate(self):
         return KroneckerProduct(*[a.conjugate() for a in self.args]).doit()
 
     def _eval_transpose(self, axis=-1):
         if axis == self.default_axis:
             return KroneckerProduct(*list(map(transpose, self.args))).doit()
 
     def _eval_trace(self):
         from .trace import trace
         return prod(trace(a) for a in self.args)
 
-    def _eval_determinant(self, **kwargs):
+    def _eval_determinant(self):
         from .determinant import det
         if not all(a.is_square for a in self.args):
-            return
+            return 
 
         m = self.rows
         return prod(det(a)**(m/a.rows) for a in self.args)
 
     def _eval_inverse(self):
         try:
             return KroneckerProduct(*[a.inverse() for a in self.args])
```

### Comparing `sympy.keras-1.0.21/sympy/matrices/expressions/matexpr.py` & `sympy.keras-1.0.4/sympy/matrices/expressions/matexpr.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 from functools import wraps, reduce
 import collections
 
 from sympy.core import S, Symbol, Tuple, Integer, Basic, Expr, Eq, Mul, Add
 from sympy.core.decorators import call_highest_priority
 from sympy.core.compatibility import default_sort_key
 from sympy.core.sympify import SympifyError, _sympify
-from sympy.functions import conjugate
+from sympy.functions import conjugate, adjoint
 from sympy.functions.special.tensor_functions import KroneckerDelta
 from sympy.matrices import ShapeError
 from sympy.simplify import simplify
 from sympy.core.cache import cacheit
 
 
 def _sympifyit(arg, retval=None):
@@ -107,16 +107,15 @@
             raise ShapeError("Power of non-square matrix %s" % self)
         elif self.is_Identity:
             return self
         elif other is S.Zero:
             return Identity(self.rows)
         elif other is S.One:
             return self
-        from sympy.core.power import Pow
-        return Pow(self, other, evaluate=False)
+        return MatPow(self, other).doit(deep=False)
 
     @_sympifyit('other', NotImplemented)
     @call_highest_priority('__pow__')
     def __rpow__(self, other):
         from sympy.core.power import Pow
         return Pow(other, self, evaluate=False)
 
@@ -124,15 +123,15 @@
     @call_highest_priority('__rdiv__')
     def __div__(self, other):
         return self * other ** S.NegativeOne
 
     @_sympifyit('other', NotImplemented)
     @call_highest_priority('__div__')
     def __rdiv__(self, other):  
-        from sympy.core.power import Pow
+        from sympy.core.power import Pow      
         return Mul(other, Pow(self, S.NegativeOne))
 
     __truediv__ = __div__
     __rtruediv__ = __rdiv__
 
     @property
     def rows(self):
@@ -141,30 +140,23 @@
         return self.shape[0]
 
     @property
     def cols(self):
         return self.shape[-1]
 
     def _eval_conjugate(self):
-        if len(self.shape) < 2:
-            return
         from sympy.matrices.expressions.adjoint import Adjoint
         from sympy.matrices.expressions.transpose import Transpose
         return Adjoint(Transpose(self))
 
-    def as_real_imag(self, **_):
+    def as_real_imag(self):
         from sympy import I
-        conj = self._eval_conjugate()
-        if conj is None:
-            real = self
-            im = S.Zero
-        else:
-            real = (self + conj) / 2
-            im = (self - conj) / (2 * I)
-        return real, im
+        real = (S(1) / 2) * (self + self._eval_conjugate())
+        im = (self - self._eval_conjugate()) / (2 * I)
+        return (real, im)
 
     def _eval_inverse(self):
         from sympy.matrices.expressions.inverse import Inverse
         return Inverse(self)
 
     def _eval_transpose(self, axis=-1):
         ...
@@ -209,14 +201,17 @@
         else:
             from sympy import Derivative
             return Derivative(x, self)
 
     def _accept_eval_derivative(self, s):
         return s._visit_eval_derivative_array(self)
 
+    def adjoint(self):
+        return adjoint(self)
+
     def as_coeff_Mul(self, rational=False):
         """Efficiently extract the coefficient of a product. """
         return S.One, self
 
     def conjugate(self):
         return conjugate(self)
 
@@ -234,17 +229,17 @@
                 (0 <= i) != False and (i < self.rows) != False) and
                 (0 <= j) != False and (j < self.cols) != False)
 
     def __getitem__(self, key):
         if not isinstance(key, tuple) and isinstance(key, slice):
             return self._entry(key)
         
-        if isinstance(key, tuple):
+        if isinstance(key, tuple): 
             if len(key) == 1:
-                key, = key
+                key = key[0]
             elif len(key) == 2:
                 i, j = key
                 if isinstance(i, slice) or isinstance(j, slice):
                     return self._entry(i, j)
 
                 i, j = _sympify(i), _sympify(j)
                 assert self.valid_index(i, j) != False
@@ -543,17 +538,14 @@
         return ElementwiseApplyFunction(func, self)
 
     def _eval_Eq(self, other):
         if isinstance(other, MatrixExpr) and not self - other:
             return True
         return Eq(self, other, evaluate=False)
 
-    def _eval_is_random(self):
-        return any(arg.is_random for arg in self.args)
-
 
 def get_postprocessor(cls):
 
     def _postprocessor(expr):
         # To avoid circular imports, we can't have MatMul/MatAdd on the top level
         mat_class = {Mul: Mul, Add: Add}[cls]
         nonmatrices = []
@@ -844,15 +836,15 @@
     is_upper = True
     is_lower = True
     is_singular = False
     is_finite = True
 
     def __new__(cls, *args, **kwargs):
         if args:
-            n, = args
+            [n] = args
         else:
             n, S[n] = kwargs['shape']
             
         if n == 1:
             return S.One
          
         return super(Identity, cls).__new__(cls, shape=(n, n))
@@ -889,88 +881,47 @@
     def _eval_inverse(self):
         return self
 
     def conjugate(self):
         return self
 
     def _entry(self, i, j=None, **_):
-        from sympy import BlockMatrix, ZeroMatrix, Lamda
+        from sympy.concrete.expr_with_limits import Lamda
         if j is None:
-            if isinstance(i, slice):
-                start, stop, step = i.start, i.stop, i.step
-                assert step == 1 or step is None
-                n = self.shape[-1]
-                
-                size = stop - start
-                if start == 0:
-                    if size == n:
-                        return self
-
-                    assert 0 < size < n
-                    return BlockMatrix[1](self.func(size), ZeroMatrix(size, n - size), shape=(size, n))
-                elif stop == n:
-                    assert start > 0
-                    return BlockMatrix[1](ZeroMatrix(size, start), self.func(size), shape=(size, n))
-                else:
-                    raise Exception("unimplemented")
-            else:
-                j = self.generate_var(excludes=i.free_symbols, integer=True)
-                return Lamda[j:self.n](KroneckerDelta(i, j))
+            j = self.generate_var(excludes=i.free_symbols, integer=True)
+            return Lamda[j:self.n](KroneckerDelta(i, j))
         elif isinstance(i, slice):
             if i.start is None and i.stop is None and i.step is None:
-                if isinstance(j, slice):
-                    start, stop, step = j.start, j.stop, j.step
-                    assert step == 1 or step is None
-                    n = self.shape[-1]
-                    size = stop - start
-                    
-                    if start == 0:
-                        if size == n:
-                            return self
-    
-                        assert 0 < size < n
-                        return BlockMatrix(self.func(size), ZeroMatrix(n - size, size), shape=(n, size))
-                    elif stop == n:
-                        assert start > 0
-                        return BlockMatrix(ZeroMatrix(start, size), self.func(size), shape=(n, size))
-                    else:
-                        raise Exception("unimplemented")
-                else:
-                    i = self.generate_var(excludes=j.free_symbols, integer=True)
-                    return Lamda[i:self.n](KroneckerDelta(i, j))
+                i = self.generate_var(excludes=j.free_symbols, integer=True)
+                return Lamda[i:self.n](KroneckerDelta(i, j))
             else:
                 raise Exception("unimplemented")
         else:
             eq = Eq(i, j)
             if eq is S.true:
                 return S.One
             elif eq is S.false:
                 return S.Zero
             return KroneckerDelta(i, j)
 
-    def _eval_determinant(self, **kwargs):
+    def _eval_determinant(self):
         return S.One
 
     def _eval_is_extended_integer(self):
         return True
 
     def _eval_is_extended_positive(self):
         ...
         
     def _eval_is_extended_negative(self):
         return False
     
     def doit(self, **hints):
         return self
     
-    def __rmul__(self, other): 
-        if isinstance(other, Basic) and len(other.shape) >= len(self.shape):
-            return other
-        return Mul(other, self)
-    
 
 def simplify_shape(shape):
     while shape:
         if shape[0] == 1:
             shape = shape[1:]
         elif shape[-1] == 1:
             shape = shape[:-1]
@@ -1002,79 +953,69 @@
         if not shape:
             return S.Zero
         return super(ZeroMatrix, cls).__new__(cls, shape=shape)
 
     @_sympifyit('other', NotImplemented)
     @call_highest_priority('__rpow__')
     def __pow__(self, other):
-        if other > 0:
-            return self
+        if other != 1 and not self.is_square:
+            raise ShapeError("Power of non-square matrix %s" % self)
         if other == 0:
-            return OneMatrix(*self.shape)
-        if other < 0:
+            return Identity(self.rows)
+        if other < 1:
             raise ValueError("Matrix det == 0; not invertible.")
-
-        from sympy import Pow
-        return Pow(self, other, evaluate=False)
+        return self
 
     def _eval_transpose(self, axis=-1):
         if axis == self.default_axis:
             if len(self.shape) <= 1:
                 return self
             *shape, rows, cols = self.shape
             return ZeroMatrix(cols, rows, *shape)
 
     def _eval_trace(self):
         return S.Zero
 
-    def _eval_determinant(self, **kwargs):
+    def _eval_determinant(self):
         return S.Zero
 
     def conjugate(self):
         return self
 
-    @staticmethod
-    def static_entry(self, i, j):
-        from sympy.functions.elementary.integers import Ceiling
+    def _entry(self, i, j=None, **kwargs):
         if j is None:
-            if isinstance(i, slice):
-                start, stop, step = i.start, i.stop, i.step
-                if start is None:
-                    start = 0
-                if stop is None:
-                    stop = self.shape[0]
-                size = stop - start
-                if step is None:
-                    step = 1
-                
-                return self.func(Ceiling(size / step), *self.shape[1:])
-            
-            return self.func(*self.shape[1:])
-            
-        elif isinstance(i, slice):
-            if i == slice(None, None):
-                if isinstance(j, slice):
-                    start, stop, step = j.start, j.stop, j.step
+            if len(self.shape) > 1:
+                if isinstance(i, slice):
+                    start, stop, step = i.start, i.stop, i.step
                     if start is None:
                         start = 0
                     if stop is None:
-                        stop = self.shape[1]
+                        stop = self.shape[0]
                     size = stop - start
                     if step is None:
                         step = 1
-                    
-                    return self.func(self.shape[0], Ceiling(size / step), *self.shape[2:])
+                        
+                    from sympy.functions.elementary.integers import Ceiling
+                    return self.func(Ceiling(size / step), *self.shape[1:])
                 else:
-                    return self.func(self.shape[0])
+                    return self.func(*self.shape[1:])
+            else:
+                return S.Zero
+            
+        elif isinstance(i, slice):
+            if isinstance(j, slice):
+                raise Exception('unimplemented slice object %s' % i)
+            else:
+                start, stop = i.start, i.stop
+                if start is None:
+                    if stop is None:
+                        return self.func(self.shape[0])
             raise Exception('unimplemented slice object %s' % i)
         
         return self.func(*self.shape[2:])
-        
-    def _entry(self, i, j=None, **kwargs):
-        return ZeroMatrix.static_entry(self, i, j)
 
     def __nonzero__(self):
         return False
 
     __bool__ = __nonzero__
 
     def _latex(self, p):
@@ -1092,20 +1033,20 @@
     def __mul__(self, lhs):
         if isinstance(lhs, Basic) and len(lhs.shape) > len(self.shape):
             return self.func(*lhs.shape)
         return self
     
     def __add__(self, other):
         if len(other.shape) < len(self.shape):
-            return OneMatrix(*self.shape) * other
+            return OneMatrix(*self.shape) * other        
         return other
 
     def __radd__(self, other):
         if len(other.shape) < len(self.shape):
-            return OneMatrix(*self.shape) * other
+            return OneMatrix(*self.shape) * other        
         return other
     
     def doit(self, **hints):
         return self
     
     @staticmethod
     def simplify_Lamda(self, squeeze=False):
@@ -1121,24 +1062,14 @@
                 from sympy.sets.fancysets import Range
                 a, b = v.domain.of(Range)
                 size = b - a
             shape.append(size)
         shape.reverse()
         return ZeroMatrix(*shape, *self.expr.shape)
     
-    def _eval_exp(self):
-        return OneMatrix(*self.shape)
-    
-    def of(self, cls):
-        if cls.is_Zero or cls.is_ZeroMatrix:
-            return ()
-
-    def is_consistently_of(self, struct):
-        return struct.is_ZeroMatrix or struct.is_Zero
-
 
 class GenericZeroMatrix(ZeroMatrix):
     """
     A zero matrix without a specified shape
 
     This exists primarily so MatAdd() with no arguments can return something
     meaningful.
@@ -1197,29 +1128,45 @@
                 return self
             *shape, rows, cols = self.shape
             return OneMatrix(cols, rows, *shape)
 
     def _eval_trace(self):
         return S.One * self.rows
 
-    def _eval_determinant(self, **kwargs):
+    def _eval_determinant(self):
         condition = Eq(self.shape[0], 1) & Eq(self.shape[1], 1)
         if condition == True:
             return S.One
         elif condition == False:
             return S.Zero
         
     def conjugate(self):
         return self
 
     def _entry(self, i, j=None, **_):
-        return ZeroMatrix.static_entry(self, i, j)
+        if isinstance(i, slice):
+            if isinstance(j, slice):
+                raise Exception('unimplemented slice object %s' % j)
+            else:
+                start, stop = i.start, i.stop
+                if start is None:
+                    if stop is None:
+                        return self.func(self.shape[0])
+                raise Exception('unimplemented slice object %s' % j)
+        if len(self.shape) > 1:
+            if j is None:
+                return self.func(*self.shape[1:])
+            else:
+                return self.func(*self.shape[2:])
+        else: 
+            return S.One
 
     def _latex(self, p):
         return r"\mathbf{1}"
+#         return r"\mathbb{0}" if p._settings['mat_symbol_style'] == 'plain' else r"\mathbf{0}"
 
     def _sympystr(self, p):
         return "1"
 
     def __mul__(self, rhs):
         if len(rhs.shape) >= len(self.shape):
             return rhs
@@ -1253,33 +1200,15 @@
                 from sympy.sets.fancysets import Range
                 a, b = v.domain.of(Range)
                 size = b - a
             shape.append(size)
         shape.reverse()
         return OneMatrix(*shape, *self.expr.shape)
     
-    @staticmethod
-    def expand_dims(self, shape, pivot):
-        consistent_shape = shape[:-pivot] 
-        extra_shape = shape[-pivot:]
-        consistent_shape_len = len(consistent_shape)
-#                   transpose matrix from (*consistent_shape, *extra_shape) to (*extra_shape, *consistent_shape)
-#                   (3, 4, 5, 6) => (5, 6, 3, 4)
-        axes = []
-        for j in range(len(extra_shape)):
-            for i in range(consistent_shape_len):
-                axes.append(consistent_shape_len + j - i)
-
-        from sympy import Transpose
-        return Transpose[tuple(axes)](self * OneMatrix(*consistent_shape, *extra_shape))
-
-    def is_consistently_of(self, struct):
-        return struct.is_OneMatrix
-
-
+    
 def matrix_symbols(expr):
     return [sym for sym in expr.free_symbols if sym.is_Matrix]
 
 
 class _LeftRightArgs(object):
     r"""
     Helper class to compute matrix derivatives.
@@ -1505,34 +1434,34 @@
         else:
             return_reference_i = False
             
         if j is None:
             return_reference_j = True
             j = self.generate_var(excludes=i.free_symbols, integer=True)
         else:
-            return_reference_j = False
+            return_reference_j = False                        
         piecewise = Piecewise((KroneckerDelta(j, self.i), Equal(i, self.j)),
                               (KroneckerDelta(j, self.j), Equal(i, self.i)),
                               (KroneckerDelta(j, i), True))
 
         if return_reference_j:
             return Lamda[j:self.n](piecewise)
         if return_reference_i:
             return Lamda[i:self.n](piecewise)
-        return piecewise
+        return piecewise            
 
     @property
     def i(self):
         return self.args[0]
 
     @property
     def j(self):
         return self.args[1]
 
-    def _eval_determinant(self, **kwargs):        
+    def _eval_determinant(self):        
         return 2 * KroneckerDelta(self.i, self.j) - 1
 
     def _eval_transpose(self, axis=-1):
         if axis == self.default_axis: 
             return self
 
     def _eval_inverse(self):
@@ -1607,34 +1536,34 @@
     def _eval_inverse(self):
         return self.func(self.n, self.i, 1 / self.multiplier)
 
     @property
     def i(self):
         return self.args[-2]
     
-    def _eval_determinant(self, **kwargs):
+    def _eval_determinant(self):
         return self.multiplier
 
     def _entry(self, i, j=None, **_):
         from sympy.concrete.expr_with_limits import Lamda
 #     1   0   0   0   0   0
-#     0   1   0   0   0   0
+#     0   1   0   0   0   0    
 #     0   0   k   0   0   0    <-----self.i    th row
-#     0   0   0   1   0   0
-#     0   0   0   0   1   0
-#     0   0   0   0   0   1
+#     0   0   0   1   0   0            
+#     0   0   0   0   1   0                        
+#     0   0   0   0   0   1  
 #             ^       
 #             |       
-#            i col
+#            i col          
         
         if j is None:
             return_reference = True
             j = self.generate_var(excludes=i.free_symbols, integer=True)
         else:
-            return_reference = False
+            return_reference = False                        
             
         piecewise = (1 + (self.multiplier - 1) * KroneckerDelta(i, self.i)) * KroneckerDelta(i, j)
         
         if return_reference:
             return Lamda[j:self.n](piecewise)
         return piecewise
 
@@ -1744,40 +1673,40 @@
 
     def _entry(self, i, j=None, **_):
         from sympy.concrete.expr_with_limits import Lamda
         from sympy.functions.elementary.piecewise import Piecewise
         from sympy.core.relational import Equal
         
 #     1   0   0   0   0   0
-#     0   1   0   0   0   0
+#     0   1   0   0   0   0    
 #     0   0   1   0   0   0    <-----self.i    th row
-#     0   0   0   1   0   0
-#     0   0   k   0   1   0    <-----self.j th row
-#     0   0   0   0   0   1
+#     0   0   0   1   0   0            
+#     0   0   k   0   1   0    <-----self.j th row                    
+#     0   0   0   0   0   1  
 #             ^       ^
 #             |       |
-#            i col    j col
+#            i col    j col      
         
         if j is None:
             return_reference = True
             j = self.generate_var(excludes=i.free_symbols, integer=True)
         else:
-            return_reference = False
+            return_reference = False                        
             
         piecewise = Piecewise((KroneckerDelta(j, i), Equal(self.i, self.j)),
                               (Piecewise((self.multiplier, Equal(j, self.i)),
                                          (KroneckerDelta(j, self.j), True)),
                                          Equal(i, self.j)),
                               (KroneckerDelta(j, i), True))
 
         if return_reference:
             return Lamda[j:self.n](piecewise)
-        return piecewise
+        return piecewise            
 
-    def _eval_determinant(self, **kwargs):
+    def _eval_determinant(self):
         return S.One
 
     @_sympifyit('other', NotImplemented)
     @call_highest_priority('__rmatmul__')
     def __matmul__(self, other):
         if other.is_BlockMatrix:
             other_i = other[self.i]
@@ -1873,69 +1802,69 @@
     def i(self):
         return self.args[-2]
 
     @property
     def j(self):
         return self.args[-1]
     
-    def _eval_determinant(self, **kwargs):
+    def _eval_determinant(self):
         return (-1) ** (self.j - self.i)
 
     def _eval_transpose(self, axis=-1):
         if axis == self.default_axis:
             return ShiftMatrix(self.n, self.j, self.i)
 
     def _eval_inverse(self):
         return self.T
 
     def _entry(self, i, j=None, **_):
         from sympy.concrete.expr_with_limits import Lamda
         from sympy.functions.elementary.piecewise import Piecewise
-        from sympy.core.relational import Equal, Less
+        from sympy.core.relational import Equal, Less 
         from sympy.sets import Element, Range
         if j is None:
             return_reference = True
             j = self.generate_var(excludes=i.free_symbols, integer=True)
         else:
-            return_reference = False
+            return_reference = False                        
 #     1   0   0   0   0   0
 #     0   1   0   0   0   0
-#     0   0   0   1   0   0    <-----self.i th row
+#     0   0   0   1   0   0    <-----self.i th row        
 #     0   0   0   0   1   0    delete i th row and insert after j th row
-#     0   0   1   0   0   0    <-----self.j th row
-#     0   0   0   0   0   1
+#     0   0   1   0   0   0    <-----self.j th row                    
+#     0   0   0   0   0   1  
 #             ^       ^
 #             |       |
-#            i col    j col
+#            i col    j col      
 #         
         piecewise_ij = Piecewise((KroneckerDelta(self.i, j), Equal(i, self.j)),
                                  (KroneckerDelta(i + 1, j), Element(i, Range(self.i, self.j))),
                                  (KroneckerDelta(i, j), True))
         
 #     1   0   0   0   0   0
 #     0   1   0   0   0   0
 #     0   0   0   0   1   0    <-----self.j th row
 #     0   0   1   0   0   0    delete i th row and insert before j th row
 #     0   0   0   1   0   0    <-----self.i th row
-#     0   0   0   0   0   1
+#     0   0   0   0   0   1  
 #             ^       ^
 #             |       |
-#            j col    i col
+#            j col    i col      
         
         piecewise_ji = Piecewise((KroneckerDelta(i, self.j), Equal(j, self.i)),
                                  (KroneckerDelta(i, j + 1), Element(j, Range(self.j, self.i))),
                                  (KroneckerDelta(i, j), True))
         
         piecewise = Piecewise((KroneckerDelta(i, j), Equal(self.i, self.j)),
                               (piecewise_ij, Less(self.i, self.j)),
                               (piecewise_ji, True))
 
         if return_reference:
             return Lamda[j:self.n](piecewise)
-        return piecewise
+        return piecewise            
 
     @_sympifyit('other', NotImplemented)
     @call_highest_priority('__rmatmul__')
     def __matmul__(self, other):
         if self.j == self.i:
             return other
```

### Comparing `sympy.keras-1.0.21/sympy/matrices/expressions/matmul.py` & `sympy.keras-1.0.4/sympy/matrices/expressions/matmul.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,10 +1,11 @@
 from sympy import Number
 from sympy.core import Mul, Basic, sympify
 
+from sympy.functions import adjoint
 from sympy.strategies import (rm_id, unpack, typed, flatten, exhaust,
         do_one, new)
 from sympy.matrices.expressions.matexpr import (MatrixExpr, ShapeError, Identity, ZeroMatrix)
 from sympy.matrices.expressions.blockmatrix import BlockMatrix
 from sympy.matrices.expressions.matpow import MatPow
 from sympy.matrices.matrices import MatrixBase
 from sympy.core.logic import fuzzy_and
@@ -15,15 +16,15 @@
     """
     A product of matrix expressions
 
     Examples
     ========
 
     >>> m = 2
-    >>> n = 2
+    >>> n = 2    
     >>> a = Symbol(real=True, shape=(m, n))
     >>> m1 = Matrix([[a[i, j] for j in range(n)] for i in range(m)])
     >>> m1
     >>> l = 2
     >>> b = Symbol(real=True, shape=(n, l))
     >>> m2 = Matrix([[b[i, j] for j in range(l)] for i in range(n)])
     >>> m2
@@ -43,22 +44,17 @@
 
         # This must be removed aggressively in the constructor
         args = list(map(sympify, args))
         
         if any(arg.is_MatMul for arg in args):
 
             def generator():
-                size = len(args)
-                for i, arg in enumerate(args):
+                for arg in args:
                     if arg.is_MatMul:
-                        if i + 1 < size and len(args[i + 1].shape) == 1 and len(arg.args[-1].shape) == 1 or i and len(args[i - 1].shape) == 1 and len(arg.args[0].shape) == 1:
-                            for t in reversed(arg.args):
-                                yield t.T
-                        else:
-                            yield from arg.args
+                        yield from arg.args
                     else:
                         yield arg
                         
             args = [*generator()]
             
         coeffs = []
         matrices = []
@@ -70,77 +66,60 @@
                     if mat.is_MatPow:
                         if last.base == mat.base:
                             matrices[-1] = last.func(last.base, last.exp + mat.exp)
                             return
                     elif last.base == mat: 
                         matrices[-1] = last.func(last.base, last.exp + 1)
                         return
-
                 elif last == mat:
                     if mat.is_square:
                         if mat._eval_inverse() == last:
                             matrices.pop()
                         else:
                             matrices[-1] = MatPow(last, 2)
                         return
-                    
-                elif len(last.shape) == 1 and len(mat.shape) > 1:
-                    if len(matrices) > 1:
-                        second_last = matrices[-2]
-                        if len(second_last.shape) > 1:
-                            matrices[-1], matrices[-2] = second_last.T, last
-                    
+            
             if mat.is_ZeroMatrix:
                 from sympy import S
                 coeffs.append(S.Zero)
             
-            if mat.is_MatMul:
-                args = mat.args
-                if matrices:
-                    if last.is_square and last.inverse() == args[0]:
-                        matrices.pop()
-                        args = args[1:]
-                matrices.extend(args) 
-            else:
-                matrices.append(mat)
+            matrices.append(mat)
                 
         for arg in args:
             if not arg.is_Mul:
                 append(arg)
                 continue
             
             coeff = []
             matrix = []
             for t in arg.args:
                 if t.shape:
-                    matrix.append(t)
+                    matrix.append(t)                        
                 else:
                     coeff.append(t)
             if coeff:
                 coeffs.append(Mul(*coeff))
                 append(Mul(*matrix))
             else:
                 append(arg)
                 
         if not matrices:
             return Identity(args[0].shape[-1])
         matrices = [*filter(lambda X: not X.is_Identity, matrices)]
                         
         if len(matrices) == 1:
             mat = matrices.pop()
-        elif not matrices:
-            return Identity(args[0].shape[-1])
-        
         else:
+            
             mat = Basic.__new__(cls, *matrices)
             factor, matrices = mat.as_coeff_matrices()
             if check:
                 validate(*matrices)
             if not matrices:
-                mat = factor
+                mat = factor            
         
         if coeffs: 
             mat = Mul(*coeffs) * mat
                         
         return mat
 
     def argmax_shape(self):
@@ -166,25 +145,25 @@
                     assert batch_size == _batch_size
                 else:
                     assert batch_size[:-len(_batch_size)] == _batch_size
                 return (*batch_size, n)                
         elif len_lhs_shape < len_rhs_shape:
             *_batch_size, k = lhs_shape
             * batch_size, _k, n = rhs_shape
-            assert k == _k
+            assert k == _k   
             if len(batch_size) == len(_batch_size):
                 assert batch_size == _batch_size, "%s, %s, batch_size mismatch!" % (lhs_shape, rhs_shape)
             else:
                 assert batch_size[:-len(_batch_size)] == _batch_size
             return (*batch_size, n)                
         else:
             if len_lhs_shape == 1:
                 assert lhs_shape == rhs_shape
                 return ()
-            * batch_size, n, k = lhs_shape
+            * batch_size, n, k = lhs_shape 
             * _batch_size, _k, m = rhs_shape
             assert k == _k, f"{lhs_shape}, {rhs_shape} are not compatible in matrix multiplication"
             assert batch_size == _batch_size
             return (*batch_size, n, m)
             
     @cacheit
     def _eval_shape(self):
@@ -225,15 +204,15 @@
             return MatMul(*args)[tuple(j, *rest)]
         
     def _entry(self, i, j=None, expand=True, **kwargs):
         if j is None:
             if len(self.args[0].shape) == 1:
                 return self.args[0] @ self.func(*self.args[1:])[:, i]
             rhs = self.func(*self.args[1:])
-            if len(rhs.shape) > 2:
+            if len(rhs.shape) == 3:
                 rhs = rhs[i]
             return self.args[0][i] @ rhs
         
         if len(self.shape) > 2:
             len_shape = self.max_len_shape()
             args = [*self.args]
             for t, arg in enumerate(args):
@@ -337,16 +316,15 @@
         return coeff, matrices
 
     def as_coeff_mmul(self):
         coeff, matrices = self.as_coeff_matrices()
         return coeff, MatMul(*matrices)
 
     def _eval_adjoint(self):
-        from sympy import Adjoint
-        return MatMul(*[Adjoint(arg) for arg in self.args[::-1]]).doit()
+        return MatMul(*[adjoint(arg) for arg in self.args[::-1]]).doit()
 
     def _eval_trace(self):
         factor, mmul = self.as_coeff_mmul()
         if factor != 1:
             from .trace import trace
             return factor * trace(mmul.doit())
         else:
@@ -545,15 +523,15 @@
         if A.is_Transpose:
             if B.is_Transpose:
                 return (B.arg @ A.arg).expand().T
         
         if B.is_BlockMatrix:
             if len(B.shape) == 2 and B.axis == 1:
                 return (B.T @ A.T).expand().T
-            return self
+            return self     
               
         if A.is_MatProduct:
             return self
         
         kwargs = {'var': var, 'generator': self}
         
         if len(A.shape) == 1 and len(B.shape) > 1 and B.shape[-1].is_Integer:
@@ -581,15 +559,16 @@
             return is_integer
         return True
 
     @property
     def domain(self):
         from sympy import Interval, oo, Range, CartesianSpace
         shape = self.shape
-        interval = self.dtype.universalSet
+        interval = (Range if self.is_integer else Interval)(-oo, oo)
+        
         if shape: 
             return CartesianSpace(interval, *shape)
         return interval
 
     def _sympystr(self, p):
         from sympy.core.mul import _keep_coeff
         from sympy.printing.precedence import precedence
@@ -643,62 +622,43 @@
     def _eval_is_extended_positive(self):
         return fuzzy_and(arg.is_extended_positive for arg in self.args)
 
     def _eval_is_extended_negative(self):
         return fuzzy_and(arg.is_extended_negative for arg in self.args)
 
     def _eval_is_finite(self):
-        if self._has_infinite_dimension():
-            return
         return fuzzy_and(arg.is_finite for arg in self.args)
 
     @classmethod
     def class_key(cls):
         return 3, 0, cls.__name__
     
-    @cacheit
-    def _has_infinite_dimension(self):
-        args = self.args
-        for i in range(len(args) - 1):
-            expr = args[i]
-            s = expr.shape[-1]
-            if not isinstance(s, int) and s.is_infinite:
-                return True
-        
     @property
     def dtype(self):
         dtype = None
         for arg in self.args:
             _dtype = arg.dtype
             if dtype is None or dtype in _dtype:
                 dtype = _dtype
-
-        if self._has_infinite_dimension():
-            return dtype.extended_type()
-
         return dtype
     
     @cacheit
     def _eval_domain_defined(self, x, **_):
         if x.dtype.is_set:
             return x.universalSet
         
         domain = x.domain
         for arg in self.args:
-            if any(s._has(x) for s in arg.shape):
-                kwargs = dict(allow_empty=True)
-            else:
-                kwargs = {}
-            domain &= arg.domain_defined(x, **kwargs)
+            domain &= arg.domain_defined(x)
         return domain
     
     def domain_definition(self):
         eq = MatrixExpr.domain_definition(self)
         for arg in self.args:
-            eq &= arg.domain_definition()
+            eq &= arg.domain_definition()        
         return eq
 
     def _eval_transpose(self, axis=-1):
         """Transposition of matrix multiplication.
 
         Notes
         =====
@@ -722,43 +682,25 @@
     def _subs(self, old, new, **hints):
         if old.is_MatMul:
             args = old.args
             from std.search import sunday
             i = sunday(self.args, args)
             if i >= 0:
                 return self.func(*self.args[:i] + (new.args if new.is_MatMul else (new,)) + self.args[i + len(args):]).simplify()
-            
-        [*args] = self.args
-        hit = False
-        for i, arg in enumerate(args):
-            try:
-                arg = arg._subs(old, new)
-                if self.args[i] != arg:
-                    args[i] = arg
-                    hit = True
-            except Exception as e:
-                if str(e) == 'empty slices':
-                    if any(s._has(old) for s in arg.shape):
-                        return ZeroMatrix(*self.shape)
-                
-                raise e
-        if hit:
-            return self.func(*args)
-        return self
+        return MatrixExpr._subs(self, old, new, **hints)
 
     def _eval_torch(self):
         from functools import reduce
         return reduce(lambda x, y: x @ y if len(y.shape) > 1 else (x @ y.unsqueeze(-1)).squeeze(-1), (arg.torch for arg in self.args))
     
-    
     @staticmethod
     def simplify_Lamda(self, squeeze=False):
         expr = self.expr
         var = self.limits[0]
-        *former, last = expr.args
+        *former, last = expr.args 
         if last._has(var) and not any(e._has(var) for e in former):
             last = self.func(last, var)
             _last = last.simplify()
             if last != _last:
                 if len(_last.shape) == 2:
                     _last = _last.T
                 independent = expr.func(*former, _last).simplify()
@@ -780,22 +722,15 @@
                 limits = self.limits[:-1]
                 if limits:
                     independent = self.func(independent, *limits)
                 return independent
 
         return self
         
-    @cacheit
-    def sort_key(self, order=None):
-        args = self._sorted_args
-        args = len(args), tuple(arg.class_key() for arg in args), tuple(arg.sort_key(order=order) for arg in args)
-        from sympy import S
-        return self.class_key(), args, S.One.sort_key(), S.One
-
-
+    
 def validate(*matrices):
     """ Checks for valid shapes for args of MatMul """
     for i in range(len(matrices) - 1):
         A, B = matrices[i:i + 2]
         if A.cols != B.rows:
             raise ShapeError("Matrices %s and %s are not aligned" % (A, B))
```

### Comparing `sympy.keras-1.0.21/sympy/matrices/expressions/matpow.py` & `sympy.keras-1.0.4/sympy/matrices/expressions/matpow.py`

 * *Files 2% similar despite different names*

```diff
@@ -10,28 +10,22 @@
     
     @property
     def is_Inverse(self):
         return self.exp is S.NegativeOne
     
     def __new__(cls, base, exp):
         base = _sympify(base)
-        assert base.is_square, str(base)
+        assert base.is_square, str(base)        
 #         if not base.is_Matrix:
 #             raise TypeError("Function parameter should be a matrix")
         exp = _sympify(exp)
-        
-        if base.is_MatPow:
-            base, e = base.args
-            exp *= e
-
         if exp.is_zero:
             return Identity(base.shape[-1])
         elif exp.is_One:
             return base
-        
         return super(MatPow, cls).__new__(cls, base, exp)
 
     @property
     def base(self):
         return self.args[0]
 
     @property
@@ -89,17 +83,14 @@
         elif isinstance(base, MatrixBase) and exp.is_number:
             if exp is S.One:
                 return base
             return base ** exp
         # Note: just evaluate cases we know, return unevaluated on others.
         # E.g., MatrixSymbol('x', n, m) to power 0 is not an error.
         elif exp is S(-1) and base.is_square:
-            if self.base is base:
-                return self
-
             return Inverse(base).doit(**kwargs)
         elif exp is S.One:
             return base
         return MatPow(base, exp)
 
     def _eval_transpose(self, axis=-1):
         if axis == self.default_axis:
@@ -142,29 +133,29 @@
             newexpr = MatMul.fromiter([self.base for i in range(exp)])
         elif (exp == -1) == True:
             arg = self.args[0]
             lines = arg._eval_derivative_matrix_lines(x)
             for line in lines:
                 line.first_pointer *= -self.T
                 line.second_pointer *= self
-            return lines
+            return lines            
 #             return Inverse(self.base)._eval_derivative_matrix_lines(x)
         elif (exp < 0) == True:
             newexpr = MatMul.fromiter([Inverse(self.base) for i in range(-exp)])
         elif (exp == 0) == True:
             return self.doit()._eval_derivative_matrix_lines(x)
         else:
             raise NotImplementedError("cannot evaluate %s derived by %s" % (self, x))
         return newexpr._eval_derivative_matrix_lines(x)
 
     def _eval_inverse(self):
         if self.exp is S.NegativeOne:
             return self.base
 
-    def _eval_determinant(self, **kwargs):
+    def _eval_determinant(self):
         from sympy.matrices.expressions.determinant import det
         return det(self.base) ** self.exp
 
     @property
     def dtype(self):
         return self.base.dtype
 
@@ -173,30 +164,20 @@
         PREC = precedence(self)
 #         deliberately to distinguish from x ** y which is element-wise power operator
         return '%s ^ %s' % (p.parenthesize(self.base, PREC, strict=False),
                          p.parenthesize(self.exp, PREC, strict=False))
 
     def _latex(self, p):
         base, exp = self.base, self.exp
-        if base.is_symbol or base.is_BlockMatrix:
-            return r"%s^{\color{magenta} %s}" % (p._print(base), p._print(exp))
+        if base.is_symbol:
+            return r"%s^{\left[%s\right]}" % (p._print(base), p._print(exp))            
         else:
-            return r"\left(%s\right)^{\color{magenta} %s}" % (p._print(base), p._print(exp))
+            return r"\left(%s\right)^{\left[%s\right]}" % (p._print(base), p._print(exp))
 
     def domain_definition(self):
         if self.exp.is_extended_negative:
             from sympy import Unequal
             base = self.base
             if base.is_singular == False:
                 return S.true
             return Unequal(base.det(), S.Zero)
-        return MatrixExpr.domain_definition(self)
-    
-    def _eval_is_singular(self):
-        exp = self.exp
-        if exp.is_Integer and exp < 0:
-            return False
-
-    def _eval_is_finite(self):
-        exp = self.exp
-        if exp.is_Integer and exp < 0:
-            return True
+        return MatrixExpr.domain_definition(self)
```

### Comparing `sympy.keras-1.0.21/sympy/matrices/expressions/minors.py` & `sympy.keras-1.0.4/sympy/matrices/expressions/minors.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/matrices/expressions/permutation.py` & `sympy.keras-1.0.4/sympy/matrices/expressions/permutation.py`

 * *Files 0% similar despite different names*

```diff
@@ -89,15 +89,15 @@
         return PermutationMatrix(self.args[0] ** exp).doit()
 
     def _eval_inverse(self):
         return PermutationMatrix(self.args[0] ** -1)
 
     _eval_transpose = _eval_adjoint = _eval_inverse
 
-    def _eval_determinant(self, **kwargs):
+    def _eval_determinant(self):
         sign = self.args[0].signature()
         if sign == 1:
             return S.One
         elif sign == -1:
             return S.NegativeOne
         raise NotImplementedError
```

### Comparing `sympy.keras-1.0.21/sympy/matrices/expressions/sets.py` & `sympy.keras-1.0.4/sympy/matrices/expressions/sets.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/matrices/expressions/slice.py` & `sympy.keras-1.0.4/sympy/matrices/expressions/slice.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-from sympy.matrices.expressions.matexpr import MatrixExpr
+from sympy.matrices.expressions.matexpr  import MatrixExpr
 from sympy import Tuple, Basic
 from sympy.functions.elementary.integers import floor
 from sympy.core.cache import cacheit
 
 def normalize(i, parentsize):
     if isinstance(i, slice):
         i = (i.start, i.stop, i.step)
```

### Comparing `sympy.keras-1.0.21/sympy/matrices/expressions/trace.py` & `sympy.keras-1.0.4/sympy/matrices/expressions/trace.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/matrices/expressions/transpose.py` & `sympy.keras-1.0.4/sympy/matrices/expressions/transpose.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,9 +1,9 @@
 from sympy import Basic
-from sympy.functions import conjugate
+from sympy.functions import adjoint, conjugate
 
 from sympy.matrices.expressions.matexpr import MatrixExpr
 from sympy.core.sympify import _sympify
 from sympy.core.cache import cacheit
 
 
 class Transpose(MatrixExpr):
@@ -53,16 +53,16 @@
                 
         if axis < 0:
             axis += len(arg.shape)
                 
         if kwargs.get('evaluate', True):
             transpose = arg._eval_transpose(axis=axis)
             if transpose is not None:
-                return transpose
-
+                return transpose            
+            
         obj = MatrixExpr.__new__(cls, arg, **kwargs)
         obj.axis = _sympify(axis)
         return obj
     
     def _sympystr(self, p):
         from sympy.printing.precedence import PRECEDENCE
         if self.axis == self.default_axis:
@@ -120,30 +120,21 @@
     def _entry(self, i, j=None, expand=False, **kwargs):
         if self.axis == self.default_axis:
             if j is None:
                 if len(self.shape) > 2:
                     return self.arg[i].T
                 
                 if isinstance(i, slice):
-                    size = self.shape[0]
-                    start, stop, step = i.start, i.stop, i.step
+                    start, stop = i.start, i.stop
                     if start is None:
-                        start = 0
-
-                    if stop is None:
-                        stop = self.shape[0]
-
-                    if step is None:
-                        step = 1
-                        
-                    if start == 0 and stop == size and step == 1:
-                        return self
-                    
-                    from sympy import Sliced, Tuple 
-                    return Sliced(self.arg, Tuple(None, None), Tuple(start, stop))
+                        if stop is None:
+                            return self
+                    from sympy.tensor.indexed import Sliced
+                    from sympy.core.containers import Tuple
+                    return Sliced(self.arg, Tuple(None, None), i)
                 return self.arg[:, i]
                         
             if hasattr(self.arg, '_entry'):
                 return self.arg._entry(j, i, expand=expand, **kwargs)
             
             if isinstance(i, slice):
                 if isinstance(j, slice): 
@@ -158,40 +149,39 @@
                     return self.arg[:, i]
             raise Exception('unimplemented')
 
     def _eval_adjoint(self):
         return conjugate(self.arg)
 
     def _eval_conjugate(self):
-        from sympy import Adjoint
-        return Adjoint(self.arg)
+        return adjoint(self.arg)
 
     def _eval_transpose(self, axis=-1):
         if axis == self.axis:
             return self.arg
 
     def _eval_trace(self):
         from .trace import Trace
         return Trace(self.arg)  # Trace(X.T) => Trace(X)
 
-    def _eval_determinant(self, **kwargs):
+    def _eval_determinant(self):
         from sympy.matrices.expressions.determinant import det
         return det(self.arg)
 
     def _eval_is_extended_real(self):
         return self.arg.is_extended_real
     
     def _eval_is_extended_positive(self):
         return self.arg.is_extended_positive
     
     def _eval_is_extended_negative(self):
         return self.arg.is_extended_negative
     
     def _eval_is_finite(self):
-        return self.arg.is_finite
+        return self.arg.is_finite    
 
     def _eval_derivative_matrix_lines(self, x):
         lines = self.args[0]._eval_derivative_matrix_lines(x)
         return [i.transpose() for i in lines]
 
     @classmethod
     def simplify_Equal(cls, self, lhs, rhs):
@@ -202,16 +192,14 @@
             return self.func(lhs.arg, rhs.arg)
 
     def simplify(self, **_):
         from sympy.core.function import Function
         from sympy.core.mul import Mul
         f = self.arg
         if isinstance(f, Function):
-            if len(f.shape) > 1:
-                return self
             return f.func(self.func(f.arg).simplify())
         if isinstance(f, Mul):
             if len(f.args[0].shape) == 0:
                 return f.func(f.args[0], self.func(f.func(*f.args[1:])).simplify())
 
         return self
 
@@ -232,15 +220,15 @@
                 return this.func(*this.args[:i] + (new.T,) + this.args[i + len(args):]).simplify().T
                 
         return MatrixExpr._subs(self, old, new, **hints)
 
     def __getitem__(self, key):
         if not isinstance(key, tuple) and isinstance(key, slice):
             return self._entry(key)
-        if isinstance(key, tuple):
+        if isinstance(key, tuple): 
             if len(key) == 1:
                 key = key[0]
             elif len(key) == 2:
                 i, j = key
                 if isinstance(i, slice):
                     if isinstance(j, slice):
                         return self._entry(i, j)
@@ -289,32 +277,14 @@
                     return MatrixExpr.of(self, cls)
                 else:
                     return self.args
 
     def _eval_torch(self):
         return self.arg.torch.transpose(self.axis - 1, self.axis)
     
-    @staticmethod
-    def expand_dims(self, shape, pivot):
-        consistent_shape = shape[:-pivot] 
-        extra_shape = shape[-pivot:]
-        consistent_shape_len = len(consistent_shape)
-#                   transpose matrix from (*consistent_shape, *extra_shape) to (*extra_shape, *consistent_shape)
-#                   (3, 4, 5, 6) => (5, 6, 3, 4)
-        axes = []
-        for j in range(len(extra_shape)):
-            for i in range(consistent_shape_len):
-                axes.append(consistent_shape_len + j - i)
-
-        if len(self.shape) < len(shape):
-            from sympy import OneMatrix
-            self *= OneMatrix(*consistent_shape, *extra_shape)
-
-        return Transpose[tuple(axes)](self)
-
         
 def transpose(expr):
     """Matrix transpose"""
     return Transpose(expr).doit(deep=False)
 
 
 from sympy.assumptions.ask import ask, Q
```

### Comparing `sympy.keras-1.0.21/sympy/matrices/graph.py` & `sympy.keras-1.0.4/sympy/matrices/graph.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/matrices/immutable.py` & `sympy.keras-1.0.4/sympy/matrices/immutable.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/matrices/inverse.py` & `sympy.keras-1.0.4/sympy/matrices/inverse.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/matrices/matrices.py` & `sympy.keras-1.0.4/sympy/matrices/matrices.py`

 * *Files 0% similar despite different names*

```diff
@@ -273,15 +273,15 @@
         # U factor in the LU decomposition.
         for k in range(lu.rows):
             det *= lu[k, k]
 
         # return det(P)*det(U)
         return det
 
-    def _eval_determinant(self, **kwargs):
+    def _eval_determinant(self):
         """Assumed to exist by matrix expressions; If we subclass
         MatrixDeterminant, we can fully evaluate determinants."""
         return self.det()
 
     def adjugate(self, method="berkowitz"):
         """Returns the adjugate, or classical adjoint, of
         a matrix.  That is, the transpose of the matrix of cofactors.
@@ -1205,15 +1205,15 @@
     def _diagonalize_clear_subproducts(self):
         del self._is_symbolic
         del self._is_symmetric
         del self._eigenvects
 
     def _format_str(self, printer=None):
         if not printer:
-            from sympy.printing.string import StrPrinter
+            from sympy.printing.str import StrPrinter
             printer = StrPrinter()
         # Handle zero dimensions:
         if self.rows == 0 or self.cols == 0:
             return 'Matrix(%s, %s, [])' % (self.rows, self.cols)
         if self.rows == 1:
             return "Matrix([%s])" % self.table(printer, rowsep=',\n')
         return "Matrix([\n%s])" % self.table(printer, rowsep=',\n')
@@ -1488,19 +1488,18 @@
             # Empty Matrix
             rows = cols = 0
             flat_list = []
         elif len(args) == 2:
             rows = 1
             cols = len(args)
             flat_list = args
-            
         if flat_list is None:
-            rows = 1
-            cols = len(args)
-            flat_list = args
+            raise TypeError(filldedent('''
+                Data type not understood; expecting list of lists
+                or lists of values.'''))
 
         return sympify(rows), sympify(cols), flat_list
 
     def _setitem(self, key, value):
         """Helper to set value at location given by key.
 
         Examples
@@ -3747,15 +3746,15 @@
 
         This is used by the string printer for Matrix.
 
         Examples
         ========
 
         >>> from sympy import Matrix
-        >>> from sympy.printing.string import StrPrinter
+        >>> from sympy.printing.str import StrPrinter
         >>> M = Matrix([[1, 2], [-33, 4]])
         >>> printer = StrPrinter()
         >>> M.table(printer)
         '[  1, 2]\n[-33, 4]'
         >>> print(M.table(printer))
         [  1, 2]
         [-33, 4]
```

### Comparing `sympy.keras-1.0.21/sympy/matrices/normalforms.py` & `sympy.keras-1.0.4/sympy/matrices/normalforms.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/matrices/reductions.py` & `sympy.keras-1.0.4/sympy/matrices/reductions.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/matrices/solvers.py` & `sympy.keras-1.0.4/sympy/matrices/solvers.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/matrices/sparse.py` & `sympy.keras-1.0.4/sympy/matrices/sparse.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/matrices/sparsetools.py` & `sympy.keras-1.0.4/sympy/matrices/sparsetools.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/matrices/subspaces.py` & `sympy.keras-1.0.4/sympy/matrices/subspaces.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/matrices/utilities.py` & `sympy.keras-1.0.4/sympy/matrices/utilities.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/multipledispatch/conflict.py` & `sympy.keras-1.0.4/sympy/multipledispatch/conflict.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/multipledispatch/core.py` & `sympy.keras-1.0.4/sympy/multipledispatch/core.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/multipledispatch/dispatcher.py` & `sympy.keras-1.0.4/sympy/multipledispatch/dispatcher.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/multipledispatch/utils.py` & `sympy.keras-1.0.4/sympy/multipledispatch/utils.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/ntheory/__init__.py` & `sympy.keras-1.0.4/sympy/ntheory/__init__.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/ntheory/bbp_pi.py` & `sympy.keras-1.0.4/sympy/ntheory/bbp_pi.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/ntheory/continued_fraction.py` & `sympy.keras-1.0.4/sympy/ntheory/continued_fraction.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/ntheory/digits.py` & `sympy.keras-1.0.4/sympy/ntheory/digits.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/ntheory/ecm.py` & `sympy.keras-1.0.4/sympy/ntheory/ecm.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/ntheory/egyptian_fraction.py` & `sympy.keras-1.0.4/sympy/ntheory/egyptian_fraction.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/ntheory/elliptic_curve.py` & `sympy.keras-1.0.4/sympy/ntheory/elliptic_curve.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/ntheory/factor_.py` & `sympy.keras-1.0.4/sympy/ntheory/factor_.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/ntheory/generate.py` & `sympy.keras-1.0.4/sympy/ntheory/generate.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/ntheory/modular.py` & `sympy.keras-1.0.4/sympy/ntheory/modular.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/ntheory/multinomial.py` & `sympy.keras-1.0.4/sympy/ntheory/multinomial.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/ntheory/partitions_.py` & `sympy.keras-1.0.4/sympy/ntheory/partitions_.py`

 * *Files 1% similar despite different names*

```diff
@@ -185,7 +185,9 @@
         if verbose:
             print("step", q, "of", M, to_str(a, 10), to_str(d, 10))
         # On average, the terms decrease rapidly in magnitude.
         # Dynamically reducing the precision greatly improves
         # performance.
         p = bitcount(abs(to_int(d))) + 50
     return int(to_int(mpf_add(s, fhalf, prec)))
+
+__all__ = ['npartitions']
```

### Comparing `sympy.keras-1.0.21/sympy/ntheory/primetest.py` & `sympy.keras-1.0.4/sympy/ntheory/primetest.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/ntheory/qs.py` & `sympy.keras-1.0.4/sympy/ntheory/qs.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/ntheory/residue_ntheory.py` & `sympy.keras-1.0.4/sympy/ntheory/residue_ntheory.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/parsing/ast_parser.py` & `sympy.keras-1.0.4/sympy/parsing/ast_parser.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/parsing/autolev/__init__.py` & `sympy.keras-1.0.4/sympy/parsing/autolev/__init__.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/parsing/autolev/_antlr/autolevlexer.py` & `sympy.keras-1.0.4/sympy/parsing/autolev/_antlr/autolevlexer.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/parsing/autolev/_antlr/autolevlistener.py` & `sympy.keras-1.0.4/sympy/parsing/autolev/_antlr/autolevlistener.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/parsing/autolev/_antlr/autolevparser.py` & `sympy.keras-1.0.4/sympy/parsing/autolev/_antlr/autolevparser.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/parsing/autolev/_build_autolev_antlr.py` & `sympy.keras-1.0.4/sympy/parsing/autolev/_build_autolev_antlr.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/parsing/autolev/_listener_autolev_antlr.py` & `sympy.keras-1.0.4/sympy/parsing/autolev/_listener_autolev_antlr.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/parsing/autolev/_parse_autolev_antlr.py` & `sympy.keras-1.0.4/sympy/parsing/autolev/_parse_autolev_antlr.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/parsing/c/c_parser.py` & `sympy.keras-1.0.4/sympy/parsing/c/c_parser.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/parsing/fortran/fortran_parser.py` & `sympy.keras-1.0.4/sympy/parsing/fortran/fortran_parser.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/parsing/latex/__init__.py` & `sympy.keras-1.0.4/sympy/parsing/latex/__init__.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/parsing/latex/_antlr/latexlexer.py` & `sympy.keras-1.0.4/sympy/parsing/latex/_antlr/latexlexer.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/parsing/latex/_antlr/latexparser.py` & `sympy.keras-1.0.4/sympy/parsing/latex/_antlr/latexparser.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/parsing/latex/_build_latex_antlr.py` & `sympy.keras-1.0.4/sympy/parsing/latex/_build_latex_antlr.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/parsing/latex/_parse_latex_antlr.py` & `sympy.keras-1.0.4/sympy/parsing/latex/_parse_latex_antlr.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,602 +1,602 @@
-# Ported from latex2sympy by @augustt198
-# https://github.com/augustt198/latex2sympy
-# See license in LICENSE.txt
-from importlib.metadata import version
-import sympy
-from sympy.external import import_module
-from sympy.printing.string import StrPrinter
-
-from .errors import LaTeXParsingError
-
-
-LaTeXParser = LaTeXLexer = MathErrorListener = None
-
-try:
-    LaTeXParser = import_module('sympy.parsing.latex._antlr.latexparser',
-                                import_kwargs={'fromlist': ['LaTeXParser']}).LaTeXParser
-    LaTeXLexer = import_module('sympy.parsing.latex._antlr.latexlexer',
-                               import_kwargs={'fromlist': ['LaTeXLexer']}).LaTeXLexer
-except Exception:
-    pass
-
-ErrorListener = import_module('antlr4.error.ErrorListener',
-                              warn_not_installed=True,
-                              import_kwargs={'fromlist': ['ErrorListener']}
-                              )
-
-
-
-if ErrorListener:
-    class MathErrorListener(ErrorListener.ErrorListener):  # type: ignore
-        def __init__(self, src):
-            super(ErrorListener.ErrorListener, self).__init__()
-            self.src = src
-
-        def syntaxError(self, recog, symbol, line, col, msg, e):
-            fmt = "%s\n%s\n%s"
-            marker = "~" * col + "^"
-
-            if msg.startswith("missing"):
-                err = fmt % (msg, self.src, marker)
-            elif msg.startswith("no viable"):
-                err = fmt % ("I expected something else here", self.src, marker)
-            elif msg.startswith("mismatched"):
-                names = LaTeXParser.literalNames
-                expected = [
-                    names[i] for i in e.getExpectedTokens() if i < len(names)
-                ]
-                if len(expected) < 10:
-                    expected = " ".join(expected)
-                    err = (fmt % ("I expected one of these: " + expected, self.src,
-                                  marker))
-                else:
-                    err = (fmt % ("I expected something else here", self.src,
-                                  marker))
-            else:
-                err = fmt % ("I don't understand this", self.src, marker)
-            raise LaTeXParsingError(err)
-
-
-def parse_latex(sympy):
-    antlr4 = import_module('antlr4')
-
-    if None in [antlr4, MathErrorListener] or \
-            version('antlr4-python3-runtime') != '4.10':
-        raise ImportError("LaTeX parsing requires the antlr4 Python package,"
-                          " provided by pip (antlr4-python3-runtime) or"
-                          " conda (antlr-python-runtime), version 4.10")
-
-    matherror = MathErrorListener(sympy)
-
-    stream = antlr4.InputStream(sympy)
-    lex = LaTeXLexer(stream)
-    lex.removeErrorListeners()
-    lex.addErrorListener(matherror)
-
-    tokens = antlr4.CommonTokenStream(lex)
-    parser = LaTeXParser(tokens)
-
-    # remove default console error listener
-    parser.removeErrorListeners()
-    parser.addErrorListener(matherror)
-
-    relation = parser.math().relation()
-    expr = convert_relation(relation)
-
-    return expr
-
-
-def convert_relation(rel):
-    if rel.expr():
-        return convert_expr(rel.expr())
-
-    lh = convert_relation(rel.relation(0))
-    rh = convert_relation(rel.relation(1))
-    if rel.LT():
-        return sympy.StrictLessThan(lh, rh)
-    elif rel.LTE():
-        return sympy.LessThan(lh, rh)
-    elif rel.GT():
-        return sympy.StrictGreaterThan(lh, rh)
-    elif rel.GTE():
-        return sympy.GreaterThan(lh, rh)
-    elif rel.EQUAL():
-        return sympy.Eq(lh, rh)
-    elif rel.NEQ():
-        return sympy.Ne(lh, rh)
-
-
-def convert_expr(expr):
-    return convert_add(expr.additive())
-
-
-def convert_add(add):
-    if add.ADD():
-        lh = convert_add(add.additive(0))
-        rh = convert_add(add.additive(1))
-        return sympy.Add(lh, rh, evaluate=False)
-    elif add.SUB():
-        lh = convert_add(add.additive(0))
-        rh = convert_add(add.additive(1))
-        return sympy.Add(lh, sympy.Mul(-1, rh, evaluate=False),
-                         evaluate=False)
-    else:
-        return convert_mp(add.mp())
-
-
-def convert_mp(mp):
-    if hasattr(mp, 'mp'):
-        mp_left = mp.mp(0)
-        mp_right = mp.mp(1)
-    else:
-        mp_left = mp.mp_nofunc(0)
-        mp_right = mp.mp_nofunc(1)
-
-    if mp.MUL() or mp.CMD_TIMES() or mp.CMD_CDOT():
-        lh = convert_mp(mp_left)
-        rh = convert_mp(mp_right)
-        return sympy.Mul(lh, rh, evaluate=False)
-    elif mp.DIV() or mp.CMD_DIV() or mp.COLON():
-        lh = convert_mp(mp_left)
-        rh = convert_mp(mp_right)
-        return sympy.Mul(lh, sympy.Pow(rh, -1, evaluate=False), evaluate=False)
-    else:
-        if hasattr(mp, 'unary'):
-            return convert_unary(mp.unary())
-        else:
-            return convert_unary(mp.unary_nofunc())
-
-
-def convert_unary(unary):
-    if hasattr(unary, 'unary'):
-        nested_unary = unary.unary()
-    else:
-        nested_unary = unary.unary_nofunc()
-    if hasattr(unary, 'postfix_nofunc'):
-        first = unary.postfix()
-        tail = unary.postfix_nofunc()
-        postfix = [first] + tail
-    else:
-        postfix = unary.postfix()
-
-    if unary.ADD():
-        return convert_unary(nested_unary)
-    elif unary.SUB():
-        numabs = convert_unary(nested_unary)
-        # Use Integer(-n) instead of Mul(-1, n)
-        return -numabs
-    elif postfix:
-        return convert_postfix_list(postfix)
-
-
-def convert_postfix_list(arr, i=0):
-    if i >= len(arr):
-        raise LaTeXParsingError("Index out of bounds")
-
-    res = convert_postfix(arr[i])
-    if isinstance(res, sympy.Expr):
-        if i == len(arr) - 1:
-            return res  # nothing to multiply by
-        else:
-            if i > 0:
-                left = convert_postfix(arr[i - 1])
-                right = convert_postfix(arr[i + 1])
-                if isinstance(left, sympy.Expr) and isinstance(
-                        right, sympy.Expr):
-                    left_syms = convert_postfix(arr[i - 1]).atoms(sympy.Symbol)
-                    right_syms = convert_postfix(arr[i + 1]).atoms(
-                        sympy.Symbol)
-                    # if the left and right sides contain no variables and the
-                    # symbol in between is 'x', treat as multiplication.
-                    if not (left_syms or right_syms) and str(res) == 'x':
-                        return convert_postfix_list(arr, i + 1)
-            # multiply by next
-            return sympy.Mul(
-                res, convert_postfix_list(arr, i + 1), evaluate=False)
-    else:  # must be derivative
-        wrt = res[0]
-        if i == len(arr) - 1:
-            raise LaTeXParsingError("Expected expression for derivative")
-        else:
-            expr = convert_postfix_list(arr, i + 1)
-            return sympy.Derivative(expr, wrt)
-
-
-def do_subs(expr, at):
-    if at.expr():
-        at_expr = convert_expr(at.expr())
-        syms = at_expr.atoms(sympy.Symbol)
-        if len(syms) == 0:
-            return expr
-        elif len(syms) > 0:
-            sym = next(iter(syms))
-            return expr.subs(sym, at_expr)
-    elif at.equality():
-        lh = convert_expr(at.equality().expr(0))
-        rh = convert_expr(at.equality().expr(1))
-        return expr.subs(lh, rh)
-
-
-def convert_postfix(postfix):
-    if hasattr(postfix, 'exp'):
-        exp_nested = postfix.exp()
-    else:
-        exp_nested = postfix.exp_nofunc()
-
-    exp = convert_exp(exp_nested)
-    for op in postfix.postfix_op():
-        if op.BANG():
-            if isinstance(exp, list):
-                raise LaTeXParsingError("Cannot apply postfix to derivative")
-            exp = sympy.factorial(exp, evaluate=False)
-        elif op.eval_at():
-            ev = op.eval_at()
-            at_b = None
-            at_a = None
-            if ev.eval_at_sup():
-                at_b = do_subs(exp, ev.eval_at_sup())
-            if ev.eval_at_sub():
-                at_a = do_subs(exp, ev.eval_at_sub())
-            if at_b is not None and at_a is not None:
-                exp = sympy.Add(at_b, -1 * at_a, evaluate=False)
-            elif at_b is not None:
-                exp = at_b
-            elif at_a is not None:
-                exp = at_a
-
-    return exp
-
-
-def convert_exp(exp):
-    if hasattr(exp, 'exp'):
-        exp_nested = exp.exp()
-    else:
-        exp_nested = exp.exp_nofunc()
-
-    if exp_nested:
-        base = convert_exp(exp_nested)
-        if isinstance(base, list):
-            raise LaTeXParsingError("Cannot raise derivative to power")
-        if exp.atom():
-            exponent = convert_atom(exp.atom())
-        elif exp.expr():
-            exponent = convert_expr(exp.expr())
-        return sympy.Pow(base, exponent, evaluate=False)
-    else:
-        if hasattr(exp, 'comp'):
-            return convert_comp(exp.comp())
-        else:
-            return convert_comp(exp.comp_nofunc())
-
-
-def convert_comp(comp):
-    if comp.group():
-        return convert_expr(comp.group().expr())
-    elif comp.abs_group():
-        return sympy.Abs(convert_expr(comp.abs_group().expr()), evaluate=False)
-    elif comp.atom():
-        return convert_atom(comp.atom())
-    elif comp.floor():
-        return convert_floor(comp.floor())
-    elif comp.ceil():
-        return convert_ceil(comp.ceil())
-    elif comp.func():
-        return convert_func(comp.func())
-
-
-def convert_atom(atom):
-    if atom.LETTER():
-        sname = atom.LETTER().getText()
-        if atom.subexpr():
-            if atom.subexpr().expr():  # subscript is expr
-                subscript = convert_expr(atom.subexpr().expr())
-            else:  # subscript is atom
-                subscript = convert_atom(atom.subexpr().atom())
-            sname += '_{' + StrPrinter().doprint(subscript) + '}'
-        if atom.SINGLE_QUOTES():
-            sname += atom.SINGLE_QUOTES().getText()  # put after subscript for easy identify
-        return sympy.Symbol(sname)
-    elif atom.SYMBOL():
-        s = atom.SYMBOL().getText()[1:]
-        if s == "infty":
-            return sympy.oo
-        else:
-            if atom.subexpr():
-                subscript = None
-                if atom.subexpr().expr():  # subscript is expr
-                    subscript = convert_expr(atom.subexpr().expr())
-                else:  # subscript is atom
-                    subscript = convert_atom(atom.subexpr().atom())
-                subscriptName = StrPrinter().doprint(subscript)
-                s += '_{' + subscriptName + '}'
-            return sympy.Symbol(s)
-    elif atom.number():
-        s = atom.number().getText().replace(",", "")
-        return sympy.Number(s)
-    elif atom.DIFFERENTIAL():
-        var = get_differential_var(atom.DIFFERENTIAL())
-        return sympy.Symbol('d' + var.name)
-    elif atom.mathit():
-        text = rule2text(atom.mathit().mathit_text())
-        return sympy.Symbol(text)
-    elif atom.frac():
-        return convert_frac(atom.frac())
-    elif atom.binom():
-        return convert_binom(atom.binom())
-    elif atom.bra():
-        val = convert_expr(atom.bra().expr())
-        from sympy.physics.quantum.state import Bra
-        return Bra(val)
-    elif atom.ket():
-        val = convert_expr(atom.ket().expr())
-        from sympy.physics.quantum.state import Ket
-        return Ket(val)
-
-
-def rule2text(ctx):
-    stream = ctx.start.getInputStream()
-    # starting index of starting token
-    startIdx = ctx.start.start
-    # stopping index of stopping token
-    stopIdx = ctx.stop.stop
-
-    return stream.getText(startIdx, stopIdx)
-
-
-def convert_frac(frac):
-    diff_op = False
-    partial_op = False
-    if frac.lower and frac.upper:
-        lower_itv = frac.lower.getSourceInterval()
-        lower_itv_len = lower_itv[1] - lower_itv[0] + 1
-        if (frac.lower.start == frac.lower.stop
-                and frac.lower.start.type == LaTeXLexer.DIFFERENTIAL):
-            wrt = get_differential_var_str(frac.lower.start.text)
-            diff_op = True
-        elif (lower_itv_len == 2 and frac.lower.start.type == LaTeXLexer.SYMBOL
-              and frac.lower.start.text == '\\partial'
-              and (frac.lower.stop.type == LaTeXLexer.LETTER
-                   or frac.lower.stop.type == LaTeXLexer.SYMBOL)):
-            partial_op = True
-            wrt = frac.lower.stop.text
-            if frac.lower.stop.type == LaTeXLexer.SYMBOL:
-                wrt = wrt[1:]
-
-        if diff_op or partial_op:
-            wrt = sympy.Symbol(wrt)
-            if (diff_op and frac.upper.start == frac.upper.stop
-                    and frac.upper.start.type == LaTeXLexer.LETTER
-                    and frac.upper.start.text == 'd'):
-                return [wrt]
-            elif (partial_op and frac.upper.start == frac.upper.stop
-                  and frac.upper.start.type == LaTeXLexer.SYMBOL
-                  and frac.upper.start.text == '\\partial'):
-                return [wrt]
-            upper_text = rule2text(frac.upper)
-
-            expr_top = None
-            if diff_op and upper_text.startswith('d'):
-                expr_top = parse_latex(upper_text[1:])
-            elif partial_op and frac.upper.start.text == '\\partial':
-                expr_top = parse_latex(upper_text[len('\\partial'):])
-            if expr_top:
-                return sympy.Derivative(expr_top, wrt)
-    if frac.upper:
-        expr_top = convert_expr(frac.upper)
-    else:
-        expr_top = sympy.Number(frac.upperd.text)
-    if frac.lower:
-        expr_bot = convert_expr(frac.lower)
-    else:
-        expr_bot = sympy.Number(frac.lowerd.text)
-    inverse_denom = sympy.Pow(expr_bot, -1, evaluate=False)
-    if expr_top == 1:
-        return inverse_denom
-    else:
-        return sympy.Mul(expr_top, inverse_denom, evaluate=False)
-
-def convert_binom(binom):
-    expr_n = convert_expr(binom.n)
-    expr_k = convert_expr(binom.k)
-    return sympy.binomial(expr_n, expr_k, evaluate=False)
-
-def convert_floor(floor):
-    val = convert_expr(floor.val)
-    return sympy.floor(val, evaluate=False)
-
-def convert_ceil(ceil):
-    val = convert_expr(ceil.val)
-    return sympy.ceiling(val, evaluate=False)
-
-def convert_func(func):
-    if func.func_normal():
-        if func.L_PAREN():  # function called with parenthesis
-            arg = convert_func_arg(func.func_arg())
-        else:
-            arg = convert_func_arg(func.func_arg_noparens())
-
-        name = func.func_normal().start.text[1:]
-
-        # change arc<trig> -> a<trig>
-        if name in [
-                "arcsin", "arccos", "arctan", "arccsc", "arcsec", "arccot"
-        ]:
-            name = "a" + name[3:]
-            expr = getattr(sympy.functions, name)(arg, evaluate=False)
-        if name in ["arsinh", "arcosh", "artanh"]:
-            name = "a" + name[2:]
-            expr = getattr(sympy.functions, name)(arg, evaluate=False)
-
-        if name == "exp":
-            expr = sympy.exp(arg, evaluate=False)
-
-        if name in ("log", "lg", "ln"):
-            if func.subexpr():
-                if func.subexpr().expr():
-                    base = convert_expr(func.subexpr().expr())
-                else:
-                    base = convert_atom(func.subexpr().atom())
-            elif name == "lg":  # ISO 80000-2:2019
-                base = 10
-            elif name in ("ln", "log"):  # SymPy's latex printer prints ln as log by default
-                base = sympy.E
-            expr = sympy.log(arg, base, evaluate=False)
-
-        func_pow = None
-        should_pow = True
-        if func.supexpr():
-            if func.supexpr().expr():
-                func_pow = convert_expr(func.supexpr().expr())
-            else:
-                func_pow = convert_atom(func.supexpr().atom())
-
-        if name in [
-                "sin", "cos", "tan", "csc", "sec", "cot", "sinh", "cosh",
-                "tanh"
-        ]:
-            if func_pow == -1:
-                name = "a" + name
-                should_pow = False
-            expr = getattr(sympy.functions, name)(arg, evaluate=False)
-
-        if func_pow and should_pow:
-            expr = sympy.Pow(expr, func_pow, evaluate=False)
-
-        return expr
-    elif func.LETTER() or func.SYMBOL():
-        if func.LETTER():
-            fname = func.LETTER().getText()
-        elif func.SYMBOL():
-            fname = func.SYMBOL().getText()[1:]
-        fname = str(fname)  # can't be unicode
-        if func.subexpr():
-            if func.subexpr().expr():  # subscript is expr
-                subscript = convert_expr(func.subexpr().expr())
-            else:  # subscript is atom
-                subscript = convert_atom(func.subexpr().atom())
-            subscriptName = StrPrinter().doprint(subscript)
-            fname += '_{' + subscriptName + '}'
-        if func.SINGLE_QUOTES():
-            fname += func.SINGLE_QUOTES().getText()
-        input_args = func.args()
-        output_args = []
-        while input_args.args():  # handle multiple arguments to function
-            output_args.append(convert_expr(input_args.expr()))
-            input_args = input_args.args()
-        output_args.append(convert_expr(input_args.expr()))
-        return sympy.Function(fname)(*output_args)
-    elif func.FUNC_INT():
-        return handle_integral(func)
-    elif func.FUNC_SQRT():
-        expr = convert_expr(func.base)
-        if func.root:
-            r = convert_expr(func.root)
-            return sympy.root(expr, r, evaluate=False)
-        else:
-            return sympy.sqrt(expr, evaluate=False)
-    elif func.FUNC_OVERLINE():
-        expr = convert_expr(func.base)
-        return sympy.conjugate(expr, evaluate=False)
-    elif func.FUNC_SUM():
-        return handle_sum_or_prod(func, "summation")
-    elif func.FUNC_PROD():
-        return handle_sum_or_prod(func, "product")
-    elif func.FUNC_LIM():
-        return handle_limit(func)
-
-
-def convert_func_arg(arg):
-    if hasattr(arg, 'expr'):
-        return convert_expr(arg.expr())
-    else:
-        return convert_mp(arg.mp_nofunc())
-
-
-def handle_integral(func):
-    if func.additive():
-        integrand = convert_add(func.additive())
-    elif func.frac():
-        integrand = convert_frac(func.frac())
-    else:
-        integrand = 1
-
-    int_var = None
-    if func.DIFFERENTIAL():
-        int_var = get_differential_var(func.DIFFERENTIAL())
-    else:
-        for sym in integrand.atoms(sympy.Symbol):
-            s = str(sym)
-            if len(s) > 1 and s[0] == 'd':
-                if s[1] == '\\':
-                    int_var = sympy.Symbol(s[2:])
-                else:
-                    int_var = sympy.Symbol(s[1:])
-                int_sym = sym
-        if int_var:
-            integrand = integrand.subs(int_sym, 1)
-        else:
-            # Assume dx by default
-            int_var = sympy.Symbol('x')
-
-    if func.subexpr():
-        if func.subexpr().atom():
-            lower = convert_atom(func.subexpr().atom())
-        else:
-            lower = convert_expr(func.subexpr().expr())
-        if func.supexpr().atom():
-            upper = convert_atom(func.supexpr().atom())
-        else:
-            upper = convert_expr(func.supexpr().expr())
-        return sympy.Integral(integrand, (int_var, lower, upper))
-    else:
-        return sympy.Integral(integrand, int_var)
-
-
-def handle_sum_or_prod(func, name):
-    val = convert_mp(func.mp())
-    iter_var = convert_expr(func.subeq().equality().expr(0))
-    start = convert_expr(func.subeq().equality().expr(1))
-    if func.supexpr().expr():  # ^{expr}
-        end = convert_expr(func.supexpr().expr())
-    else:  # ^atom
-        end = convert_atom(func.supexpr().atom())
-
-    if name == "summation":
-        return sympy.Sum(val, (iter_var, start, end))
-    elif name == "product":
-        return sympy.Product(val, (iter_var, start, end))
-
-
-def handle_limit(func):
-    sub = func.limit_sub()
-    if sub.LETTER():
-        var = sympy.Symbol(sub.LETTER().getText())
-    elif sub.SYMBOL():
-        var = sympy.Symbol(sub.SYMBOL().getText()[1:])
-    else:
-        var = sympy.Symbol('x')
-    if sub.SUB():
-        direction = "-"
-    else:
-        direction = "+"
-    approaching = convert_expr(sub.expr())
-    content = convert_mp(func.mp())
-
-    return sympy.Limit(content, var, approaching, direction)
-
-
-def get_differential_var(d):
-    text = get_differential_var_str(d.getText())
-    return sympy.Symbol(text)
-
-
-def get_differential_var_str(text):
-    for i in range(1, len(text)):
-        c = text[i]
-        if not (c == " " or c == "\r" or c == "\n" or c == "\t"):
-            idx = i
-            break
-    text = text[idx:]
-    if text[0] == "\\":
-        text = text[1:]
-    return text
+# Ported from latex2sympy by @augustt198
+# https://github.com/augustt198/latex2sympy
+# See license in LICENSE.txt
+from importlib.metadata import version
+import sympy
+from sympy.external import import_module
+from sympy.printing.str import StrPrinter
+
+from .errors import LaTeXParsingError
+
+
+LaTeXParser = LaTeXLexer = MathErrorListener = None
+
+try:
+    LaTeXParser = import_module('sympy.parsing.latex._antlr.latexparser',
+                                import_kwargs={'fromlist': ['LaTeXParser']}).LaTeXParser
+    LaTeXLexer = import_module('sympy.parsing.latex._antlr.latexlexer',
+                               import_kwargs={'fromlist': ['LaTeXLexer']}).LaTeXLexer
+except Exception:
+    pass
+
+ErrorListener = import_module('antlr4.error.ErrorListener',
+                              warn_not_installed=True,
+                              import_kwargs={'fromlist': ['ErrorListener']}
+                              )
+
+
+
+if ErrorListener:
+    class MathErrorListener(ErrorListener.ErrorListener):  # type: ignore
+        def __init__(self, src):
+            super(ErrorListener.ErrorListener, self).__init__()
+            self.src = src
+
+        def syntaxError(self, recog, symbol, line, col, msg, e):
+            fmt = "%s\n%s\n%s"
+            marker = "~" * col + "^"
+
+            if msg.startswith("missing"):
+                err = fmt % (msg, self.src, marker)
+            elif msg.startswith("no viable"):
+                err = fmt % ("I expected something else here", self.src, marker)
+            elif msg.startswith("mismatched"):
+                names = LaTeXParser.literalNames
+                expected = [
+                    names[i] for i in e.getExpectedTokens() if i < len(names)
+                ]
+                if len(expected) < 10:
+                    expected = " ".join(expected)
+                    err = (fmt % ("I expected one of these: " + expected, self.src,
+                                  marker))
+                else:
+                    err = (fmt % ("I expected something else here", self.src,
+                                  marker))
+            else:
+                err = fmt % ("I don't understand this", self.src, marker)
+            raise LaTeXParsingError(err)
+
+
+def parse_latex(sympy):
+    antlr4 = import_module('antlr4')
+
+    if None in [antlr4, MathErrorListener] or \
+            version('antlr4-python3-runtime') != '4.10':
+        raise ImportError("LaTeX parsing requires the antlr4 Python package,"
+                          " provided by pip (antlr4-python3-runtime) or"
+                          " conda (antlr-python-runtime), version 4.10")
+
+    matherror = MathErrorListener(sympy)
+
+    stream = antlr4.InputStream(sympy)
+    lex = LaTeXLexer(stream)
+    lex.removeErrorListeners()
+    lex.addErrorListener(matherror)
+
+    tokens = antlr4.CommonTokenStream(lex)
+    parser = LaTeXParser(tokens)
+
+    # remove default console error listener
+    parser.removeErrorListeners()
+    parser.addErrorListener(matherror)
+
+    relation = parser.math().relation()
+    expr = convert_relation(relation)
+
+    return expr
+
+
+def convert_relation(rel):
+    if rel.expr():
+        return convert_expr(rel.expr())
+
+    lh = convert_relation(rel.relation(0))
+    rh = convert_relation(rel.relation(1))
+    if rel.LT():
+        return sympy.StrictLessThan(lh, rh)
+    elif rel.LTE():
+        return sympy.LessThan(lh, rh)
+    elif rel.GT():
+        return sympy.StrictGreaterThan(lh, rh)
+    elif rel.GTE():
+        return sympy.GreaterThan(lh, rh)
+    elif rel.EQUAL():
+        return sympy.Eq(lh, rh)
+    elif rel.NEQ():
+        return sympy.Ne(lh, rh)
+
+
+def convert_expr(expr):
+    return convert_add(expr.additive())
+
+
+def convert_add(add):
+    if add.ADD():
+        lh = convert_add(add.additive(0))
+        rh = convert_add(add.additive(1))
+        return sympy.Add(lh, rh, evaluate=False)
+    elif add.SUB():
+        lh = convert_add(add.additive(0))
+        rh = convert_add(add.additive(1))
+        return sympy.Add(lh, sympy.Mul(-1, rh, evaluate=False),
+                         evaluate=False)
+    else:
+        return convert_mp(add.mp())
+
+
+def convert_mp(mp):
+    if hasattr(mp, 'mp'):
+        mp_left = mp.mp(0)
+        mp_right = mp.mp(1)
+    else:
+        mp_left = mp.mp_nofunc(0)
+        mp_right = mp.mp_nofunc(1)
+
+    if mp.MUL() or mp.CMD_TIMES() or mp.CMD_CDOT():
+        lh = convert_mp(mp_left)
+        rh = convert_mp(mp_right)
+        return sympy.Mul(lh, rh, evaluate=False)
+    elif mp.DIV() or mp.CMD_DIV() or mp.COLON():
+        lh = convert_mp(mp_left)
+        rh = convert_mp(mp_right)
+        return sympy.Mul(lh, sympy.Pow(rh, -1, evaluate=False), evaluate=False)
+    else:
+        if hasattr(mp, 'unary'):
+            return convert_unary(mp.unary())
+        else:
+            return convert_unary(mp.unary_nofunc())
+
+
+def convert_unary(unary):
+    if hasattr(unary, 'unary'):
+        nested_unary = unary.unary()
+    else:
+        nested_unary = unary.unary_nofunc()
+    if hasattr(unary, 'postfix_nofunc'):
+        first = unary.postfix()
+        tail = unary.postfix_nofunc()
+        postfix = [first] + tail
+    else:
+        postfix = unary.postfix()
+
+    if unary.ADD():
+        return convert_unary(nested_unary)
+    elif unary.SUB():
+        numabs = convert_unary(nested_unary)
+        # Use Integer(-n) instead of Mul(-1, n)
+        return -numabs
+    elif postfix:
+        return convert_postfix_list(postfix)
+
+
+def convert_postfix_list(arr, i=0):
+    if i >= len(arr):
+        raise LaTeXParsingError("Index out of bounds")
+
+    res = convert_postfix(arr[i])
+    if isinstance(res, sympy.Expr):
+        if i == len(arr) - 1:
+            return res  # nothing to multiply by
+        else:
+            if i > 0:
+                left = convert_postfix(arr[i - 1])
+                right = convert_postfix(arr[i + 1])
+                if isinstance(left, sympy.Expr) and isinstance(
+                        right, sympy.Expr):
+                    left_syms = convert_postfix(arr[i - 1]).atoms(sympy.Symbol)
+                    right_syms = convert_postfix(arr[i + 1]).atoms(
+                        sympy.Symbol)
+                    # if the left and right sides contain no variables and the
+                    # symbol in between is 'x', treat as multiplication.
+                    if not (left_syms or right_syms) and str(res) == 'x':
+                        return convert_postfix_list(arr, i + 1)
+            # multiply by next
+            return sympy.Mul(
+                res, convert_postfix_list(arr, i + 1), evaluate=False)
+    else:  # must be derivative
+        wrt = res[0]
+        if i == len(arr) - 1:
+            raise LaTeXParsingError("Expected expression for derivative")
+        else:
+            expr = convert_postfix_list(arr, i + 1)
+            return sympy.Derivative(expr, wrt)
+
+
+def do_subs(expr, at):
+    if at.expr():
+        at_expr = convert_expr(at.expr())
+        syms = at_expr.atoms(sympy.Symbol)
+        if len(syms) == 0:
+            return expr
+        elif len(syms) > 0:
+            sym = next(iter(syms))
+            return expr.subs(sym, at_expr)
+    elif at.equality():
+        lh = convert_expr(at.equality().expr(0))
+        rh = convert_expr(at.equality().expr(1))
+        return expr.subs(lh, rh)
+
+
+def convert_postfix(postfix):
+    if hasattr(postfix, 'exp'):
+        exp_nested = postfix.exp()
+    else:
+        exp_nested = postfix.exp_nofunc()
+
+    exp = convert_exp(exp_nested)
+    for op in postfix.postfix_op():
+        if op.BANG():
+            if isinstance(exp, list):
+                raise LaTeXParsingError("Cannot apply postfix to derivative")
+            exp = sympy.factorial(exp, evaluate=False)
+        elif op.eval_at():
+            ev = op.eval_at()
+            at_b = None
+            at_a = None
+            if ev.eval_at_sup():
+                at_b = do_subs(exp, ev.eval_at_sup())
+            if ev.eval_at_sub():
+                at_a = do_subs(exp, ev.eval_at_sub())
+            if at_b is not None and at_a is not None:
+                exp = sympy.Add(at_b, -1 * at_a, evaluate=False)
+            elif at_b is not None:
+                exp = at_b
+            elif at_a is not None:
+                exp = at_a
+
+    return exp
+
+
+def convert_exp(exp):
+    if hasattr(exp, 'exp'):
+        exp_nested = exp.exp()
+    else:
+        exp_nested = exp.exp_nofunc()
+
+    if exp_nested:
+        base = convert_exp(exp_nested)
+        if isinstance(base, list):
+            raise LaTeXParsingError("Cannot raise derivative to power")
+        if exp.atom():
+            exponent = convert_atom(exp.atom())
+        elif exp.expr():
+            exponent = convert_expr(exp.expr())
+        return sympy.Pow(base, exponent, evaluate=False)
+    else:
+        if hasattr(exp, 'comp'):
+            return convert_comp(exp.comp())
+        else:
+            return convert_comp(exp.comp_nofunc())
+
+
+def convert_comp(comp):
+    if comp.group():
+        return convert_expr(comp.group().expr())
+    elif comp.abs_group():
+        return sympy.Abs(convert_expr(comp.abs_group().expr()), evaluate=False)
+    elif comp.atom():
+        return convert_atom(comp.atom())
+    elif comp.floor():
+        return convert_floor(comp.floor())
+    elif comp.ceil():
+        return convert_ceil(comp.ceil())
+    elif comp.func():
+        return convert_func(comp.func())
+
+
+def convert_atom(atom):
+    if atom.LETTER():
+        sname = atom.LETTER().getText()
+        if atom.subexpr():
+            if atom.subexpr().expr():  # subscript is expr
+                subscript = convert_expr(atom.subexpr().expr())
+            else:  # subscript is atom
+                subscript = convert_atom(atom.subexpr().atom())
+            sname += '_{' + StrPrinter().doprint(subscript) + '}'
+        if atom.SINGLE_QUOTES():
+            sname += atom.SINGLE_QUOTES().getText()  # put after subscript for easy identify
+        return sympy.Symbol(sname)
+    elif atom.SYMBOL():
+        s = atom.SYMBOL().getText()[1:]
+        if s == "infty":
+            return sympy.oo
+        else:
+            if atom.subexpr():
+                subscript = None
+                if atom.subexpr().expr():  # subscript is expr
+                    subscript = convert_expr(atom.subexpr().expr())
+                else:  # subscript is atom
+                    subscript = convert_atom(atom.subexpr().atom())
+                subscriptName = StrPrinter().doprint(subscript)
+                s += '_{' + subscriptName + '}'
+            return sympy.Symbol(s)
+    elif atom.number():
+        s = atom.number().getText().replace(",", "")
+        return sympy.Number(s)
+    elif atom.DIFFERENTIAL():
+        var = get_differential_var(atom.DIFFERENTIAL())
+        return sympy.Symbol('d' + var.name)
+    elif atom.mathit():
+        text = rule2text(atom.mathit().mathit_text())
+        return sympy.Symbol(text)
+    elif atom.frac():
+        return convert_frac(atom.frac())
+    elif atom.binom():
+        return convert_binom(atom.binom())
+    elif atom.bra():
+        val = convert_expr(atom.bra().expr())
+        from sympy.physics.quantum.state import Bra
+        return Bra(val)
+    elif atom.ket():
+        val = convert_expr(atom.ket().expr())
+        from sympy.physics.quantum.state import Ket
+        return Ket(val)
+
+
+def rule2text(ctx):
+    stream = ctx.start.getInputStream()
+    # starting index of starting token
+    startIdx = ctx.start.start
+    # stopping index of stopping token
+    stopIdx = ctx.stop.stop
+
+    return stream.getText(startIdx, stopIdx)
+
+
+def convert_frac(frac):
+    diff_op = False
+    partial_op = False
+    if frac.lower and frac.upper:
+        lower_itv = frac.lower.getSourceInterval()
+        lower_itv_len = lower_itv[1] - lower_itv[0] + 1
+        if (frac.lower.start == frac.lower.stop
+                and frac.lower.start.type == LaTeXLexer.DIFFERENTIAL):
+            wrt = get_differential_var_str(frac.lower.start.text)
+            diff_op = True
+        elif (lower_itv_len == 2 and frac.lower.start.type == LaTeXLexer.SYMBOL
+              and frac.lower.start.text == '\\partial'
+              and (frac.lower.stop.type == LaTeXLexer.LETTER
+                   or frac.lower.stop.type == LaTeXLexer.SYMBOL)):
+            partial_op = True
+            wrt = frac.lower.stop.text
+            if frac.lower.stop.type == LaTeXLexer.SYMBOL:
+                wrt = wrt[1:]
+
+        if diff_op or partial_op:
+            wrt = sympy.Symbol(wrt)
+            if (diff_op and frac.upper.start == frac.upper.stop
+                    and frac.upper.start.type == LaTeXLexer.LETTER
+                    and frac.upper.start.text == 'd'):
+                return [wrt]
+            elif (partial_op and frac.upper.start == frac.upper.stop
+                  and frac.upper.start.type == LaTeXLexer.SYMBOL
+                  and frac.upper.start.text == '\\partial'):
+                return [wrt]
+            upper_text = rule2text(frac.upper)
+
+            expr_top = None
+            if diff_op and upper_text.startswith('d'):
+                expr_top = parse_latex(upper_text[1:])
+            elif partial_op and frac.upper.start.text == '\\partial':
+                expr_top = parse_latex(upper_text[len('\\partial'):])
+            if expr_top:
+                return sympy.Derivative(expr_top, wrt)
+    if frac.upper:
+        expr_top = convert_expr(frac.upper)
+    else:
+        expr_top = sympy.Number(frac.upperd.text)
+    if frac.lower:
+        expr_bot = convert_expr(frac.lower)
+    else:
+        expr_bot = sympy.Number(frac.lowerd.text)
+    inverse_denom = sympy.Pow(expr_bot, -1, evaluate=False)
+    if expr_top == 1:
+        return inverse_denom
+    else:
+        return sympy.Mul(expr_top, inverse_denom, evaluate=False)
+
+def convert_binom(binom):
+    expr_n = convert_expr(binom.n)
+    expr_k = convert_expr(binom.k)
+    return sympy.binomial(expr_n, expr_k, evaluate=False)
+
+def convert_floor(floor):
+    val = convert_expr(floor.val)
+    return sympy.floor(val, evaluate=False)
+
+def convert_ceil(ceil):
+    val = convert_expr(ceil.val)
+    return sympy.ceiling(val, evaluate=False)
+
+def convert_func(func):
+    if func.func_normal():
+        if func.L_PAREN():  # function called with parenthesis
+            arg = convert_func_arg(func.func_arg())
+        else:
+            arg = convert_func_arg(func.func_arg_noparens())
+
+        name = func.func_normal().start.text[1:]
+
+        # change arc<trig> -> a<trig>
+        if name in [
+                "arcsin", "arccos", "arctan", "arccsc", "arcsec", "arccot"
+        ]:
+            name = "a" + name[3:]
+            expr = getattr(sympy.functions, name)(arg, evaluate=False)
+        if name in ["arsinh", "arcosh", "artanh"]:
+            name = "a" + name[2:]
+            expr = getattr(sympy.functions, name)(arg, evaluate=False)
+
+        if name == "exp":
+            expr = sympy.exp(arg, evaluate=False)
+
+        if name in ("log", "lg", "ln"):
+            if func.subexpr():
+                if func.subexpr().expr():
+                    base = convert_expr(func.subexpr().expr())
+                else:
+                    base = convert_atom(func.subexpr().atom())
+            elif name == "lg":  # ISO 80000-2:2019
+                base = 10
+            elif name in ("ln", "log"):  # SymPy's latex printer prints ln as log by default
+                base = sympy.E
+            expr = sympy.log(arg, base, evaluate=False)
+
+        func_pow = None
+        should_pow = True
+        if func.supexpr():
+            if func.supexpr().expr():
+                func_pow = convert_expr(func.supexpr().expr())
+            else:
+                func_pow = convert_atom(func.supexpr().atom())
+
+        if name in [
+                "sin", "cos", "tan", "csc", "sec", "cot", "sinh", "cosh",
+                "tanh"
+        ]:
+            if func_pow == -1:
+                name = "a" + name
+                should_pow = False
+            expr = getattr(sympy.functions, name)(arg, evaluate=False)
+
+        if func_pow and should_pow:
+            expr = sympy.Pow(expr, func_pow, evaluate=False)
+
+        return expr
+    elif func.LETTER() or func.SYMBOL():
+        if func.LETTER():
+            fname = func.LETTER().getText()
+        elif func.SYMBOL():
+            fname = func.SYMBOL().getText()[1:]
+        fname = str(fname)  # can't be unicode
+        if func.subexpr():
+            if func.subexpr().expr():  # subscript is expr
+                subscript = convert_expr(func.subexpr().expr())
+            else:  # subscript is atom
+                subscript = convert_atom(func.subexpr().atom())
+            subscriptName = StrPrinter().doprint(subscript)
+            fname += '_{' + subscriptName + '}'
+        if func.SINGLE_QUOTES():
+            fname += func.SINGLE_QUOTES().getText()
+        input_args = func.args()
+        output_args = []
+        while input_args.args():  # handle multiple arguments to function
+            output_args.append(convert_expr(input_args.expr()))
+            input_args = input_args.args()
+        output_args.append(convert_expr(input_args.expr()))
+        return sympy.Function(fname)(*output_args)
+    elif func.FUNC_INT():
+        return handle_integral(func)
+    elif func.FUNC_SQRT():
+        expr = convert_expr(func.base)
+        if func.root:
+            r = convert_expr(func.root)
+            return sympy.root(expr, r, evaluate=False)
+        else:
+            return sympy.sqrt(expr, evaluate=False)
+    elif func.FUNC_OVERLINE():
+        expr = convert_expr(func.base)
+        return sympy.conjugate(expr, evaluate=False)
+    elif func.FUNC_SUM():
+        return handle_sum_or_prod(func, "summation")
+    elif func.FUNC_PROD():
+        return handle_sum_or_prod(func, "product")
+    elif func.FUNC_LIM():
+        return handle_limit(func)
+
+
+def convert_func_arg(arg):
+    if hasattr(arg, 'expr'):
+        return convert_expr(arg.expr())
+    else:
+        return convert_mp(arg.mp_nofunc())
+
+
+def handle_integral(func):
+    if func.additive():
+        integrand = convert_add(func.additive())
+    elif func.frac():
+        integrand = convert_frac(func.frac())
+    else:
+        integrand = 1
+
+    int_var = None
+    if func.DIFFERENTIAL():
+        int_var = get_differential_var(func.DIFFERENTIAL())
+    else:
+        for sym in integrand.atoms(sympy.Symbol):
+            s = str(sym)
+            if len(s) > 1 and s[0] == 'd':
+                if s[1] == '\\':
+                    int_var = sympy.Symbol(s[2:])
+                else:
+                    int_var = sympy.Symbol(s[1:])
+                int_sym = sym
+        if int_var:
+            integrand = integrand.subs(int_sym, 1)
+        else:
+            # Assume dx by default
+            int_var = sympy.Symbol('x')
+
+    if func.subexpr():
+        if func.subexpr().atom():
+            lower = convert_atom(func.subexpr().atom())
+        else:
+            lower = convert_expr(func.subexpr().expr())
+        if func.supexpr().atom():
+            upper = convert_atom(func.supexpr().atom())
+        else:
+            upper = convert_expr(func.supexpr().expr())
+        return sympy.Integral(integrand, (int_var, lower, upper))
+    else:
+        return sympy.Integral(integrand, int_var)
+
+
+def handle_sum_or_prod(func, name):
+    val = convert_mp(func.mp())
+    iter_var = convert_expr(func.subeq().equality().expr(0))
+    start = convert_expr(func.subeq().equality().expr(1))
+    if func.supexpr().expr():  # ^{expr}
+        end = convert_expr(func.supexpr().expr())
+    else:  # ^atom
+        end = convert_atom(func.supexpr().atom())
+
+    if name == "summation":
+        return sympy.Sum(val, (iter_var, start, end))
+    elif name == "product":
+        return sympy.Product(val, (iter_var, start, end))
+
+
+def handle_limit(func):
+    sub = func.limit_sub()
+    if sub.LETTER():
+        var = sympy.Symbol(sub.LETTER().getText())
+    elif sub.SYMBOL():
+        var = sympy.Symbol(sub.SYMBOL().getText()[1:])
+    else:
+        var = sympy.Symbol('x')
+    if sub.SUB():
+        direction = "-"
+    else:
+        direction = "+"
+    approaching = convert_expr(sub.expr())
+    content = convert_mp(func.mp())
+
+    return sympy.Limit(content, var, approaching, direction)
+
+
+def get_differential_var(d):
+    text = get_differential_var_str(d.getText())
+    return sympy.Symbol(text)
+
+
+def get_differential_var_str(text):
+    for i in range(1, len(text)):
+        c = text[i]
+        if not (c == " " or c == "\r" or c == "\n" or c == "\t"):
+            idx = i
+            break
+    text = text[idx:]
+    if text[0] == "\\":
+        text = text[1:]
+    return text
```

### Comparing `sympy.keras-1.0.21/sympy/parsing/mathematica.py` & `sympy.keras-1.0.4/sympy/parsing/mathematica.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/parsing/maxima.py` & `sympy.keras-1.0.4/sympy/parsing/maxima.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/parsing/sym_expr.py` & `sympy.keras-1.0.4/sympy/parsing/sym_expr.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/parsing/sympy_parser.py` & `sympy.keras-1.0.4/sympy/parsing/sympy_parser.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/physics/continuum_mechanics/beam.py` & `sympy.keras-1.0.4/sympy/physics/continuum_mechanics/beam.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/physics/control/lti.py` & `sympy.keras-1.0.4/sympy/physics/control/lti.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,12 +1,14 @@
 from sympy import Basic, Mul, degree, Symbol, expand, cancel, Expr, exp
 from sympy.core.evalf import EvalfMixin
 from sympy.core.numbers import Integer
 from sympy.core.sympify import sympify, _sympify
 
+__all__ = ['TransferFunction', 'Series', 'Parallel', 'Feedback']
+
 
 class TransferFunction(Basic, EvalfMixin):
     """
     A class for representing LTI (Linear, time-invariant) systems that can be strictly described
     by ratio of polynomials in the Laplace Transform complex variable. The arguments
     are ``num``, ``den``, and ``var``, where ``num`` and ``den`` are numerator and
     denominator polynomials of the ``TransferFunction`` respectively, and the third argument is
```

### Comparing `sympy.keras-1.0.21/sympy/physics/gaussopt.py` & `sympy.keras-1.0.4/sympy/physics/gaussopt.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/physics/hep/gamma_matrices.py` & `sympy.keras-1.0.4/sympy/physics/hep/gamma_matrices.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/physics/hydrogen.py` & `sympy.keras-1.0.4/sympy/physics/hydrogen.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/physics/matrices.py` & `sympy.keras-1.0.4/sympy/physics/matrices.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/physics/mechanics/body.py` & `sympy.keras-1.0.4/sympy/physics/mechanics/body.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,12 +1,14 @@
 from sympy.core.backend import Symbol
 from sympy.physics.mechanics import (RigidBody, Particle, ReferenceFrame,
                                      inertia)
 from sympy.physics.vector import Point, Vector
 
+__all__ = ['Body']
+
 
 class Body(RigidBody, Particle):
     """
     Body is a common representation of either a RigidBody or a Particle SymPy
     object depending on what is passed in during initialization. If a mass is
     passed in and central_inertia is left as None, the Particle object is
     created. Otherwise a RigidBody object will be created.
```

### Comparing `sympy.keras-1.0.21/sympy/physics/mechanics/functions.py` & `sympy.keras-1.0.4/sympy/physics/mechanics/functions.py`

 * *Files 6% similar despite different names*

```diff
@@ -6,14 +6,29 @@
                                            init_vprinting)
 from sympy.physics.mechanics.particle import Particle
 from sympy.physics.mechanics.rigidbody import RigidBody
 from sympy import simplify
 from sympy.core.backend import (Matrix, sympify, Mul, Derivative, sin, cos,
                                 tan, AppliedUndef, S)
 
+__all__ = ['inertia',
+           'inertia_of_point_mass',
+           'linear_momentum',
+           'angular_momentum',
+           'kinetic_energy',
+           'potential_energy',
+           'Lagrangian',
+           'mechanics_printing',
+           'mprint',
+           'msprint',
+           'mpprint',
+           'mlatex',
+           'msubs',
+           'find_dynamicsymbols']
+
 # These are functions that we've moved and renamed during extracting the
 # basic vector calculus code from the mechanics packages.
 
 mprint = vprint
 msprint = vsprint
 mpprint = vpprint
 mlatex = vlatex
```

### Comparing `sympy.keras-1.0.21/sympy/physics/mechanics/kane.py` & `sympy.keras-1.0.4/sympy/physics/mechanics/kane.py`

 * *Files 0% similar despite different names*

```diff
@@ -8,14 +8,16 @@
 from sympy.physics.mechanics.rigidbody import RigidBody
 from sympy.physics.mechanics.functions import (msubs, find_dynamicsymbols,
                                                _f_list_parser)
 from sympy.physics.mechanics.linearize import Linearizer
 from sympy.utilities.exceptions import SymPyDeprecationWarning
 from sympy.utilities.iterables import iterable
 
+__all__ = ['KanesMethod']
+
 
 class KanesMethod(object):
     """Kane's method object.
 
     This object is used to do the "book-keeping" as you go through and form
     equations of motion in the way Kane presents in:
     Kane, T., Levinson, D. Dynamics Theory and Applications. 1985 McGraw-Hill
```

### Comparing `sympy.keras-1.0.21/sympy/physics/mechanics/lagrange.py` & `sympy.keras-1.0.4/sympy/physics/mechanics/lagrange.py`

 * *Files 0% similar despite different names*

```diff
@@ -2,14 +2,16 @@
 from sympy.physics.vector import dynamicsymbols, ReferenceFrame
 from sympy.physics.mechanics.functions import (find_dynamicsymbols, msubs,
                                                _f_list_parser)
 from sympy.physics.mechanics.linearize import Linearizer
 from sympy.utilities import default_sort_key
 from sympy.utilities.iterables import iterable
 
+__all__ = ['LagrangesMethod']
+
 
 class LagrangesMethod(object):
     """Lagrange's method object.
 
     This object generates the equations of motion in a two step procedure. The
     first step involves the initialization of LagrangesMethod by supplying the
     Lagrangian and the generalized coordinates, at the bare minimum. If there
```

### Comparing `sympy.keras-1.0.21/sympy/physics/mechanics/linearize.py` & `sympy.keras-1.0.4/sympy/physics/mechanics/linearize.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,7 +1,9 @@
+__all__ = ['Linearizer']
+
 from sympy.core.backend import Matrix, eye, zeros
 from sympy.core.compatibility import Iterable
 from sympy import Dummy
 from sympy.utilities.iterables import flatten
 from sympy.physics.vector import dynamicsymbols
 from sympy.physics.mechanics.functions import msubs
```

### Comparing `sympy.keras-1.0.21/sympy/physics/mechanics/models.py` & `sympy.keras-1.0.4/sympy/physics/mechanics/models.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/physics/mechanics/particle.py` & `sympy.keras-1.0.4/sympy/physics/mechanics/particle.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,11 +1,13 @@
 from sympy.core.backend import sympify
 
 from sympy.physics.vector import Point
 
+__all__ = ['Particle']
+
 
 class Particle(object):
     """A particle.
 
     Particles have a non-zero mass and lack spatial extension; they take up no
     space.
```

### Comparing `sympy.keras-1.0.21/sympy/physics/mechanics/rigidbody.py` & `sympy.keras-1.0.4/sympy/physics/mechanics/rigidbody.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,12 +1,14 @@
 # -*- encoding: utf-8 -*-
 from sympy.core.backend import sympify
 
 from sympy.physics.vector import Point, ReferenceFrame, Dyadic
 
+__all__ = ['RigidBody']
+
 
 class RigidBody(object):
     """An idealized rigid body.
 
     This is essentially a container which holds the various components which
     describe a rigid body: a name, mass, center of mass, reference frame, and
     inertia.
```

### Comparing `sympy.keras-1.0.21/sympy/physics/mechanics/system.py` & `sympy.keras-1.0.4/sympy/physics/mechanics/system.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,11 +1,13 @@
 from sympy.core.backend import eye, Matrix, zeros
 from sympy.physics.mechanics import dynamicsymbols
 from sympy.physics.mechanics.functions import find_dynamicsymbols
 
+__all__ = ['SymbolicSystem']
+
 
 class SymbolicSystem(object):
     """SymbolicSystem is a class that contains all the information about a
     system in a symbolic format such as the equations of motions and the bodies
     and loads in the system.
 
     There are three ways that the equations of motion can be described for
```

### Comparing `sympy.keras-1.0.21/sympy/physics/optics/gaussopt.py` & `sympy.keras-1.0.4/sympy/physics/optics/gaussopt.py`

 * *Files 3% similar despite different names*

```diff
@@ -17,14 +17,33 @@
     positive for convergent lenses
 object distance
     positive for real objects
 image distance
     positive for real images
 """
 
+__all__ = [
+    'RayTransferMatrix',
+    'FreeSpace',
+    'FlatRefraction',
+    'CurvedRefraction',
+    'FlatMirror',
+    'CurvedMirror',
+    'ThinLens',
+    'GeometricRay',
+    'BeamParameter',
+    'waist2rayleigh',
+    'rayleigh2waist',
+    'geometric_conj_ab',
+    'geometric_conj_af',
+    'geometric_conj_bf',
+    'gaussian_conj',
+    'conjugate_gauss_beams',
+]
+
 
 from sympy import (atan2, Expr, I, im, Matrix, oo, pi, re, sqrt, sympify,
     together)
 from sympy.utilities.misc import filldedent
 
 ###
 # A, B, C, D matrices
```

### Comparing `sympy.keras-1.0.21/sympy/physics/optics/medium.py` & `sympy.keras-1.0.4/sympy/physics/optics/medium.py`

 * *Files 1% similar despite different names*

```diff
@@ -2,14 +2,16 @@
 **Contains**
 
 * Medium
 """
 
 from sympy.physics.units import second, meter, kilogram, ampere
 
+__all__ = ['Medium']
+
 from sympy import Symbol, sympify, sqrt
 from sympy.physics.units import speed_of_light, u0, e0
 
 
 c = speed_of_light.convert_to(meter/second)
 _e0mksa = e0.convert_to(ampere**2*second**4/(kilogram*meter**3))
 _u0mksa = u0.convert_to(meter*kilogram/(ampere**2*second**2))
```

### Comparing `sympy.keras-1.0.21/sympy/physics/optics/polarization.py` & `sympy.keras-1.0.4/sympy/physics/optics/polarization.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/physics/optics/utils.py` & `sympy.keras-1.0.4/sympy/physics/optics/utils.py`

 * *Files 2% similar despite different names*

```diff
@@ -9,14 +9,26 @@
 * lens_makers_formula
 * mirror_formula
 * lens_formula
 * hyperfocal_distance
 * transverse_magnification
 """
 
+__all__ = ['refraction_angle',
+           'deviation',
+           'fresnel_coefficients',
+           'brewster_angle',
+           'critical_angle',
+           'lens_makers_formula',
+           'mirror_formula',
+           'lens_formula',
+           'hyperfocal_distance',
+           'transverse_magnification'
+           ]
+
 from sympy import Symbol, sympify, sqrt, Matrix, acos, oo, Limit, atan2, asin,\
 cos, sin, tan, I, cancel, pi, Float
 from sympy.core.compatibility import is_sequence
 from sympy.geometry.line import Ray3D, Point3D
 from sympy.geometry.util import intersection
 from sympy.geometry.plane import Plane
 from .medium import Medium
```

### Comparing `sympy.keras-1.0.21/sympy/physics/optics/waves.py` & `sympy.keras-1.0.4/sympy/physics/optics/waves.py`

 * *Files 0% similar despite different names*

```diff
@@ -2,14 +2,16 @@
 This module has all the classes and functions related to waves in optics.
 
 **Contains**
 
 * TWave
 """
 
+__all__ = ['TWave']
+
 from sympy import (sympify, pi, sin, cos, sqrt, Symbol, S,
     symbols, Derivative, atan2)
 from sympy.core.expr import Expr
 from sympy.physics.units import speed_of_light, meter, second
 
 
 c = speed_of_light.convert_to(meter/second)
```

### Comparing `sympy.keras-1.0.21/sympy/physics/paulialgebra.py` & `sympy.keras-1.0.4/sympy/physics/paulialgebra.py`

 * *Files 2% similar despite different names*

```diff
@@ -8,14 +8,16 @@
 ~~~~~~~~~~
 .. [1] https://en.wikipedia.org/wiki/Pauli_matrices
 """
 
 from sympy import Symbol, I, Mul, Pow, Add
 from sympy.physics.quantum import TensorProduct
 
+__all__ = ['evaluate_pauli_product']
+
 
 def delta(i, j):
     """
     Returns 1 if i == j, else 0.
 
     This is used in the multiplication of Pauli matrices.
```

### Comparing `sympy.keras-1.0.21/sympy/physics/pring.py` & `sympy.keras-1.0.4/sympy/physics/pring.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/physics/qho_1d.py` & `sympy.keras-1.0.4/sympy/physics/qho_1d.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/physics/quantum/anticommutator.py` & `sympy.keras-1.0.4/sympy/physics/quantum/anticommutator.py`

 * *Files 1% similar despite different names*

```diff
@@ -2,14 +2,18 @@
 
 from sympy import S, Expr, Mul, Integer
 from sympy.printing.pretty.stringpict import prettyForm
 
 from sympy.physics.quantum.operator import Operator
 from sympy.physics.quantum.dagger import Dagger
 
+__all__ = [
+    'AntiCommutator'
+]
+
 #-----------------------------------------------------------------------------
 # Anti-commutator
 #-----------------------------------------------------------------------------
 
 
 class AntiCommutator(Expr):
     """The standard anticommutator, in an unevaluated state.
```

### Comparing `sympy.keras-1.0.21/sympy/physics/quantum/boson.py` & `sympy.keras-1.0.4/sympy/physics/quantum/boson.py`

 * *Files 8% similar despite different names*

```diff
@@ -2,14 +2,23 @@
 
 from sympy import Mul, Integer, exp, sqrt, conjugate
 from sympy.physics.quantum import Operator
 from sympy.physics.quantum import HilbertSpace, FockSpace, Ket, Bra, IdentityOperator
 from sympy.functions.special.tensor_functions import KroneckerDelta
 
 
+__all__ = [
+    'BosonOp',
+    'BosonFockKet',
+    'BosonFockBra',
+    'BosonCoherentKet',
+    'BosonCoherentBra'
+]
+
+
 class BosonOp(Operator):
     """A bosonic operator that satisfies [a, Dagger(a)] == 1.
 
     Parameters
     ==========
 
     name : str
```

### Comparing `sympy.keras-1.0.21/sympy/physics/quantum/cartesian.py` & `sympy.keras-1.0.4/sympy/physics/quantum/cartesian.py`

 * *Files 4% similar despite different names*

```diff
@@ -10,14 +10,32 @@
 
 
 from sympy.physics.quantum.constants import hbar
 from sympy.physics.quantum.hilbert import L2
 from sympy.physics.quantum.operator import DifferentialOperator, HermitianOperator
 from sympy.physics.quantum.state import Ket, Bra, State
 
+__all__ = [
+    'XOp',
+    'YOp',
+    'ZOp',
+    'PxOp',
+    'X',
+    'Y',
+    'Z',
+    'Px',
+    'XKet',
+    'XBra',
+    'PxKet',
+    'PxBra',
+    'PositionState3D',
+    'PositionKet3D',
+    'PositionBra3D'
+]
+
 #-------------------------------------------------------------------------
 # Position operators
 #-------------------------------------------------------------------------
 
 
 class XOp(HermitianOperator):
     """1D cartesian position operator."""
```

### Comparing `sympy.keras-1.0.21/sympy/physics/quantum/cg.py` & `sympy.keras-1.0.4/sympy/physics/quantum/cg.py`

 * *Files 1% similar despite different names*

```diff
@@ -8,14 +8,22 @@
                    symbols, sympify, Wild)
 
 from sympy.printing.pretty.stringpict import prettyForm, stringPict
 
 from sympy.functions.special.tensor_functions import KroneckerDelta
 from sympy.physics.wigner import clebsch_gordan, wigner_3j, wigner_6j, wigner_9j
 
+__all__ = [
+    'CG',
+    'Wigner3j',
+    'Wigner6j',
+    'Wigner9j',
+    'cg_simp'
+]
+
 #-----------------------------------------------------------------------------
 # CG Coefficients
 #-----------------------------------------------------------------------------
 
 
 class Wigner3j(Expr):
     """Class for the Wigner-3j symbols
```

### Comparing `sympy.keras-1.0.21/sympy/physics/quantum/circuitplot.py` & `sympy.keras-1.0.4/sympy/physics/quantum/circuitplot.py`

 * *Files 2% similar despite different names*

```diff
@@ -18,14 +18,24 @@
 
 from sympy.external import import_module
 from sympy.physics.quantum.gate import Gate, OneQubitGate, CGate, CGateS
 from sympy.core.core import BasicMeta
 from sympy.core.assumptions import ManagedProperties
 
 
+__all__ = [
+    'CircuitPlot',
+    'circuit_plot',
+    'labeller',
+    'Mz',
+    'Mx',
+    'CreateOneQubitGate',
+    'CreateCGate',
+]
+
 np = import_module('numpy')
 matplotlib = import_module(
     'matplotlib', __import__kwargs={'fromlist': ['pyplot']},
     catch=(RuntimeError,))  # This is raised in environments that have no display.
 
 if not np or not matplotlib:
     class CircuitPlot(object):
```

### Comparing `sympy.keras-1.0.21/sympy/physics/quantum/circuitutils.py` & `sympy.keras-1.0.4/sympy/physics/quantum/circuitutils.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,14 +1,25 @@
 """Primitive circuit operations on quantum circuits."""
 
 from sympy import Symbol, Tuple, Mul, sympify, default_sort_key
 from sympy.utilities import numbered_symbols
 from sympy.core.compatibility import reduce
 from sympy.physics.quantum.gate import Gate
 
+__all__ = [
+    'kmp_table',
+    'find_subcircuit',
+    'replace_subcircuit',
+    'convert_to_symbolic_indices',
+    'convert_to_real_indices',
+    'random_reduce',
+    'random_insert'
+]
+
+
 def kmp_table(word):
     """Build the 'partial match' table of the Knuth-Morris-Pratt algorithm.
 
     Note: This is applicable to strings or
     quantum circuits represented as tuples.
     """
```

### Comparing `sympy.keras-1.0.21/sympy/physics/quantum/commutator.py` & `sympy.keras-1.0.4/sympy/physics/quantum/commutator.py`

 * *Files 4% similar despite different names*

```diff
@@ -3,14 +3,18 @@
 from sympy import S, Expr, Mul, Add
 from sympy.printing.pretty.stringpict import prettyForm
 
 from sympy.physics.quantum.dagger import Dagger
 from sympy.physics.quantum.operator import Operator
 
 
+__all__ = [
+    'Commutator'
+]
+
 #-----------------------------------------------------------------------------
 # Commutator
 #-----------------------------------------------------------------------------
 
 
 class Commutator(Expr):
     """The standard commutator, in an unevaluated state.
```

### Comparing `sympy.keras-1.0.21/sympy/physics/quantum/constants.py` & `sympy.keras-1.0.4/sympy/physics/quantum/constants.py`

 * *Files 3% similar despite different names*

```diff
@@ -6,14 +6,19 @@
 from sympy.printing.pretty.stringpict import prettyForm
 import mpmath.libmp as mlib
 
 #-----------------------------------------------------------------------------
 # Constants
 #-----------------------------------------------------------------------------
 
+__all__ = [
+    'hbar'
+]
+
+
 class HBar(with_metaclass(Singleton, NumberSymbol)):
     """Reduced Plank's constant in numerical and symbolic form [1]_.
 
     Examples
     ========
 
         >>> from sympy.physics.quantum.constants import hbar
```

### Comparing `sympy.keras-1.0.21/sympy/physics/quantum/dagger.py` & `sympy.keras-1.0.4/sympy/physics/quantum/dagger.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,12 +1,16 @@
 """Hermitian conjugation."""
 
 from sympy.core import Expr
 from sympy.functions.elementary.complexes import adjoint
 
+__all__ = [
+    'Dagger'
+]
+
 
 class Dagger(adjoint):
     """General Hermitian conjugate operation.
 
     Take the Hermetian conjugate of an argument [1]_. For matrices this
     operation is equivalent to transpose and complex conjugate [2]_.
```

### Comparing `sympy.keras-1.0.21/sympy/physics/quantum/density.py` & `sympy.keras-1.0.4/sympy/physics/quantum/density.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/physics/quantum/fermion.py` & `sympy.keras-1.0.4/sympy/physics/quantum/fermion.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,14 +2,21 @@
 
 from sympy import Integer
 from sympy.physics.quantum import Operator
 from sympy.physics.quantum import HilbertSpace, Ket, Bra
 from sympy.functions.special.tensor_functions import KroneckerDelta
 
 
+__all__ = [
+    'FermionOp',
+    'FermionFockKet',
+    'FermionFockBra'
+]
+
+
 class FermionOp(Operator):
     """A fermionic operator that satisfies {c, Dagger(c)} == 1.
 
     Parameters
     ==========
 
     name : str
```

### Comparing `sympy.keras-1.0.21/sympy/physics/quantum/gate.py` & `sympy.keras-1.0.4/sympy/physics/quantum/gate.py`

 * *Files 4% similar despite different names*

```diff
@@ -30,14 +30,47 @@
 from sympy.physics.quantum.matrixutils import matrix_tensor_product, matrix_eye
 from sympy.physics.quantum.matrixcache import matrix_cache
 
 from sympy.matrices.matrices import MatrixBase
 
 from sympy.utilities import default_sort_key
 
+__all__ = [
+    'Gate',
+    'CGate',
+    'UGate',
+    'OneQubitGate',
+    'TwoQubitGate',
+    'IdentityGate',
+    'HadamardGate',
+    'XGate',
+    'YGate',
+    'ZGate',
+    'TGate',
+    'PhaseGate',
+    'SwapGate',
+    'CNotGate',
+    # Aliased gate names
+    'CNOT',
+    'SWAP',
+    'H',
+    'X',
+    'Y',
+    'Z',
+    'T',
+    'S',
+    'Phase',
+    'normalized',
+    'gate_sort',
+    'gate_simp',
+    'random_circuit',
+    'CPHASE',
+    'CGateS',
+]
+
 #-----------------------------------------------------------------------------
 # Gate Super-Classes
 #-----------------------------------------------------------------------------
 
 _normalized = True
```

### Comparing `sympy.keras-1.0.21/sympy/physics/quantum/grover.py` & `sympy.keras-1.0.4/sympy/physics/quantum/grover.py`

 * *Files 2% similar despite different names*

```diff
@@ -14,14 +14,23 @@
 from sympy.physics.quantum.qapply import qapply
 from sympy.physics.quantum.qexpr import QuantumError
 from sympy.physics.quantum.hilbert import ComplexSpace
 from sympy.physics.quantum.operator import UnitaryOperator
 from sympy.physics.quantum.gate import Gate
 from sympy.physics.quantum.qubit import IntQubit
 
+__all__ = [
+    'OracleGate',
+    'WGate',
+    'superposition_basis',
+    'grover_iteration',
+    'apply_grover'
+]
+
+
 def superposition_basis(nqubits):
     """Creates an equal superposition of the computational basis.
 
     Parameters
     ==========
 
     nqubits : int
```

### Comparing `sympy.keras-1.0.21/sympy/physics/quantum/hilbert.py` & `sympy.keras-1.0.4/sympy/physics/quantum/hilbert.py`

 * *Files 2% similar despite different names*

```diff
@@ -9,14 +9,22 @@
 
 from sympy.printing.pretty.stringpict import prettyForm
 
 from sympy.physics.quantum.qexpr import QuantumError
 
 from sympy.core.compatibility import reduce
 
+__all__ = [
+    'HilbertSpaceError',
+    'HilbertSpace',
+    'ComplexSpace',
+    'L2',
+    'FockSpace'
+]
+
 #-----------------------------------------------------------------------------
 # Main objects
 #-----------------------------------------------------------------------------
 
 
 class HilbertSpaceError(QuantumError):
     pass
```

### Comparing `sympy.keras-1.0.21/sympy/physics/quantum/identitysearch.py` & `sympy.keras-1.0.4/sympy/physics/quantum/identitysearch.py`

 * *Files 1% similar despite different names*

```diff
@@ -3,14 +3,29 @@
 
 
 from sympy.external import import_module
 from sympy import Mul, Basic, Number, Pow, Integer
 from sympy.physics.quantum.represent import represent
 from sympy.physics.quantum.dagger import Dagger
 
+__all__ = [
+    # Public interfaces
+    'generate_gate_rules',
+    'generate_equivalent_ids',
+    'GateIdentity',
+    'bfs_identity_search',
+    'random_identity_search',
+
+    # "Private" functions
+    'is_scalar_sparse_matrix',
+    'is_scalar_nonsparse_matrix',
+    'is_degenerate',
+    'is_reducible',
+]
+
 np = import_module('numpy')
 scipy = import_module('scipy', __import__kwargs={'fromlist': ['sparse']})
 
 
 def is_scalar_sparse_matrix(circuit, nqubits, identity_only, eps=1e-11):
     """Checks if a given scipy.sparse matrix is a scalar matrix.
```

### Comparing `sympy.keras-1.0.21/sympy/physics/quantum/innerproduct.py` & `sympy.keras-1.0.4/sympy/physics/quantum/innerproduct.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,14 +1,19 @@
 """Symbolic inner product."""
 
 from sympy import Expr, conjugate
 from sympy.printing.pretty.stringpict import prettyForm
 from sympy.physics.quantum.dagger import Dagger
 from sympy.physics.quantum.state import KetBase, BraBase
 
+__all__ = [
+    'InnerProduct'
+]
+
+
 # InnerProduct is not an QExpr because it is really just a regular commutative
 # number. We have gone back and forth about this, but we gain a lot by having
 # it subclass Expr. The main challenges were getting Dagger to work
 # (we use _eval_conjugate) and represent (we can use atoms and subs). Having
 # it be an Expr, mean that there are no commutative QExpr subclasses,
 # which simplifies the design of everything.
```

### Comparing `sympy.keras-1.0.21/sympy/physics/quantum/matrixcache.py` & `sympy.keras-1.0.4/sympy/physics/quantum/matrixcache.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/physics/quantum/matrixutils.py` & `sympy.keras-1.0.4/sympy/physics/quantum/matrixutils.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,13 +1,29 @@
 """Utilities to deal with sympy.Matrix, numpy and scipy.sparse."""
 
 from sympy import MatrixBase, I, Expr, Integer
 from sympy.matrices import eye, zeros
 from sympy.external import import_module
 
+__all__ = [
+    'numpy_ndarray',
+    'scipy_sparse_matrix',
+    'sympy_to_numpy',
+    'sympy_to_scipy_sparse',
+    'numpy_to_sympy',
+    'scipy_sparse_to_sympy',
+    'flatten_scalar',
+    'matrix_dagger',
+    'to_sympy',
+    'to_numpy',
+    'to_scipy_sparse',
+    'matrix_tensor_product',
+    'matrix_zeros'
+]
+
 # Conditionally define the base classes for numpy and scipy.sparse arrays
 # for use in isinstance tests.
 
 np = import_module('numpy')
 if not np:
     class numpy_ndarray(object):
         pass
```

### Comparing `sympy.keras-1.0.21/sympy/physics/quantum/operator.py` & `sympy.keras-1.0.4/sympy/physics/quantum/operator.py`

 * *Files 4% similar despite different names*

```diff
@@ -11,14 +11,23 @@
 
 from sympy import Derivative, Expr, Integer, oo, Mul, expand, Add
 from sympy.printing.pretty.stringpict import prettyForm
 from sympy.physics.quantum.dagger import Dagger
 from sympy.physics.quantum.qexpr import QExpr, dispatch_method
 from sympy.matrices import eye
 
+__all__ = [
+    'Operator',
+    'HermitianOperator',
+    'UnitaryOperator',
+    'IdentityOperator',
+    'OuterProduct',
+    'DifferentialOperator'
+]
+
 #-----------------------------------------------------------------------------
 # Operators and outer products
 #-----------------------------------------------------------------------------
 
 
 class Operator(QExpr):
     """Base class for non-commuting quantum operators.
```

### Comparing `sympy.keras-1.0.21/sympy/physics/quantum/operatorordering.py` & `sympy.keras-1.0.4/sympy/physics/quantum/operatorordering.py`

 * *Files 2% similar despite different names*

```diff
@@ -4,14 +4,19 @@
 
 from sympy import Add, Mul, Pow, Integer
 
 from sympy.physics.quantum import Operator, Commutator, AntiCommutator
 from sympy.physics.quantum.boson import BosonOp
 from sympy.physics.quantum.fermion import FermionOp
 
+__all__ = [
+    'normal_order',
+    'normal_ordered_form'
+]
+
 
 def _expand_powers(factors):
     """
     Helper function for normal_ordered_form and normal_order: Expand a
     power expression to a multiplication expression so that that the
     expression can be handled by the normal ordering functions.
     """
```

### Comparing `sympy.keras-1.0.21/sympy/physics/quantum/operatorset.py` & `sympy.keras-1.0.4/sympy/physics/quantum/operatorset.py`

 * *Files 2% similar despite different names*

```diff
@@ -17,14 +17,19 @@
 from sympy.physics.quantum.cartesian import (XOp, YOp, ZOp, XKet, PxOp, PxKet,
                                              PositionKet3D)
 from sympy.physics.quantum.operator import Operator
 from sympy.physics.quantum.state import StateBase, BraBase, Ket
 from sympy.physics.quantum.spin import (JxOp, JyOp, JzOp, J2Op, JxKet, JyKet,
                                         JzKet)
 
+__all__ = [
+    'operators_to_state',
+    'state_to_operators'
+]
+
 #state_mapping stores the mappings between states and their associated
 #operators or tuples of operators. This should be updated when new
 #classes are written! Entries are of the form PxKet : PxOp or
 #something like 3DKet : (ROp, ThetaOp, PhiOp)
 
 #frozenset is used so that the reverse mapping can be made
 #(regular sets are not hashable because they are mutable
```

### Comparing `sympy.keras-1.0.21/sympy/physics/quantum/pauli.py` & `sympy.keras-1.0.4/sympy/physics/quantum/pauli.py`

 * *Files 0% similar despite different names*

```diff
@@ -2,14 +2,19 @@
 
 from sympy import I, Mul, Add, Pow, exp, Integer
 from sympy.physics.quantum import Operator, Ket, Bra
 from sympy.physics.quantum import ComplexSpace
 from sympy.matrices import Matrix
 from sympy.functions.special.tensor_functions import KroneckerDelta
 
+__all__ = [
+    'SigmaX', 'SigmaY', 'SigmaZ', 'SigmaMinus', 'SigmaPlus', 'SigmaZKet',
+    'SigmaZBra', 'qsimplify_pauli'
+]
+
 
 class SigmaOpBase(Operator):
     """Pauli sigma operator, base class"""
 
     @property
     def name(self):
         return self.args[0]
```

### Comparing `sympy.keras-1.0.21/sympy/physics/quantum/piab.py` & `sympy.keras-1.0.4/sympy/physics/quantum/piab.py`

 * *Files 8% similar despite different names*

```diff
@@ -8,14 +8,21 @@
 from sympy.functions.special.tensor_functions import KroneckerDelta
 from sympy.physics.quantum.hilbert import L2
 
 m = Symbol('m')
 L = Symbol('L')
 
 
+__all__ = [
+    'PIABHamiltonian',
+    'PIABKet',
+    'PIABBra'
+]
+
+
 class PIABHamiltonian(HermitianOperator):
     """Particle in a box Hamiltonian operator."""
 
     @classmethod
     def _eval_hilbert_space(cls, label):
         return L2(Interval(S.NegativeInfinity, S.Infinity))
```

### Comparing `sympy.keras-1.0.21/sympy/physics/quantum/qapply.py` & `sympy.keras-1.0.4/sympy/physics/quantum/qapply.py`

 * *Files 1% similar despite different names*

```diff
@@ -11,14 +11,18 @@
 from sympy.physics.quantum.commutator import Commutator
 from sympy.physics.quantum.dagger import Dagger
 from sympy.physics.quantum.innerproduct import InnerProduct
 from sympy.physics.quantum.operator import OuterProduct, Operator
 from sympy.physics.quantum.state import State, KetBase, BraBase, Wavefunction
 from sympy.physics.quantum.tensorproduct import TensorProduct
 
+__all__ = [
+    'qapply'
+]
+
 
 #-----------------------------------------------------------------------------
 # Main code
 #-----------------------------------------------------------------------------
 
 def qapply(e, **options):
     """Apply operators to states in a quantum expression.
```

### Comparing `sympy.keras-1.0.21/sympy/physics/quantum/qasm.py` & `sympy.keras-1.0.4/sympy/physics/quantum/qasm.py`

 * *Files 2% similar despite different names*

```diff
@@ -12,14 +12,18 @@
 CNOT(1,0)*H(1)
 
 >>> q = Qasm('qubit q0', 'qubit q1', 'cnot q0,q1', 'cnot q1,q0', 'cnot q0,q1')
 >>> q.get_circuit()
 CNOT(1,0)*CNOT(0,1)*CNOT(1,0)
 """
 
+__all__ = [
+    'Qasm',
+    ]
+
 from sympy.physics.quantum.gate import H, CNOT, X, Z, CGate, CGateS, SWAP, S, T,CPHASE
 from sympy.physics.quantum.circuitplot import Mz
 
 def read_qasm(lines):
     return Qasm(*lines.splitlines())
 
 def read_qasm_file(filename):
```

### Comparing `sympy.keras-1.0.21/sympy/physics/quantum/qexpr.py` & `sympy.keras-1.0.4/sympy/physics/quantum/qexpr.py`

 * *Files 1% similar despite different names*

```diff
@@ -5,14 +5,19 @@
 
 from sympy.physics.quantum.dagger import Dagger
 from sympy.physics.quantum.matrixutils import (
     numpy_ndarray, scipy_sparse_matrix,
     to_sympy, to_numpy, to_scipy_sparse
 )
 
+__all__ = [
+    'QuantumError',
+    'QExpr'
+]
+
 
 #-----------------------------------------------------------------------------
 # Error handling
 #-----------------------------------------------------------------------------
 
 class QuantumError(Exception):
     pass
```

### Comparing `sympy.keras-1.0.21/sympy/physics/quantum/qft.py` & `sympy.keras-1.0.4/sympy/physics/quantum/qft.py`

 * *Files 2% similar despite different names*

```diff
@@ -20,14 +20,21 @@
 from sympy.matrices import eye
 from sympy.physics.quantum.tensorproduct import matrix_tensor_product
 
 from sympy.physics.quantum.gate import (
     Gate, HadamardGate, SwapGate, OneQubitGate, CGate, PhaseGate, TGate, ZGate
 )
 
+__all__ = [
+    'QFT',
+    'IQFT',
+    'RkGate',
+    'Rk'
+]
+
 #-----------------------------------------------------------------------------
 # Fourier stuff
 #-----------------------------------------------------------------------------
 
 
 class RkGate(OneQubitGate):
     """This is the R_k gate of the QTF."""
```

### Comparing `sympy.keras-1.0.21/sympy/physics/quantum/qubit.py` & `sympy.keras-1.0.4/sympy/physics/quantum/qubit.py`

 * *Files 2% similar despite different names*

```diff
@@ -20,14 +20,28 @@
 from sympy.physics.quantum.qexpr import QuantumError
 from sympy.physics.quantum.represent import represent
 from sympy.physics.quantum.matrixutils import (
     numpy_ndarray, scipy_sparse_matrix
 )
 from mpmath.libmp.libintmath import bitcount
 
+__all__ = [
+    'Qubit',
+    'QubitBra',
+    'IntQubit',
+    'IntQubitBra',
+    'qubit_to_matrix',
+    'matrix_to_qubit',
+    'matrix_to_density',
+    'measure_all',
+    'measure_partial',
+    'measure_partial_oneshot',
+    'measure_all_oneshot'
+]
+
 #-----------------------------------------------------------------------------
 # Qubit Classes
 #-----------------------------------------------------------------------------
 
 
 class QubitState(State):
     """Base class for Qubit and QubitBra."""
```

### Comparing `sympy.keras-1.0.21/sympy/physics/quantum/represent.py` & `sympy.keras-1.0.4/sympy/physics/quantum/represent.py`

 * *Files 2% similar despite different names*

```diff
@@ -15,14 +15,23 @@
 from sympy.physics.quantum.tensorproduct import TensorProduct
 from sympy.physics.quantum.matrixutils import flatten_scalar
 from sympy.physics.quantum.state import KetBase, BraBase, StateBase
 from sympy.physics.quantum.operator import Operator, OuterProduct
 from sympy.physics.quantum.qapply import qapply
 from sympy.physics.quantum.operatorset import operators_to_state, state_to_operators
 
+__all__ = [
+    'represent',
+    'rep_innerproduct',
+    'rep_expectation',
+    'integrate_result',
+    'get_basis',
+    'enumerate_states'
+]
+
 #-----------------------------------------------------------------------------
 # Represent
 #-----------------------------------------------------------------------------
 
 
 def _sympy_to_scalar(e):
     """Convert from a sympy scalar to a Python scalar."""
```

### Comparing `sympy.keras-1.0.21/sympy/physics/quantum/sho1d.py` & `sympy.keras-1.0.4/sympy/physics/quantum/sho1d.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/physics/quantum/shor.py` & `sympy.keras-1.0.4/sympy/physics/quantum/shor.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/physics/quantum/spin.py` & `sympy.keras-1.0.4/sympy/physics/quantum/spin.py`

 * *Files 2% similar despite different names*

```diff
@@ -16,14 +16,41 @@
 from sympy.physics.quantum.constants import hbar
 from sympy.physics.quantum.hilbert import ComplexSpace, DirectSumHilbertSpace
 from sympy.physics.quantum.tensorproduct import TensorProduct
 from sympy.physics.quantum.cg import CG
 from sympy.physics.quantum.qapply import qapply
 
 
+__all__ = [
+    'm_values',
+    'Jplus',
+    'Jminus',
+    'Jx',
+    'Jy',
+    'Jz',
+    'J2',
+    'Rotation',
+    'WignerD',
+    'JxKet',
+    'JxBra',
+    'JyKet',
+    'JyBra',
+    'JzKet',
+    'JzBra',
+    'JxKetCoupled',
+    'JxBraCoupled',
+    'JyKetCoupled',
+    'JyBraCoupled',
+    'JzKetCoupled',
+    'JzBraCoupled',
+    'couple',
+    'uncouple'
+]
+
+
 def m_values(j):
     j = sympify(j)
     size = 2*j + 1
     if not size.is_Integer or not size > 0:
         raise ValueError(
             'Only integer or half-integer values allowed for j, got: : %r' % j
         )
```

### Comparing `sympy.keras-1.0.21/sympy/physics/quantum/state.py` & `sympy.keras-1.0.4/sympy/physics/quantum/state.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,14 +2,28 @@
 
 from sympy import (cacheit, conjugate, Expr, Function, integrate, oo, sqrt,
                    Tuple)
 
 from sympy.printing.pretty.stringpict import stringPict
 from sympy.physics.quantum.qexpr import QExpr, dispatch_method
 
+__all__ = [
+    'KetBase',
+    'BraBase',
+    'StateBase',
+    'State',
+    'Ket',
+    'Bra',
+    'TimeDepState',
+    'TimeDepBra',
+    'TimeDepKet',
+    'Wavefunction'
+]
+
+
 #-----------------------------------------------------------------------------
 # States, bras and kets.
 #-----------------------------------------------------------------------------
 
 # ASCII brackets
 _lbracket = "<"
 _rbracket = ">"
```

### Comparing `sympy.keras-1.0.21/sympy/physics/quantum/tensorproduct.py` & `sympy.keras-1.0.4/sympy/physics/quantum/tensorproduct.py`

 * *Files 0% similar despite different names*

```diff
@@ -13,14 +13,19 @@
 from sympy.physics.quantum.matrixutils import (
     numpy_ndarray,
     scipy_sparse_matrix,
     matrix_tensor_product
 )
 
 
+__all__ = [
+    'TensorProduct',
+    'tensor_product_simp'
+]
+
 #-----------------------------------------------------------------------------
 # Tensor product
 #-----------------------------------------------------------------------------
 
 _combined_printing = False
 
 
@@ -139,15 +144,15 @@
 
     def _eval_rewrite(self, pattern, rule, **hints):
         sargs = self.args
         terms = [t._eval_rewrite(pattern, rule, **hints) for t in sargs]
         return TensorProduct(*terms).expand(tensorproduct=True)
 
     def _sympystr(self, printer, *args):
-        from sympy.printing.string import sstr
+        from sympy.printing.str import sstr
         length = len(self.args)
         s = ''
         for i in range(length):
             if isinstance(self.args[i], (Add, Pow, Mul)):
                 s = s + '('
             s = s + sstr(self.args[i])
             if isinstance(self.args[i], (Add, Pow, Mul)):
```

### Comparing `sympy.keras-1.0.21/sympy/physics/secondquant.py` & `sympy.keras-1.0.4/sympy/physics/secondquant.py`

 * *Files 0% similar despite different names*

```diff
@@ -5,20 +5,59 @@
 of Many-Particle Systems."
 """
 from collections import defaultdict
 
 from sympy import (Add, Basic, cacheit, Dummy, Expr, Function, I,
                    KroneckerDelta, Mul, Pow, S, sqrt, Symbol, sympify, Tuple,
                    zeros)
-from sympy.printing.string import StrPrinter
+from sympy.printing.str import StrPrinter
 
 
 from sympy.utilities.iterables import has_dups
 from sympy.utilities import default_sort_key
 
+__all__ = [
+    'Dagger',
+    'KroneckerDelta',
+    'BosonicOperator',
+    'AnnihilateBoson',
+    'CreateBoson',
+    'AnnihilateFermion',
+    'CreateFermion',
+    'FockState',
+    'FockStateBra',
+    'FockStateKet',
+    'FockStateBosonKet',
+    'FockStateBosonBra',
+    'BBra',
+    'BKet',
+    'FBra',
+    'FKet',
+    'F',
+    'Fd',
+    'B',
+    'Bd',
+    'apply_operators',
+    'InnerProduct',
+    'BosonicBasis',
+    'VarBosonicBasis',
+    'FixedBosonicBasis',
+    'Commutator',
+    'matrix_rep',
+    'contraction',
+    'wicks',
+    'NO',
+    'evaluate_deltas',
+    'AntiSymmetricTensor',
+    'substitute_dummies',
+    'PermutationOperator',
+    'simplify_index_permutations',
+]
+
+
 class SecondQuantizationError(Exception):
     pass
 
 
 class AppliesOnlyToSymbolicIndex(SecondQuantizationError):
     pass
```

### Comparing `sympy.keras-1.0.21/sympy/physics/sho.py` & `sympy.keras-1.0.4/sympy/physics/sho.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/physics/units/__init__.py` & `sympy.keras-1.0.4/sympy/physics/units/__init__.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/physics/units/definitions/dimension_definitions.py` & `sympy.keras-1.0.4/sympy/physics/units/definitions/dimension_definitions.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/physics/units/definitions/unit_definitions.py` & `sympy.keras-1.0.4/sympy/physics/units/definitions/unit_definitions.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/physics/units/dimensions.py` & `sympy.keras-1.0.4/sympy/physics/units/dimensions.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/physics/units/prefixes.py` & `sympy.keras-1.0.4/sympy/physics/units/prefixes.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/physics/units/quantities.py` & `sympy.keras-1.0.4/sympy/physics/units/quantities.py`

 * *Files 1% similar despite different names*

```diff
@@ -161,15 +161,15 @@
             return Mul(*[Quantity.get_dimensional_expr(i) for i in expr.args])
         elif isinstance(expr, Pow):
             return Quantity.get_dimensional_expr(expr.base) ** expr.exp
         elif isinstance(expr, Add):
             return Quantity.get_dimensional_expr(expr.args[0])
         elif isinstance(expr, Derivative):
             dim = Quantity.get_dimensional_expr(expr.expr)
-            for independent, count in expr.limits:
+            for independent, count in expr.variable_count:
                 dim /= Quantity.get_dimensional_expr(independent)**count
             return dim
         elif isinstance(expr, Function):
             args = [Quantity.get_dimensional_expr(arg) for arg in expr.args]
             if all(i == 1 for i in args):
                 return S.One
             return expr.func(*args)
@@ -206,15 +206,15 @@
                         'Dimension of "{0}" is {1}, '
                         'but it should be {2}'.format(
                             addend, addend_dim, dim))
                 factor += addend_factor
             return factor, dim
         elif isinstance(expr, Derivative):
             factor, dim = Quantity._collect_factor_and_dimension(expr.args[0])
-            for independent, count in expr.limits:
+            for independent, count in expr.variable_count:
                 ifactor, idim = Quantity._collect_factor_and_dimension(independent)
                 factor /= ifactor**count
                 dim /= idim**count
             return factor, dim
         elif isinstance(expr, Function):
             fds = [Quantity._collect_factor_and_dimension(
                 arg) for arg in expr.args]
```

### Comparing `sympy.keras-1.0.21/sympy/physics/units/systems/cgs.py` & `sympy.keras-1.0.4/sympy/physics/units/systems/cgs.py`

 * *Files 14% similar despite different names*

```diff
@@ -65,7 +65,17 @@
 cgs_gauss.set_quantity_scale_factor(ohm, 10**9/speed_of_light**2*second/centimeter)
 cgs_gauss.set_quantity_scale_factor(farad, One/10**9*speed_of_light**2*centimeter)
 cgs_gauss.set_quantity_scale_factor(henry, 10**9/speed_of_light**2/centimeter*second**2)
 
 # Coulomb's constant:
 cgs_gauss.set_quantity_dimension(coulomb_constant, 1)
 cgs_gauss.set_quantity_scale_factor(coulomb_constant, 1)
+
+__all__ = [
+    'ohm', 'tesla', 'maxwell', 'speed_of_light', 'volt', 'second', 'voltage',
+    'debye', 'dimsys_length_weight_time', 'centimeter', 'coulomb_constant',
+    'farad', 'sqrt', 'UnitSystem', 'current', 'charge', 'weber', 'gram',
+    'statcoulomb', 'gauss', 'S', 'statvolt', 'oersted', 'statampere',
+    'dimsys_cgs', 'coulomb', 'magnetic_density', 'magnetic_flux', 'One',
+    'length', 'erg', 'mass', 'coulombs_constant', 'henry', 'ampere',
+    'cgs_gauss',
+]
```

### Comparing `sympy.keras-1.0.21/sympy/physics/units/systems/length_weight_time.py` & `sympy.keras-1.0.4/sympy/physics/units/systems/length_weight_time.py`

 * *Files 23% similar despite different names*

```diff
@@ -116,7 +116,37 @@
 
 # Reduced Planck constant
 # REF: NIST SP 959 (June 2019)
 
 dimsys_length_weight_time.set_quantity_dimension(hbar, action)
 dimsys_length_weight_time.set_quantity_scale_factor(hbar, planck / (2 * pi))
 
+
+__all__ = [
+    'mmHg', 'atmosphere', 'newton', 'meter', 'vacuum_permittivity', 'pascal',
+    'magnetic_constant', 'angular_mil', 'julian_year', 'weber', 'exbibyte',
+    'liter', 'molar_gas_constant', 'faraday_constant', 'avogadro_constant',
+    'planck_momentum', 'planck_density', 'gee', 'mol', 'bit', 'gray', 'kibi',
+    'bar', 'curie', 'prefix_unit', 'PREFIXES', 'planck_time', 'gram',
+    'candela', 'force', 'planck_intensity', 'energy', 'becquerel',
+    'planck_acceleration', 'speed_of_light', 'dioptre', 'second', 'frequency',
+    'Hz', 'power', 'lux', 'planck_current', 'momentum', 'tebibyte',
+    'planck_power', 'degree', 'mebi', 'K', 'planck_volume',
+    'quart', 'pressure', 'W', 'joule', 'boltzmann_constant', 'c', 'g',
+    'planck_force', 'exbi', 's', 'watt', 'action', 'hbar', 'gibibyte',
+    'DimensionSystem', 'cd', 'volt', 'planck_charge',
+    'dimsys_length_weight_time', 'pebi', 'vacuum_impedance', 'planck',
+    'farad', 'gravitational_constant', 'u0', 'hertz', 'tesla', 'steradian',
+    'josephson_constant', 'planck_area', 'stefan_boltzmann_constant',
+    'astronomical_unit', 'J', 'N', 'planck_voltage', 'planck_energy',
+    'atomic_mass_constant', 'rutherford', 'elementary_charge', 'Pa',
+    'planck_mass', 'henry', 'planck_angular_frequency', 'ohm', 'pound',
+    'planck_pressure', 'G', 'avogadro_number', 'psi', 'von_klitzing_constant',
+    'planck_length', 'radian', 'mole', 'acceleration',
+    'planck_energy_density', 'mebibyte', 'length',
+    'acceleration_due_to_gravity', 'planck_temperature', 'tebi', 'inch',
+    'electronvolt', 'coulomb_constant', 'kelvin', 'kPa', 'boltzmann',
+    'milli_mass_unit', 'gibi', 'planck_impedance', 'electric_constant', 'kg',
+    'coulomb', 'siemens', 'byte', 'atomic_mass_unit', 'm', 'kibibyte',
+    'kilogram', 'lightyear', 'mass', 'time', 'pebibyte', 'velocity',
+    'ampere', 'katal',
+]
```

### Comparing `sympy.keras-1.0.21/sympy/physics/units/systems/mks.py` & `sympy.keras-1.0.4/sympy/physics/units/systems/mks.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/physics/units/systems/mksa.py` & `sympy.keras-1.0.4/sympy/physics/units/systems/mksa.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/physics/units/systems/natural.py` & `sympy.keras-1.0.4/sympy/physics/units/systems/natural.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/physics/units/systems/si.py` & `sympy.keras-1.0.4/sympy/physics/units/systems/si.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/physics/units/unitsystem.py` & `sympy.keras-1.0.4/sympy/physics/units/unitsystem.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/physics/units/util.py` & `sympy.keras-1.0.4/sympy/physics/units/util.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/physics/vector/dyadic.py` & `sympy.keras-1.0.4/sympy/physics/vector/dyadic.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,12 +1,14 @@
 from sympy.core.backend import sympify, Add, ImmutableMatrix as Matrix
 from sympy.core.compatibility import unicode
 from .printing import (VectorLatexPrinter, VectorPrettyPrinter,
                        VectorStrPrinter)
 
+__all__ = ['Dyadic']
+
 
 class Dyadic(object):
     """A Dyadic object.
 
     See:
     https://en.wikipedia.org/wiki/Dyadic_tensor
     Kane, T., Levinson, D. Dynamics Theory and Applications. 1985 McGraw-Hill
```

### Comparing `sympy.keras-1.0.21/sympy/physics/vector/fieldfunctions.py` & `sympy.keras-1.0.4/sympy/physics/vector/fieldfunctions.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,13 +1,18 @@
 from sympy import diff, integrate, S
 from sympy.physics.vector import Vector, express
 from sympy.physics.vector.frame import _check_frame
 from sympy.physics.vector.vector import _check_vector
 
 
+__all__ = ['curl', 'divergence', 'gradient', 'is_conservative',
+           'is_solenoidal', 'scalar_potential',
+           'scalar_potential_difference']
+
+
 def curl(vect, frame):
     """
     Returns the curl of a vector field computed wrt the coordinate
     symbols of the given frame.
 
     Parameters
     ==========
```

### Comparing `sympy.keras-1.0.21/sympy/physics/vector/frame.py` & `sympy.keras-1.0.4/sympy/physics/vector/frame.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,14 +1,16 @@
 from sympy.core.backend import (diff, expand, sin, cos, sympify,
                    eye, symbols, ImmutableMatrix as Matrix, MatrixBase)
 from sympy import (trigsimp, solve, Symbol, Dummy)
 
 from sympy.physics.vector.vector import Vector, _check_vector
 from sympy.utilities.misc import translate
 
+__all__ = ['CoordinateSym', 'ReferenceFrame']
+
 
 class CoordinateSym(Symbol):
     """
     A coordinate symbol/base scalar associated wrt a Reference Frame.
 
     Ideally, users should not instantiate this class. Instances of
     this class must only be accessed through the corresponding frame
```

### Comparing `sympy.keras-1.0.21/sympy/physics/vector/functions.py` & `sympy.keras-1.0.4/sympy/physics/vector/functions.py`

 * *Files 1% similar despite different names*

```diff
@@ -5,14 +5,19 @@
 from .vector import Vector, _check_vector
 from .frame import CoordinateSym, _check_frame
 from .dyadic import Dyadic
 from .printing import vprint, vsprint, vpprint, vlatex, init_vprinting
 from sympy.utilities.iterables import iterable
 from sympy.utilities.misc import translate
 
+__all__ = ['cross', 'dot', 'express', 'time_derivative', 'outer',
+           'kinematic_equations', 'get_motion_params', 'partial_velocity',
+           'dynamicsymbols', 'vprint', 'vsprint', 'vpprint', 'vlatex',
+           'init_vprinting']
+
 
 def cross(vec1, vec2):
     """Cross product convenience wrapper for Vector.cross(): \n"""
     if not isinstance(vec1, (Vector, Dyadic)):
         raise TypeError('Cross product is between two vectors')
     return vec1 ^ vec2
 cross.__doc__ += Vector.cross.__doc__
```

### Comparing `sympy.keras-1.0.21/sympy/physics/vector/point.py` & `sympy.keras-1.0.4/sympy/physics/vector/point.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,10 +1,12 @@
 from .vector import Vector, _check_vector
 from .frame import _check_frame
 
+__all__ = ['Point']
+
 
 class Point(object):
     """This object represents a point in a dynamic system.
 
     It stores the: position, velocity, and acceleration of a point.
     The position is a vector defined as the vector distance from a parent
     point to this point.
```

### Comparing `sympy.keras-1.0.21/sympy/physics/vector/printing.py` & `sympy.keras-1.0.4/sympy/physics/vector/printing.py`

 * *Files 1% similar despite different names*

```diff
@@ -2,15 +2,18 @@
 from sympy.core.function import UndefinedFunction, AppliedUndef
 from sympy.core.symbol import Symbol
 from sympy.interactive.printing import init_printing
 from sympy.printing.conventions import split_super_sub
 from sympy.printing.latex import LatexPrinter, translate
 from sympy.printing.pretty.pretty import PrettyPrinter
 from sympy.printing.pretty.pretty_symbology import center_accent
-from sympy.printing.string import StrPrinter
+from sympy.printing.str import StrPrinter
+
+__all__ = ['vprint', 'vsstrrepr', 'vsprint', 'vpprint', 'vlatex',
+           'init_vprinting']
 
 
 class VectorStrPrinter(StrPrinter):
     """String Printer for vector expressions. """
 
     def _print_Derivative(self, e):
         from sympy.physics.vector.functions import dynamicsymbols
```

### Comparing `sympy.keras-1.0.21/sympy/physics/vector/vector.py` & `sympy.keras-1.0.4/sympy/physics/vector/vector.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,13 +1,15 @@
 from sympy.core.backend import (S, sympify, expand, sqrt, Add, zeros,
     ImmutableMatrix as Matrix)
 from sympy import trigsimp
 from sympy.core.compatibility import unicode
 from sympy.utilities.misc import filldedent
 
+__all__ = ['Vector']
+
 
 class Vector(object):
     """The class used to define vectors.
 
     It along with ReferenceFrame are the building blocks of describing a
     classical mechanics system in PyDy and sympy.physics.vector.
```

### Comparing `sympy.keras-1.0.21/sympy/physics/wigner.py` & `sympy.keras-1.0.4/sympy/physics/wigner.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/plotting/experimental_lambdify.py` & `sympy.keras-1.0.4/sympy/plotting/experimental_lambdify.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/plotting/intervalmath/interval_arithmetic.py` & `sympy.keras-1.0.4/sympy/plotting/intervalmath/interval_arithmetic.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/plotting/intervalmath/interval_membership.py` & `sympy.keras-1.0.4/sympy/plotting/intervalmath/interval_membership.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/plotting/intervalmath/lib_interval.py` & `sympy.keras-1.0.4/sympy/plotting/intervalmath/lib_interval.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/plotting/plot.py` & `sympy.keras-1.0.4/sympy/plotting/plot.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/plotting/plot_implicit.py` & `sympy.keras-1.0.4/sympy/plotting/plot_implicit.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/plotting/pygletplot/__init__.py` & `sympy.keras-1.0.4/sympy/plotting/pygletplot/__init__.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/plotting/pygletplot/color_scheme.py` & `sympy.keras-1.0.4/sympy/plotting/pygletplot/color_scheme.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/plotting/pygletplot/managed_window.py` & `sympy.keras-1.0.4/sympy/plotting/pygletplot/managed_window.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/plotting/pygletplot/plot.py` & `sympy.keras-1.0.4/sympy/plotting/pygletplot/plot.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/plotting/pygletplot/plot_axes.py` & `sympy.keras-1.0.4/sympy/plotting/pygletplot/plot_axes.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/plotting/pygletplot/plot_camera.py` & `sympy.keras-1.0.4/sympy/plotting/pygletplot/plot_camera.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/plotting/pygletplot/plot_controller.py` & `sympy.keras-1.0.4/sympy/plotting/pygletplot/plot_controller.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/plotting/pygletplot/plot_curve.py` & `sympy.keras-1.0.4/sympy/plotting/pygletplot/plot_curve.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/plotting/pygletplot/plot_interval.py` & `sympy.keras-1.0.4/sympy/plotting/pygletplot/plot_interval.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/plotting/pygletplot/plot_mode.py` & `sympy.keras-1.0.4/sympy/plotting/pygletplot/plot_mode.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/plotting/pygletplot/plot_mode_base.py` & `sympy.keras-1.0.4/sympy/plotting/pygletplot/plot_mode_base.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/plotting/pygletplot/plot_modes.py` & `sympy.keras-1.0.4/sympy/plotting/pygletplot/plot_modes.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/plotting/pygletplot/plot_rotation.py` & `sympy.keras-1.0.4/sympy/plotting/pygletplot/plot_rotation.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/plotting/pygletplot/plot_surface.py` & `sympy.keras-1.0.4/sympy/plotting/pygletplot/plot_surface.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/plotting/pygletplot/plot_window.py` & `sympy.keras-1.0.4/sympy/plotting/pygletplot/plot_window.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/plotting/pygletplot/util.py` & `sympy.keras-1.0.4/sympy/plotting/pygletplot/util.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/plotting/textplot.py` & `sympy.keras-1.0.4/sympy/plotting/textplot.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/polys/agca/extensions.py` & `sympy.keras-1.0.4/sympy/polys/agca/extensions.py`

 * *Files 0% similar despite different names*

```diff
@@ -94,15 +94,15 @@
     def __ne__(f, g):
         return not f == g
 
     def __hash__(f):
         return hash((f.rep, f.ext))
 
     def __str__(f):
-        from sympy.printing.string import sstr
+        from sympy.printing.str import sstr
         return sstr(f.rep)
 
     __repr__ = __str__
 
 ExtElem = ExtensionElement
```

### Comparing `sympy.keras-1.0.21/sympy/polys/agca/homomorphisms.py` & `sympy.keras-1.0.4/sympy/polys/agca/homomorphisms.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/polys/agca/ideals.py` & `sympy.keras-1.0.4/sympy/polys/agca/ideals.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/polys/agca/modules.py` & `sympy.keras-1.0.4/sympy/polys/agca/modules.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/polys/compatibility.py` & `sympy.keras-1.0.4/sympy/polys/compatibility.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/polys/constructor.py` & `sympy.keras-1.0.4/sympy/polys/constructor.py`

 * *Files 0% similar despite different names*

```diff
@@ -166,15 +166,15 @@
 
     for coeff in coeffs:
         if coeff.is_Rational:
             if not coeff.is_Integer:
                 rationals = True
         elif coeff.is_Float:
             reals = True
-            break
+            break        
 
     if reals:
         max_prec = max([c._prec for c in coeffs])
         ground = RealField(prec=max_prec)
     elif rationals:
         ground = QQ
     else:
```

### Comparing `sympy.keras-1.0.21/sympy/polys/densearith.py` & `sympy.keras-1.0.4/sympy/polys/densearith.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/polys/densebasic.py` & `sympy.keras-1.0.4/sympy/polys/densebasic.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/polys/densetools.py` & `sympy.keras-1.0.4/sympy/polys/densetools.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/polys/dispersion.py` & `sympy.keras-1.0.4/sympy/polys/dispersion.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/polys/distributedmodules.py` & `sympy.keras-1.0.4/sympy/polys/distributedmodules.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/polys/domainmatrix.py` & `sympy.keras-1.0.4/sympy/polys/domainmatrix.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/polys/domains/complexfield.py` & `sympy.keras-1.0.4/sympy/polys/domains/complexfield.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/polys/domains/compositedomain.py` & `sympy.keras-1.0.4/sympy/polys/domains/compositedomain.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/polys/domains/domain.py` & `sympy.keras-1.0.4/sympy/polys/domains/domain.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/polys/domains/expressiondomain.py` & `sympy.keras-1.0.4/sympy/polys/domains/expressiondomain.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/polys/domains/field.py` & `sympy.keras-1.0.4/sympy/polys/domains/field.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/polys/domains/finitefield.py` & `sympy.keras-1.0.4/sympy/polys/domains/finitefield.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/polys/domains/fractionfield.py` & `sympy.keras-1.0.4/sympy/polys/domains/fractionfield.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/polys/domains/gaussiandomains.py` & `sympy.keras-1.0.4/sympy/polys/domains/gaussiandomains.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,12 +1,13 @@
 """Domains of Gaussian type."""
 
 from sympy.core.numbers import I
 from sympy.polys.polyerrors import CoercionFailed
 from sympy.polys.domains import ZZ, QQ
+from sympy.polys.domains.algebraicfield import AlgebraicField
 from sympy.polys.domains.domainelement import DomainElement
 from sympy.polys.domains.field import Field
 from sympy.polys.domains.ring import Ring
 
 
 class GaussianElement(DomainElement):
     """Base class for elements of Gaussian type domains."""
@@ -364,15 +365,14 @@
 
     def get_field(self):
         """Returns a field associated with ``self``. """
         return self
 
     def as_AlgebraicField(self):
         """Get equivalent domain as an ``AlgebraicField``. """
-        from sympy.polys.domains.realfield import AlgebraicField
         return AlgebraicField(self.dom, I)
 
     def numer(self, a):
         """Get the numerator of ``a``."""
         ZZ_I = self.get_ring()
         return ZZ_I.convert(a * self.denom(a))
```

### Comparing `sympy.keras-1.0.21/sympy/polys/domains/gmpyintegerring.py` & `sympy.keras-1.0.4/sympy/polys/domains/gmpyintegerring.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/polys/domains/gmpyrationalfield.py` & `sympy.keras-1.0.4/sympy/polys/domains/gmpyrationalfield.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/polys/domains/groundtypes.py` & `sympy.keras-1.0.4/sympy/polys/domains/groundtypes.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,9 +1,11 @@
 """Ground types for various mathematical domains in SymPy. """
 
+__all__ = []
+
 from sympy.core.compatibility import builtins, HAS_GMPY
 
 PythonInteger = builtins.int
 PythonReal = builtins.float
 PythonComplex = builtins.complex
 
 from .pythonrational import PythonRational
```

### Comparing `sympy.keras-1.0.21/sympy/polys/domains/integerring.py` & `sympy.keras-1.0.4/sympy/polys/domains/integerring.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/polys/domains/modularinteger.py` & `sympy.keras-1.0.4/sympy/polys/domains/modularinteger.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/polys/domains/mpelements.py` & `sympy.keras-1.0.4/sympy/polys/domains/mpelements.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/polys/domains/old_fractionfield.py` & `sympy.keras-1.0.4/sympy/polys/domains/old_fractionfield.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/polys/domains/old_polynomialring.py` & `sympy.keras-1.0.4/sympy/polys/domains/old_polynomialring.py`

 * *Files 0% similar despite different names*

```diff
@@ -289,15 +289,15 @@
 
     def new(self, a):
         """Construct an element of `self` domain from `a`. """
         res = self.dtype(a, self.dom, len(self.gens) - 1, ring=self)
 
         # make sure res is actually in our ring
         if res.denom().terms(order=self.order)[0][0] != (0,)*len(self.gens):
-            from sympy.printing.string import sstr
+            from sympy.printing.str import sstr
             raise CoercionFailed("denominator %s not allowed in %s"
                                  % (sstr(res), self))
         return res
 
     def __contains__(self, a):
         try:
             a = self.convert(a)
```

### Comparing `sympy.keras-1.0.21/sympy/polys/domains/polynomialring.py` & `sympy.keras-1.0.4/sympy/polys/domains/polynomialring.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/polys/domains/pythonintegerring.py` & `sympy.keras-1.0.4/sympy/polys/domains/pythonintegerring.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/polys/domains/pythonrational.py` & `sympy.keras-1.0.4/sympy/polys/domains/pythonrational.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/polys/domains/pythonrationalfield.py` & `sympy.keras-1.0.4/sympy/polys/domains/pythonrationalfield.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/polys/domains/quotientring.py` & `sympy.keras-1.0.4/sympy/polys/domains/quotientring.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/polys/domains/rationalfield.py` & `sympy.keras-1.0.4/sympy/polys/domains/rationalfield.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/polys/domains/realfield.py` & `sympy.keras-1.0.4/sympy/sets/ordinals.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,241 +1,267 @@
-"""Implementation of :class:`RealField` class. """
+from sympy.core import Basic, Integer
+import operator
 
-from sympy.core.numbers import Float
-from sympy.polys.domains.field import Field
-from sympy.polys.domains.simpledomain import SimpleDomain
-from sympy.polys.domains.characteristiczero import CharacteristicZero
-from sympy.polys.domains.mpelements import MPContext
-from sympy.polys.polyerrors import CoercionFailed
-from sympy.utilities import public
+class OmegaPower(Basic):
+    """
+    Represents ordinal exponential and multiplication terms one of the
+    building blocks of the Ordinal class.
+    In OmegaPower(a, b) a represents exponent and b represents multiplicity.
+    """
+    def __new__(cls, a, b):
+        if isinstance(b, int):
+            b = Integer(b)
+        if not isinstance(b, Integer) or b <= 0:
+            raise TypeError("multiplicity must be a positive integer")
 
-@public
-class RealField(Field, CharacteristicZero, SimpleDomain):
-    """Real numbers up to the given precision. """
+        if not isinstance(a, Ordinal):
+            a = Ordinal.convert(a)
 
-    rep = 'RR'
+        return Basic.__new__(cls, a, b)
 
-    is_RealField = is_RR = True
+    @property
+    def exp(self):
+        return self.args[0]
 
-    is_Exact = False
-    is_Numerical = True
-    is_PID = False
+    @property
+    def mult(self):
+        return self.args[1]
 
-    has_assoc_Ring = False
-    has_assoc_Field = True
+    def _compare_term(self, other, op):
+        if self.exp == other.exp:
+            return op(self.mult, other.mult)
+        else:
+            return op(self.exp, other.exp)
 
-    _default_precision = 53
+    def __eq__(self, other):
+        if not isinstance(other, OmegaPower):
+            try:
+                other = OmegaPower(0, other)
+            except TypeError:
+                return NotImplemented
+        return self.args == other.args
+
+    __hash__ = Basic.__hash__
+
+    def __lt__(self, other):
+        if not isinstance(other, OmegaPower):
+            try:
+                other = OmegaPower(0, other)
+            except TypeError:
+                return NotImplemented
+        return self._compare_term(other, operator.lt)
+
+class Ordinal(Basic):
+    """
+    Represents ordinals in Cantor normal form.
+
+    Internally, this class is just a list of instances of OmegaPower
+    Examples
+    ========
+    >>> from sympy.sets import Ordinal, ord0, OmegaPower
+    >>> from sympy.sets.ordinals import omega
+    >>> w = omega
+    >>> w.is_limit_ordinal
+    True
+    >>> Ordinal(OmegaPower(w + 1 ,1), OmegaPower(3, 2))
+    w**(w + 1) + w**3*2
+    >>> 3 + w
+    w
+    >>> (w + 1) * w
+    w**2
+
+    References
+    ==========
+
+    .. [1] https://en.wikipedia.org/wiki/Ordinal_arithmetic
+    """
+    def __new__(cls, *terms):
+        obj = super(Ordinal, cls).__new__(cls, *terms)
+        powers = [i.exp for i in obj.args]
+        if not all(powers[i] >= powers[i+1] for i in range(len(powers) - 1)):
+            raise ValueError("powers must be in decreasing order")
+        return obj
 
     @property
-    def has_default_precision(self):
-        return self.precision == self._default_precision
+    def leading_term(self):
+        if self == ord0:
+            raise ValueError("ordinal zero has no leading term")
+        return self.args[0]
 
     @property
-    def precision(self):
-        return self._context.prec
+    def trailing_term(self):
+        if self == ord0:
+            raise ValueError("ordinal zero has no trailing term")
+        return self.args[-1]
 
     @property
-    def dps(self):
-        return self._context.dps
+    def is_successor_ordinal(self):
+        try:
+            return self.trailing_term.exp == ord0
+        except ValueError:
+            return False
 
     @property
-    def tolerance(self):
-        return self._context.tolerance
+    def is_limit_ordinal(self):
+        try:
+            return not self.trailing_term.exp == ord0
+        except ValueError:
+            return False
 
-    def __init__(self, prec=_default_precision, dps=None, tol=None):
-        context = MPContext(prec, dps, tol)
-        context._parent = self
-        self._context = context
+    @property
+    def degree(self):
+        return self.leading_term.exp
 
-        self.dtype = context.mpf
-        self.zero = self.dtype(0)
-        self.one = self.dtype(1)
+    @classmethod
+    def convert(cls, integer_value):
+        if integer_value == 0:
+            return ord0
+        return Ordinal(OmegaPower(0, integer_value))
 
     def __eq__(self, other):
-        return (isinstance(other, RealField)
-           and self.precision == other.precision
-           and self.tolerance == other.tolerance)
+        if not isinstance(other, Ordinal):
+            try:
+                other = Ordinal.convert(other)
+            except TypeError:
+                return NotImplemented
+        return self.args == other.args
 
     def __hash__(self):
-        return hash((self.__class__.__name__, self.dtype, self.precision, self.tolerance))
-
-    def to_sympy(self, element):
-        """Convert ``element`` to SymPy number. """
-        return Float(element, self.dps)
-
-    def from_sympy(self, expr):
-        """Convert SymPy's number to ``dtype``. """
-        number = expr.evalf(n=self.dps)
-
-        if number.is_Number:
-            return self.dtype(number)
-        else:
-            raise CoercionFailed("expected real number, got %s" % expr)
-
-    def from_ZZ_python(self, element, base):
-        return self.dtype(element)
-
-    def from_QQ_python(self, element, base):
-        return self.dtype(element.numerator) / element.denominator
-
-    def from_ZZ_gmpy(self, element, base):
-        return self.dtype(int(element))
-
-    def from_QQ_gmpy(self, element, base):
-        return self.dtype(int(element.numerator)) / int(element.denominator)
-
-    def from_RealField(self, element, base):
-        if self == base:
-            return element
-        else:
-            return self.dtype(element)
-
-    def from_ComplexField(self, element, base):
-        if not element.imag:
-            return self.dtype(element.real)
-
-    def to_rational(self, element, limit=True):
-        """Convert a real number to rational number. """
-        return self._context.to_rational(element, limit)
-
-    def get_ring(self):
-        """Returns a ring associated with ``self``. """
-        return self
-
-    def get_exact(self):
-        """Returns an exact domain associated with ``self``. """
-        from sympy.polys.domains import QQ
-        return QQ
+        return hash(self.args)
 
-    def gcd(self, a, b):
-        """Returns GCD of ``a`` and ``b``. """
-        return self.one
+    def __lt__(self, other):
+        if not isinstance(other, Ordinal):
+            try:
+                other = Ordinal.convert(other)
+            except TypeError:
+                return NotImplemented
+        for term_self, term_other in zip(self.args, other.args):
+            if term_self != term_other:
+                return term_self < term_other
+        return len(self.args) < len(other.args)
 
-    def lcm(self, a, b):
-        """Returns LCM of ``a`` and ``b``. """
-        return a*b
+    def __le__(self, other):
+        return (self == other or self < other)
 
-    def almosteq(self, a, b, tolerance=None):
-        """Check if ``a`` and ``b`` are almost equal. """
-        return self._context.almosteq(a, b, tolerance)
+    def __gt__(self, other):
+        return not self <= other
 
-
-"""Implementation of :class:`AlgebraicField` class. """
-
-from sympy.polys.polyclasses import ANP
-from sympy.polys.polyerrors import DomainError, NotAlgebraic, IsomorphismFailed
-
-@public
-class AlgebraicField(Field, CharacteristicZero, SimpleDomain):
-    """A class for representing algebraic number fields. """
-
-    dtype = ANP
-
-    is_AlgebraicField = is_Algebraic = True
-    is_Numerical = True
-
-    has_assoc_Ring = False
-    has_assoc_Field = True
-
-    def __init__(self, dom, *ext):
-        if not dom.is_QQ:
-            raise DomainError("ground domain must be a rational field")
-
-        from sympy.polys.numberfields import to_number_field
-
-        self.orig_ext = ext
-        self.ext = to_number_field(ext)
-        self.mod = self.ext.minpoly.rep
-        self.domain = self.dom = dom
-
-        self.ngens = 1
-        self.symbols = self.gens = (self.ext,)
-        self.unit = self([dom(1), dom(0)])
-
-        self.zero = self.dtype.zero(self.mod.rep, dom)
-        self.one = self.dtype.one(self.mod.rep, dom)
-
-    def new(self, element):
-        return self.dtype(element, self.mod.rep, self.dom)
+    def __ge__(self, other):
+        return not self < other
 
     def __str__(self):
-        return str(self.dom) + '<' + str(self.ext) + '>'
-
-    def __hash__(self):
-        return hash((self.__class__.__name__, self.dtype, self.dom, self.ext))
-
-    def __eq__(self, other):
-        """Returns ``True`` if two domains are equivalent. """
-        return isinstance(other, AlgebraicField) and \
-            self.dtype == other.dtype and self.ext == other.ext
-
-    def algebraic_field(self, *extension):
-        r"""Returns an algebraic field, i.e. `\mathbb{Q}(\alpha, \ldots)`. """
-        return AlgebraicField(self.dom, *((self.ext,) + extension))
-
-    def to_sympy(self, a):
-        """Convert ``a`` to a SymPy object. """
-        from sympy.polys.numberfields import AlgebraicNumber
-        return AlgebraicNumber(self.ext, a).as_expr()
+        net_str = ""
+        plus_count = 0
+        if self == ord0:
+            return 'ord0'
+        for i in self.args:
+            if plus_count:
+                net_str += " + "
+
+            if i.exp == ord0:
+                net_str += str(i.mult)
+            elif i.exp == 1:
+                net_str += 'w'
+            elif len(i.exp.args) > 1 or i.exp.is_limit_ordinal:
+                net_str += 'w**(%s)'%i.exp
+            else:
+                net_str += 'w**%s'%i.exp
+
+            if not i.mult == 1 and not i.exp == ord0:
+                net_str += '*%s'%i.mult
+
+            plus_count += 1
+        return(net_str)
+
+    __repr__ = __str__
+
+    def __add__(self, other):
+        if not isinstance(other, Ordinal):
+            try:
+                other = Ordinal.convert(other)
+            except TypeError:
+                return NotImplemented
+        if other == ord0:
+            return self
+        a_terms = list(self.args)
+        b_terms = list(other.args)
+        r = len(a_terms) - 1
+        b_exp = other.degree
+        while r >= 0 and a_terms[r].exp < b_exp:
+            r -= 1
+        if r < 0:
+            terms = b_terms
+        elif a_terms[r].exp == b_exp:
+            sum_term = OmegaPower(b_exp, a_terms[r].mult + other.leading_term.mult)
+            terms = a_terms[:r] + [sum_term] + b_terms[1:]
+        else:
+            terms = a_terms[:r+1] + b_terms
+        return Ordinal(*terms)
 
-    def from_sympy(self, a):
-        """Convert SymPy's expression to ``dtype``. """
-        try:
-            return self([self.dom.from_sympy(a)])
-        except CoercionFailed:
-            pass
+    def __radd__(self, other):
+        if not isinstance(other, Ordinal):
+            try:
+                other = Ordinal.convert(other)
+            except TypeError:
+                return NotImplemented
+        return other + self
+
+    def __mul__(self, other):
+        if not isinstance(other, Ordinal):
+            try:
+                other = Ordinal.convert(other)
+            except TypeError:
+                return NotImplemented
+        if ord0 in (self, other):
+            return ord0
+        a_exp = self.degree
+        a_mult = self.leading_term.mult
+        sum = []
+        if other.is_limit_ordinal:
+            for arg in other.args:
+                sum.append(OmegaPower(a_exp + arg.exp, arg.mult))
 
-        from sympy.polys.numberfields import to_number_field
+        else:
+            for arg in other.args[:-1]:
+                sum.append(OmegaPower(a_exp + arg.exp, arg.mult))
+            b_mult = other.trailing_term.mult
+            sum.append(OmegaPower(a_exp, a_mult*b_mult))
+            sum += list(self.args[1:])
+        return Ordinal(*sum)
+
+    def __rmul__(self, other):
+        if not isinstance(other, Ordinal):
+            try:
+                other = Ordinal.convert(other)
+            except TypeError:
+                return NotImplemented
+        return other * self
+
+    def __pow__(self, other):
+        if not self == omega:
+            return NotImplemented
+        return Ordinal(OmegaPower(other, 1))
+
+class OrdinalZero(Ordinal):
+    """The ordinal zero.
+
+    OrdinalZero can be imported as ``ord0``.
+    """
+    pass
+
+class OrdinalOmega(Ordinal):
+    """The ordinal omega which forms the base of all ordinals in cantor normal form.
+
+    OrdinalOmega can be imported as ``omega``.
+
+    Examples
+    ========
+
+    >>> from sympy.sets.ordinals import omega
+    >>> omega + omega
+    w*2
+    """
+    def __new__(cls):
+        return Ordinal.__new__(cls, OmegaPower(1, 1))
 
-        try:
-            return self(to_number_field(a, self.ext).native_coeffs())
-        except (NotAlgebraic, IsomorphismFailed):
-            raise CoercionFailed(
-                "%s is not a valid algebraic number in %s" % (a, self))
-
-    def from_ZZ_python(K1, a, K0):
-        """Convert a Python ``int`` object to ``dtype``. """
-        return K1(K1.dom.convert(a, K0))
-
-    def from_QQ_python(K1, a, K0):
-        """Convert a Python ``Fraction`` object to ``dtype``. """
-        return K1(K1.dom.convert(a, K0))
-
-    def from_ZZ_gmpy(K1, a, K0):
-        """Convert a GMPY ``mpz`` object to ``dtype``. """
-        return K1(K1.dom.convert(a, K0))
-
-    def from_QQ_gmpy(K1, a, K0):
-        """Convert a GMPY ``mpq`` object to ``dtype``. """
-        return K1(K1.dom.convert(a, K0))
-
-    def from_RealField(K1, a, K0):
-        """Convert a mpmath ``mpf`` object to ``dtype``. """
-        return K1(K1.dom.convert(a, K0))
-
-    def get_ring(self):
-        """Returns a ring associated with ``self``. """
-        raise DomainError('there is no ring associated with %s' % self)
-
-    def is_positive(self, a):
-        """Returns True if ``a`` is positive. """
-        return self.dom.is_positive(a.LC())
-
-    def is_negative(self, a):
-        """Returns True if ``a`` is negative. """
-        return self.dom.is_negative(a.LC())
-
-    def is_nonpositive(self, a):
-        """Returns True if ``a`` is non-positive. """
-        return self.dom.is_nonpositive(a.LC())
-
-    def is_nonnegative(self, a):
-        """Returns True if ``a`` is non-negative. """
-        return self.dom.is_nonnegative(a.LC())
-
-    def numer(self, a):
-        """Returns numerator of ``a``. """
-        return a
-
-    def denom(self, a):
-        """Returns denominator of ``a``. """
-        return self.one
+ord0 = OrdinalZero()
+omega = OrdinalOmega()
```

### Comparing `sympy.keras-1.0.21/sympy/polys/domains/ring.py` & `sympy.keras-1.0.4/sympy/polys/domains/ring.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/polys/euclidtools.py` & `sympy.keras-1.0.4/sympy/polys/euclidtools.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/polys/factortools.py` & `sympy.keras-1.0.4/sympy/polys/factortools.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/polys/fglmtools.py` & `sympy.keras-1.0.4/sympy/polys/fglmtools.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/polys/fields.py` & `sympy.keras-1.0.4/sympy/polys/fields.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/polys/galoistools.py` & `sympy.keras-1.0.4/sympy/polys/galoistools.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/polys/groebnertools.py` & `sympy.keras-1.0.4/sympy/polys/groebnertools.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/polys/heuristicgcd.py` & `sympy.keras-1.0.4/sympy/polys/heuristicgcd.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/polys/modulargcd.py` & `sympy.keras-1.0.4/sympy/polys/modulargcd.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/polys/monomials.py` & `sympy.keras-1.0.4/sympy/polys/monomials.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/polys/multivariate_resultants.py` & `sympy.keras-1.0.4/sympy/polys/multivariate_resultants.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/polys/numberfields.py` & `sympy.keras-1.0.4/sympy/polys/numberfields.py`

 * *Files 1% similar despite different names*

```diff
@@ -799,14 +799,15 @@
         if result.coeff(x**degree(result, x)) < 0:
             result = expand_mul(-result)
 
     return result
 
 
 minpoly = minimal_polynomial
+__all__.append('minpoly')
 
 def _coeffs_generator(n):
     """Generate coefficients for `primitive_element()`. """
     for coeffs in variations([1, -1, 2, -2, 3, -3], n, repetition=True):
         # Two linear combinations with coeffs of opposite signs are
         # opposites of each other. Hence it suffices to test only one.
         if coeffs[0] > 0:
```

### Comparing `sympy.keras-1.0.21/sympy/polys/orderings.py` & `sympy.keras-1.0.4/sympy/polys/orderings.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,9 +1,11 @@
 """Definitions of monomial orderings. """
 
+__all__ = ["lex", "grlex", "grevlex", "ilex", "igrlex", "igrevlex"]
+
 from sympy.core import Symbol
 from sympy.core.compatibility import iterable
 
 class MonomialOrder(object):
     """Base class for monomial orderings. """
 
     alias = None
```

### Comparing `sympy.keras-1.0.21/sympy/polys/orthopolys.py` & `sympy.keras-1.0.4/sympy/polys/orthopolys.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/polys/partfrac.py` & `sympy.keras-1.0.4/sympy/polys/partfrac.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/polys/polyclasses.py` & `sympy.keras-1.0.4/sympy/polys/polyclasses.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/polys/polyconfig.py` & `sympy.keras-1.0.4/sympy/polys/polyconfig.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/polys/polyerrors.py` & `sympy.keras-1.0.4/sympy/polys/polyerrors.py`

 * *Files 0% similar despite different names*

```diff
@@ -12,15 +12,15 @@
 @public
 class ExactQuotientFailed(BasePolynomialError):
 
     def __init__(self, f, g, dom=None):
         self.f, self.g, self.dom = f, g, dom
 
     def __str__(self):  # pragma: no cover
-        from sympy.printing.string import sstr
+        from sympy.printing.str import sstr
 
         if self.dom is None:
             return "%s does not divide %s" % (sstr(self.g), sstr(self.f))
         else:
             return "%s does not divide %s in %s" % (sstr(self.g), sstr(self.f), sstr(self.dom))
 
     def new(self, f, g):
```

### Comparing `sympy.keras-1.0.21/sympy/polys/polyfuncs.py` & `sympy.keras-1.0.4/sympy/polys/polyfuncs.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/polys/polymatrix.py` & `sympy.keras-1.0.4/sympy/polys/polymatrix.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/polys/polyoptions.py` & `sympy.keras-1.0.4/sympy/polys/polyoptions.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,9 +1,11 @@
 """Options manager for :class:`Poly` and public API functions. """
 
+__all__ = ["Options"]
+
 from sympy.core import S, Basic, sympify
 from sympy.core.compatibility import with_metaclass
 from sympy.polys.polyerrors import GeneratorsError, OptionError, FlagError
 from sympy.utilities import numbered_symbols, topological_sort, public
 from sympy.utilities.iterables import has_dups
 
 import sympy.polys
@@ -274,19 +276,18 @@
 
     @classmethod
     def default(cls):
         return ()
 
     @classmethod
     def preprocess(cls, gens): 
-        from sympy import Symbol, Function, Pow, Sliced, Indexed
-        from sympy.concrete.expr_with_limits import AddWithLimits
+        from sympy import Symbol, Function, Pow, Sum, Sliced, Indexed
         if isinstance(gens, Basic):
             gens = (gens,)
-        elif len(gens) == 1 and hasattr(gens[0], '__iter__') and not isinstance(gens[0], (Sliced, Indexed, Symbol, Function, Pow, AddWithLimits)):
+        elif len(gens) == 1 and hasattr(gens[0], '__iter__') and not isinstance(gens[0], (Sliced, Indexed, Symbol, Function, Pow, Sum)):
             gens = gens[0]
 
         if gens == (None,):
             gens = ()
         elif has_dups(gens):
             raise GeneratorsError("duplicated generators: %s" % str(gens))
 #         elif any(gen.is_commutative == False for gen in gens):
```

### Comparing `sympy.keras-1.0.21/sympy/polys/polyquinticconst.py` & `sympy.keras-1.0.4/sympy/polys/polyquinticconst.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/polys/polyroots.py` & `sympy.keras-1.0.4/sympy/polys/polyroots.py`

 * *Files 0% similar despite different names*

```diff
@@ -590,15 +590,15 @@
     for i in range(1, 5):
         for j in range(5):
             Res_n[i][j] = Res[i][j].n()
             Res[i][j] = _quintic_simplify(Res[i][j])
     r1 = Res[1][0]
     r1_n = Res_n[1][0]
 
-    from sympy import Im
+    from sympy import Im 
     for i in range(5):
         if comp(Im(r1_n * Res_n[4][i]), 0, tol):
             r4 = Res[4][i]
             break
 
     # Now we have various Res values. Each will be a list of five
     # values. We have to pick one r value from those five for each Res
```

### Comparing `sympy.keras-1.0.21/sympy/polys/polytools.py` & `sympy.keras-1.0.4/sympy/polys/polytools.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/polys/polyutils.py` & `sympy.keras-1.0.4/sympy/polys/polyutils.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/polys/rationaltools.py` & `sympy.keras-1.0.4/sympy/polys/rationaltools.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/polys/ring_series.py` & `sympy.keras-1.0.4/sympy/polys/ring_series.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/polys/rings.py` & `sympy.keras-1.0.4/sympy/polys/rings.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/polys/rootisolation.py` & `sympy.keras-1.0.4/sympy/polys/rootisolation.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/polys/rootoftools.py` & `sympy.keras-1.0.4/sympy/polys/rootoftools.py`

 * *Files 0% similar despite different names*

```diff
@@ -21,14 +21,18 @@
     dup_isolate_real_roots_sqf)
 from sympy.utilities import lambdify, public, sift
 
 from mpmath import mpf, mpc, findroot, workprec
 from mpmath.libmp.libmpf import dps_to_prec, prec_to_dps
 
 
+__all__ = ['CRootOf']
+
+
+
 class _pure_key_dict(object):
     """A minimal dictionary that makes sure that the key is a
     univariate PurePoly instance.
 
     Examples
     ========
```

### Comparing `sympy.keras-1.0.21/sympy/polys/solvers.py` & `sympy.keras-1.0.4/sympy/polys/solvers.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/polys/specialpolys.py` & `sympy.keras-1.0.4/sympy/polys/specialpolys.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/polys/sqfreetools.py` & `sympy.keras-1.0.4/sympy/polys/sqfreetools.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/polys/subresultants_qq_zz.py` & `sympy.keras-1.0.4/sympy/polys/subresultants_qq_zz.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/printing/c.py` & `sympy.keras-1.0.4/sympy/printing/c.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/printing/codeprinter.py` & `sympy.keras-1.0.4/sympy/printing/codeprinter.py`

 * *Files 0% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 
 from sympy.core import Add, Mul, Pow, S, sympify, Float
 from sympy.core.basic import Basic
 from sympy.core.compatibility import default_sort_key
 from sympy.core.function import Lambda
 from sympy.core.mul import _keep_coeff
 from sympy.core.symbol import Symbol
-from sympy.printing.string import StrPrinter
+from sympy.printing.str import StrPrinter
 from sympy.printing.precedence import precedence
 
 # Backwards compatibility
 from sympy.codegen.ast import Assignment
 
 
 class requires(object):
```

### Comparing `sympy.keras-1.0.21/sympy/printing/conventions.py` & `sympy.keras-1.0.4/sympy/printing/conventions.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/printing/cxx.py` & `sympy.keras-1.0.4/sympy/printing/cxx.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/printing/defaults.py` & `sympy.keras-1.0.4/sympy/printing/defaults.py`

 * *Files 2% similar despite different names*

```diff
@@ -8,11 +8,11 @@
     a class to get proper default printing.
 
     """
 
     # Note, we always use the default ordering (lex) in __str__ and __repr__,
     # regardless of the global setting. See issue 5487.
     def __str__(self):
-        from sympy.printing.string import sstr
+        from sympy.printing.str import sstr
         return sstr(self, order=None)
 
     __repr__ = __str__
```

### Comparing `sympy.keras-1.0.21/sympy/printing/dot.py` & `sympy.keras-1.0.4/sympy/printing/dot.py`

 * *Files 2% similar despite different names*

```diff
@@ -3,14 +3,15 @@
 from sympy.core.symbol import Symbol
 from sympy.core.numbers import Integer, Rational, Float
 from sympy.core.compatibility import default_sort_key
 from sympy.core.add import Add
 from sympy.core.mul import Mul
 from sympy.printing.repr import srepr
 
+__all__ = ['dotprint']
 
 default_styles = (
     (Basic, {'color': 'blue', 'shape': 'ellipse'}),
     (Expr,  {'color': 'black'})
 )
 
 slotClasses = (Symbol, Integer, Rational, Float)
```

### Comparing `sympy.keras-1.0.21/sympy/printing/fortran.py` & `sympy.keras-1.0.4/sympy/printing/fortran.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/printing/glsl.py` & `sympy.keras-1.0.4/sympy/printing/glsl.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/printing/jscode.py` & `sympy.keras-1.0.4/sympy/printing/jscode.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/printing/julia.py` & `sympy.keras-1.0.4/sympy/printing/julia.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/printing/lambdarepr.py` & `sympy.keras-1.0.4/sympy/printing/lambdarepr.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/printing/latex.py` & `sympy.keras-1.0.4/sympy/printing/latex.py`

 * *Files 0% similar despite different names*

```diff
@@ -479,24 +479,20 @@
           - if it is a recognized latex name, use the appropriate latex command
           - if it is a single letter, just use that letter
           - if it is a longer name, then put \operatorname{} around it and be
             mindful of undercores in the name
         '''
         func = self._deal_with_super_sub(func)
         if func in accepted_latex_functions:
-            func = r"\%s" % func
-        elif len(func) == 1:
-            from std.unicode import ascii2greek
-            if func == ascii2greek('phi'):
-                func = '\\phi'
-        elif func.startswith('\\'):
-            ...
+            name = r"\%s" % func
+        elif len(func) == 1 or func.startswith('\\'):
+            name = func
         else:
-            func = r"\operatorname{%s}" % func
-        return func
+            name = r"\operatorname{%s}" % func
+        return name
 
     def _print_UndefinedFunction(self, expr):
         return self._hprint_Function(str(expr))
 
     def _print_ElementwiseApplyFunction(self, expr):
         return r"%s\left({%s}\ldots\right)" % (
             self._print(expr.function),
```

### Comparing `sympy.keras-1.0.21/sympy/printing/llvmjitcode.py` & `sympy.keras-1.0.4/sympy/printing/llvmjitcode.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/printing/maple.py` & `sympy.keras-1.0.4/sympy/printing/maple.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/printing/mathematica.py` & `sympy.keras-1.0.4/sympy/printing/mathematica.py`

 * *Files 1% similar despite different names*

```diff
@@ -253,15 +253,15 @@
         return "Hold[Integrate[" + ', '.join(self.doprint(a) for a in args) + "]]"
 
     def _print_Sum(self, expr):
         return "Hold[Sum[" + ', '.join(self.doprint(a) for a in expr.args) + "]]"
 
     def _print_Derivative(self, expr):
         dexpr = expr.expr
-        dvars = [i[0] if i[1] == 1 else i for i in expr.limits]
+        dvars = [i[0] if i[1] == 1 else i for i in expr.variable_count]
         return "Hold[D[" + ', '.join(self.doprint(a) for a in [dexpr] + dvars) + "]]"
 
 
     def _get_comment(self, text):
         return "(* {} *)".format(text)
```

### Comparing `sympy.keras-1.0.21/sympy/printing/mathml.py` & `sympy.keras-1.0.4/sympy/printing/mathml.py`

 * *Files 0% similar despite different names*

```diff
@@ -426,15 +426,15 @@
         x = self.dom.createElement('apply')
         diff_symbol = self.mathml_tag(e)
         if requires_partial(e):
             diff_symbol = 'partialdiff'
         x.appendChild(self.dom.createElement(diff_symbol))
         x_1 = self.dom.createElement('bvar')
 
-        for sym, times in reversed(e.limits):
+        for sym, times in reversed(e.variable_count):
             x_1.appendChild(self._print(sym))
             if times > 1:
                 degree = self.dom.createElement('degree')
                 degree.appendChild(self._print(sympify(times)))
                 x_1.appendChild(degree)
 
         x.appendChild(x_1)
@@ -970,15 +970,15 @@
             d = '&#x2202;'
         else:
             d = self.mathml_tag(e)
 
         # Determine denominator
         m = self.dom.createElement('mrow')
         dim = 0  # Total diff dimension, for numerator
-        for sym, num in reversed(e.limits):
+        for sym, num in reversed(e.variable_count):
             dim += num
             if num >= 2:
                 x = self.dom.createElement('msup')
                 xx = self.dom.createElement('mo')
                 xx.appendChild(self.dom.createTextNode(d))
                 x.appendChild(xx)
                 x.appendChild(self._print(num))
```

### Comparing `sympy.keras-1.0.21/sympy/printing/octave.py` & `sympy.keras-1.0.4/sympy/printing/octave.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/printing/precedence.py` & `sympy.keras-1.0.4/sympy/printing/precedence.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/printing/pretty/pretty.py` & `sympy.keras-1.0.4/sympy/printing/pretty/pretty.py`

 * *Files 0% similar despite different names*

```diff
@@ -7,15 +7,15 @@
 from sympy.core.numbers import Rational
 from sympy.core.relational import Equal
 from sympy.core.symbol import Symbol
 from sympy.core.sympify import SympifyError
 from sympy.printing.conventions import requires_partial
 from sympy.printing.precedence import PRECEDENCE, precedence_traditional
 from sympy.printing.printer import Printer
-from sympy.printing.string import sstr
+from sympy.printing.str import sstr
 from sympy.utilities import default_sort_key
 from sympy.utilities.iterables import has_variety
 
 from sympy.printing.pretty.stringpict import prettyForm, stringPict
 from sympy.printing.pretty.pretty_symbology import xstr, hobj, vobj, xobj, \
     xsym, pretty_symbol, pretty_atom, pretty_use_unicode, greek_unicode, U, \
     pretty_try_use_unicode,  annotated
@@ -335,15 +335,15 @@
         if requires_partial(deriv) and self._use_unicode:
             deriv_symbol = U('PARTIAL DIFFERENTIAL')
         else:
             deriv_symbol = r'd'
         x = None
         count_total_deriv = 0
 
-        for sym, num in reversed(deriv.limits):
+        for sym, num in reversed(deriv.variable_count):
             s = self._print(sym)
             ds = prettyForm(*s.left(deriv_symbol))
             count_total_deriv += num
 
             if (not num.is_Integer) or (num > 1):
                 ds = ds**prettyForm(str(num))
```

### Comparing `sympy.keras-1.0.21/sympy/printing/pretty/pretty_symbology.py` & `sympy.keras-1.0.4/sympy/printing/pretty/pretty_symbology.py`

 * *Files 1% similar despite different names*

```diff
@@ -33,14 +33,17 @@
 
 # prefix conventions when constructing tables
 # L   - LATIN     i
 # G   - GREEK     beta
 # D   - DIGIT     0
 # S   - SYMBOL    +
 
+__all__ = ['greek_unicode', 'sub', 'sup', 'xsym', 'vobj', 'hobj', 'pretty_symbol',
+           'annotated']
+
 _use_unicode = False
 
 
 def pretty_use_unicode(flag=None):
     """Set whether pretty-printer should use unicode by default"""
     global _use_unicode
     global unicode_warnings
```

### Comparing `sympy.keras-1.0.21/sympy/printing/pretty/stringpict.py` & `sympy.keras-1.0.4/sympy/printing/pretty/stringpict.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/printing/preview.py` & `sympy.keras-1.0.4/sympy/printing/preview.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/printing/printer.py` & `sympy.keras-1.0.4/sympy/printing/printer.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/printing/pycode.py` & `sympy.keras-1.0.4/sympy/printing/pycode.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/printing/python.py` & `sympy.keras-1.0.4/sympy/printing/python.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,13 +1,13 @@
 # -*- coding: utf-8 -*-
 
 import keyword as kw
 import sympy
 from .repr import ReprPrinter
-from .string import StrPrinter
+from .str import StrPrinter
 
 # A list of classes that should be printed using StrPrinter
 STRPRINT = ("Add", "Infinity", "Integer", "Mul", "NegativeInfinity",
             "Pow", "Zero")
 
 
 class PythonPrinter(ReprPrinter, StrPrinter):
```

### Comparing `sympy.keras-1.0.21/sympy/printing/rcode.py` & `sympy.keras-1.0.4/sympy/printing/rcode.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/printing/repr.py` & `sympy.keras-1.0.4/sympy/printing/repr.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/printing/rust.py` & `sympy.keras-1.0.4/sympy/printing/rust.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/printing/string.py` & `sympy.keras-1.0.4/sympy/printing/str.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/printing/tableform.py` & `sympy.keras-1.0.4/sympy/printing/tableform.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/printing/tensorflow.py` & `sympy.keras-1.0.4/sympy/printing/tensorflow.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/printing/theanocode.py` & `sympy.keras-1.0.4/sympy/printing/theanocode.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/printing/tree.py` & `sympy.keras-1.0.4/sympy/printing/tree.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/sandbox/indexed_integrals.py` & `sympy.keras-1.0.4/sympy/sandbox/indexed_integrals.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/series/acceleration.py` & `sympy.keras-1.0.4/sympy/series/acceleration.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/series/approximants.py` & `sympy.keras-1.0.4/sympy/series/approximants.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/series/formal.py` & `sympy.keras-1.0.4/sympy/series/formal.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/series/fourier.py` & `sympy.keras-1.0.4/sympy/series/fourier.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/series/gruntz.py` & `sympy.keras-1.0.4/sympy/series/gruntz.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/series/kauers.py` & `sympy.keras-1.0.4/sympy/series/kauers.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/series/limits.py` & `sympy.keras-1.0.4/sympy/series/limits.py`

 * *Files 12% similar despite different names*

```diff
@@ -287,15 +287,15 @@
     def dtype(self):
         expr = self.expr
         if expr.is_set:
             return expr.dtype
         
         from sympy import dtype
         if not expr.is_real:
-            return dtype.complex
+            return dtype.complex        
         return dtype.real
 
     @property
     def is_set(self):
         return self.expr.is_set
     
     @cacheit
@@ -424,86 +424,8 @@
     def _subs(self, old, new, **hints):
         if old == self.variable:
             return self
         
         return Expr._subs(self, old, new, **hints)
     
     def _eval_is_super_real(self):
-        return self.expr.is_super_real
-    
-    def _eval_is_random(self):
-        if self.expr.is_random:
-            return True
-
-        for x, *ab in self.limits:
-            for v in ab:
-                if v.is_random:
-                    return True
-
-    def _eval_is_extended_negative(self):
-        is_extended_negative = self.expr.is_extended_negative
-        if is_extended_negative == False:
-            return False
-
-    def _eval_is_extended_positive(self):
-        is_extended_positive = self.expr.is_extended_positive
-        if is_extended_positive == False:
-            return False
-
-    def yield_random_symbols(self):
-        limits = self.limits
-        for v in self.expr.yield_random_symbols():
-            if v.is_Indexed:
-                x, *indices = v.args
-                slices = [*indices]
-                is_random = False
-                for i, index in enumerate(indices):
-                    if index.is_random:
-                        is_random = True
-                        break
-
-                    for v, *ab in limits:
-                        if index._has(v):
-                            if v.is_integer and ab and len(ab) == 2 and not isinstance(slices[i], slice):
-                                a, b = ab
-#                                 f(x) = k * x + h
-                                h, k = slices[i].of_simple_poly(v)
-                                if k:
-                                    if k > 0:
-                                        start = slices[i]._subs(v, a)
-                                        stop = slices[i]._subs(v, b)
-                                        slices[i] = slice(start, stop, k)
-                                    elif k < 0:
-                                        stop = slices[i]._subs(v, a - 1)
-                                        start = slices[i]._subs(v, b - 1)
-                                        slices[i] = slice(start, stop, -k)
-                                    else:
-                                        slices[i] = slice(None, None)
-                                else:
-                                    slices[i] = slice(None, None)
-                            else:
-                                slices[i] = slice(None, None)
-                                break
-                    
-                if is_random:
-                    yield v
-                else:
-                    yield x[tuple(slices)]
-
-            else:                    
-                yield v
-
-        for x, *ab in limits:
-            for v in ab:
-                yield from v.yield_random_symbols()
-
-    def limits_in_context(self, has_args=None, parent=None):
-        limits = []
-        from sympy import Range, Interval, oo
-        for z, z0, dir in reversed(self.limits):
-            if not z.shape and z0.is_infinite:
-                if z.is_integer:
-                    limits.append((z, Range(1, oo) if dir < 0 else Range(-oo, 0)))
-                else:
-                    limits.append((z, Interval(1, oo) if dir < 0 else Interval(-oo, -1)))
-
-        return limits
+        return self.expr.is_super_real
```

### Comparing `sympy.keras-1.0.21/sympy/series/limitseq.py` & `sympy.keras-1.0.4/sympy/series/limitseq.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/series/order.py` & `sympy.keras-1.0.4/sympy/series/order.py`

 * *Files 1% similar despite different names*

```diff
@@ -287,19 +287,19 @@
         else:
             return ()
 
     @cacheit
     def _eval_free_symbols(self):
         return self.expr.free_symbols | set(self.variables)
 
-    def _eval_power(self, e):
+    def _eval_power(b, e):
         if e.is_Number and e.is_nonnegative:
-            return self.func(self.expr ** e, *self.args[1:])
+            return b.func(b.expr ** e, *b.args[1:])
         if e == O(1):
-            return self
+            return b
         return
 
     def as_expr_variables(self, order_symbols):
         if order_symbols is None:
             order_symbols = self.args[1:]
         else:
             if (not all(o[1] == order_symbols[0][1] for o in order_symbols) and
```

### Comparing `sympy.keras-1.0.21/sympy/series/residues.py` & `sympy.keras-1.0.4/sympy/series/residues.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/series/sequences.py` & `sympy.keras-1.0.4/sympy/series/sequences.py`

 * *Files 0% similar despite different names*

```diff
@@ -91,15 +91,16 @@
         ========
 
         >>> from sympy import SeqFormula
         >>> from sympy.abc import n, m
         >>> SeqFormula(m*n**2, (n, 0, 5)).free_symbols
         {m}
         """
-        return (set(j for i in self.args for j in i.free_symbols.difference(self.variables)))
+        return (set(j for i in self.args for j in i.free_symbols
+                   .difference(self.variables)))
 
     @cacheit
     def coeff(self, pt):
         """Returns the coefficient at point pt"""
         if pt < self.start or pt > self.stop:
             raise IndexError("Index %s out of bounds %s" % (pt, self.interval))
         return self._eval_coeff(pt)
```

### Comparing `sympy.keras-1.0.21/sympy/series/series_class.py` & `sympy.keras-1.0.4/sympy/series/series_class.py`

 * *Files 0% similar despite different names*

```diff
@@ -39,15 +39,16 @@
 
     @cacheit
     def _eval_free_symbols(self):
         """
         This method returns the symbols in the object, excluding those
         that take on a specific value (i.e. the dummy symbols).
         """
-        return (set(j for i in self.args for j in i.free_symbols).difference(self.variables))
+        return (set(j for i in self.args for j in i.free_symbols)
+                .difference(self.variables))
 
     @cacheit
     def term(self, pt):
         """Term at point pt of a series"""
         if pt < self.start or pt > self.stop:
             raise IndexError("Index %s out of bounds %s" % (pt, self.interval))
         return self._eval_term(pt)
```

### Comparing `sympy.keras-1.0.21/sympy/sets/__init__.py` & `sympy.keras-1.0.4/sympy/sets/__init__.py`

 * *Files 1% similar despite different names*

```diff
@@ -12,13 +12,13 @@
 
 from sympy.sets.setexpr import Card, Measure
 from sympy.core.cache import cacheit
 
 PositiveIntegers = Range(1, S.Infinity)
 NonnegativeIntegers = Range(S.Infinity)
 
-Naturals = PositiveIntegers
+Naturals = PositiveIntegers 
 Naturals0 = NonnegativeIntegers
 
 Integers = Range(S.NegativeInfinity, S.Infinity)
 ExtendedIntegers = Range(S.NegativeInfinity, S.Infinity, left_open=False, right_open=False)
 del S
```

### Comparing `sympy.keras-1.0.21/sympy/sets/contains.py` & `sympy.keras-1.0.4/sympy/sets/contains.py`

 * *Files 7% similar despite different names*

```diff
@@ -56,15 +56,15 @@
         return r"%s \in %s" % tuple(p._print(a) for a in self.args)
 
     def _sympystr(self, p):
         return "%s \N{ELEMENT OF} %s" % tuple(p._print(a) for a in self.args)
 
     def _pretty(self, p):
         from sympy.printing.pretty.stringpict import prettyForm, stringPict
-        from sympy.printing.string import sstr
+        from sympy.printing.str import sstr
         
         var, s = self.args
         if p._use_unicode:
             el = u" \N{ELEMENT OF} "
             return prettyForm(*stringPict.next(p._print(var),
                                                el, p._print(s)), binding=8)
         else:
@@ -135,20 +135,18 @@
         return self
 
     def __and__(self, other):
         """Overloading for & operator"""
         if other.is_NotElement:
             if self.element == other.element:
                 return self.func(self.element, self.rhs - other.rhs).simplify()
-
         elif other.is_Element:
             if self.element == other.element:
                 s = self.rhs & other.rhs
                 return self.func(self.element, s)
-
         elif self.rhs.is_Range or self.rhs.is_Interval:
             if other.is_LessEqual: 
                 if self.lhs == other.lhs:
                     if self.rhs.left_open:
                         if other.rhs <= self.rhs.start:
                             return S.false
                     else: 
@@ -208,15 +206,15 @@
                 c1 = poly.nth(1)
                 c0 = poly.nth(0)
                 if c1 == 1:
                     interval = interval.func(interval.start - c0, interval.stop - c0, interval.step, **interval.kwargs)
                     return domain & interval
                 elif c1 == -1:
                     interval = interval.func(c0 - interval.stop, c0 - interval.start, interval.step, left_open=interval.right_open, right_open=interval.left_open)
-                    return domain & interval
+                    return domain & interval                            
       
         elif interval.is_Interval: 
             poly = self.lhs.as_poly(x)
             if poly is not None and poly.degree() == 1:
                 c1 = poly.nth(1)
                 c0 = poly.nth(0)
                 if c1 > 0:
@@ -235,19 +233,14 @@
         if x in limits_dict:
             domain = limits_dict[x]
             if not isinstance(domain, list):
                 if domain.is_set:
                     if domain in function.rhs:
                         return S.BooleanTrue
 
-    @classmethod
-    def class_key(cls):
-        """Nice order of classes. """
-        return 5, 1, cls.__name__
-
 
 class NotElement(BinaryCondition):
     """
     Asserts that x is not an element of the set S
 
     Examples
     ========
@@ -297,15 +290,15 @@
         return r"%s \not\in %s" % tuple(p._print(a) for a in self.args)
 
     def _sympystr(self, p):
         return "%s \N{NOT AN ELEMENT OF} %s" % tuple(p._print(a) for a in self.args)
 
     def _pretty(self, p):
         from sympy.printing.pretty.stringpict import prettyForm, stringPict
-        from sympy.printing.string import sstr
+        from sympy.printing.str import sstr
         
         var, s = self.args
         if p._use_unicode:
             el = u" \N{NOT AN ELEMENT OF} "
             return prettyForm(*stringPict.next(p._print(var),
                                                el, p._print(s)), binding=8)
         else:
@@ -336,17 +329,17 @@
 
     def simplify(self, deep=False):
         e, s = self.args
         this = s.func.simplify_NotElement(self, e, s)
         if this is not None:
             return this
             
-        finiteset = e.domain - s
-        if finiteset.is_FiniteSet:
-            return self.invert_type(e, finiteset).simplify()
+        domain = e.domain - s
+        if domain.is_FiniteSet:
+            return self.invert_type(e, domain).simplify()
         
         return self
 
     def __and__(self, other):
         if other.is_NotElement:
             if self.element == other.element:
                 s = self.rhs | other.rhs
@@ -410,19 +403,14 @@
     def simplify_ForAll(cls, self, function, *limits):
         element, container = function.args
         forall = self.limits_dict
         if element in forall:
             if forall[element] == container:
                 return S.BooleanFalse
 
-    @classmethod
-    def class_key(cls):
-        """Nice order of classes. """
-        return 5, 2, cls.__name__
-
 
 class Contains(BinaryCondition):
     """
     Asserts that x is an element of the set S
 
     Examples
     ========
@@ -455,15 +443,15 @@
 
     def _sympystr(self, p):
         # unicodedata.lookup('CONTAINS AS MEMBER'), '\N{CONTAINS AS MEMBER}'
         return "%s \N{CONTAINS AS MEMBER} %s" % tuple(p._print(a) for a in self.args)
 
     def _pretty(self, p):
         from sympy.printing.pretty.stringpict import prettyForm, stringPict
-        from sympy.printing.string import sstr
+        from sympy.printing.str import sstr
         
         var, s = self.args
         if p._use_unicode:
             el = u" \N{CONTAINS AS MEMBER} "
             return prettyForm(*stringPict.next(p._print(var),
                                                el, p._print(s)), binding=8)
         else:
@@ -548,15 +536,15 @@
         return r"%s \not\ni %s" % tuple(p._print(a) for a in self.args)
 
     def _sympystr(self, p):
         return "%s \N{DOES NOT CONTAIN AS MEMBER} %s" % tuple(p._print(a) for a in self.args)
 
     def _pretty(self, p):
         from sympy.printing.pretty.stringpict import prettyForm, stringPict
-        from sympy.printing.string import sstr
+        from sympy.printing.str import sstr
         
         var, s = self.args
         if p._use_unicode:
             el = u" \N{DOES NOT CONTAIN AS MEMBER} "
             return prettyForm(*stringPict.next(p._print(var),
                                                el, p._print(s)), binding=8)
         else:
```

### Comparing `sympy.keras-1.0.21/sympy/sets/handlers/add.py` & `sympy.keras-1.0.4/sympy/sets/handlers/add.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/sets/handlers/comparison.py` & `sympy.keras-1.0.4/sympy/sets/handlers/comparison.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/sets/handlers/functions.py` & `sympy.keras-1.0.4/sympy/sets/handlers/functions.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/sets/handlers/issubset.py` & `sympy.keras-1.0.4/sympy/sets/handlers/issubset.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/sets/handlers/mul.py` & `sympy.keras-1.0.4/sympy/sets/handlers/mul.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/sets/handlers/power.py` & `sympy.keras-1.0.4/sympy/sets/handlers/power.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/sets/powerset.py` & `sympy.keras-1.0.4/sympy/sets/powerset.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/sets/setexpr.py` & `sympy.keras-1.0.4/sympy/sets/setexpr.py`

 * *Files 0% similar despite different names*

```diff
@@ -146,15 +146,15 @@
     def _eval_is_extended_positive(self):
         is_z = self.is_zero
         if is_z is not None:
             return not is_z
 
     def _eval_is_rational(self):
         if self.arg.is_set:
-            return True
+            return True                
         return self.args[0].is_rational
 
     def _eval_is_finite(self):
         return self.arg.is_finiteset
 
     def _eval_is_even(self):
         if self.args[0].is_extended_real:
@@ -186,15 +186,15 @@
                     if e % q:
                         break
                     
                     t = b ** (e / q)
                     args.append(t)
                 else:
                     x = Mul(*args)
-                    return abs(x) ** exponent.p
+                    return abs(x) ** exponent.p 
         return
 
     def _eval_nseries(self, x, n, logx):
         direction = self.args[0].leadterm(x)[0]
         s = self.args[0]._eval_nseries(x, n=n, logx=logx)
         when = Eq(direction, 0)
         return Piecewise(
@@ -326,15 +326,15 @@
     def _eval_is_extended_positive(self):
         is_z = self.is_zero
         if is_z is not None:
             return not is_z
 
     def _eval_is_rational(self):
         if self.arg.is_set:
-            return True
+            return True                
         return self.args[0].is_rational
 
     def _eval_is_finite(self):
         return self.arg.is_finite
 
     def _eval_is_even(self):
         if self.args[0].is_extended_real:
@@ -366,15 +366,15 @@
                     if e % q:
                         break
                     
                     t = b ** (e / q)
                     args.append(t)
                 else:
                     x = Mul(*args)
-                    return abs(x) ** exponent.p
+                    return abs(x) ** exponent.p 
         return
 
     def _eval_nseries(self, x, n, logx):
         direction = self.args[0].leadterm(x)[0]
         s = self.args[0]._eval_nseries(x, n=n, logx=logx)
         when = Eq(direction, 0)
         return Piecewise(
```

### Comparing `sympy.keras-1.0.21/sympy/sets/sets.py` & `sympy.keras-1.0.4/sympy/sets/sets.py`

 * *Files 2% similar despite different names*

```diff
@@ -91,8080 +91,7986 @@
 000005a0: 2020 2020 6973 5f6e 756d 6265 7220 3d20      is_number = 
 000005b0: 4661 6c73 650a 2020 2020 6973 5f73 6574  False.    is_set
 000005c0: 203d 2054 7275 650a 2020 2020 6973 5f69   = True.    is_i
 000005d0: 7465 7261 626c 6520 3d20 4661 6c73 650a  terable = False.
 000005e0: 2020 2020 6973 5f69 6e74 6572 7661 6c20      is_interval 
 000005f0: 3d20 4661 6c73 650a 0a20 2020 2064 6566  = False..    def
 00000600: 205f 6576 616c 5f69 735f 6669 6e69 7465   _eval_is_finite
-00000610: 7365 7428 7365 6c66 293a 0a20 2020 2020  set(self):.     
-00000620: 2020 202e 2e2e 0a20 2020 2020 2020 200a     ....        .
-00000630: 2020 2020 4070 726f 7065 7274 790a 2020      @property.  
-00000640: 2020 6465 6620 646f 6d61 696e 2873 656c    def domain(sel
-00000650: 6629 3a0a 2020 2020 2020 2020 7265 7475  f):.        retu
-00000660: 726e 2073 656c 662e 756e 6976 6572 7361  rn self.universa
-00000670: 6c53 6574 0a20 2020 200a 2020 2020 6465  lSet.    .    de
-00000680: 6620 5f65 7661 6c5f 7368 6170 6528 7365  f _eval_shape(se
-00000690: 6c66 293a 0a20 2020 2020 2020 2072 6574  lf):.        ret
-000006a0: 7572 6e20 2829 0a0a 2020 2020 6465 6620  urn ()..    def 
-000006b0: 696d 6167 655f 7365 7428 7365 6c66 293a  image_set(self):
-000006c0: 0a20 2020 2020 2020 202e 2e2e 0a0a 2020  .        .....  
-000006d0: 2020 6465 6620 656c 656d 656e 745f 7379    def element_sy
-000006e0: 6d62 6f6c 2873 656c 662c 2065 7863 6c75  mbol(self, exclu
-000006f0: 6465 733d 4e6f 6e65 293a 0a20 2020 2020  des=None):.     
-00000700: 2020 2072 6574 7572 6e20 7365 6c66 2e67     return self.g
-00000710: 656e 6572 6174 655f 7661 7228 6578 636c  enerate_var(excl
-00000720: 7564 6573 2c20 2a2a 7365 6c66 2e65 7479  udes, **self.ety
-00000730: 7065 2e64 6963 7429 0a0a 2020 2020 4070  pe.dict)..    @p
-00000740: 726f 7065 7274 790a 2020 2020 6465 6620  roperty.    def 
-00000750: 6474 7970 6528 7365 6c66 293a 0a20 2020  dtype(self):.   
-00000760: 2020 2020 2061 7373 6572 7420 7365 6c66       assert self
-00000770: 2e65 7479 7065 2069 7320 6e6f 7420 4e6f  .etype is not No
-00000780: 6e65 2c20 7365 6c66 0a20 2020 2020 2020  ne, self.       
-00000790: 2072 6574 7572 6e20 7365 6c66 2e65 7479   return self.ety
-000007a0: 7065 2e73 6574 0a0a 2020 2020 6465 6620  pe.set..    def 
-000007b0: 636f 756c 645f 6578 7472 6163 745f 6d69  could_extract_mi
-000007c0: 6e75 735f 7369 676e 2873 656c 6629 3a0a  nus_sign(self):.
-000007d0: 2020 2020 2020 2020 7265 7475 726e 2046          return F
-000007e0: 616c 7365 0a0a 2020 2020 4073 7461 7469  alse..    @stati
-000007f0: 636d 6574 686f 640a 2020 2020 6465 6620  cmethod.    def 
-00000800: 5f69 6e66 696d 756d 5f6b 6579 2865 7870  _infimum_key(exp
-00000810: 7229 3a0a 2020 2020 2020 2020 2222 220a  r):.        """.
-00000820: 2020 2020 2020 2020 5265 7475 726e 2069          Return i
-00000830: 6e66 696d 756d 2028 6966 2070 6f73 7369  nfimum (if possi
-00000840: 626c 6529 2065 6c73 6520 532e 496e 6669  ble) else S.Infi
-00000850: 6e69 7479 2e0a 2020 2020 2020 2020 2222  nity..        ""
-00000860: 220a 2020 2020 2020 2020 7472 793a 0a20  ".        try:. 
-00000870: 2020 2020 2020 2020 2020 2069 6e66 696d             infim
-00000880: 756d 203d 2065 7870 722e 696e 660a 2020  um = expr.inf.  
-00000890: 2020 2020 2020 2020 2020 6173 7365 7274            assert
-000008a0: 2069 6e66 696d 756d 2e69 735f 636f 6d70   infimum.is_comp
-000008b0: 6172 6162 6c65 0a20 2020 2020 2020 2065  arable.        e
-000008c0: 7863 6570 7420 284e 6f74 496d 706c 656d  xcept (NotImplem
-000008d0: 656e 7465 6445 7272 6f72 2c0a 2020 2020  entedError,.    
-000008e0: 2020 2020 2020 2020 2020 2020 4174 7472              Attr
-000008f0: 6962 7574 6545 7272 6f72 2c20 4173 7365  ibuteError, Asse
-00000900: 7274 696f 6e45 7272 6f72 2c20 5661 6c75  rtionError, Valu
-00000910: 6545 7272 6f72 293a 0a20 2020 2020 2020  eError):.       
-00000920: 2020 2020 2069 6e66 696d 756d 203d 2053       infimum = S
-00000930: 2e49 6e66 696e 6974 790a 2020 2020 2020  .Infinity.      
-00000940: 2020 7265 7475 726e 2069 6e66 696d 756d    return infimum
-00000950: 0a0a 2020 2020 6465 6620 756e 696f 6e28  ..    def union(
-00000960: 7365 6c66 2c20 6f74 6865 7229 3a0a 2020  self, other):.  
-00000970: 2020 2020 2020 2222 220a 2020 2020 2020        """.      
-00000980: 2020 5265 7475 726e 7320 7468 6520 756e    Returns the un
-00000990: 696f 6e20 6f66 2027 7365 6c66 2720 616e  ion of 'self' an
-000009a0: 6420 276f 7468 6572 272e 0a0a 2020 2020  d 'other'...    
-000009b0: 2020 2020 4578 616d 706c 6573 0a20 2020      Examples.   
-000009c0: 2020 2020 203d 3d3d 3d3d 3d3d 3d0a 0a20       ========.. 
-000009d0: 2020 2020 2020 2041 7320 6120 7368 6f72         As a shor
-000009e0: 7463 7574 2069 7420 6973 2070 6f73 7369  tcut it is possi
-000009f0: 626c 6520 746f 2075 7365 2074 6865 2027  ble to use the '
-00000a00: 2b27 206f 7065 7261 746f 723a 0a0a 2020  +' operator:..  
-00000a10: 2020 2020 2020 3e3e 3e20 6672 6f6d 2073        >>> from s
-00000a20: 796d 7079 2069 6d70 6f72 7420 496e 7465  ympy import Inte
-00000a30: 7276 616c 2c20 4669 6e69 7465 5365 740a  rval, FiniteSet.
-00000a40: 2020 2020 2020 2020 3e3e 3e20 496e 7465          >>> Inte
-00000a50: 7276 616c 2830 2c20 3129 2e75 6e69 6f6e  rval(0, 1).union
-00000a60: 2849 6e74 6572 7661 6c28 322c 2033 2929  (Interval(2, 3))
-00000a70: 0a20 2020 2020 2020 2055 6e69 6f6e 2849  .        Union(I
-00000a80: 6e74 6572 7661 6c28 302c 2031 292c 2049  nterval(0, 1), I
-00000a90: 6e74 6572 7661 6c28 322c 2033 2929 0a20  nterval(2, 3)). 
-00000aa0: 2020 2020 2020 203e 3e3e 2049 6e74 6572         >>> Inter
-00000ab0: 7661 6c28 302c 2031 2920 2b20 496e 7465  val(0, 1) + Inte
-00000ac0: 7276 616c 2832 2c20 3329 0a20 2020 2020  rval(2, 3).     
-00000ad0: 2020 2055 6e69 6f6e 2849 6e74 6572 7661     Union(Interva
-00000ae0: 6c28 302c 2031 292c 2049 6e74 6572 7661  l(0, 1), Interva
-00000af0: 6c28 322c 2033 2929 0a0a 2020 2020 2020  l(2, 3))..      
-00000b00: 2020 5369 6d69 6c61 726c 7920 6974 2069    Similarly it i
-00000b10: 7320 706f 7373 6962 6c65 2074 6f20 7573  s possible to us
-00000b20: 6520 7468 6520 272d 2720 6f70 6572 6174  e the '-' operat
-00000b30: 6f72 2066 6f72 2073 6574 2064 6966 6665  or for set diffe
-00000b40: 7265 6e63 6573 3a0a 0a20 2020 2020 2020  rences:..       
-00000b50: 203e 3e3e 2049 6e74 6572 7661 6c28 302c   >>> Interval(0,
-00000b60: 2032 2920 2d20 496e 7465 7276 616c 2830   2) - Interval(0
-00000b70: 2c20 3129 0a20 2020 2020 2020 2049 6e74  , 1).        Int
-00000b80: 6572 7661 6c2e 4c6f 7065 6e28 312c 2032  erval.Lopen(1, 2
-00000b90: 290a 2020 2020 2020 2020 3e3e 3e20 496e  ).        >>> In
-00000ba0: 7465 7276 616c 2831 2c20 3329 202d 2046  terval(1, 3) - F
-00000bb0: 696e 6974 6553 6574 2832 290a 2020 2020  initeSet(2).    
-00000bc0: 2020 2020 556e 696f 6e28 496e 7465 7276      Union(Interv
-00000bd0: 616c 2e52 6f70 656e 2831 2c20 3229 2c20  al.Ropen(1, 2), 
-00000be0: 496e 7465 7276 616c 2e4c 6f70 656e 2832  Interval.Lopen(2
-00000bf0: 2c20 3329 290a 0a20 2020 2020 2020 2022  , 3))..        "
-00000c00: 2222 0a20 2020 2020 2020 2072 6574 7572  "".        retur
-00000c10: 6e20 556e 696f 6e28 7365 6c66 2c20 6f74  n Union(self, ot
-00000c20: 6865 7229 0a0a 2020 2020 6465 6620 696e  her)..    def in
-00000c30: 7465 7273 6563 7428 7365 6c66 2c20 6f74  tersect(self, ot
-00000c40: 6865 7229 3a0a 2020 2020 2020 2020 2222  her):.        ""
-00000c50: 220a 2020 2020 2020 2020 5265 7475 726e  ".        Return
-00000c60: 7320 7468 6520 696e 7465 7273 6563 7469  s the intersecti
-00000c70: 6f6e 206f 6620 2773 656c 6627 2061 6e64  on of 'self' and
-00000c80: 2027 6f74 6865 7227 2e0a 0a20 2020 2020   'other'...     
-00000c90: 2020 203e 3e3e 2066 726f 6d20 7379 6d70     >>> from symp
-00000ca0: 7920 696d 706f 7274 2049 6e74 6572 7661  y import Interva
-00000cb0: 6c0a 0a20 2020 2020 2020 203e 3e3e 2049  l..        >>> I
-00000cc0: 6e74 6572 7661 6c28 312c 2033 292e 696e  nterval(1, 3).in
-00000cd0: 7465 7273 6563 7428 496e 7465 7276 616c  tersect(Interval
-00000ce0: 2831 2c20 3229 290a 2020 2020 2020 2020  (1, 2)).        
-00000cf0: 496e 7465 7276 616c 2831 2c20 3229 0a0a  Interval(1, 2)..
-00000d00: 2020 2020 2020 2020 3e3e 3e20 6672 6f6d          >>> from
-00000d10: 2073 796d 7079 2069 6d70 6f72 7420 696d   sympy import im
-00000d20: 6167 6573 6574 2c20 4c61 6d62 6461 2c20  ageset, Lambda, 
-00000d30: 7379 6d62 6f6c 732c 2053 0a20 2020 2020  symbols, S.     
-00000d40: 2020 203e 3e3e 206e 2c20 6d20 3d20 7379     >>> n, m = sy
-00000d50: 6d62 6f6c 7328 276e 206d 2729 0a20 2020  mbols('n m').   
-00000d60: 2020 2020 203e 3e3e 2061 203d 2069 6d61       >>> a = ima
-00000d70: 6765 7365 7428 4c61 6d62 6461 286e 2c20  geset(Lambda(n, 
-00000d80: 322a 6e29 2c20 532e 496e 7465 6765 7273  2*n), S.Integers
-00000d90: 290a 2020 2020 2020 2020 3e3e 3e20 612e  ).        >>> a.
-00000da0: 696e 7465 7273 6563 7428 696d 6167 6573  intersect(images
-00000db0: 6574 284c 616d 6264 6128 6d2c 2032 2a6d  et(Lambda(m, 2*m
-00000dc0: 202b 2031 292c 2053 2e49 6e74 6567 6572   + 1), S.Integer
-00000dd0: 7329 290a 2020 2020 2020 2020 456d 7074  s)).        Empt
-00000de0: 7953 6574 2829 0a0a 2020 2020 2020 2020  ySet()..        
-00000df0: 2222 220a 2020 2020 2020 2020 7265 7475  """.        retu
-00000e00: 726e 2049 6e74 6572 7365 6374 696f 6e28  rn Intersection(
-00000e10: 7365 6c66 2c20 6f74 6865 7229 0a0a 2020  self, other)..  
-00000e20: 2020 6465 6620 696e 7465 7273 6563 7469    def intersecti
-00000e30: 6f6e 2873 656c 662c 206f 7468 6572 293a  on(self, other):
-00000e40: 0a20 2020 2020 2020 2022 2222 0a20 2020  .        """.   
-00000e50: 2020 2020 2041 6c69 6173 2066 6f72 203a       Alias for :
-00000e60: 6d65 7468 3a60 696e 7465 7273 6563 7428  meth:`intersect(
-00000e70: 2960 0a20 2020 2020 2020 2022 2222 0a20  )`.        """. 
-00000e80: 2020 2020 2020 2072 6574 7572 6e20 7365         return se
-00000e90: 6c66 2e69 6e74 6572 7365 6374 286f 7468  lf.intersect(oth
-00000ea0: 6572 290a 0a20 2020 2064 6566 2069 735f  er)..    def is_
-00000eb0: 6469 736a 6f69 6e74 2873 656c 662c 206f  disjoint(self, o
-00000ec0: 7468 6572 293a 0a20 2020 2020 2020 2022  ther):.        "
-00000ed0: 2222 0a20 2020 2020 2020 2052 6574 7572  "".        Retur
-00000ee0: 6e73 2054 7275 6520 6966 2027 7365 6c66  ns True if 'self
-00000ef0: 2720 616e 6420 276f 7468 6572 2720 6172  ' and 'other' ar
-00000f00: 6520 6469 736a 6f69 6e74 0a0a 2020 2020  e disjoint..    
-00000f10: 2020 2020 4578 616d 706c 6573 0a20 2020      Examples.   
-00000f20: 2020 2020 203d 3d3d 3d3d 3d3d 3d0a 0a20       ========.. 
-00000f30: 2020 2020 2020 203e 3e3e 2066 726f 6d20         >>> from 
-00000f40: 7379 6d70 7920 696d 706f 7274 2049 6e74  sympy import Int
-00000f50: 6572 7661 6c0a 2020 2020 2020 2020 3e3e  erval.        >>
-00000f60: 3e20 496e 7465 7276 616c 2830 2c20 3229  > Interval(0, 2)
-00000f70: 2e69 735f 6469 736a 6f69 6e74 2849 6e74  .is_disjoint(Int
-00000f80: 6572 7661 6c28 312c 2032 2929 0a20 2020  erval(1, 2)).   
-00000f90: 2020 2020 2046 616c 7365 0a20 2020 2020       False.     
-00000fa0: 2020 203e 3e3e 2049 6e74 6572 7661 6c28     >>> Interval(
-00000fb0: 302c 2032 292e 6973 5f64 6973 6a6f 696e  0, 2).is_disjoin
-00000fc0: 7428 496e 7465 7276 616c 2833 2c20 3429  t(Interval(3, 4)
-00000fd0: 290a 2020 2020 2020 2020 5472 7565 0a0a  ).        True..
-00000fe0: 2020 2020 2020 2020 5265 6665 7265 6e63          Referenc
-00000ff0: 6573 0a20 2020 2020 2020 203d 3d3d 3d3d  es.        =====
-00001000: 3d3d 3d3d 3d0a 0a20 2020 2020 2020 202e  =====..        .
-00001010: 2e20 5b31 5d20 6874 7470 733a 2f2f 656e  . [1] https://en
-00001020: 2e77 696b 6970 6564 6961 2e6f 7267 2f77  .wikipedia.org/w
-00001030: 696b 692f 4469 736a 6f69 6e74 5f73 6574  iki/Disjoint_set
-00001040: 730a 2020 2020 2020 2020 2222 220a 2020  s.        """.  
-00001050: 2020 2020 2020 7265 7475 726e 2073 656c        return sel
-00001060: 662e 696e 7465 7273 6563 7428 6f74 6865  f.intersect(othe
-00001070: 7229 2e69 735f 456d 7074 7953 6574 0a0a  r).is_EmptySet..
-00001080: 2020 2020 6465 6620 6973 6469 736a 6f69      def isdisjoi
-00001090: 6e74 2873 656c 662c 206f 7468 6572 293a  nt(self, other):
-000010a0: 0a20 2020 2020 2020 2022 2222 0a20 2020  .        """.   
-000010b0: 2020 2020 2041 6c69 6173 2066 6f72 203a       Alias for :
-000010c0: 6d65 7468 3a60 6973 5f64 6973 6a6f 696e  meth:`is_disjoin
-000010d0: 7428 2960 0a20 2020 2020 2020 2022 2222  t()`.        """
-000010e0: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
-000010f0: 7365 6c66 2e69 735f 6469 736a 6f69 6e74  self.is_disjoint
-00001100: 286f 7468 6572 290a 0a20 2020 2064 6566  (other)..    def
-00001110: 2063 6f6d 706c 656d 656e 7428 7365 6c66   complement(self
-00001120: 2c20 756e 6976 6572 7365 293a 0a20 2020  , universe):.   
-00001130: 2020 2020 2072 2222 220a 2020 2020 2020       r""".      
-00001140: 2020 5468 6520 636f 6d70 6c65 6d65 6e74    The complement
-00001150: 206f 6620 2773 656c 6627 2077 2e72 2e74   of 'self' w.r.t
-00001160: 2074 6865 2067 6976 656e 2075 6e69 7665   the given unive
-00001170: 7273 652e 0a0a 2020 2020 2020 2020 4578  rse...        Ex
-00001180: 616d 706c 6573 0a20 2020 2020 2020 203d  amples.        =
-00001190: 3d3d 3d3d 3d3d 3d0a 0a20 2020 2020 2020  =======..       
-000011a0: 203e 3e3e 2066 726f 6d20 7379 6d70 7920   >>> from sympy 
-000011b0: 696d 706f 7274 2049 6e74 6572 7661 6c2c  import Interval,
-000011c0: 2053 0a20 2020 2020 2020 203e 3e3e 2049   S.        >>> I
-000011d0: 6e74 6572 7661 6c28 302c 2031 292e 636f  nterval(0, 1).co
-000011e0: 6d70 6c65 6d65 6e74 2852 6561 6c73 290a  mplement(Reals).
-000011f0: 2020 2020 2020 2020 556e 696f 6e28 496e          Union(In
-00001200: 7465 7276 616c 2e6f 7065 6e28 2d6f 6f2c  terval.open(-oo,
-00001210: 2030 292c 2049 6e74 6572 7661 6c2e 6f70   0), Interval.op
-00001220: 656e 2831 2c20 6f6f 2929 0a0a 2020 2020  en(1, oo))..    
-00001230: 2020 2020 3e3e 3e20 496e 7465 7276 616c      >>> Interval
-00001240: 2830 2c20 3129 2e63 6f6d 706c 656d 656e  (0, 1).complemen
-00001250: 7428 556e 6976 6572 7361 6c53 6574 2829  t(UniversalSet()
-00001260: 290a 2020 2020 2020 2020 556e 6976 6572  ).        Univer
-00001270: 7361 6c53 6574 205c 2049 6e74 6572 7661  salSet \ Interva
-00001280: 6c28 302c 2031 290a 0a20 2020 2020 2020  l(0, 1)..       
-00001290: 2022 2222 0a20 2020 2020 2020 2072 6574   """.        ret
-000012a0: 7572 6e20 436f 6d70 6c65 6d65 6e74 2875  urn Complement(u
-000012b0: 6e69 7665 7273 652c 2073 656c 6629 0a0a  niverse, self)..
-000012c0: 2020 2020 6465 6620 5f63 6f6d 706c 656d      def _complem
-000012d0: 656e 7428 7365 6c66 2c20 6f74 6865 7229  ent(self, other)
-000012e0: 3a0a 2020 2020 2020 2020 2320 7468 6973  :.        # this
-000012f0: 2062 6568 6176 6573 2061 7320 6f74 6865   behaves as othe
-00001300: 7220 2d20 7365 6c66 0a20 2020 2020 2020  r - self.       
-00001310: 2069 6620 6f74 6865 722e 6973 5f50 726f   if other.is_Pro
-00001320: 6475 6374 5365 743a 0a20 2020 2020 2020  ductSet:.       
-00001330: 2020 2020 2066 726f 6d20 7379 6d70 7920       from sympy 
-00001340: 696d 706f 7274 2046 696e 6974 6553 6574  import FiniteSet
-00001350: 0a20 2020 2020 2020 2020 2020 2023 2046  .            # F
-00001360: 6f72 2065 6163 6820 7365 7420 636f 6e73  or each set cons
-00001370: 6964 6572 2069 7420 6f72 2069 7427 7320  ider it or it's 
-00001380: 636f 6d70 6c65 6d65 6e74 0a20 2020 2020  complement.     
-00001390: 2020 2020 2020 2023 2057 6520 6e65 6564         # We need
-000013a0: 2061 7420 6c65 6173 7420 6f6e 6520 6f66   at least one of
-000013b0: 2074 6865 2073 6574 7320 746f 2062 6520   the sets to be 
-000013c0: 636f 6d70 6c65 6d65 6e74 6564 0a20 2020  complemented.   
-000013d0: 2020 2020 2020 2020 2023 2043 6f6e 7369           # Consi
-000013e0: 6465 7220 616c 6c20 325e 6e20 636f 6d62  der all 2^n comb
-000013f0: 696e 6174 696f 6e73 2e0a 2020 2020 2020  inations..      
-00001400: 2020 2020 2020 2320 5765 2063 616e 2063        # We can c
-00001410: 6f6e 7665 6e69 656e 746c 7920 7265 7072  onveniently repr
-00001420: 6573 656e 7420 7468 6573 6520 6f70 7469  esent these opti
-00001430: 6f6e 7320 6561 7369 6c79 2075 7369 6e67  ons easily using
-00001440: 2061 0a20 2020 2020 2020 2020 2020 2023   a.            #
-00001450: 2050 726f 6475 6374 5365 740a 0a20 2020   ProductSet..   
-00001460: 2020 2020 2020 2020 2023 2058 5858 3a20           # XXX: 
-00001470: 7468 6973 2064 6f65 736e 2774 2077 6f72  this doesn't wor
-00001480: 6b20 6966 2074 6865 2064 696d 656e 7369  k if the dimensi
-00001490: 6f6e 7320 6f66 2074 6865 2073 6574 7320  ons of the sets 
-000014a0: 6973 6e27 7420 7361 6d65 2e0a 2020 2020  isn't same..    
-000014b0: 2020 2020 2020 2020 2320 4120 2d20 4220          # A - B 
-000014c0: 6973 2065 7373 656e 7469 616c 6c79 2073  is essentially s
-000014d0: 616d 6520 6173 2041 2069 6620 4220 6861  ame as A if B ha
-000014e0: 7320 6120 6469 6666 6572 656e 740a 2020  s a different.  
-000014f0: 2020 2020 2020 2020 2020 2320 6469 6d65            # dime
-00001500: 6e73 696f 6e61 6c69 7479 2074 6861 6e20  nsionality than 
-00001510: 410a 2020 2020 2020 2020 2020 2020 7377  A.            sw
-00001520: 6974 6368 5f73 6574 7320 3d20 5072 6f64  itch_sets = Prod
-00001530: 7563 7453 6574 2846 696e 6974 6553 6574  uctSet(FiniteSet
-00001540: 286f 2c20 6f20 2d20 7329 2066 6f72 2073  (o, o - s) for s
-00001550: 2c20 6f20 696e 207a 6970 2873 656c 662e  , o in zip(self.
-00001560: 7365 7473 2c20 6f74 6865 722e 7365 7473  sets, other.sets
-00001570: 2929 0a20 2020 2020 2020 2020 2020 2070  )).            p
-00001580: 726f 6475 6374 5f73 6574 7320 3d20 2850  roduct_sets = (P
-00001590: 726f 6475 6374 5365 7428 2a73 2920 666f  roductSet(*s) fo
-000015a0: 7220 7320 696e 2073 7769 7463 685f 7365  r s in switch_se
-000015b0: 7473 290a 2020 2020 2020 2020 2020 2020  ts).            
-000015c0: 2320 556e 696f 6e20 6f66 2061 6c6c 2063  # Union of all c
-000015d0: 6f6d 6269 6e61 7469 6f6e 7320 6275 7420  ombinations but 
-000015e0: 7468 6973 206f 6e65 0a20 2020 2020 2020  this one.       
-000015f0: 2020 2020 2072 6574 7572 6e20 556e 696f       return Unio
-00001600: 6e28 2a28 7020 666f 7220 7020 696e 2070  n(*(p for p in p
-00001610: 726f 6475 6374 5f73 6574 7320 6966 2070  roduct_sets if p
-00001620: 2021 3d20 6f74 6865 7229 290a 0a20 2020   != other))..   
-00001630: 2020 2020 2065 6c69 6620 6f74 6865 722e       elif other.
-00001640: 6973 5f49 6e74 6572 7661 6c3a 0a20 2020  is_Interval:.   
-00001650: 2020 2020 2020 2020 2069 6620 7365 6c66           if self
-00001660: 2e69 735f 496e 7465 7276 616c 3a0a 2020  .is_Interval:.  
-00001670: 2020 2020 2020 2020 2020 2020 2020 5520                U 
-00001680: 3d20 6f74 6865 722e 6574 7970 652e 756e  = other.etype.un
-00001690: 6976 6572 7361 6c53 6574 0a20 2020 2020  iversalSet.     
-000016a0: 2020 2020 2020 2020 2020 2072 6574 7572             retur
-000016b0: 6e20 496e 7465 7273 6563 7469 6f6e 286f  n Intersection(o
-000016c0: 7468 6572 2c20 7365 6c66 2e63 6f6d 706c  ther, self.compl
-000016d0: 656d 656e 7428 5529 290a 0a20 2020 2020  ement(U))..     
-000016e0: 2020 2065 6c69 6620 6f74 6865 722e 6973     elif other.is
-000016f0: 5f52 616e 6765 3a0a 2020 2020 2020 2020  _Range:.        
-00001700: 2020 2020 6966 2073 656c 662e 6973 5f52      if self.is_R
-00001710: 616e 6765 2061 6e64 2073 656c 662e 7374  ange and self.st
-00001720: 6570 2e69 735f 4f6e 653a 0a20 2020 2020  ep.is_One:.     
-00001730: 2020 2020 2020 2020 2020 2066 726f 6d20             from 
-00001740: 7379 6d70 792e 7365 7473 2069 6d70 6f72  sympy.sets impor
-00001750: 7420 496e 7465 6765 7273 0a20 2020 2020  t Integers.     
-00001760: 2020 2020 2020 2020 2020 2072 6574 7572             retur
-00001770: 6e20 496e 7465 7273 6563 7469 6f6e 286f  n Intersection(o
-00001780: 7468 6572 2c20 7365 6c66 2e63 6f6d 706c  ther, self.compl
-00001790: 656d 656e 7428 496e 7465 6765 7273 2929  ement(Integers))
-000017a0: 0a0a 2020 2020 2020 2020 656c 6966 206f  ..        elif o
-000017b0: 7468 6572 2e69 735f 556e 696f 6e3a 0a20  ther.is_Union:. 
-000017c0: 2020 2020 2020 2020 2020 2073 696d 706c             simpl
-000017d0: 6966 6965 6420 3d20 5b5d 0a20 2020 2020  ified = [].     
-000017e0: 2020 2020 2020 2075 6e73 696d 706c 6966         unsimplif
-000017f0: 6965 6420 3d20 5b5d 0a20 2020 2020 2020  ied = [].       
-00001800: 2020 2020 2068 6974 203d 2046 616c 7365       hit = False
-00001810: 0a20 2020 2020 2020 2020 2020 2066 6f72  .            for
-00001820: 2061 7267 2069 6e20 6f74 6865 722e 6172   arg in other.ar
-00001830: 6773 3a0a 2020 2020 2020 2020 2020 2020  gs:.            
-00001840: 2020 2020 6469 6666 203d 2043 6f6d 706c      diff = Compl
-00001850: 656d 656e 7428 6172 672c 2073 656c 6629  ement(arg, self)
-00001860: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00001870: 2069 6620 6469 6666 2e69 735f 436f 6d70   if diff.is_Comp
-00001880: 6c65 6d65 6e74 2061 6e64 2064 6966 662e  lement and diff.
-00001890: 6172 6773 5b31 5d20 3d3d 2073 656c 663a  args[1] == self:
-000018a0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000018b0: 2020 2020 2068 6974 203d 2064 6966 662e       hit = diff.
-000018c0: 6172 6773 5b30 5d20 213d 2061 7267 0a20  args[0] != arg. 
-000018d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000018e0: 2020 2075 6e73 696d 706c 6966 6965 642e     unsimplified.
-000018f0: 6170 7065 6e64 2864 6966 662e 6172 6773  append(diff.args
-00001900: 5b30 5d29 0a20 2020 2020 2020 2020 2020  [0]).           
-00001910: 2020 2020 2065 6c73 653a 200a 2020 2020       else: .    
-00001920: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00001930: 6869 7420 3d20 5472 7565 0a20 2020 2020  hit = True.     
-00001940: 2020 2020 2020 2020 2020 2020 2020 2073                 s
-00001950: 696d 706c 6966 6965 642e 6170 7065 6e64  implified.append
-00001960: 2864 6966 6629 0a20 2020 2020 2020 2020  (diff).         
-00001970: 2020 2069 6620 6869 743a 0a20 2020 2020     if hit:.     
-00001980: 2020 2020 2020 2020 2020 2073 696d 706c             simpl
-00001990: 6966 6965 6420 3d20 556e 696f 6e28 2a73  ified = Union(*s
-000019a0: 696d 706c 6966 6965 642c 2065 7661 6c75  implified, evalu
-000019b0: 6174 653d 4661 6c73 6529 2069 6620 7369  ate=False) if si
-000019c0: 6d70 6c69 6669 6564 2065 6c73 6520 7365  mplified else se
-000019d0: 6c66 2e65 7479 7065 2e65 6d70 7479 5365  lf.etype.emptySe
-000019e0: 740a 2020 2020 2020 2020 2020 2020 2020  t.              
-000019f0: 2020 756e 7369 6d70 6c69 6669 6564 203d    unsimplified =
-00001a00: 2043 6f6d 706c 656d 656e 7428 556e 696f   Complement(Unio
-00001a10: 6e28 2a75 6e73 696d 706c 6966 6965 642c  n(*unsimplified,
-00001a20: 2065 7661 6c75 6174 653d 4661 6c73 6529   evaluate=False)
-00001a30: 2c20 7365 6c66 2c20 6576 616c 7561 7465  , self, evaluate
-00001a40: 3d46 616c 7365 2920 6966 2075 6e73 696d  =False) if unsim
-00001a50: 706c 6966 6965 6420 656c 7365 2073 656c  plified else sel
-00001a60: 662e 6574 7970 652e 656d 7074 7953 6574  f.etype.emptySet
-00001a70: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00001a80: 2072 6574 7572 6e20 7369 6d70 6c69 6669   return simplifi
-00001a90: 6564 207c 2075 6e73 696d 706c 6966 6965  ed | unsimplifie
-00001aa0: 640a 0a20 2020 2020 2020 2065 6c69 6620  d..        elif 
-00001ab0: 6f74 6865 722e 6973 5f43 6f6d 706c 656d  other.is_Complem
-00001ac0: 656e 743a 0a20 2020 2020 2020 2020 2020  ent:.           
-00001ad0: 2069 6620 6f74 6865 722e 6172 6773 5b30   if other.args[0
-00001ae0: 5d20 696e 2073 656c 663a 0a20 2020 2020  ] in self:.     
-00001af0: 2020 2020 2020 2020 2020 2072 6574 7572             retur
-00001b00: 6e20 7365 6c66 2e65 7479 7065 2e65 6d70  n self.etype.emp
-00001b10: 7479 5365 740a 2020 2020 2020 2020 2020  tySet.          
-00001b20: 2020 7265 7475 726e 2043 6f6d 706c 656d    return Complem
-00001b30: 656e 7428 6f74 6865 722e 6172 6773 5b30  ent(other.args[0
-00001b40: 5d2c 2055 6e69 6f6e 286f 7468 6572 2e61  ], Union(other.a
-00001b50: 7267 735b 315d 2c20 7365 6c66 292c 2065  rgs[1], self), e
-00001b60: 7661 6c75 6174 653d 4661 6c73 6529 0a0a  valuate=False)..
-00001b70: 2020 2020 2020 2020 656c 6966 206f 7468          elif oth
-00001b80: 6572 2e69 735f 456d 7074 7953 6574 3a0a  er.is_EmptySet:.
-00001b90: 2020 2020 2020 2020 2020 2020 7265 7475              retu
-00001ba0: 726e 206f 7468 6572 0a0a 2020 2020 2020  rn other..      
-00001bb0: 2020 656c 6966 206f 7468 6572 2e69 735f    elif other.is_
-00001bc0: 4669 6e69 7465 5365 743a 0a20 2020 2020  FiniteSet:.     
-00001bd0: 2020 2020 2020 2073 6966 7465 6420 3d20         sifted = 
-00001be0: 7369 6674 286f 7468 6572 2c20 6c61 6d62  sift(other, lamb
-00001bf0: 6461 2078 3a20 6675 7a7a 795f 626f 6f6c  da x: fuzzy_bool
-00001c00: 2873 656c 662e 636f 6e74 6169 6e73 2878  (self.contains(x
-00001c10: 2929 290a 2020 2020 2020 2020 2020 2020  ))).            
-00001c20: 2320 6967 6e6f 7265 2074 686f 7365 2074  # ignore those t
-00001c30: 6861 7420 6172 6520 636f 6e74 6169 6e65  hat are containe
-00001c40: 6420 696e 2073 656c 660a 2020 2020 2020  d in self.      
-00001c50: 2020 2020 2020 7265 7475 726e 2055 6e69        return Uni
-00001c60: 6f6e 2846 696e 6974 6553 6574 282a 2873  on(FiniteSet(*(s
-00001c70: 6966 7465 645b 4661 6c73 655d 2929 2c20  ifted[False])), 
-00001c80: 436f 6d70 6c65 6d65 6e74 2846 696e 6974  Complement(Finit
-00001c90: 6553 6574 282a 2873 6966 7465 645b 4e6f  eSet(*(sifted[No
-00001ca0: 6e65 5d29 292c 2073 656c 662c 2065 7661  ne])), self, eva
-00001cb0: 6c75 6174 653d 4661 6c73 6529 2069 6620  luate=False) if 
-00001cc0: 7369 6674 6564 5b4e 6f6e 655d 2065 6c73  sifted[None] els
-00001cd0: 6520 7365 6c66 2e65 7479 7065 2e65 6d70  e self.etype.emp
-00001ce0: 7479 5365 7429 0a0a 2020 2020 6465 6620  tySet)..    def 
-00001cf0: 7379 6d6d 6574 7269 635f 6469 6666 6572  symmetric_differ
-00001d00: 656e 6365 2873 656c 662c 206f 7468 6572  ence(self, other
-00001d10: 293a 0a20 2020 2020 2020 2022 2222 0a20  ):.        """. 
-00001d20: 2020 2020 2020 2052 6574 7572 6e73 2073         Returns s
-00001d30: 796d 6d65 7472 6963 2064 6966 6665 7265  ymmetric differe
-00001d40: 6e63 6520 6f66 2060 7365 6c66 6020 616e  nce of `self` an
-00001d50: 6420 606f 7468 6572 602e 0a0a 2020 2020  d `other`...    
-00001d60: 2020 2020 4578 616d 706c 6573 0a20 2020      Examples.   
-00001d70: 2020 2020 203d 3d3d 3d3d 3d3d 3d0a 0a20       ========.. 
-00001d80: 2020 2020 2020 203e 3e3e 2066 726f 6d20         >>> from 
-00001d90: 7379 6d70 7920 696d 706f 7274 2049 6e74  sympy import Int
-00001da0: 6572 7661 6c2c 2053 0a20 2020 2020 2020  erval, S.       
-00001db0: 203e 3e3e 2049 6e74 6572 7661 6c28 312c   >>> Interval(1,
-00001dc0: 2033 292e 7379 6d6d 6574 7269 635f 6469   3).symmetric_di
-00001dd0: 6666 6572 656e 6365 2852 6561 6c73 290a  fference(Reals).
-00001de0: 2020 2020 2020 2020 556e 696f 6e28 496e          Union(In
-00001df0: 7465 7276 616c 2e6f 7065 6e28 2d6f 6f2c  terval.open(-oo,
-00001e00: 2031 292c 2049 6e74 6572 7661 6c2e 6f70   1), Interval.op
-00001e10: 656e 2833 2c20 6f6f 2929 0a20 2020 2020  en(3, oo)).     
-00001e20: 2020 203e 3e3e 2049 6e74 6572 7661 6c28     >>> Interval(
-00001e30: 312c 2031 3029 2e73 796d 6d65 7472 6963  1, 10).symmetric
-00001e40: 5f64 6966 6665 7265 6e63 6528 5265 616c  _difference(Real
-00001e50: 7329 0a20 2020 2020 2020 2055 6e69 6f6e  s).        Union
-00001e60: 2849 6e74 6572 7661 6c2e 6f70 656e 282d  (Interval.open(-
-00001e70: 6f6f 2c20 3129 2c20 496e 7465 7276 616c  oo, 1), Interval
-00001e80: 2e6f 7065 6e28 3130 2c20 6f6f 2929 0a0a  .open(10, oo))..
-00001e90: 2020 2020 2020 2020 3e3e 3e20 6672 6f6d          >>> from
-00001ea0: 2073 796d 7079 2069 6d70 6f72 7420 532c   sympy import S,
-00001eb0: 2045 6d70 7479 5365 740a 2020 2020 2020   EmptySet.      
-00001ec0: 2020 3e3e 3e20 5265 616c 732e 7379 6d6d    >>> Reals.symm
-00001ed0: 6574 7269 635f 6469 6666 6572 656e 6365  etric_difference
-00001ee0: 2845 6d70 7479 5365 7428 2929 0a20 2020  (EmptySet()).   
-00001ef0: 2020 2020 2052 6561 6c73 0a0a 2020 2020       Reals..    
-00001f00: 2020 2020 5265 6665 7265 6e63 6573 0a20      References. 
-00001f10: 2020 2020 2020 203d 3d3d 3d3d 3d3d 3d3d         =========
-00001f20: 3d0a 2020 2020 2020 2020 2e2e 205b 315d  =.        .. [1]
-00001f30: 2068 7474 7073 3a2f 2f65 6e2e 7769 6b69   https://en.wiki
-00001f40: 7065 6469 612e 6f72 672f 7769 6b69 2f53  pedia.org/wiki/S
-00001f50: 796d 6d65 7472 6963 5f64 6966 6665 7265  ymmetric_differe
-00001f60: 6e63 650a 0a20 2020 2020 2020 2022 2222  nce..        """
-00001f70: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
-00001f80: 5379 6d6d 6574 7269 6344 6966 6665 7265  SymmetricDiffere
-00001f90: 6e63 6528 7365 6c66 2c20 6f74 6865 7229  nce(self, other)
-00001fa0: 0a0a 2020 2020 6465 6620 5f73 796d 6d65  ..    def _symme
-00001fb0: 7472 6963 5f64 6966 6665 7265 6e63 6528  tric_difference(
-00001fc0: 7365 6c66 2c20 6f74 6865 7229 3a0a 2020  self, other):.  
-00001fd0: 2020 2020 2020 7265 7475 726e 2055 6e69        return Uni
-00001fe0: 6f6e 2843 6f6d 706c 656d 656e 7428 7365  on(Complement(se
-00001ff0: 6c66 2c20 6f74 6865 7229 2c20 436f 6d70  lf, other), Comp
-00002000: 6c65 6d65 6e74 286f 7468 6572 2c20 7365  lement(other, se
-00002010: 6c66 2929 0a0a 2020 2020 4070 726f 7065  lf))..    @prope
-00002020: 7274 790a 2020 2020 6465 6620 696e 6628  rty.    def inf(
-00002030: 7365 6c66 293a 0a20 2020 2020 2020 2022  self):.        "
-00002040: 2222 0a20 2020 2020 2020 2054 6865 2069  "".        The i
-00002050: 6e66 696d 756d 206f 6620 2773 656c 6627  nfimum of 'self'
-00002060: 0a0a 2020 2020 2020 2020 4578 616d 706c  ..        Exampl
-00002070: 6573 0a20 2020 2020 2020 203d 3d3d 3d3d  es.        =====
-00002080: 3d3d 3d0a 0a20 2020 2020 2020 203e 3e3e  ===..        >>>
-00002090: 2066 726f 6d20 7379 6d70 7920 696d 706f   from sympy impo
-000020a0: 7274 2049 6e74 6572 7661 6c2c 2055 6e69  rt Interval, Uni
-000020b0: 6f6e 0a20 2020 2020 2020 203e 3e3e 2049  on.        >>> I
-000020c0: 6e74 6572 7661 6c28 302c 2031 292e 696e  nterval(0, 1).in
-000020d0: 660a 2020 2020 2020 2020 300a 2020 2020  f.        0.    
-000020e0: 2020 2020 3e3e 3e20 556e 696f 6e28 496e      >>> Union(In
-000020f0: 7465 7276 616c 2830 2c20 3129 2c20 496e  terval(0, 1), In
-00002100: 7465 7276 616c 2832 2c20 3329 292e 696e  terval(2, 3)).in
-00002110: 660a 2020 2020 2020 2020 300a 0a20 2020  f.        0..   
-00002120: 2020 2020 2022 2222 0a20 2020 2020 2020       """.       
-00002130: 2072 6574 7572 6e20 7365 6c66 2e5f 696e   return self._in
-00002140: 660a 0a20 2020 2040 7072 6f70 6572 7479  f..    @property
-00002150: 0a20 2020 2064 6566 205f 696e 6628 7365  .    def _inf(se
-00002160: 6c66 293a 0a20 2020 2020 2020 2072 6169  lf):.        rai
-00002170: 7365 204e 6f74 496d 706c 656d 656e 7465  se NotImplemente
-00002180: 6445 7272 6f72 2822 2825 7329 2e5f 696e  dError("(%s)._in
-00002190: 6622 2025 2073 656c 6629 0a0a 2020 2020  f" % self)..    
-000021a0: 4070 726f 7065 7274 790a 2020 2020 6465  @property.    de
-000021b0: 6620 7375 7028 7365 6c66 293a 0a20 2020  f sup(self):.   
-000021c0: 2020 2020 2022 2222 0a20 2020 2020 2020       """.       
-000021d0: 2054 6865 2073 7570 7265 6d75 6d20 6f66   The supremum of
-000021e0: 2027 7365 6c66 270a 0a20 2020 2020 2020   'self'..       
-000021f0: 2045 7861 6d70 6c65 730a 2020 2020 2020   Examples.      
-00002200: 2020 3d3d 3d3d 3d3d 3d3d 0a0a 2020 2020    ========..    
-00002210: 2020 2020 3e3e 3e20 6672 6f6d 2073 796d      >>> from sym
-00002220: 7079 2069 6d70 6f72 7420 496e 7465 7276  py import Interv
-00002230: 616c 2c20 556e 696f 6e0a 2020 2020 2020  al, Union.      
-00002240: 2020 3e3e 3e20 496e 7465 7276 616c 2830    >>> Interval(0
-00002250: 2c20 3129 2e73 7570 0a20 2020 2020 2020  , 1).sup.       
-00002260: 2031 0a20 2020 2020 2020 203e 3e3e 2055   1.        >>> U
-00002270: 6e69 6f6e 2849 6e74 6572 7661 6c28 302c  nion(Interval(0,
-00002280: 2031 292c 2049 6e74 6572 7661 6c28 322c   1), Interval(2,
-00002290: 2033 2929 2e73 7570 0a20 2020 2020 2020   3)).sup.       
-000022a0: 2033 0a0a 2020 2020 2020 2020 2222 220a   3..        """.
-000022b0: 2020 2020 2020 2020 7265 7475 726e 2073          return s
-000022c0: 656c 662e 5f73 7570 0a0a 2020 2020 4070  elf._sup..    @p
-000022d0: 726f 7065 7274 790a 2020 2020 6465 6620  roperty.    def 
-000022e0: 5f73 7570 2873 656c 6629 3a0a 2020 2020  _sup(self):.    
-000022f0: 2020 2020 7261 6973 6520 4e6f 7449 6d70      raise NotImp
-00002300: 6c65 6d65 6e74 6564 4572 726f 7228 2228  lementedError("(
-00002310: 2573 292e 5f73 7570 2220 2520 7365 6c66  %s)._sup" % self
-00002320: 290a 0a20 2020 2064 6566 205f 636f 6e74  )..    def _cont
-00002330: 6169 6e73 2873 656c 662c 206f 7468 6572  ains(self, other
-00002340: 293a 0a20 2020 2020 2020 2072 6169 7365  ):.        raise
-00002350: 204e 6f74 496d 706c 656d 656e 7465 6445   NotImplementedE
-00002360: 7272 6f72 2822 2825 7329 2e5f 636f 6e74  rror("(%s)._cont
-00002370: 6169 6e73 2825 7329 2220 2520 2873 656c  ains(%s)" % (sel
-00002380: 662c 206f 7468 6572 2929 0a0a 2020 2020  f, other))..    
-00002390: 6465 6620 6973 5f73 7562 7365 7428 7365  def is_subset(se
-000023a0: 6c66 2c20 6f74 6865 7229 3a0a 2020 2020  lf, other):.    
-000023b0: 2020 2020 2222 220a 2020 2020 2020 2020      """.        
-000023c0: 5265 7475 726e 7320 5472 7565 2069 6620  Returns True if 
-000023d0: 2773 656c 6627 2069 7320 6120 7375 6273  'self' is a subs
-000023e0: 6574 206f 6620 276f 7468 6572 272e 0a0a  et of 'other'...
-000023f0: 2020 2020 2020 2020 4578 616d 706c 6573          Examples
-00002400: 0a20 2020 2020 2020 203d 3d3d 3d3d 3d3d  .        =======
-00002410: 3d0a 0a20 2020 2020 2020 203e 3e3e 2066  =..        >>> f
-00002420: 726f 6d20 7379 6d70 7920 696d 706f 7274  rom sympy import
-00002430: 2049 6e74 6572 7661 6c0a 2020 2020 2020   Interval.      
-00002440: 2020 3e3e 3e20 496e 7465 7276 616c 2830    >>> Interval(0
-00002450: 2c20 302e 3529 2e69 735f 7375 6273 6574  , 0.5).is_subset
-00002460: 2849 6e74 6572 7661 6c28 302c 2031 2929  (Interval(0, 1))
-00002470: 0a20 2020 2020 2020 2054 7275 650a 2020  .        True.  
-00002480: 2020 2020 2020 3e3e 3e20 496e 7465 7276        >>> Interv
-00002490: 616c 2830 2c20 3129 2e69 735f 7375 6273  al(0, 1).is_subs
-000024a0: 6574 2849 6e74 6572 7661 6c28 302c 2031  et(Interval(0, 1
-000024b0: 2c20 6c65 6674 5f6f 7065 6e3d 5472 7565  , left_open=True
-000024c0: 2929 0a20 2020 2020 2020 2046 616c 7365  )).        False
-000024d0: 0a0a 2020 2020 2020 2020 2222 220a 2020  ..        """.  
-000024e0: 2020 2020 2020 6966 206f 7468 6572 2e69        if other.i
-000024f0: 735f 7365 743a 0a20 2020 2020 2020 2020  s_set:.         
-00002500: 2020 2023 2058 5858 2069 7373 7565 2031     # XXX issue 1
-00002510: 3638 3733 0a20 2020 2020 2020 2020 2020  6873.           
-00002520: 2023 2073 656c 6620 6d69 6768 7420 6265   # self might be
-00002530: 2061 6e20 756e 6576 616c 7561 7465 6420   an unevaluated 
-00002540: 666f 726d 206f 6620 7365 6c66 0a20 2020  form of self.   
-00002550: 2020 2020 2020 2020 2023 2073 6f20 7468           # so th
-00002560: 6520 6571 7561 6c69 7479 2074 6573 7420  e equality test 
-00002570: 7769 6c6c 2066 6169 6c0a 2020 2020 2020  will fail.      
-00002580: 2020 2020 2020 7265 7475 726e 2073 656c        return sel
-00002590: 662e 696e 7465 7273 6563 7428 6f74 6865  f.intersect(othe
-000025a0: 7229 203d 3d20 7365 6c66 0a20 2020 2020  r) == self.     
-000025b0: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
-000025c0: 2020 2020 2072 6169 7365 2056 616c 7565       raise Value
-000025d0: 4572 726f 7228 2255 6e6b 6e6f 776e 2061  Error("Unknown a
-000025e0: 7267 756d 656e 7420 2725 7327 2220 2520  rgument '%s'" % 
-000025f0: 6f74 6865 7229 0a0a 2020 2020 6465 6620  other)..    def 
-00002600: 6973 7375 6273 6574 2873 656c 662c 206f  issubset(self, o
-00002610: 7468 6572 293a 0a20 2020 2020 2020 2022  ther):.        "
-00002620: 2222 0a20 2020 2020 2020 2041 6c69 6173  "".        Alias
-00002630: 2066 6f72 203a 6d65 7468 3a60 6973 5f73   for :meth:`is_s
-00002640: 7562 7365 7428 2960 0a20 2020 2020 2020  ubset()`.       
-00002650: 2022 2222 0a20 2020 2020 2020 2072 6574   """.        ret
-00002660: 7572 6e20 7365 6c66 2e69 735f 7375 6273  urn self.is_subs
-00002670: 6574 286f 7468 6572 290a 0a20 2020 2064  et(other)..    d
-00002680: 6566 2069 735f 7072 6f70 6572 5f73 7562  ef is_proper_sub
-00002690: 7365 7428 7365 6c66 2c20 6f74 6865 7229  set(self, other)
-000026a0: 3a0a 2020 2020 2020 2020 2222 220a 2020  :.        """.  
-000026b0: 2020 2020 2020 5265 7475 726e 7320 5472        Returns Tr
-000026c0: 7565 2069 6620 2773 656c 6627 2069 7320  ue if 'self' is 
-000026d0: 6120 7072 6f70 6572 2073 7562 7365 7420  a proper subset 
-000026e0: 6f66 2027 6f74 6865 7227 2e0a 0a20 2020  of 'other'...   
-000026f0: 2020 2020 2045 7861 6d70 6c65 730a 2020       Examples.  
-00002700: 2020 2020 2020 3d3d 3d3d 3d3d 3d3d 0a0a        ========..
-00002710: 2020 2020 2020 2020 3e3e 3e20 6672 6f6d          >>> from
-00002720: 2073 796d 7079 2069 6d70 6f72 7420 496e   sympy import In
-00002730: 7465 7276 616c 0a20 2020 2020 2020 203e  terval.        >
-00002740: 3e3e 2049 6e74 6572 7661 6c28 302c 2030  >> Interval(0, 0
-00002750: 2e35 292e 6973 5f70 726f 7065 725f 7375  .5).is_proper_su
-00002760: 6273 6574 2849 6e74 6572 7661 6c28 302c  bset(Interval(0,
-00002770: 2031 2929 0a20 2020 2020 2020 2054 7275   1)).        Tru
-00002780: 650a 2020 2020 2020 2020 3e3e 3e20 496e  e.        >>> In
-00002790: 7465 7276 616c 2830 2c20 3129 2e69 735f  terval(0, 1).is_
-000027a0: 7072 6f70 6572 5f73 7562 7365 7428 496e  proper_subset(In
-000027b0: 7465 7276 616c 2830 2c20 3129 290a 2020  terval(0, 1)).  
-000027c0: 2020 2020 2020 4661 6c73 650a 0a20 2020        False..   
-000027d0: 2020 2020 2022 2222 0a20 2020 2020 2020       """.       
-000027e0: 2069 6620 6f74 6865 722e 6973 5f73 6574   if other.is_set
-000027f0: 3a0a 2020 2020 2020 2020 2020 2020 7265  :.            re
-00002800: 7475 726e 2073 656c 6620 213d 206f 7468  turn self != oth
-00002810: 6572 2061 6e64 2073 656c 662e 6973 5f73  er and self.is_s
-00002820: 7562 7365 7428 6f74 6865 7229 0a20 2020  ubset(other).   
-00002830: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
-00002840: 2020 2020 2020 2072 6169 7365 2056 616c         raise Val
-00002850: 7565 4572 726f 7228 2255 6e6b 6e6f 776e  ueError("Unknown
-00002860: 2061 7267 756d 656e 7420 2725 7327 2220   argument '%s'" 
-00002870: 2520 6f74 6865 7229 0a0a 2020 2020 6465  % other)..    de
-00002880: 6620 6973 5f73 7570 6572 7365 7428 7365  f is_superset(se
-00002890: 6c66 2c20 6f74 6865 7229 3a0a 2020 2020  lf, other):.    
-000028a0: 2020 2020 2222 220a 2020 2020 2020 2020      """.        
-000028b0: 5265 7475 726e 7320 5472 7565 2069 6620  Returns True if 
-000028c0: 2773 656c 6627 2069 7320 6120 7375 7065  'self' is a supe
-000028d0: 7273 6574 206f 6620 276f 7468 6572 272e  rset of 'other'.
-000028e0: 0a0a 2020 2020 2020 2020 4578 616d 706c  ..        Exampl
-000028f0: 6573 0a20 2020 2020 2020 203d 3d3d 3d3d  es.        =====
-00002900: 3d3d 3d0a 0a20 2020 2020 2020 203e 3e3e  ===..        >>>
-00002910: 2066 726f 6d20 7379 6d70 7920 696d 706f   from sympy impo
-00002920: 7274 2049 6e74 6572 7661 6c0a 2020 2020  rt Interval.    
-00002930: 2020 2020 3e3e 3e20 496e 7465 7276 616c      >>> Interval
-00002940: 2830 2c20 302e 3529 2e69 735f 7375 7065  (0, 0.5).is_supe
-00002950: 7273 6574 2849 6e74 6572 7661 6c28 302c  rset(Interval(0,
-00002960: 2031 2929 0a20 2020 2020 2020 2046 616c   1)).        Fal
-00002970: 7365 0a20 2020 2020 2020 203e 3e3e 2049  se.        >>> I
-00002980: 6e74 6572 7661 6c28 302c 2031 292e 6973  nterval(0, 1).is
-00002990: 5f73 7570 6572 7365 7428 496e 7465 7276  _superset(Interv
-000029a0: 616c 2830 2c20 312c 206c 6566 745f 6f70  al(0, 1, left_op
-000029b0: 656e 3d54 7275 6529 290a 2020 2020 2020  en=True)).      
-000029c0: 2020 5472 7565 0a0a 2020 2020 2020 2020    True..        
-000029d0: 2222 220a 2020 2020 2020 2020 6966 206f  """.        if o
-000029e0: 7468 6572 2e69 735f 7365 743a 0a20 2020  ther.is_set:.   
-000029f0: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
-00002a00: 6f74 6865 722e 6973 5f73 7562 7365 7428  other.is_subset(
-00002a10: 7365 6c66 290a 2020 2020 2020 2020 656c  self).        el
-00002a20: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
-00002a30: 7261 6973 6520 5661 6c75 6545 7272 6f72  raise ValueError
-00002a40: 2822 556e 6b6e 6f77 6e20 6172 6775 6d65  ("Unknown argume
-00002a50: 6e74 2027 2573 2722 2025 206f 7468 6572  nt '%s'" % other
-00002a60: 290a 0a20 2020 2064 6566 2069 7373 7570  )..    def issup
-00002a70: 6572 7365 7428 7365 6c66 2c20 6f74 6865  erset(self, othe
-00002a80: 7229 3a0a 2020 2020 2020 2020 2222 220a  r):.        """.
-00002a90: 2020 2020 2020 2020 416c 6961 7320 666f          Alias fo
-00002aa0: 7220 3a6d 6574 683a 6069 735f 7375 7065  r :meth:`is_supe
-00002ab0: 7273 6574 2829 600a 2020 2020 2020 2020  rset()`.        
-00002ac0: 2222 220a 2020 2020 2020 2020 7265 7475  """.        retu
-00002ad0: 726e 2073 656c 662e 6973 5f73 7570 6572  rn self.is_super
-00002ae0: 7365 7428 6f74 6865 7229 0a0a 2020 2020  set(other)..    
-00002af0: 6465 6620 6973 5f70 726f 7065 725f 7375  def is_proper_su
-00002b00: 7065 7273 6574 2873 656c 662c 206f 7468  perset(self, oth
-00002b10: 6572 293a 0a20 2020 2020 2020 2022 2222  er):.        """
-00002b20: 0a20 2020 2020 2020 2052 6574 7572 6e73  .        Returns
-00002b30: 2054 7275 6520 6966 2027 7365 6c66 2720   True if 'self' 
-00002b40: 6973 2061 2070 726f 7065 7220 7375 7065  is a proper supe
-00002b50: 7273 6574 206f 6620 276f 7468 6572 272e  rset of 'other'.
-00002b60: 0a0a 2020 2020 2020 2020 4578 616d 706c  ..        Exampl
-00002b70: 6573 0a20 2020 2020 2020 203d 3d3d 3d3d  es.        =====
-00002b80: 3d3d 3d0a 0a20 2020 2020 2020 203e 3e3e  ===..        >>>
-00002b90: 2066 726f 6d20 7379 6d70 7920 696d 706f   from sympy impo
-00002ba0: 7274 2049 6e74 6572 7661 6c0a 2020 2020  rt Interval.    
-00002bb0: 2020 2020 3e3e 3e20 496e 7465 7276 616c      >>> Interval
-00002bc0: 2830 2c20 3129 2e69 735f 7072 6f70 6572  (0, 1).is_proper
-00002bd0: 5f73 7570 6572 7365 7428 496e 7465 7276  _superset(Interv
-00002be0: 616c 2830 2c20 302e 3529 290a 2020 2020  al(0, 0.5)).    
-00002bf0: 2020 2020 5472 7565 0a20 2020 2020 2020      True.       
-00002c00: 203e 3e3e 2049 6e74 6572 7661 6c28 302c   >>> Interval(0,
-00002c10: 2031 292e 6973 5f70 726f 7065 725f 7375   1).is_proper_su
-00002c20: 7065 7273 6574 2849 6e74 6572 7661 6c28  perset(Interval(
-00002c30: 302c 2031 2929 0a20 2020 2020 2020 2046  0, 1)).        F
-00002c40: 616c 7365 0a0a 2020 2020 2020 2020 2222  alse..        ""
-00002c50: 220a 2020 2020 2020 2020 6966 206f 7468  ".        if oth
-00002c60: 6572 2e69 735f 7365 743a 0a20 2020 2020  er.is_set:.     
-00002c70: 2020 2020 2020 2072 6574 7572 6e20 7365         return se
-00002c80: 6c66 2021 3d20 6f74 6865 7220 616e 6420  lf != other and 
-00002c90: 7365 6c66 2e69 735f 7375 7065 7273 6574  self.is_superset
-00002ca0: 286f 7468 6572 290a 2020 2020 2020 2020  (other).        
-00002cb0: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
-00002cc0: 2020 7261 6973 6520 5661 6c75 6545 7272    raise ValueErr
-00002cd0: 6f72 2822 556e 6b6e 6f77 6e20 6172 6775  or("Unknown argu
-00002ce0: 6d65 6e74 2027 2573 2722 2025 206f 7468  ment '%s'" % oth
-00002cf0: 6572 290a 0a20 2020 2064 6566 205f 6576  er)..    def _ev
-00002d00: 616c 5f70 6f77 6572 7365 7428 7365 6c66  al_powerset(self
-00002d10: 293a 0a20 2020 2020 2020 2072 6169 7365  ):.        raise
-00002d20: 204e 6f74 496d 706c 656d 656e 7465 6445   NotImplementedE
-00002d30: 7272 6f72 2827 506f 7765 7220 7365 7420  rror('Power set 
-00002d40: 6e6f 7420 6465 6669 6e65 6420 666f 723a  not defined for:
-00002d50: 2025 7327 2025 2073 656c 662e 6675 6e63   %s' % self.func
-00002d60: 290a 0a20 2020 2064 6566 2070 6f77 6572  )..    def power
-00002d70: 7365 7428 7365 6c66 293a 0a20 2020 2020  set(self):.     
-00002d80: 2020 2022 2222 0a20 2020 2020 2020 2046     """.        F
-00002d90: 696e 6420 7468 6520 506f 7765 7220 7365  ind the Power se
-00002da0: 7420 6f66 2027 7365 6c66 272e 0a0a 2020  t of 'self'...  
-00002db0: 2020 2020 2020 4578 616d 706c 6573 0a20        Examples. 
-00002dc0: 2020 2020 2020 203d 3d3d 3d3d 3d3d 3d0a         ========.
-00002dd0: 0a20 2020 2020 2020 203e 3e3e 2066 726f  .        >>> fro
-00002de0: 6d20 7379 6d70 7920 696d 706f 7274 2046  m sympy import F
-00002df0: 696e 6974 6553 6574 2c20 456d 7074 7953  initeSet, EmptyS
-00002e00: 6574 0a20 2020 2020 2020 203e 3e3e 2041  et.        >>> A
-00002e10: 203d 2045 6d70 7479 5365 7428 290a 2020   = EmptySet().  
-00002e20: 2020 2020 2020 3e3e 3e20 412e 706f 7765        >>> A.powe
-00002e30: 7273 6574 2829 0a20 2020 2020 2020 207b  rset().        {
-00002e40: 456d 7074 7953 6574 2829 7d0a 2020 2020  EmptySet()}.    
-00002e50: 2020 2020 3e3e 3e20 4120 3d20 4669 6e69      >>> A = Fini
-00002e60: 7465 5365 7428 312c 2032 290a 2020 2020  teSet(1, 2).    
-00002e70: 2020 2020 3e3e 3e20 612c 2062 2c20 6320      >>> a, b, c 
-00002e80: 3d20 4669 6e69 7465 5365 7428 3129 2c20  = FiniteSet(1), 
-00002e90: 4669 6e69 7465 5365 7428 3229 2c20 4669  FiniteSet(2), Fi
-00002ea0: 6e69 7465 5365 7428 312c 2032 290a 2020  niteSet(1, 2).  
-00002eb0: 2020 2020 2020 3e3e 3e20 412e 706f 7765        >>> A.powe
-00002ec0: 7273 6574 2829 203d 3d20 4669 6e69 7465  rset() == Finite
-00002ed0: 5365 7428 612c 2062 2c20 632c 2045 6d70  Set(a, b, c, Emp
-00002ee0: 7479 5365 7428 2929 0a20 2020 2020 2020  tySet()).       
-00002ef0: 2054 7275 650a 0a20 2020 2020 2020 2052   True..        R
-00002f00: 6566 6572 656e 6365 730a 2020 2020 2020  eferences.      
-00002f10: 2020 3d3d 3d3d 3d3d 3d3d 3d3d 0a0a 2020    ==========..  
-00002f20: 2020 2020 2020 2e2e 205b 315d 2068 7474        .. [1] htt
-00002f30: 7073 3a2f 2f65 6e2e 7769 6b69 7065 6469  ps://en.wikipedi
-00002f40: 612e 6f72 672f 7769 6b69 2f50 6f77 6572  a.org/wiki/Power
-00002f50: 5f73 6574 0a0a 2020 2020 2020 2020 2222  _set..        ""
-00002f60: 220a 2020 2020 2020 2020 7265 7475 726e  ".        return
-00002f70: 2073 656c 662e 5f65 7661 6c5f 706f 7765   self._eval_powe
-00002f80: 7273 6574 2829 0a0a 2020 2020 4070 726f  rset()..    @pro
-00002f90: 7065 7274 790a 2020 2020 6465 6620 6d65  perty.    def me
-00002fa0: 6173 7572 6528 7365 6c66 293a 0a20 2020  asure(self):.   
-00002fb0: 2020 2020 2022 2222 0a20 2020 2020 2020       """.       
-00002fc0: 2054 6865 2028 4c65 6265 7367 7565 2920   The (Lebesgue) 
-00002fd0: 6d65 6173 7572 6520 6f66 2027 7365 6c66  measure of 'self
-00002fe0: 270a 0a20 2020 2020 2020 2045 7861 6d70  '..        Examp
-00002ff0: 6c65 730a 2020 2020 2020 2020 3d3d 3d3d  les.        ====
-00003000: 3d3d 3d3d 0a0a 2020 2020 2020 2020 3e3e  ====..        >>
-00003010: 3e20 6672 6f6d 2073 796d 7079 2069 6d70  > from sympy imp
-00003020: 6f72 7420 496e 7465 7276 616c 2c20 556e  ort Interval, Un
-00003030: 696f 6e0a 2020 2020 2020 2020 3e3e 3e20  ion.        >>> 
-00003040: 496e 7465 7276 616c 2830 2c20 3129 2e6d  Interval(0, 1).m
-00003050: 6561 7375 7265 0a20 2020 2020 2020 2031  easure.        1
-00003060: 0a20 2020 2020 2020 203e 3e3e 2055 6e69  .        >>> Uni
-00003070: 6f6e 2849 6e74 6572 7661 6c28 302c 2031  on(Interval(0, 1
-00003080: 292c 2049 6e74 6572 7661 6c28 322c 2033  ), Interval(2, 3
-00003090: 2929 2e6d 6561 7375 7265 0a20 2020 2020  )).measure.     
-000030a0: 2020 2032 0a0a 2020 2020 2020 2020 2222     2..        ""
-000030b0: 220a 2020 2020 2020 2020 7265 7475 726e  ".        return
-000030c0: 2073 656c 662e 5f6d 6561 7375 7265 0a0a   self._measure..
-000030d0: 2020 2020 4070 726f 7065 7274 790a 2020      @property.  
-000030e0: 2020 6465 6620 626f 756e 6461 7279 2873    def boundary(s
-000030f0: 656c 6629 3a0a 2020 2020 2020 2020 2222  elf):.        ""
-00003100: 220a 2020 2020 2020 2020 5468 6520 626f  ".        The bo
-00003110: 756e 6461 7279 206f 7220 6672 6f6e 7469  undary or fronti
-00003120: 6572 206f 6620 6120 7365 740a 0a20 2020  er of a set..   
-00003130: 2020 2020 2041 2070 6f69 6e74 2078 2069       A point x i
-00003140: 7320 6f6e 2074 6865 2062 6f75 6e64 6172  s on the boundar
-00003150: 7920 6f66 2061 2073 6574 2053 2069 660a  y of a set S if.
-00003160: 0a20 2020 2020 2020 2031 2e20 2078 2069  .        1.  x i
-00003170: 7320 696e 2074 6865 2063 6c6f 7375 7265  s in the closure
-00003180: 206f 6620 532e 0a20 2020 2020 2020 2020   of S..         
-00003190: 2020 2049 2e65 2e20 4576 6572 7920 6e65     I.e. Every ne
-000031a0: 6967 6862 6f72 686f 6f64 206f 6620 7820  ighborhood of x 
-000031b0: 636f 6e74 6169 6e73 2061 2070 6f69 6e74  contains a point
-000031c0: 2069 6e20 532e 0a20 2020 2020 2020 2032   in S..        2
-000031d0: 2e20 2078 2069 7320 6e6f 7420 696e 2074  .  x is not in t
-000031e0: 6865 2069 6e74 6572 696f 7220 6f66 2053  he interior of S
-000031f0: 2e0a 2020 2020 2020 2020 2020 2020 492e  ..            I.
-00003200: 652e 2054 6865 7265 2064 6f65 7320 6e6f  e. There does no
-00003210: 7420 6578 6973 7420 616e 206f 7065 6e20  t exist an open 
-00003220: 7365 7420 6365 6e74 6572 6564 206f 6e20  set centered on 
-00003230: 7820 636f 6e74 6169 6e65 640a 2020 2020  x contained.    
-00003240: 2020 2020 2020 2020 656e 7469 7265 6c79          entirely
-00003250: 2077 6974 6869 6e20 532e 0a0a 2020 2020   within S...    
-00003260: 2020 2020 5468 6572 6520 6172 6520 7468      There are th
-00003270: 6520 706f 696e 7473 206f 6e20 7468 6520  e points on the 
-00003280: 6f75 7465 7220 7269 6d20 6f66 2053 2e20  outer rim of S. 
-00003290: 2049 6620 5320 6973 206f 7065 6e20 7468   If S is open th
-000032a0: 656e 2074 6865 7365 0a20 2020 2020 2020  en these.       
-000032b0: 2070 6f69 6e74 7320 6e65 6564 206e 6f74   points need not
-000032c0: 2061 6374 7561 6c6c 7920 6265 2063 6f6e   actually be con
-000032d0: 7461 696e 6564 2077 6974 6869 6e20 532e  tained within S.
-000032e0: 0a0a 2020 2020 2020 2020 466f 7220 6578  ..        For ex
-000032f0: 616d 706c 652c 2074 6865 2062 6f75 6e64  ample, the bound
-00003300: 6172 7920 6f66 2061 6e20 696e 7465 7276  ary of an interv
-00003310: 616c 2069 7320 6974 7320 7374 6172 7420  al is its start 
-00003320: 616e 6420 656e 6420 706f 696e 7473 2e0a  and end points..
-00003330: 2020 2020 2020 2020 5468 6973 2069 7320          This is 
-00003340: 7472 7565 2072 6567 6172 646c 6573 7320  true regardless 
-00003350: 6f66 2077 6865 7468 6572 206f 7220 6e6f  of whether or no
-00003360: 7420 7468 6520 696e 7465 7276 616c 2069  t the interval i
-00003370: 7320 6f70 656e 2e0a 0a20 2020 2020 2020  s open...       
-00003380: 2045 7861 6d70 6c65 730a 2020 2020 2020   Examples.      
-00003390: 2020 3d3d 3d3d 3d3d 3d3d 0a0a 2020 2020    ========..    
-000033a0: 2020 2020 3e3e 3e20 6672 6f6d 2073 796d      >>> from sym
-000033b0: 7079 2069 6d70 6f72 7420 496e 7465 7276  py import Interv
-000033c0: 616c 0a20 2020 2020 2020 203e 3e3e 2049  al.        >>> I
-000033d0: 6e74 6572 7661 6c28 302c 2031 292e 626f  nterval(0, 1).bo
-000033e0: 756e 6461 7279 0a20 2020 2020 2020 207b  undary.        {
-000033f0: 302c 2031 7d0a 2020 2020 2020 2020 2222  0, 1}.        ""
-00003400: 220a 2020 2020 2020 2020 7265 7475 726e  ".        return
-00003410: 2073 656c 662e 5f62 6f75 6e64 6172 790a   self._boundary.
-00003420: 0a20 2020 2040 7072 6f70 6572 7479 0a20  .    @property. 
-00003430: 2020 2064 6566 2069 735f 6f70 656e 2873     def is_open(s
-00003440: 656c 6629 3a0a 2020 2020 2020 2020 2222  elf):.        ""
-00003450: 220a 2020 2020 2020 2020 5072 6f70 6572  ".        Proper
-00003460: 7479 206d 6574 686f 6420 746f 2063 6865  ty method to che
-00003470: 636b 2077 6865 7468 6572 2061 2073 6574  ck whether a set
-00003480: 2069 7320 6f70 656e 2e0a 2020 2020 2020   is open..      
-00003490: 2020 4120 7365 7420 6973 206f 7065 6e20    A set is open 
-000034a0: 6966 2061 6e64 206f 6e6c 7920 6966 2069  if and only if i
-000034b0: 7420 6861 7320 616e 2065 6d70 7479 2069  t has an empty i
-000034c0: 6e74 6572 7365 6374 696f 6e20 7769 7468  ntersection with
-000034d0: 2069 7473 0a20 2020 2020 2020 2062 6f75   its.        bou
-000034e0: 6e64 6172 792e 0a0a 2020 2020 2020 2020  ndary...        
-000034f0: 4578 616d 706c 6573 0a20 2020 2020 2020  Examples.       
-00003500: 203d 3d3d 3d3d 3d3d 3d0a 2020 2020 2020   ========.      
-00003510: 2020 3e3e 3e20 6672 6f6d 2073 796d 7079    >>> from sympy
-00003520: 2069 6d70 6f72 7420 530a 2020 2020 2020   import S.      
-00003530: 2020 3e3e 3e20 5265 616c 732e 6973 5f6f    >>> Reals.is_o
-00003540: 7065 6e0a 2020 2020 2020 2020 5472 7565  pen.        True
-00003550: 0a20 2020 2020 2020 2022 2222 0a20 2020  .        """.   
-00003560: 2020 2020 2069 6620 6e6f 7420 496e 7465       if not Inte
-00003570: 7273 6563 7469 6f6e 2873 656c 662c 2073  rsection(self, s
-00003580: 656c 662e 626f 756e 6461 7279 293a 0a20  elf.boundary):. 
-00003590: 2020 2020 2020 2020 2020 2072 6574 7572             retur
-000035a0: 6e20 5472 7565 0a20 2020 2020 2020 2023  n True.        #
-000035b0: 2057 6520 6361 6e27 7420 636f 6e66 6964   We can't confid
-000035c0: 656e 746c 7920 636c 6169 6d20 7468 6174  ently claim that
-000035d0: 2061 6e20 696e 7465 7273 6563 7469 6f6e   an intersection
-000035e0: 2065 7869 7374 730a 2020 2020 2020 2020   exists.        
-000035f0: 7265 7475 726e 204e 6f6e 650a 0a20 2020  return None..   
-00003600: 2040 7072 6f70 6572 7479 0a20 2020 2064   @property.    d
-00003610: 6566 2069 735f 636c 6f73 6564 2873 656c  ef is_closed(sel
-00003620: 6629 3a0a 2020 2020 2020 2020 2222 220a  f):.        """.
-00003630: 2020 2020 2020 2020 4120 7072 6f70 6572          A proper
-00003640: 7479 206d 6574 686f 6420 746f 2063 6865  ty method to che
-00003650: 636b 2077 6865 7468 6572 2061 2073 6574  ck whether a set
-00003660: 2069 7320 636c 6f73 6564 2e20 4120 7365   is closed. A se
-00003670: 7420 6973 2063 6c6f 7365 640a 2020 2020  t is closed.    
-00003680: 2020 2020 6966 2069 7427 7320 636f 6d70      if it's comp
-00003690: 6c65 6d65 6e74 2069 7320 616e 206f 7065  lement is an ope
-000036a0: 6e20 7365 742e 0a0a 2020 2020 2020 2020  n set...        
-000036b0: 4578 616d 706c 6573 0a20 2020 2020 2020  Examples.       
-000036c0: 203d 3d3d 3d3d 3d3d 3d0a 2020 2020 2020   ========.      
-000036d0: 2020 3e3e 3e20 6672 6f6d 2073 796d 7079    >>> from sympy
-000036e0: 2069 6d70 6f72 7420 496e 7465 7276 616c   import Interval
-000036f0: 0a20 2020 2020 2020 203e 3e3e 2049 6e74  .        >>> Int
-00003700: 6572 7661 6c28 302c 2031 292e 6973 5f63  erval(0, 1).is_c
-00003710: 6c6f 7365 640a 2020 2020 2020 2020 5472  losed.        Tr
-00003720: 7565 0a20 2020 2020 2020 2022 2222 0a20  ue.        """. 
-00003730: 2020 2020 2020 2072 6574 7572 6e20 7365         return se
-00003740: 6c66 2e62 6f75 6e64 6172 792e 6973 5f73  lf.boundary.is_s
-00003750: 7562 7365 7428 7365 6c66 290a 0a20 2020  ubset(self)..   
-00003760: 2040 7072 6f70 6572 7479 0a20 2020 2064   @property.    d
-00003770: 6566 2063 6c6f 7375 7265 2873 656c 6629  ef closure(self)
-00003780: 3a0a 2020 2020 2020 2020 2222 220a 2020  :.        """.  
-00003790: 2020 2020 2020 5072 6f70 6572 7479 206d        Property m
-000037a0: 6574 686f 6420 7768 6963 6820 7265 7475  ethod which retu
-000037b0: 726e 7320 7468 6520 636c 6f73 7572 6520  rns the closure 
-000037c0: 6f66 2061 2073 6574 2e0a 2020 2020 2020  of a set..      
-000037d0: 2020 5468 6520 636c 6f73 7572 6520 6973    The closure is
-000037e0: 2064 6566 696e 6564 2061 7320 7468 6520   defined as the 
-000037f0: 756e 696f 6e20 6f66 2074 6865 2073 6574  union of the set
-00003800: 2069 7473 656c 6620 616e 6420 6974 730a   itself and its.
-00003810: 2020 2020 2020 2020 626f 756e 6461 7279          boundary
-00003820: 2e0a 0a20 2020 2020 2020 2045 7861 6d70  ...        Examp
-00003830: 6c65 730a 2020 2020 2020 2020 3d3d 3d3d  les.        ====
-00003840: 3d3d 3d3d 0a20 2020 2020 2020 203e 3e3e  ====.        >>>
-00003850: 2066 726f 6d20 7379 6d70 7920 696d 706f   from sympy impo
-00003860: 7274 2053 2c20 496e 7465 7276 616c 0a20  rt S, Interval. 
-00003870: 2020 2020 2020 203e 3e3e 2052 6561 6c73         >>> Reals
-00003880: 2e63 6c6f 7375 7265 0a20 2020 2020 2020  .closure.       
-00003890: 2052 6561 6c73 0a20 2020 2020 2020 203e   Reals.        >
-000038a0: 3e3e 2049 6e74 6572 7661 6c28 302c 2031  >> Interval(0, 1
-000038b0: 292e 636c 6f73 7572 650a 2020 2020 2020  ).closure.      
-000038c0: 2020 496e 7465 7276 616c 2830 2c20 3129    Interval(0, 1)
-000038d0: 0a20 2020 2020 2020 2022 2222 0a20 2020  .        """.   
-000038e0: 2020 2020 2072 6574 7572 6e20 7365 6c66       return self
-000038f0: 202b 2073 656c 662e 626f 756e 6461 7279   + self.boundary
-00003900: 0a0a 2020 2020 4070 726f 7065 7274 790a  ..    @property.
-00003910: 2020 2020 6465 6620 696e 7465 7269 6f72      def interior
-00003920: 2873 656c 6629 3a0a 2020 2020 2020 2020  (self):.        
-00003930: 2222 220a 2020 2020 2020 2020 5072 6f70  """.        Prop
-00003940: 6572 7479 206d 6574 686f 6420 7768 6963  erty method whic
-00003950: 6820 7265 7475 726e 7320 7468 6520 696e  h returns the in
-00003960: 7465 7269 6f72 206f 6620 6120 7365 742e  terior of a set.
-00003970: 0a20 2020 2020 2020 2054 6865 2069 6e74  .        The int
-00003980: 6572 696f 7220 6f66 2061 2073 6574 2053  erior of a set S
-00003990: 2063 6f6e 7369 7374 7320 616c 6c20 706f   consists all po
-000039a0: 696e 7473 206f 6620 5320 7468 6174 2064  ints of S that d
-000039b0: 6f20 6e6f 740a 2020 2020 2020 2020 6265  o not.        be
-000039c0: 6c6f 6e67 2074 6f20 7468 6520 626f 756e  long to the boun
-000039d0: 6461 7279 206f 6620 532e 0a0a 2020 2020  dary of S...    
-000039e0: 2020 2020 4578 616d 706c 6573 0a20 2020      Examples.   
-000039f0: 2020 2020 203d 3d3d 3d3d 3d3d 3d0a 2020       ========.  
-00003a00: 2020 2020 2020 3e3e 3e20 6672 6f6d 2073        >>> from s
-00003a10: 796d 7079 2069 6d70 6f72 7420 496e 7465  ympy import Inte
-00003a20: 7276 616c 0a20 2020 2020 2020 203e 3e3e  rval.        >>>
-00003a30: 2049 6e74 6572 7661 6c28 302c 2031 292e   Interval(0, 1).
-00003a40: 696e 7465 7269 6f72 0a20 2020 2020 2020  interior.       
-00003a50: 2049 6e74 6572 7661 6c2e 6f70 656e 2830   Interval.open(0
-00003a60: 2c20 3129 0a20 2020 2020 2020 203e 3e3e  , 1).        >>>
-00003a70: 2049 6e74 6572 7661 6c28 302c 2031 292e   Interval(0, 1).
-00003a80: 626f 756e 6461 7279 2e69 6e74 6572 696f  boundary.interio
-00003a90: 720a 2020 2020 2020 2020 456d 7074 7953  r.        EmptyS
-00003aa0: 6574 2829 0a20 2020 2020 2020 2022 2222  et().        """
-00003ab0: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
-00003ac0: 7365 6c66 202d 2073 656c 662e 626f 756e  self - self.boun
-00003ad0: 6461 7279 0a0a 2020 2020 4070 726f 7065  dary..    @prope
-00003ae0: 7274 790a 2020 2020 6465 6620 5f62 6f75  rty.    def _bou
-00003af0: 6e64 6172 7928 7365 6c66 293a 0a20 2020  ndary(self):.   
-00003b00: 2020 2020 2072 6169 7365 204e 6f74 496d       raise NotIm
-00003b10: 706c 656d 656e 7465 6445 7272 6f72 2829  plementedError()
-00003b20: 0a0a 2020 2020 4070 726f 7065 7274 790a  ..    @property.
-00003b30: 2020 2020 6465 6620 5f6d 6561 7375 7265      def _measure
-00003b40: 2873 656c 6629 3a0a 2020 2020 2020 2020  (self):.        
-00003b50: 7261 6973 6520 4e6f 7449 6d70 6c65 6d65  raise NotImpleme
-00003b60: 6e74 6564 4572 726f 7228 2228 2573 292e  ntedError("(%s).
-00003b70: 5f6d 6561 7375 7265 2220 2520 7365 6c66  _measure" % self
-00003b80: 290a 0a20 2020 2064 6566 205f 5f61 6464  )..    def __add
-00003b90: 5f5f 2873 656c 662c 206f 7468 6572 293a  __(self, other):
-00003ba0: 0a20 2020 2020 2020 2072 6169 7365 2045  .        raise E
-00003bb0: 7863 6570 7469 6f6e 2822 636f 756c 6420  xception("could 
-00003bc0: 6e6f 7420 6164 6420 2573 2c20 2573 2220  not add %s, %s" 
-00003bd0: 2520 2873 656c 662c 206f 7468 6572 2929  % (self, other))
-00003be0: 0a0a 2020 2020 6465 6620 5f5f 6f72 5f5f  ..    def __or__
-00003bf0: 2873 656c 662c 206f 7468 6572 293a 0a20  (self, other):. 
-00003c00: 2020 2020 2020 2072 6574 7572 6e20 7365         return se
-00003c10: 6c66 2e75 6e69 6f6e 286f 7468 6572 290a  lf.union(other).
-00003c20: 0a20 2020 2064 6566 205f 5f61 6e64 5f5f  .    def __and__
-00003c30: 2873 656c 662c 206f 7468 6572 293a 0a20  (self, other):. 
-00003c40: 2020 2020 2020 2072 6574 7572 6e20 7365         return se
-00003c50: 6c66 2e69 6e74 6572 7365 6374 286f 7468  lf.intersect(oth
-00003c60: 6572 290a 0a20 2020 2064 6566 205f 5f6d  er)..    def __m
-00003c70: 6174 6d75 6c5f 5f28 7365 6c66 2c20 6f74  atmul__(self, ot
-00003c80: 6865 7229 3a0a 2020 2020 2020 2020 7265  her):.        re
-00003c90: 7475 726e 2050 726f 6475 6374 5365 7428  turn ProductSet(
-00003ca0: 7365 6c66 2c20 6f74 6865 7229 0a0a 2020  self, other)..  
-00003cb0: 2020 6465 6620 5f5f 6d75 6c5f 5f28 7365    def __mul__(se
-00003cc0: 6c66 2c20 6f74 6865 7229 3a0a 2020 2020  lf, other):.    
-00003cd0: 2020 2020 7261 6973 6520 4578 6365 7074      raise Except
-00003ce0: 696f 6e28 2263 6f75 6c64 206e 6f74 206d  ion("could not m
-00003cf0: 756c 7469 706c 7920 2573 2c20 2573 2220  ultiply %s, %s" 
-00003d00: 2520 2873 656c 662c 206f 7468 6572 2929  % (self, other))
-00003d10: 0a0a 2020 2020 6465 6620 5f5f 786f 725f  ..    def __xor_
-00003d20: 5f28 7365 6c66 2c20 6f74 6865 7229 3a0a  _(self, other):.
-00003d30: 2020 2020 2020 2020 7265 7475 726e 2053          return S
-00003d40: 796d 6d65 7472 6963 4469 6666 6572 656e  ymmetricDifferen
-00003d50: 6365 2873 656c 662c 206f 7468 6572 290a  ce(self, other).
-00003d60: 0a20 2020 2064 6566 205f 5f70 6f77 5f5f  .    def __pow__
-00003d70: 2873 656c 662c 2065 7870 293a 0a20 2020  (self, exp):.   
-00003d80: 2020 2020 2069 6620 6e6f 7420 7379 6d70       if not symp
-00003d90: 6966 7928 6578 7029 2e69 735f 496e 7465  ify(exp).is_Inte
-00003da0: 6765 7220 616e 6420 6578 7020 3e3d 2030  ger and exp >= 0
-00003db0: 3a0a 2020 2020 2020 2020 2020 2020 7261  :.            ra
-00003dc0: 6973 6520 5661 6c75 6545 7272 6f72 2822  ise ValueError("
-00003dd0: 2573 3a20 4578 706f 6e65 6e74 206d 7573  %s: Exponent mus
-00003de0: 7420 6265 2061 2070 6f73 6974 6976 6520  t be a positive 
-00003df0: 496e 7465 6765 7222 2025 2065 7870 290a  Integer" % exp).
-00003e00: 2020 2020 2020 2020 7265 7475 726e 2050          return P
-00003e10: 726f 6475 6374 5365 7428 5b73 656c 665d  roductSet([self]
-00003e20: 202a 2065 7870 290a 0a20 2020 2064 6566   * exp)..    def
-00003e30: 205f 5f73 7562 5f5f 2873 656c 662c 206f   __sub__(self, o
-00003e40: 7468 6572 293a 200a 2020 2020 2020 2020  ther): .        
-00003e50: 7265 7475 726e 2043 6f6d 706c 656d 656e  return Complemen
-00003e60: 7428 7365 6c66 2c20 6f74 6865 7229 0a0a  t(self, other)..
-00003e70: 2020 2020 2320 7065 7266 6f72 6d69 6e67      # performing
-00003e80: 206f 7468 6572 2069 6e20 7365 6c66 0a20   other in self. 
-00003e90: 2020 2064 6566 205f 5f63 6f6e 7461 696e     def __contain
-00003ea0: 735f 5f28 7365 6c66 2c20 6f74 6865 7229  s__(self, other)
-00003eb0: 3a0a 2020 2020 2020 2020 636f 6e74 6169  :.        contai
-00003ec0: 6e73 203d 2073 656c 662e 636f 6e74 6169  ns = self.contai
-00003ed0: 6e73 5f77 6974 685f 7375 6273 6574 286f  ns_with_subset(o
-00003ee0: 7468 6572 290a 2020 2020 2020 2020 6966  ther).        if
-00003ef0: 2063 6f6e 7461 696e 7320 6973 206e 6f74   contains is not
-00003f00: 204e 6f6e 653a 0a20 2020 2020 2020 2020   None:.         
-00003f10: 2020 2072 6574 7572 6e20 636f 6e74 6169     return contai
-00003f20: 6e73 0a20 2020 2020 2020 200a 2020 2020  ns.        .    
-00003f30: 2020 2020 7265 7475 726e 2073 796d 7069      return sympi
-00003f40: 6679 2873 656c 662e 636f 6e74 6169 6e73  fy(self.contains
-00003f50: 286f 7468 6572 2929 0a0a 2020 2020 6465  (other))..    de
-00003f60: 6620 636f 6e6a 7567 6174 6528 7365 6c66  f conjugate(self
-00003f70: 293a 0a20 2020 2020 2020 2066 726f 6d20  ):.        from 
-00003f80: 7379 6d70 792e 6675 6e63 7469 6f6e 732e  sympy.functions.
-00003f90: 656c 656d 656e 7461 7279 2e63 6f6d 706c  elementary.compl
-00003fa0: 6578 6573 2069 6d70 6f72 7420 636f 6e6a  exes import conj
-00003fb0: 7567 6174 650a 2020 2020 2020 2020 7265  ugate.        re
-00003fc0: 7475 726e 2063 6f6e 6a75 6761 7465 2873  turn conjugate(s
-00003fd0: 656c 6629 0a0a 2020 2020 6465 6620 5f65  elf)..    def _e
-00003fe0: 7661 6c5f 636f 6e6a 7567 6174 6528 7365  val_conjugate(se
-00003ff0: 6c66 293a 0a20 2020 2020 2020 2072 6574  lf):.        ret
-00004000: 7572 6e0a 0a20 2020 2064 6566 205f 6576  urn..    def _ev
-00004010: 616c 5f69 735f 6e6f 6e65 6d70 7479 2873  al_is_nonempty(s
-00004020: 656c 6629 3a0a 2020 2020 2020 2020 6966  elf):.        if
-00004030: 2073 656c 662e 7368 6170 653a 0a20 2020   self.shape:.   
-00004040: 2020 2020 2020 2020 2072 6574 7572 6e0a           return.
-00004050: 0a20 2020 2020 2020 207a 6572 6f20 3d20  .        zero = 
-00004060: 7365 6c66 2e69 735f 656d 7074 790a 2020  self.is_empty.  
-00004070: 2020 2020 2020 6966 207a 6572 6f3a 0a20        if zero:. 
-00004080: 2020 2020 2020 2020 2020 2072 6574 7572             retur
-00004090: 6e20 4661 6c73 650a 0a20 2020 2020 2020  n False..       
-000040a0: 2069 6620 7a65 726f 203d 3d20 4661 6c73   if zero == Fals
-000040b0: 653a 0a20 2020 2020 2020 2020 2020 2072  e:.            r
-000040c0: 6574 7572 6e20 5472 7565 0a0a 0a63 6c61  eturn True...cla
-000040d0: 7373 2050 726f 6475 6374 5365 7428 5365  ss ProductSet(Se
-000040e0: 7429 3a0a 2020 2020 2222 220a 2020 2020  t):.    """.    
-000040f0: 5265 7072 6573 656e 7473 2061 2043 6172  Represents a Car
-00004100: 7465 7369 616e 2050 726f 6475 6374 206f  tesian Product o
-00004110: 6620 5365 7473 2e0a 0a20 2020 2052 6574  f Sets...    Ret
-00004120: 7572 6e73 2061 2043 6172 7465 7369 616e  urns a Cartesian
-00004130: 2070 726f 6475 6374 2067 6976 656e 2073   product given s
-00004140: 6576 6572 616c 2073 6574 7320 6173 2065  everal sets as e
-00004150: 6974 6865 7220 616e 2069 7465 7261 626c  ither an iterabl
-00004160: 650a 2020 2020 6f72 2069 6e64 6976 6964  e.    or individ
-00004170: 7561 6c20 6172 6775 6d65 6e74 732e 0a0a  ual arguments...
-00004180: 2020 2020 4361 6e20 7573 6520 272a 2720      Can use '*' 
-00004190: 6f70 6572 6174 6f72 206f 6e20 616e 7920  operator on any 
-000041a0: 7365 7473 2066 6f72 2063 6f6e 7665 6e69  sets for conveni
-000041b0: 656e 7420 7368 6f72 7468 616e 642e 0a0a  ent shorthand...
-000041c0: 2020 2020 4578 616d 706c 6573 0a20 2020      Examples.   
-000041d0: 203d 3d3d 3d3d 3d3d 3d0a 0a20 2020 203e   ========..    >
-000041e0: 3e3e 2066 726f 6d20 7379 6d70 7920 696d  >> from sympy im
-000041f0: 706f 7274 2049 6e74 6572 7661 6c2c 2046  port Interval, F
-00004200: 696e 6974 6553 6574 2c20 5072 6f64 7563  initeSet, Produc
-00004210: 7453 6574 0a20 2020 203e 3e3e 2049 203d  tSet.    >>> I =
-00004220: 2049 6e74 6572 7661 6c28 302c 2035 293b   Interval(0, 5);
-00004230: 2053 203d 2046 696e 6974 6553 6574 2831   S = FiniteSet(1
-00004240: 2c20 322c 2033 290a 2020 2020 3e3e 3e20  , 2, 3).    >>> 
-00004250: 5072 6f64 7563 7453 6574 2849 2c20 5329  ProductSet(I, S)
-00004260: 0a20 2020 2049 6e74 6572 7661 6c28 302c  .    Interval(0,
-00004270: 2035 2920 7820 7b31 2c20 322c 2033 7d0a   5) x {1, 2, 3}.
-00004280: 0a20 2020 203e 3e3e 2028 322c 2032 2920  .    >>> (2, 2) 
-00004290: 696e 2050 726f 6475 6374 5365 7428 492c  in ProductSet(I,
-000042a0: 2053 290a 2020 2020 5472 7565 0a0a 2020   S).    True..  
-000042b0: 2020 3e3e 3e20 496e 7465 7276 616c 2830    >>> Interval(0
-000042c0: 2c20 3129 202a 2049 6e74 6572 7661 6c28  , 1) * Interval(
-000042d0: 302c 2031 2920 2320 5468 6520 756e 6974  0, 1) # The unit
-000042e0: 2073 7175 6172 650a 2020 2020 496e 7465   square.    Inte
-000042f0: 7276 616c 2830 2c20 3129 2078 2049 6e74  rval(0, 1) x Int
-00004300: 6572 7661 6c28 302c 2031 290a 0a20 2020  erval(0, 1)..   
-00004310: 203e 3e3e 2063 6f69 6e20 3d20 4669 6e69   >>> coin = Fini
-00004320: 7465 5365 7428 2748 272c 2027 5427 290a  teSet('H', 'T').
-00004330: 2020 2020 3e3e 3e20 7365 7428 636f 696e      >>> set(coin
-00004340: 2a2a 3229 0a20 2020 207b 2848 2c20 4829  **2).    {(H, H)
-00004350: 2c20 2848 2c20 5429 2c20 2854 2c20 4829  , (H, T), (T, H)
-00004360: 2c20 2854 2c20 5429 7d0a 0a0a 2020 2020  , (T, T)}...    
-00004370: 4e6f 7465 730a 2020 2020 3d3d 3d3d 3d0a  Notes.    =====.
-00004380: 0a20 2020 202d 2050 6173 7365 7320 6d6f  .    - Passes mo
-00004390: 7374 206f 7065 7261 7469 6f6e 7320 646f  st operations do
-000043a0: 776e 2074 6f20 7468 6520 6172 6775 6d65  wn to the argume
-000043b0: 6e74 2073 6574 730a 2020 2020 2d20 466c  nt sets.    - Fl
-000043c0: 6174 7465 6e73 2050 726f 6475 6374 7320  attens Products 
-000043d0: 6f66 2050 726f 6475 6374 5365 7473 0a0a  of ProductSets..
-000043e0: 2020 2020 5265 6665 7265 6e63 6573 0a20      References. 
-000043f0: 2020 203d 3d3d 3d3d 3d3d 3d3d 3d0a 0a20     ==========.. 
-00004400: 2020 202e 2e20 5b31 5d20 6874 7470 733a     .. [1] https:
-00004410: 2f2f 656e 2e77 696b 6970 6564 6961 2e6f  //en.wikipedia.o
-00004420: 7267 2f77 696b 692f 4361 7274 6573 6961  rg/wiki/Cartesia
-00004430: 6e5f 7072 6f64 7563 740a 2020 2020 2222  n_product.    ""
-00004440: 220a 2020 2020 6465 6620 696e 7465 7273  ".    def inters
-00004450: 6563 7469 6f6e 5f73 6574 7328 7365 6c66  ection_sets(self
-00004460: 2c20 6229 3a0a 2020 2020 2020 2020 6966  , b):.        if
-00004470: 206e 6f74 2062 2e69 735f 5072 6f64 7563   not b.is_Produc
-00004480: 7453 6574 3a0a 2020 2020 2020 2020 2020  tSet:.          
-00004490: 2020 7265 7475 726e 204e 6f6e 650a 0a20    return None.. 
-000044a0: 2020 2020 2020 2069 6620 6c65 6e28 622e         if len(b.
-000044b0: 6172 6773 2920 213d 206c 656e 2873 656c  args) != len(sel
-000044c0: 662e 6172 6773 293a 0a20 2020 2020 2020  f.args):.       
-000044d0: 2020 2020 2072 6574 7572 6e20 456d 7074       return Empt
-000044e0: 7953 6574 2829 0a20 2020 2020 2020 2072  ySet().        r
-000044f0: 6574 7572 6e20 5072 6f64 7563 7453 6574  eturn ProductSet
-00004500: 2869 2e69 6e74 6572 7365 6374 286a 290a  (i.intersect(j).
-00004510: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004520: 666f 7220 692c 206a 2069 6e20 7a69 7028  for i, j in zip(
-00004530: 7365 6c66 2e73 6574 732c 2062 2e73 6574  self.sets, b.set
-00004540: 7329 290a 0a20 2020 2064 6566 2075 6e69  s))..    def uni
-00004550: 6f6e 5f73 6574 7328 7365 6c66 2c20 6229  on_sets(self, b)
-00004560: 3a0a 2020 2020 2020 2020 6966 2062 2e69  :.        if b.i
-00004570: 735f 5072 6f64 7563 7453 6574 3a0a 2020  s_ProductSet:.  
-00004580: 2020 2020 2020 2020 2020 6966 2062 2e69            if b.i
-00004590: 735f 7375 6273 6574 2873 656c 6629 3a0a  s_subset(self):.
-000045a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000045b0: 7265 7475 726e 2073 656c 660a 2020 2020  return self.    
-000045c0: 2020 2020 2020 2020 6966 206c 656e 2862          if len(b
-000045d0: 2e61 7267 7329 2021 3d20 6c65 6e28 7365  .args) != len(se
-000045e0: 6c66 2e61 7267 7329 3a0a 2020 2020 2020  lf.args):.      
-000045f0: 2020 2020 2020 2020 2020 7265 7475 726e            return
-00004600: 204e 6f6e 650a 2020 2020 2020 2020 2020   None.          
-00004610: 2020 6966 2073 656c 662e 6172 6773 5b30    if self.args[0
-00004620: 5d20 3d3d 2062 2e61 7267 735b 305d 3a0a  ] == b.args[0]:.
-00004630: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004640: 7265 7475 726e 2073 656c 662e 6172 6773  return self.args
-00004650: 5b30 5d20 2a20 556e 696f 6e28 5072 6f64  [0] * Union(Prod
-00004660: 7563 7453 6574 2873 656c 662e 6172 6773  uctSet(self.args
-00004670: 5b31 3a5d 292c 0a20 2020 2020 2020 2020  [1:]),.         
-00004680: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00000610: 2873 656c 6629 3a0a 2020 2020 2020 2020  (self):.        
+00000620: 2e2e 2e0a 2020 2020 2020 2020 0a20 2020  ....        .   
+00000630: 2040 7072 6f70 6572 7479 0a20 2020 2064   @property.    d
+00000640: 6566 2064 6f6d 6169 6e28 7365 6c66 293a  ef domain(self):
+00000650: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
+00000660: 7365 6c66 2e75 6e69 7665 7273 616c 5365  self.universalSe
+00000670: 7420 2020 2020 2020 200a 2020 2020 0a20  t        .    . 
+00000680: 2020 2064 6566 205f 6576 616c 5f73 6861     def _eval_sha
+00000690: 7065 2873 656c 6629 3a0a 2020 2020 2020  pe(self):.      
+000006a0: 2020 7265 7475 726e 2028 290a 0a20 2020    return ()..   
+000006b0: 2064 6566 2069 6d61 6765 5f73 6574 2873   def image_set(s
+000006c0: 656c 6629 3a0a 2020 2020 2020 2020 2e2e  elf):.        ..
+000006d0: 2e0a 0a20 2020 2064 6566 2065 6c65 6d65  ...    def eleme
+000006e0: 6e74 5f73 796d 626f 6c28 7365 6c66 2c20  nt_symbol(self, 
+000006f0: 6578 636c 7564 6573 3d4e 6f6e 6529 3a0a  excludes=None):.
+00000700: 2020 2020 2020 2020 7265 7475 726e 2073          return s
+00000710: 656c 662e 6765 6e65 7261 7465 5f76 6172  elf.generate_var
+00000720: 2865 7863 6c75 6465 732c 202a 2a73 656c  (excludes, **sel
+00000730: 662e 6574 7970 652e 6469 6374 290a 0a20  f.etype.dict).. 
+00000740: 2020 2040 7072 6f70 6572 7479 0a20 2020     @property.   
+00000750: 2064 6566 2064 7479 7065 2873 656c 6629   def dtype(self)
+00000760: 3a0a 2020 2020 2020 2020 6173 7365 7274  :.        assert
+00000770: 2073 656c 662e 6574 7970 6520 6973 206e   self.etype is n
+00000780: 6f74 204e 6f6e 652c 2073 656c 660a 2020  ot None, self.  
+00000790: 2020 2020 2020 7265 7475 726e 2073 656c        return sel
+000007a0: 662e 6574 7970 652e 7365 740a 0a20 2020  f.etype.set..   
+000007b0: 2064 6566 2063 6f75 6c64 5f65 7874 7261   def could_extra
+000007c0: 6374 5f6d 696e 7573 5f73 6967 6e28 7365  ct_minus_sign(se
+000007d0: 6c66 293a 0a20 2020 2020 2020 2072 6574  lf):.        ret
+000007e0: 7572 6e20 4661 6c73 650a 0a20 2020 2040  urn False..    @
+000007f0: 7374 6174 6963 6d65 7468 6f64 0a20 2020  staticmethod.   
+00000800: 2064 6566 205f 696e 6669 6d75 6d5f 6b65   def _infimum_ke
+00000810: 7928 6578 7072 293a 0a20 2020 2020 2020  y(expr):.       
+00000820: 2022 2222 0a20 2020 2020 2020 2052 6574   """.        Ret
+00000830: 7572 6e20 696e 6669 6d75 6d20 2869 6620  urn infimum (if 
+00000840: 706f 7373 6962 6c65 2920 656c 7365 2053  possible) else S
+00000850: 2e49 6e66 696e 6974 792e 0a20 2020 2020  .Infinity..     
+00000860: 2020 2022 2222 0a20 2020 2020 2020 2074     """.        t
+00000870: 7279 3a0a 2020 2020 2020 2020 2020 2020  ry:.            
+00000880: 696e 6669 6d75 6d20 3d20 6578 7072 2e69  infimum = expr.i
+00000890: 6e66 0a20 2020 2020 2020 2020 2020 2061  nf.            a
+000008a0: 7373 6572 7420 696e 6669 6d75 6d2e 6973  ssert infimum.is
+000008b0: 5f63 6f6d 7061 7261 626c 650a 2020 2020  _comparable.    
+000008c0: 2020 2020 6578 6365 7074 2028 4e6f 7449      except (NotI
+000008d0: 6d70 6c65 6d65 6e74 6564 4572 726f 722c  mplementedError,
+000008e0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000008f0: 2041 7474 7269 6275 7465 4572 726f 722c   AttributeError,
+00000900: 2041 7373 6572 7469 6f6e 4572 726f 722c   AssertionError,
+00000910: 2056 616c 7565 4572 726f 7229 3a0a 2020   ValueError):.  
+00000920: 2020 2020 2020 2020 2020 696e 6669 6d75            infimu
+00000930: 6d20 3d20 532e 496e 6669 6e69 7479 0a20  m = S.Infinity. 
+00000940: 2020 2020 2020 2072 6574 7572 6e20 696e         return in
+00000950: 6669 6d75 6d0a 0a20 2020 2064 6566 2075  fimum..    def u
+00000960: 6e69 6f6e 2873 656c 662c 206f 7468 6572  nion(self, other
+00000970: 293a 0a20 2020 2020 2020 2022 2222 0a20  ):.        """. 
+00000980: 2020 2020 2020 2052 6574 7572 6e73 2074         Returns t
+00000990: 6865 2075 6e69 6f6e 206f 6620 2773 656c  he union of 'sel
+000009a0: 6627 2061 6e64 2027 6f74 6865 7227 2e0a  f' and 'other'..
+000009b0: 0a20 2020 2020 2020 2045 7861 6d70 6c65  .        Example
+000009c0: 730a 2020 2020 2020 2020 3d3d 3d3d 3d3d  s.        ======
+000009d0: 3d3d 0a0a 2020 2020 2020 2020 4173 2061  ==..        As a
+000009e0: 2073 686f 7274 6375 7420 6974 2069 7320   shortcut it is 
+000009f0: 706f 7373 6962 6c65 2074 6f20 7573 6520  possible to use 
+00000a00: 7468 6520 272b 2720 6f70 6572 6174 6f72  the '+' operator
+00000a10: 3a0a 0a20 2020 2020 2020 203e 3e3e 2066  :..        >>> f
+00000a20: 726f 6d20 7379 6d70 7920 696d 706f 7274  rom sympy import
+00000a30: 2049 6e74 6572 7661 6c2c 2046 696e 6974   Interval, Finit
+00000a40: 6553 6574 0a20 2020 2020 2020 203e 3e3e  eSet.        >>>
+00000a50: 2049 6e74 6572 7661 6c28 302c 2031 292e   Interval(0, 1).
+00000a60: 756e 696f 6e28 496e 7465 7276 616c 2832  union(Interval(2
+00000a70: 2c20 3329 290a 2020 2020 2020 2020 556e  , 3)).        Un
+00000a80: 696f 6e28 496e 7465 7276 616c 2830 2c20  ion(Interval(0, 
+00000a90: 3129 2c20 496e 7465 7276 616c 2832 2c20  1), Interval(2, 
+00000aa0: 3329 290a 2020 2020 2020 2020 3e3e 3e20  3)).        >>> 
+00000ab0: 496e 7465 7276 616c 2830 2c20 3129 202b  Interval(0, 1) +
+00000ac0: 2049 6e74 6572 7661 6c28 322c 2033 290a   Interval(2, 3).
+00000ad0: 2020 2020 2020 2020 556e 696f 6e28 496e          Union(In
+00000ae0: 7465 7276 616c 2830 2c20 3129 2c20 496e  terval(0, 1), In
+00000af0: 7465 7276 616c 2832 2c20 3329 290a 0a20  terval(2, 3)).. 
+00000b00: 2020 2020 2020 2053 696d 696c 6172 6c79         Similarly
+00000b10: 2069 7420 6973 2070 6f73 7369 626c 6520   it is possible 
+00000b20: 746f 2075 7365 2074 6865 2027 2d27 206f  to use the '-' o
+00000b30: 7065 7261 746f 7220 666f 7220 7365 7420  perator for set 
+00000b40: 6469 6666 6572 656e 6365 733a 0a0a 2020  differences:..  
+00000b50: 2020 2020 2020 3e3e 3e20 496e 7465 7276        >>> Interv
+00000b60: 616c 2830 2c20 3229 202d 2049 6e74 6572  al(0, 2) - Inter
+00000b70: 7661 6c28 302c 2031 290a 2020 2020 2020  val(0, 1).      
+00000b80: 2020 496e 7465 7276 616c 2e4c 6f70 656e    Interval.Lopen
+00000b90: 2831 2c20 3229 0a20 2020 2020 2020 203e  (1, 2).        >
+00000ba0: 3e3e 2049 6e74 6572 7661 6c28 312c 2033  >> Interval(1, 3
+00000bb0: 2920 2d20 4669 6e69 7465 5365 7428 3229  ) - FiniteSet(2)
+00000bc0: 0a20 2020 2020 2020 2055 6e69 6f6e 2849  .        Union(I
+00000bd0: 6e74 6572 7661 6c2e 526f 7065 6e28 312c  nterval.Ropen(1,
+00000be0: 2032 292c 2049 6e74 6572 7661 6c2e 4c6f   2), Interval.Lo
+00000bf0: 7065 6e28 322c 2033 2929 0a0a 2020 2020  pen(2, 3))..    
+00000c00: 2020 2020 2222 220a 2020 2020 2020 2020      """.        
+00000c10: 7265 7475 726e 2055 6e69 6f6e 2873 656c  return Union(sel
+00000c20: 662c 206f 7468 6572 290a 0a20 2020 2064  f, other)..    d
+00000c30: 6566 2069 6e74 6572 7365 6374 2873 656c  ef intersect(sel
+00000c40: 662c 206f 7468 6572 293a 0a20 2020 2020  f, other):.     
+00000c50: 2020 2022 2222 0a20 2020 2020 2020 2052     """.        R
+00000c60: 6574 7572 6e73 2074 6865 2069 6e74 6572  eturns the inter
+00000c70: 7365 6374 696f 6e20 6f66 2027 7365 6c66  section of 'self
+00000c80: 2720 616e 6420 276f 7468 6572 272e 0a0a  ' and 'other'...
+00000c90: 2020 2020 2020 2020 3e3e 3e20 6672 6f6d          >>> from
+00000ca0: 2073 796d 7079 2069 6d70 6f72 7420 496e   sympy import In
+00000cb0: 7465 7276 616c 0a0a 2020 2020 2020 2020  terval..        
+00000cc0: 3e3e 3e20 496e 7465 7276 616c 2831 2c20  >>> Interval(1, 
+00000cd0: 3329 2e69 6e74 6572 7365 6374 2849 6e74  3).intersect(Int
+00000ce0: 6572 7661 6c28 312c 2032 2929 0a20 2020  erval(1, 2)).   
+00000cf0: 2020 2020 2049 6e74 6572 7661 6c28 312c       Interval(1,
+00000d00: 2032 290a 0a20 2020 2020 2020 203e 3e3e   2)..        >>>
+00000d10: 2066 726f 6d20 7379 6d70 7920 696d 706f   from sympy impo
+00000d20: 7274 2069 6d61 6765 7365 742c 204c 616d  rt imageset, Lam
+00000d30: 6264 612c 2073 796d 626f 6c73 2c20 530a  bda, symbols, S.
+00000d40: 2020 2020 2020 2020 3e3e 3e20 6e2c 206d          >>> n, m
+00000d50: 203d 2073 796d 626f 6c73 2827 6e20 6d27   = symbols('n m'
+00000d60: 290a 2020 2020 2020 2020 3e3e 3e20 6120  ).        >>> a 
+00000d70: 3d20 696d 6167 6573 6574 284c 616d 6264  = imageset(Lambd
+00000d80: 6128 6e2c 2032 2a6e 292c 2053 2e49 6e74  a(n, 2*n), S.Int
+00000d90: 6567 6572 7329 0a20 2020 2020 2020 203e  egers).        >
+00000da0: 3e3e 2061 2e69 6e74 6572 7365 6374 2869  >> a.intersect(i
+00000db0: 6d61 6765 7365 7428 4c61 6d62 6461 286d  mageset(Lambda(m
+00000dc0: 2c20 322a 6d20 2b20 3129 2c20 532e 496e  , 2*m + 1), S.In
+00000dd0: 7465 6765 7273 2929 0a20 2020 2020 2020  tegers)).       
+00000de0: 2045 6d70 7479 5365 7428 290a 0a20 2020   EmptySet()..   
+00000df0: 2020 2020 2022 2222 0a20 2020 2020 2020       """.       
+00000e00: 2072 6574 7572 6e20 496e 7465 7273 6563   return Intersec
+00000e10: 7469 6f6e 2873 656c 662c 206f 7468 6572  tion(self, other
+00000e20: 290a 0a20 2020 2064 6566 2069 6e74 6572  )..    def inter
+00000e30: 7365 6374 696f 6e28 7365 6c66 2c20 6f74  section(self, ot
+00000e40: 6865 7229 3a0a 2020 2020 2020 2020 2222  her):.        ""
+00000e50: 220a 2020 2020 2020 2020 416c 6961 7320  ".        Alias 
+00000e60: 666f 7220 3a6d 6574 683a 6069 6e74 6572  for :meth:`inter
+00000e70: 7365 6374 2829 600a 2020 2020 2020 2020  sect()`.        
+00000e80: 2222 220a 2020 2020 2020 2020 7265 7475  """.        retu
+00000e90: 726e 2073 656c 662e 696e 7465 7273 6563  rn self.intersec
+00000ea0: 7428 6f74 6865 7229 0a0a 2020 2020 6465  t(other)..    de
+00000eb0: 6620 6973 5f64 6973 6a6f 696e 7428 7365  f is_disjoint(se
+00000ec0: 6c66 2c20 6f74 6865 7229 3a0a 2020 2020  lf, other):.    
+00000ed0: 2020 2020 2222 220a 2020 2020 2020 2020      """.        
+00000ee0: 5265 7475 726e 7320 5472 7565 2069 6620  Returns True if 
+00000ef0: 2773 656c 6627 2061 6e64 2027 6f74 6865  'self' and 'othe
+00000f00: 7227 2061 7265 2064 6973 6a6f 696e 740a  r' are disjoint.
+00000f10: 0a20 2020 2020 2020 2045 7861 6d70 6c65  .        Example
+00000f20: 730a 2020 2020 2020 2020 3d3d 3d3d 3d3d  s.        ======
+00000f30: 3d3d 0a0a 2020 2020 2020 2020 3e3e 3e20  ==..        >>> 
+00000f40: 6672 6f6d 2073 796d 7079 2069 6d70 6f72  from sympy impor
+00000f50: 7420 496e 7465 7276 616c 0a20 2020 2020  t Interval.     
+00000f60: 2020 203e 3e3e 2049 6e74 6572 7661 6c28     >>> Interval(
+00000f70: 302c 2032 292e 6973 5f64 6973 6a6f 696e  0, 2).is_disjoin
+00000f80: 7428 496e 7465 7276 616c 2831 2c20 3229  t(Interval(1, 2)
+00000f90: 290a 2020 2020 2020 2020 4661 6c73 650a  ).        False.
+00000fa0: 2020 2020 2020 2020 3e3e 3e20 496e 7465          >>> Inte
+00000fb0: 7276 616c 2830 2c20 3229 2e69 735f 6469  rval(0, 2).is_di
+00000fc0: 736a 6f69 6e74 2849 6e74 6572 7661 6c28  sjoint(Interval(
+00000fd0: 332c 2034 2929 0a20 2020 2020 2020 2054  3, 4)).        T
+00000fe0: 7275 650a 0a20 2020 2020 2020 2052 6566  rue..        Ref
+00000ff0: 6572 656e 6365 730a 2020 2020 2020 2020  erences.        
+00001000: 3d3d 3d3d 3d3d 3d3d 3d3d 0a0a 2020 2020  ==========..    
+00001010: 2020 2020 2e2e 205b 315d 2068 7474 7073      .. [1] https
+00001020: 3a2f 2f65 6e2e 7769 6b69 7065 6469 612e  ://en.wikipedia.
+00001030: 6f72 672f 7769 6b69 2f44 6973 6a6f 696e  org/wiki/Disjoin
+00001040: 745f 7365 7473 0a20 2020 2020 2020 2022  t_sets.        "
+00001050: 2222 0a20 2020 2020 2020 2072 6574 7572  "".        retur
+00001060: 6e20 7365 6c66 2e69 6e74 6572 7365 6374  n self.intersect
+00001070: 286f 7468 6572 292e 6973 5f45 6d70 7479  (other).is_Empty
+00001080: 5365 740a 0a20 2020 2064 6566 2069 7364  Set..    def isd
+00001090: 6973 6a6f 696e 7428 7365 6c66 2c20 6f74  isjoint(self, ot
+000010a0: 6865 7229 3a0a 2020 2020 2020 2020 2222  her):.        ""
+000010b0: 220a 2020 2020 2020 2020 416c 6961 7320  ".        Alias 
+000010c0: 666f 7220 3a6d 6574 683a 6069 735f 6469  for :meth:`is_di
+000010d0: 736a 6f69 6e74 2829 600a 2020 2020 2020  sjoint()`.      
+000010e0: 2020 2222 220a 2020 2020 2020 2020 7265    """.        re
+000010f0: 7475 726e 2073 656c 662e 6973 5f64 6973  turn self.is_dis
+00001100: 6a6f 696e 7428 6f74 6865 7229 0a0a 2020  joint(other)..  
+00001110: 2020 6465 6620 636f 6d70 6c65 6d65 6e74    def complement
+00001120: 2873 656c 662c 2075 6e69 7665 7273 6529  (self, universe)
+00001130: 3a0a 2020 2020 2020 2020 7222 2222 0a20  :.        r""". 
+00001140: 2020 2020 2020 2054 6865 2063 6f6d 706c         The compl
+00001150: 656d 656e 7420 6f66 2027 7365 6c66 2720  ement of 'self' 
+00001160: 772e 722e 7420 7468 6520 6769 7665 6e20  w.r.t the given 
+00001170: 756e 6976 6572 7365 2e0a 0a20 2020 2020  universe...     
+00001180: 2020 2045 7861 6d70 6c65 730a 2020 2020     Examples.    
+00001190: 2020 2020 3d3d 3d3d 3d3d 3d3d 0a0a 2020      ========..  
+000011a0: 2020 2020 2020 3e3e 3e20 6672 6f6d 2073        >>> from s
+000011b0: 796d 7079 2069 6d70 6f72 7420 496e 7465  ympy import Inte
+000011c0: 7276 616c 2c20 530a 2020 2020 2020 2020  rval, S.        
+000011d0: 3e3e 3e20 496e 7465 7276 616c 2830 2c20  >>> Interval(0, 
+000011e0: 3129 2e63 6f6d 706c 656d 656e 7428 5265  1).complement(Re
+000011f0: 616c 7329 0a20 2020 2020 2020 2055 6e69  als).        Uni
+00001200: 6f6e 2849 6e74 6572 7661 6c2e 6f70 656e  on(Interval.open
+00001210: 282d 6f6f 2c20 3029 2c20 496e 7465 7276  (-oo, 0), Interv
+00001220: 616c 2e6f 7065 6e28 312c 206f 6f29 290a  al.open(1, oo)).
+00001230: 0a20 2020 2020 2020 203e 3e3e 2049 6e74  .        >>> Int
+00001240: 6572 7661 6c28 302c 2031 292e 636f 6d70  erval(0, 1).comp
+00001250: 6c65 6d65 6e74 2855 6e69 7665 7273 616c  lement(Universal
+00001260: 5365 7428 2929 0a20 2020 2020 2020 2055  Set()).        U
+00001270: 6e69 7665 7273 616c 5365 7420 5c20 496e  niversalSet \ In
+00001280: 7465 7276 616c 2830 2c20 3129 0a0a 2020  terval(0, 1)..  
+00001290: 2020 2020 2020 2222 220a 2020 2020 2020        """.      
+000012a0: 2020 7265 7475 726e 2043 6f6d 706c 656d    return Complem
+000012b0: 656e 7428 756e 6976 6572 7365 2c20 7365  ent(universe, se
+000012c0: 6c66 290a 0a20 2020 2064 6566 205f 636f  lf)..    def _co
+000012d0: 6d70 6c65 6d65 6e74 2873 656c 662c 206f  mplement(self, o
+000012e0: 7468 6572 293a 0a20 2020 2020 2020 2023  ther):.        #
+000012f0: 2074 6869 7320 6265 6861 7665 7320 6173   this behaves as
+00001300: 206f 7468 6572 202d 2073 656c 660a 2020   other - self.  
+00001310: 2020 2020 2020 6966 206f 7468 6572 2e69        if other.i
+00001320: 735f 5072 6f64 7563 7453 6574 3a0a 2020  s_ProductSet:.  
+00001330: 2020 2020 2020 2020 2020 6672 6f6d 2073            from s
+00001340: 796d 7079 2069 6d70 6f72 7420 4669 6e69  ympy import Fini
+00001350: 7465 5365 740a 2020 2020 2020 2020 2020  teSet.          
+00001360: 2020 2320 466f 7220 6561 6368 2073 6574    # For each set
+00001370: 2063 6f6e 7369 6465 7220 6974 206f 7220   consider it or 
+00001380: 6974 2773 2063 6f6d 706c 656d 656e 740a  it's complement.
+00001390: 2020 2020 2020 2020 2020 2020 2320 5765              # We
+000013a0: 206e 6565 6420 6174 206c 6561 7374 206f   need at least o
+000013b0: 6e65 206f 6620 7468 6520 7365 7473 2074  ne of the sets t
+000013c0: 6f20 6265 2063 6f6d 706c 656d 656e 7465  o be complemente
+000013d0: 640a 2020 2020 2020 2020 2020 2020 2320  d.            # 
+000013e0: 436f 6e73 6964 6572 2061 6c6c 2032 5e6e  Consider all 2^n
+000013f0: 2063 6f6d 6269 6e61 7469 6f6e 732e 0a20   combinations.. 
+00001400: 2020 2020 2020 2020 2020 2023 2057 6520             # We 
+00001410: 6361 6e20 636f 6e76 656e 6965 6e74 6c79  can conveniently
+00001420: 2072 6570 7265 7365 6e74 2074 6865 7365   represent these
+00001430: 206f 7074 696f 6e73 2065 6173 696c 7920   options easily 
+00001440: 7573 696e 6720 610a 2020 2020 2020 2020  using a.        
+00001450: 2020 2020 2320 5072 6f64 7563 7453 6574      # ProductSet
+00001460: 0a0a 2020 2020 2020 2020 2020 2020 2320  ..            # 
+00001470: 5858 583a 2074 6869 7320 646f 6573 6e27  XXX: this doesn'
+00001480: 7420 776f 726b 2069 6620 7468 6520 6469  t work if the di
+00001490: 6d65 6e73 696f 6e73 206f 6620 7468 6520  mensions of the 
+000014a0: 7365 7473 2069 736e 2774 2073 616d 652e  sets isn't same.
+000014b0: 0a20 2020 2020 2020 2020 2020 2023 2041  .            # A
+000014c0: 202d 2042 2069 7320 6573 7365 6e74 6961   - B is essentia
+000014d0: 6c6c 7920 7361 6d65 2061 7320 4120 6966  lly same as A if
+000014e0: 2042 2068 6173 2061 2064 6966 6665 7265   B has a differe
+000014f0: 6e74 0a20 2020 2020 2020 2020 2020 2023  nt.            #
+00001500: 2064 696d 656e 7369 6f6e 616c 6974 7920   dimensionality 
+00001510: 7468 616e 2041 0a20 2020 2020 2020 2020  than A.         
+00001520: 2020 2073 7769 7463 685f 7365 7473 203d     switch_sets =
+00001530: 2050 726f 6475 6374 5365 7428 4669 6e69   ProductSet(Fini
+00001540: 7465 5365 7428 6f2c 206f 202d 2073 2920  teSet(o, o - s) 
+00001550: 666f 7220 732c 206f 2069 6e20 7a69 7028  for s, o in zip(
+00001560: 7365 6c66 2e73 6574 732c 206f 7468 6572  self.sets, other
+00001570: 2e73 6574 7329 290a 2020 2020 2020 2020  .sets)).        
+00001580: 2020 2020 7072 6f64 7563 745f 7365 7473      product_sets
+00001590: 203d 2028 5072 6f64 7563 7453 6574 282a   = (ProductSet(*
+000015a0: 7329 2066 6f72 2073 2069 6e20 7377 6974  s) for s in swit
+000015b0: 6368 5f73 6574 7329 0a20 2020 2020 2020  ch_sets).       
+000015c0: 2020 2020 2023 2055 6e69 6f6e 206f 6620       # Union of 
+000015d0: 616c 6c20 636f 6d62 696e 6174 696f 6e73  all combinations
+000015e0: 2062 7574 2074 6869 7320 6f6e 650a 2020   but this one.  
+000015f0: 2020 2020 2020 2020 2020 7265 7475 726e            return
+00001600: 2055 6e69 6f6e 282a 2870 2066 6f72 2070   Union(*(p for p
+00001610: 2069 6e20 7072 6f64 7563 745f 7365 7473   in product_sets
+00001620: 2069 6620 7020 213d 206f 7468 6572 2929   if p != other))
+00001630: 0a0a 2020 2020 2020 2020 656c 6966 206f  ..        elif o
+00001640: 7468 6572 2e69 735f 496e 7465 7276 616c  ther.is_Interval
+00001650: 3a0a 2020 2020 2020 2020 2020 2020 6966  :.            if
+00001660: 2073 656c 662e 6973 5f49 6e74 6572 7661   self.is_Interva
+00001670: 6c3a 0a20 2020 2020 2020 2020 2020 2020  l:.             
+00001680: 2020 2055 203d 206f 7468 6572 2e65 7479     U = other.ety
+00001690: 7065 2e75 6e69 7665 7273 616c 5365 740a  pe.universalSet.
+000016a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000016b0: 7265 7475 726e 2049 6e74 6572 7365 6374  return Intersect
+000016c0: 696f 6e28 6f74 6865 722c 2073 656c 662e  ion(other, self.
+000016d0: 636f 6d70 6c65 6d65 6e74 2855 2929 0a0a  complement(U))..
+000016e0: 2020 2020 2020 2020 656c 6966 206f 7468          elif oth
+000016f0: 6572 2e69 735f 5261 6e67 653a 0a20 2020  er.is_Range:.   
+00001700: 2020 2020 2020 2020 2069 6620 7365 6c66           if self
+00001710: 2e69 735f 5261 6e67 6520 616e 6420 7365  .is_Range and se
+00001720: 6c66 2e73 7465 702e 6973 5f4f 6e65 3a0a  lf.step.is_One:.
+00001730: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00001740: 6672 6f6d 2073 796d 7079 2e73 6574 7320  from sympy.sets 
+00001750: 696d 706f 7274 2049 6e74 6567 6572 730a  import Integers.
+00001760: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00001770: 7265 7475 726e 2049 6e74 6572 7365 6374  return Intersect
+00001780: 696f 6e28 6f74 6865 722c 2073 656c 662e  ion(other, self.
+00001790: 636f 6d70 6c65 6d65 6e74 2849 6e74 6567  complement(Integ
+000017a0: 6572 7329 290a 0a20 2020 2020 2020 2065  ers))..        e
+000017b0: 6c69 6620 6f74 6865 722e 6973 5f55 6e69  lif other.is_Uni
+000017c0: 6f6e 3a0a 2020 2020 2020 2020 2020 2020  on:.            
+000017d0: 7369 6d70 6c69 6669 6564 203d 205b 5d0a  simplified = [].
+000017e0: 2020 2020 2020 2020 2020 2020 756e 7369              unsi
+000017f0: 6d70 6c69 6669 6564 203d 205b 5d0a 2020  mplified = [].  
+00001800: 2020 2020 2020 2020 2020 6869 7420 3d20            hit = 
+00001810: 4661 6c73 650a 2020 2020 2020 2020 2020  False.          
+00001820: 2020 666f 7220 6172 6720 696e 206f 7468    for arg in oth
+00001830: 6572 2e61 7267 733a 0a20 2020 2020 2020  er.args:.       
+00001840: 2020 2020 2020 2020 2064 6966 6620 3d20           diff = 
+00001850: 436f 6d70 6c65 6d65 6e74 2861 7267 2c20  Complement(arg, 
+00001860: 7365 6c66 290a 2020 2020 2020 2020 2020  self).          
+00001870: 2020 2020 2020 6966 2064 6966 662e 6973        if diff.is
+00001880: 5f43 6f6d 706c 656d 656e 7420 616e 6420  _Complement and 
+00001890: 6469 6666 2e61 7267 735b 315d 203d 3d20  diff.args[1] == 
+000018a0: 7365 6c66 3a0a 2020 2020 2020 2020 2020  self:.          
+000018b0: 2020 2020 2020 2020 2020 6869 7420 3d20            hit = 
+000018c0: 6469 6666 2e61 7267 735b 305d 2021 3d20  diff.args[0] != 
+000018d0: 6172 670a 2020 2020 2020 2020 2020 2020  arg.            
+000018e0: 2020 2020 2020 2020 756e 7369 6d70 6c69          unsimpli
+000018f0: 6669 6564 2e61 7070 656e 6428 6469 6666  fied.append(diff
+00001900: 2e61 7267 735b 305d 290a 2020 2020 2020  .args[0]).      
+00001910: 2020 2020 2020 2020 2020 656c 7365 3a20            else: 
+00001920: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00001930: 2020 2020 2068 6974 203d 2054 7275 650a       hit = True.
+00001940: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00001950: 2020 2020 7369 6d70 6c69 6669 6564 2e61      simplified.a
+00001960: 7070 656e 6428 6469 6666 290a 2020 2020  ppend(diff).    
+00001970: 2020 2020 2020 2020 6966 2068 6974 3a0a          if hit:.
+00001980: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00001990: 7369 6d70 6c69 6669 6564 203d 2055 6e69  simplified = Uni
+000019a0: 6f6e 282a 7369 6d70 6c69 6669 6564 2c20  on(*simplified, 
+000019b0: 6576 616c 7561 7465 3d46 616c 7365 2920  evaluate=False) 
+000019c0: 6966 2073 696d 706c 6966 6965 6420 656c  if simplified el
+000019d0: 7365 2073 656c 662e 6574 7970 652e 656d  se self.etype.em
+000019e0: 7074 7953 6574 2020 2020 2020 2020 2020  ptySet          
+000019f0: 2020 2020 2020 0a20 2020 2020 2020 2020        .         
+00001a00: 2020 2020 2020 2075 6e73 696d 706c 6966         unsimplif
+00001a10: 6965 6420 3d20 436f 6d70 6c65 6d65 6e74  ied = Complement
+00001a20: 2855 6e69 6f6e 282a 756e 7369 6d70 6c69  (Union(*unsimpli
+00001a30: 6669 6564 2c20 6576 616c 7561 7465 3d46  fied, evaluate=F
+00001a40: 616c 7365 292c 2073 656c 662c 2065 7661  alse), self, eva
+00001a50: 6c75 6174 653d 4661 6c73 6529 2069 6620  luate=False) if 
+00001a60: 756e 7369 6d70 6c69 6669 6564 2065 6c73  unsimplified els
+00001a70: 6520 7365 6c66 2e65 7479 7065 2e65 6d70  e self.etype.emp
+00001a80: 7479 5365 740a 2020 2020 2020 2020 2020  tySet.          
+00001a90: 2020 2020 2020 7265 7475 726e 2073 696d        return sim
+00001aa0: 706c 6966 6965 6420 7c20 756e 7369 6d70  plified | unsimp
+00001ab0: 6c69 6669 6564 0a0a 2020 2020 2020 2020  lified..        
+00001ac0: 656c 6966 206f 7468 6572 2e69 735f 436f  elif other.is_Co
+00001ad0: 6d70 6c65 6d65 6e74 3a0a 2020 2020 2020  mplement:.      
+00001ae0: 2020 2020 2020 6966 206f 7468 6572 2e61        if other.a
+00001af0: 7267 735b 305d 2069 6e20 7365 6c66 3a0a  rgs[0] in self:.
+00001b00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00001b10: 7265 7475 726e 2073 656c 662e 6574 7970  return self.etyp
+00001b20: 652e 656d 7074 7953 6574 0a20 2020 2020  e.emptySet.     
+00001b30: 2020 2020 2020 2072 6574 7572 6e20 436f         return Co
+00001b40: 6d70 6c65 6d65 6e74 286f 7468 6572 2e61  mplement(other.a
+00001b50: 7267 735b 305d 2c20 556e 696f 6e28 6f74  rgs[0], Union(ot
+00001b60: 6865 722e 6172 6773 5b31 5d2c 2073 656c  her.args[1], sel
+00001b70: 6629 2c20 6576 616c 7561 7465 3d46 616c  f), evaluate=Fal
+00001b80: 7365 290a 0a20 2020 2020 2020 2065 6c69  se)..        eli
+00001b90: 6620 6f74 6865 722e 6973 5f45 6d70 7479  f other.is_Empty
+00001ba0: 5365 743a 0a20 2020 2020 2020 2020 2020  Set:.           
+00001bb0: 2072 6574 7572 6e20 6f74 6865 720a 0a20   return other.. 
+00001bc0: 2020 2020 2020 2065 6c69 6620 6f74 6865         elif othe
+00001bd0: 722e 6973 5f46 696e 6974 6553 6574 3a0a  r.is_FiniteSet:.
+00001be0: 2020 2020 2020 2020 2020 2020 7369 6674              sift
+00001bf0: 6564 203d 2073 6966 7428 6f74 6865 722c  ed = sift(other,
+00001c00: 206c 616d 6264 6120 783a 2066 757a 7a79   lambda x: fuzzy
+00001c10: 5f62 6f6f 6c28 7365 6c66 2e63 6f6e 7461  _bool(self.conta
+00001c20: 696e 7328 7829 2929 0a20 2020 2020 2020  ins(x))).       
+00001c30: 2020 2020 2023 2069 676e 6f72 6520 7468       # ignore th
+00001c40: 6f73 6520 7468 6174 2061 7265 2063 6f6e  ose that are con
+00001c50: 7461 696e 6564 2069 6e20 7365 6c66 0a20  tained in self. 
+00001c60: 2020 2020 2020 2020 2020 2072 6574 7572             retur
+00001c70: 6e20 556e 696f 6e28 4669 6e69 7465 5365  n Union(FiniteSe
+00001c80: 7428 2a28 7369 6674 6564 5b46 616c 7365  t(*(sifted[False
+00001c90: 5d29 292c 2043 6f6d 706c 656d 656e 7428  ])), Complement(
+00001ca0: 4669 6e69 7465 5365 7428 2a28 7369 6674  FiniteSet(*(sift
+00001cb0: 6564 5b4e 6f6e 655d 2929 2c20 7365 6c66  ed[None])), self
+00001cc0: 2c20 6576 616c 7561 7465 3d46 616c 7365  , evaluate=False
+00001cd0: 2920 6966 2073 6966 7465 645b 4e6f 6e65  ) if sifted[None
+00001ce0: 5d20 656c 7365 2073 656c 662e 6574 7970  ] else self.etyp
+00001cf0: 652e 656d 7074 7953 6574 290a 0a20 2020  e.emptySet)..   
+00001d00: 2064 6566 2073 796d 6d65 7472 6963 5f64   def symmetric_d
+00001d10: 6966 6665 7265 6e63 6528 7365 6c66 2c20  ifference(self, 
+00001d20: 6f74 6865 7229 3a0a 2020 2020 2020 2020  other):.        
+00001d30: 2222 220a 2020 2020 2020 2020 5265 7475  """.        Retu
+00001d40: 726e 7320 7379 6d6d 6574 7269 6320 6469  rns symmetric di
+00001d50: 6666 6572 656e 6365 206f 6620 6073 656c  fference of `sel
+00001d60: 6660 2061 6e64 2060 6f74 6865 7260 2e0a  f` and `other`..
+00001d70: 0a20 2020 2020 2020 2045 7861 6d70 6c65  .        Example
+00001d80: 730a 2020 2020 2020 2020 3d3d 3d3d 3d3d  s.        ======
+00001d90: 3d3d 0a0a 2020 2020 2020 2020 3e3e 3e20  ==..        >>> 
+00001da0: 6672 6f6d 2073 796d 7079 2069 6d70 6f72  from sympy impor
+00001db0: 7420 496e 7465 7276 616c 2c20 530a 2020  t Interval, S.  
+00001dc0: 2020 2020 2020 3e3e 3e20 496e 7465 7276        >>> Interv
+00001dd0: 616c 2831 2c20 3329 2e73 796d 6d65 7472  al(1, 3).symmetr
+00001de0: 6963 5f64 6966 6665 7265 6e63 6528 5265  ic_difference(Re
+00001df0: 616c 7329 0a20 2020 2020 2020 2055 6e69  als).        Uni
+00001e00: 6f6e 2849 6e74 6572 7661 6c2e 6f70 656e  on(Interval.open
+00001e10: 282d 6f6f 2c20 3129 2c20 496e 7465 7276  (-oo, 1), Interv
+00001e20: 616c 2e6f 7065 6e28 332c 206f 6f29 290a  al.open(3, oo)).
+00001e30: 2020 2020 2020 2020 3e3e 3e20 496e 7465          >>> Inte
+00001e40: 7276 616c 2831 2c20 3130 292e 7379 6d6d  rval(1, 10).symm
+00001e50: 6574 7269 635f 6469 6666 6572 656e 6365  etric_difference
+00001e60: 2852 6561 6c73 290a 2020 2020 2020 2020  (Reals).        
+00001e70: 556e 696f 6e28 496e 7465 7276 616c 2e6f  Union(Interval.o
+00001e80: 7065 6e28 2d6f 6f2c 2031 292c 2049 6e74  pen(-oo, 1), Int
+00001e90: 6572 7661 6c2e 6f70 656e 2831 302c 206f  erval.open(10, o
+00001ea0: 6f29 290a 0a20 2020 2020 2020 203e 3e3e  o))..        >>>
+00001eb0: 2066 726f 6d20 7379 6d70 7920 696d 706f   from sympy impo
+00001ec0: 7274 2053 2c20 456d 7074 7953 6574 0a20  rt S, EmptySet. 
+00001ed0: 2020 2020 2020 203e 3e3e 2052 6561 6c73         >>> Reals
+00001ee0: 2e73 796d 6d65 7472 6963 5f64 6966 6665  .symmetric_diffe
+00001ef0: 7265 6e63 6528 456d 7074 7953 6574 2829  rence(EmptySet()
+00001f00: 290a 2020 2020 2020 2020 5265 616c 730a  ).        Reals.
+00001f10: 0a20 2020 2020 2020 2052 6566 6572 656e  .        Referen
+00001f20: 6365 730a 2020 2020 2020 2020 3d3d 3d3d  ces.        ====
+00001f30: 3d3d 3d3d 3d3d 0a20 2020 2020 2020 202e  ======.        .
+00001f40: 2e20 5b31 5d20 6874 7470 733a 2f2f 656e  . [1] https://en
+00001f50: 2e77 696b 6970 6564 6961 2e6f 7267 2f77  .wikipedia.org/w
+00001f60: 696b 692f 5379 6d6d 6574 7269 635f 6469  iki/Symmetric_di
+00001f70: 6666 6572 656e 6365 0a0a 2020 2020 2020  fference..      
+00001f80: 2020 2222 220a 2020 2020 2020 2020 7265    """.        re
+00001f90: 7475 726e 2053 796d 6d65 7472 6963 4469  turn SymmetricDi
+00001fa0: 6666 6572 656e 6365 2873 656c 662c 206f  fference(self, o
+00001fb0: 7468 6572 290a 0a20 2020 2064 6566 205f  ther)..    def _
+00001fc0: 7379 6d6d 6574 7269 635f 6469 6666 6572  symmetric_differ
+00001fd0: 656e 6365 2873 656c 662c 206f 7468 6572  ence(self, other
+00001fe0: 293a 0a20 2020 2020 2020 2072 6574 7572  ):.        retur
+00001ff0: 6e20 556e 696f 6e28 436f 6d70 6c65 6d65  n Union(Compleme
+00002000: 6e74 2873 656c 662c 206f 7468 6572 292c  nt(self, other),
+00002010: 2043 6f6d 706c 656d 656e 7428 6f74 6865   Complement(othe
+00002020: 722c 2073 656c 6629 290a 0a20 2020 2040  r, self))..    @
+00002030: 7072 6f70 6572 7479 0a20 2020 2064 6566  property.    def
+00002040: 2069 6e66 2873 656c 6629 3a0a 2020 2020   inf(self):.    
+00002050: 2020 2020 2222 220a 2020 2020 2020 2020      """.        
+00002060: 5468 6520 696e 6669 6d75 6d20 6f66 2027  The infimum of '
+00002070: 7365 6c66 270a 0a20 2020 2020 2020 2045  self'..        E
+00002080: 7861 6d70 6c65 730a 2020 2020 2020 2020  xamples.        
+00002090: 3d3d 3d3d 3d3d 3d3d 0a0a 2020 2020 2020  ========..      
+000020a0: 2020 3e3e 3e20 6672 6f6d 2073 796d 7079    >>> from sympy
+000020b0: 2069 6d70 6f72 7420 496e 7465 7276 616c   import Interval
+000020c0: 2c20 556e 696f 6e0a 2020 2020 2020 2020  , Union.        
+000020d0: 3e3e 3e20 496e 7465 7276 616c 2830 2c20  >>> Interval(0, 
+000020e0: 3129 2e69 6e66 0a20 2020 2020 2020 2030  1).inf.        0
+000020f0: 0a20 2020 2020 2020 203e 3e3e 2055 6e69  .        >>> Uni
+00002100: 6f6e 2849 6e74 6572 7661 6c28 302c 2031  on(Interval(0, 1
+00002110: 292c 2049 6e74 6572 7661 6c28 322c 2033  ), Interval(2, 3
+00002120: 2929 2e69 6e66 0a20 2020 2020 2020 2030  )).inf.        0
+00002130: 0a0a 2020 2020 2020 2020 2222 220a 2020  ..        """.  
+00002140: 2020 2020 2020 7265 7475 726e 2073 656c        return sel
+00002150: 662e 5f69 6e66 0a0a 2020 2020 4070 726f  f._inf..    @pro
+00002160: 7065 7274 790a 2020 2020 6465 6620 5f69  perty.    def _i
+00002170: 6e66 2873 656c 6629 3a0a 2020 2020 2020  nf(self):.      
+00002180: 2020 7261 6973 6520 4e6f 7449 6d70 6c65    raise NotImple
+00002190: 6d65 6e74 6564 4572 726f 7228 2228 2573  mentedError("(%s
+000021a0: 292e 5f69 6e66 2220 2520 7365 6c66 290a  )._inf" % self).
+000021b0: 0a20 2020 2040 7072 6f70 6572 7479 0a20  .    @property. 
+000021c0: 2020 2064 6566 2073 7570 2873 656c 6629     def sup(self)
+000021d0: 3a0a 2020 2020 2020 2020 2222 220a 2020  :.        """.  
+000021e0: 2020 2020 2020 5468 6520 7375 7072 656d        The suprem
+000021f0: 756d 206f 6620 2773 656c 6627 0a0a 2020  um of 'self'..  
+00002200: 2020 2020 2020 4578 616d 706c 6573 0a20        Examples. 
+00002210: 2020 2020 2020 203d 3d3d 3d3d 3d3d 3d0a         ========.
+00002220: 0a20 2020 2020 2020 203e 3e3e 2066 726f  .        >>> fro
+00002230: 6d20 7379 6d70 7920 696d 706f 7274 2049  m sympy import I
+00002240: 6e74 6572 7661 6c2c 2055 6e69 6f6e 0a20  nterval, Union. 
+00002250: 2020 2020 2020 203e 3e3e 2049 6e74 6572         >>> Inter
+00002260: 7661 6c28 302c 2031 292e 7375 700a 2020  val(0, 1).sup.  
+00002270: 2020 2020 2020 310a 2020 2020 2020 2020        1.        
+00002280: 3e3e 3e20 556e 696f 6e28 496e 7465 7276  >>> Union(Interv
+00002290: 616c 2830 2c20 3129 2c20 496e 7465 7276  al(0, 1), Interv
+000022a0: 616c 2832 2c20 3329 292e 7375 700a 2020  al(2, 3)).sup.  
+000022b0: 2020 2020 2020 330a 0a20 2020 2020 2020        3..       
+000022c0: 2022 2222 0a20 2020 2020 2020 2072 6574   """.        ret
+000022d0: 7572 6e20 7365 6c66 2e5f 7375 700a 0a20  urn self._sup.. 
+000022e0: 2020 2040 7072 6f70 6572 7479 0a20 2020     @property.   
+000022f0: 2064 6566 205f 7375 7028 7365 6c66 293a   def _sup(self):
+00002300: 0a20 2020 2020 2020 2072 6169 7365 204e  .        raise N
+00002310: 6f74 496d 706c 656d 656e 7465 6445 7272  otImplementedErr
+00002320: 6f72 2822 2825 7329 2e5f 7375 7022 2025  or("(%s)._sup" %
+00002330: 2073 656c 6629 0a0a 2020 2020 6465 6620   self)..    def 
+00002340: 5f63 6f6e 7461 696e 7328 7365 6c66 2c20  _contains(self, 
+00002350: 6f74 6865 7229 3a0a 2020 2020 2020 2020  other):.        
+00002360: 7261 6973 6520 4e6f 7449 6d70 6c65 6d65  raise NotImpleme
+00002370: 6e74 6564 4572 726f 7228 2228 2573 292e  ntedError("(%s).
+00002380: 5f63 6f6e 7461 696e 7328 2573 2922 2025  _contains(%s)" %
+00002390: 2028 7365 6c66 2c20 6f74 6865 7229 290a   (self, other)).
+000023a0: 0a20 2020 2064 6566 2069 735f 7375 6273  .    def is_subs
+000023b0: 6574 2873 656c 662c 206f 7468 6572 293a  et(self, other):
+000023c0: 0a20 2020 2020 2020 2022 2222 0a20 2020  .        """.   
+000023d0: 2020 2020 2052 6574 7572 6e73 2054 7275       Returns Tru
+000023e0: 6520 6966 2027 7365 6c66 2720 6973 2061  e if 'self' is a
+000023f0: 2073 7562 7365 7420 6f66 2027 6f74 6865   subset of 'othe
+00002400: 7227 2e0a 0a20 2020 2020 2020 2045 7861  r'...        Exa
+00002410: 6d70 6c65 730a 2020 2020 2020 2020 3d3d  mples.        ==
+00002420: 3d3d 3d3d 3d3d 0a0a 2020 2020 2020 2020  ======..        
+00002430: 3e3e 3e20 6672 6f6d 2073 796d 7079 2069  >>> from sympy i
+00002440: 6d70 6f72 7420 496e 7465 7276 616c 0a20  mport Interval. 
+00002450: 2020 2020 2020 203e 3e3e 2049 6e74 6572         >>> Inter
+00002460: 7661 6c28 302c 2030 2e35 292e 6973 5f73  val(0, 0.5).is_s
+00002470: 7562 7365 7428 496e 7465 7276 616c 2830  ubset(Interval(0
+00002480: 2c20 3129 290a 2020 2020 2020 2020 5472  , 1)).        Tr
+00002490: 7565 0a20 2020 2020 2020 203e 3e3e 2049  ue.        >>> I
+000024a0: 6e74 6572 7661 6c28 302c 2031 292e 6973  nterval(0, 1).is
+000024b0: 5f73 7562 7365 7428 496e 7465 7276 616c  _subset(Interval
+000024c0: 2830 2c20 312c 206c 6566 745f 6f70 656e  (0, 1, left_open
+000024d0: 3d54 7275 6529 290a 2020 2020 2020 2020  =True)).        
+000024e0: 4661 6c73 650a 0a20 2020 2020 2020 2022  False..        "
+000024f0: 2222 0a20 2020 2020 2020 2069 6620 6f74  "".        if ot
+00002500: 6865 722e 6973 5f73 6574 3a0a 2020 2020  her.is_set:.    
+00002510: 2020 2020 2020 2020 2320 5858 5820 6973          # XXX is
+00002520: 7375 6520 3136 3837 330a 2020 2020 2020  sue 16873.      
+00002530: 2020 2020 2020 2320 7365 6c66 206d 6967        # self mig
+00002540: 6874 2062 6520 616e 2075 6e65 7661 6c75  ht be an unevalu
+00002550: 6174 6564 2066 6f72 6d20 6f66 2073 656c  ated form of sel
+00002560: 660a 2020 2020 2020 2020 2020 2020 2320  f.            # 
+00002570: 736f 2074 6865 2065 7175 616c 6974 7920  so the equality 
+00002580: 7465 7374 2077 696c 6c20 6661 696c 0a20  test will fail. 
+00002590: 2020 2020 2020 2020 2020 2072 6574 7572             retur
+000025a0: 6e20 7365 6c66 2e69 6e74 6572 7365 6374  n self.intersect
+000025b0: 286f 7468 6572 2920 3d3d 2073 656c 660a  (other) == self.
+000025c0: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
+000025d0: 2020 2020 2020 2020 2020 7261 6973 6520            raise 
+000025e0: 5661 6c75 6545 7272 6f72 2822 556e 6b6e  ValueError("Unkn
+000025f0: 6f77 6e20 6172 6775 6d65 6e74 2027 2573  own argument '%s
+00002600: 2722 2025 206f 7468 6572 290a 0a20 2020  '" % other)..   
+00002610: 2064 6566 2069 7373 7562 7365 7428 7365   def issubset(se
+00002620: 6c66 2c20 6f74 6865 7229 3a0a 2020 2020  lf, other):.    
+00002630: 2020 2020 2222 220a 2020 2020 2020 2020      """.        
+00002640: 416c 6961 7320 666f 7220 3a6d 6574 683a  Alias for :meth:
+00002650: 6069 735f 7375 6273 6574 2829 600a 2020  `is_subset()`.  
+00002660: 2020 2020 2020 2222 220a 2020 2020 2020        """.      
+00002670: 2020 7265 7475 726e 2073 656c 662e 6973    return self.is
+00002680: 5f73 7562 7365 7428 6f74 6865 7229 0a0a  _subset(other)..
+00002690: 2020 2020 6465 6620 6973 5f70 726f 7065      def is_prope
+000026a0: 725f 7375 6273 6574 2873 656c 662c 206f  r_subset(self, o
+000026b0: 7468 6572 293a 0a20 2020 2020 2020 2022  ther):.        "
+000026c0: 2222 0a20 2020 2020 2020 2052 6574 7572  "".        Retur
+000026d0: 6e73 2054 7275 6520 6966 2027 7365 6c66  ns True if 'self
+000026e0: 2720 6973 2061 2070 726f 7065 7220 7375  ' is a proper su
+000026f0: 6273 6574 206f 6620 276f 7468 6572 272e  bset of 'other'.
+00002700: 0a0a 2020 2020 2020 2020 4578 616d 706c  ..        Exampl
+00002710: 6573 0a20 2020 2020 2020 203d 3d3d 3d3d  es.        =====
+00002720: 3d3d 3d0a 0a20 2020 2020 2020 203e 3e3e  ===..        >>>
+00002730: 2066 726f 6d20 7379 6d70 7920 696d 706f   from sympy impo
+00002740: 7274 2049 6e74 6572 7661 6c0a 2020 2020  rt Interval.    
+00002750: 2020 2020 3e3e 3e20 496e 7465 7276 616c      >>> Interval
+00002760: 2830 2c20 302e 3529 2e69 735f 7072 6f70  (0, 0.5).is_prop
+00002770: 6572 5f73 7562 7365 7428 496e 7465 7276  er_subset(Interv
+00002780: 616c 2830 2c20 3129 290a 2020 2020 2020  al(0, 1)).      
+00002790: 2020 5472 7565 0a20 2020 2020 2020 203e    True.        >
+000027a0: 3e3e 2049 6e74 6572 7661 6c28 302c 2031  >> Interval(0, 1
+000027b0: 292e 6973 5f70 726f 7065 725f 7375 6273  ).is_proper_subs
+000027c0: 6574 2849 6e74 6572 7661 6c28 302c 2031  et(Interval(0, 1
+000027d0: 2929 0a20 2020 2020 2020 2046 616c 7365  )).        False
+000027e0: 0a0a 2020 2020 2020 2020 2222 220a 2020  ..        """.  
+000027f0: 2020 2020 2020 6966 206f 7468 6572 2e69        if other.i
+00002800: 735f 7365 743a 0a20 2020 2020 2020 2020  s_set:.         
+00002810: 2020 2072 6574 7572 6e20 7365 6c66 2021     return self !
+00002820: 3d20 6f74 6865 7220 616e 6420 7365 6c66  = other and self
+00002830: 2e69 735f 7375 6273 6574 286f 7468 6572  .is_subset(other
+00002840: 290a 2020 2020 2020 2020 656c 7365 3a0a  ).        else:.
+00002850: 2020 2020 2020 2020 2020 2020 7261 6973              rais
+00002860: 6520 5661 6c75 6545 7272 6f72 2822 556e  e ValueError("Un
+00002870: 6b6e 6f77 6e20 6172 6775 6d65 6e74 2027  known argument '
+00002880: 2573 2722 2025 206f 7468 6572 290a 0a20  %s'" % other).. 
+00002890: 2020 2064 6566 2069 735f 7375 7065 7273     def is_supers
+000028a0: 6574 2873 656c 662c 206f 7468 6572 293a  et(self, other):
+000028b0: 0a20 2020 2020 2020 2022 2222 0a20 2020  .        """.   
+000028c0: 2020 2020 2052 6574 7572 6e73 2054 7275       Returns Tru
+000028d0: 6520 6966 2027 7365 6c66 2720 6973 2061  e if 'self' is a
+000028e0: 2073 7570 6572 7365 7420 6f66 2027 6f74   superset of 'ot
+000028f0: 6865 7227 2e0a 0a20 2020 2020 2020 2045  her'...        E
+00002900: 7861 6d70 6c65 730a 2020 2020 2020 2020  xamples.        
+00002910: 3d3d 3d3d 3d3d 3d3d 0a0a 2020 2020 2020  ========..      
+00002920: 2020 3e3e 3e20 6672 6f6d 2073 796d 7079    >>> from sympy
+00002930: 2069 6d70 6f72 7420 496e 7465 7276 616c   import Interval
+00002940: 0a20 2020 2020 2020 203e 3e3e 2049 6e74  .        >>> Int
+00002950: 6572 7661 6c28 302c 2030 2e35 292e 6973  erval(0, 0.5).is
+00002960: 5f73 7570 6572 7365 7428 496e 7465 7276  _superset(Interv
+00002970: 616c 2830 2c20 3129 290a 2020 2020 2020  al(0, 1)).      
+00002980: 2020 4661 6c73 650a 2020 2020 2020 2020    False.        
+00002990: 3e3e 3e20 496e 7465 7276 616c 2830 2c20  >>> Interval(0, 
+000029a0: 3129 2e69 735f 7375 7065 7273 6574 2849  1).is_superset(I
+000029b0: 6e74 6572 7661 6c28 302c 2031 2c20 6c65  nterval(0, 1, le
+000029c0: 6674 5f6f 7065 6e3d 5472 7565 2929 0a20  ft_open=True)). 
+000029d0: 2020 2020 2020 2054 7275 650a 0a20 2020         True..   
+000029e0: 2020 2020 2022 2222 0a20 2020 2020 2020       """.       
+000029f0: 2069 6620 6f74 6865 722e 6973 5f73 6574   if other.is_set
+00002a00: 3a0a 2020 2020 2020 2020 2020 2020 7265  :.            re
+00002a10: 7475 726e 206f 7468 6572 2e69 735f 7375  turn other.is_su
+00002a20: 6273 6574 2873 656c 6629 0a20 2020 2020  bset(self).     
+00002a30: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
+00002a40: 2020 2020 2072 6169 7365 2056 616c 7565       raise Value
+00002a50: 4572 726f 7228 2255 6e6b 6e6f 776e 2061  Error("Unknown a
+00002a60: 7267 756d 656e 7420 2725 7327 2220 2520  rgument '%s'" % 
+00002a70: 6f74 6865 7229 0a0a 2020 2020 6465 6620  other)..    def 
+00002a80: 6973 7375 7065 7273 6574 2873 656c 662c  issuperset(self,
+00002a90: 206f 7468 6572 293a 0a20 2020 2020 2020   other):.       
+00002aa0: 2022 2222 0a20 2020 2020 2020 2041 6c69   """.        Ali
+00002ab0: 6173 2066 6f72 203a 6d65 7468 3a60 6973  as for :meth:`is
+00002ac0: 5f73 7570 6572 7365 7428 2960 0a20 2020  _superset()`.   
+00002ad0: 2020 2020 2022 2222 0a20 2020 2020 2020       """.       
+00002ae0: 2072 6574 7572 6e20 7365 6c66 2e69 735f   return self.is_
+00002af0: 7375 7065 7273 6574 286f 7468 6572 290a  superset(other).
+00002b00: 0a20 2020 2064 6566 2069 735f 7072 6f70  .    def is_prop
+00002b10: 6572 5f73 7570 6572 7365 7428 7365 6c66  er_superset(self
+00002b20: 2c20 6f74 6865 7229 3a0a 2020 2020 2020  , other):.      
+00002b30: 2020 2222 220a 2020 2020 2020 2020 5265    """.        Re
+00002b40: 7475 726e 7320 5472 7565 2069 6620 2773  turns True if 's
+00002b50: 656c 6627 2069 7320 6120 7072 6f70 6572  elf' is a proper
+00002b60: 2073 7570 6572 7365 7420 6f66 2027 6f74   superset of 'ot
+00002b70: 6865 7227 2e0a 0a20 2020 2020 2020 2045  her'...        E
+00002b80: 7861 6d70 6c65 730a 2020 2020 2020 2020  xamples.        
+00002b90: 3d3d 3d3d 3d3d 3d3d 0a0a 2020 2020 2020  ========..      
+00002ba0: 2020 3e3e 3e20 6672 6f6d 2073 796d 7079    >>> from sympy
+00002bb0: 2069 6d70 6f72 7420 496e 7465 7276 616c   import Interval
+00002bc0: 0a20 2020 2020 2020 203e 3e3e 2049 6e74  .        >>> Int
+00002bd0: 6572 7661 6c28 302c 2031 292e 6973 5f70  erval(0, 1).is_p
+00002be0: 726f 7065 725f 7375 7065 7273 6574 2849  roper_superset(I
+00002bf0: 6e74 6572 7661 6c28 302c 2030 2e35 2929  nterval(0, 0.5))
+00002c00: 0a20 2020 2020 2020 2054 7275 650a 2020  .        True.  
+00002c10: 2020 2020 2020 3e3e 3e20 496e 7465 7276        >>> Interv
+00002c20: 616c 2830 2c20 3129 2e69 735f 7072 6f70  al(0, 1).is_prop
+00002c30: 6572 5f73 7570 6572 7365 7428 496e 7465  er_superset(Inte
+00002c40: 7276 616c 2830 2c20 3129 290a 2020 2020  rval(0, 1)).    
+00002c50: 2020 2020 4661 6c73 650a 0a20 2020 2020      False..     
+00002c60: 2020 2022 2222 0a20 2020 2020 2020 2069     """.        i
+00002c70: 6620 6f74 6865 722e 6973 5f73 6574 3a0a  f other.is_set:.
+00002c80: 2020 2020 2020 2020 2020 2020 7265 7475              retu
+00002c90: 726e 2073 656c 6620 213d 206f 7468 6572  rn self != other
+00002ca0: 2061 6e64 2073 656c 662e 6973 5f73 7570   and self.is_sup
+00002cb0: 6572 7365 7428 6f74 6865 7229 0a20 2020  erset(other).   
+00002cc0: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
+00002cd0: 2020 2020 2020 2072 6169 7365 2056 616c         raise Val
+00002ce0: 7565 4572 726f 7228 2255 6e6b 6e6f 776e  ueError("Unknown
+00002cf0: 2061 7267 756d 656e 7420 2725 7327 2220   argument '%s'" 
+00002d00: 2520 6f74 6865 7229 0a0a 2020 2020 6465  % other)..    de
+00002d10: 6620 5f65 7661 6c5f 706f 7765 7273 6574  f _eval_powerset
+00002d20: 2873 656c 6629 3a0a 2020 2020 2020 2020  (self):.        
+00002d30: 7261 6973 6520 4e6f 7449 6d70 6c65 6d65  raise NotImpleme
+00002d40: 6e74 6564 4572 726f 7228 2750 6f77 6572  ntedError('Power
+00002d50: 2073 6574 206e 6f74 2064 6566 696e 6564   set not defined
+00002d60: 2066 6f72 3a20 2573 2720 2520 7365 6c66   for: %s' % self
+00002d70: 2e66 756e 6329 0a0a 2020 2020 6465 6620  .func)..    def 
+00002d80: 706f 7765 7273 6574 2873 656c 6629 3a0a  powerset(self):.
+00002d90: 2020 2020 2020 2020 2222 220a 2020 2020          """.    
+00002da0: 2020 2020 4669 6e64 2074 6865 2050 6f77      Find the Pow
+00002db0: 6572 2073 6574 206f 6620 2773 656c 6627  er set of 'self'
+00002dc0: 2e0a 0a20 2020 2020 2020 2045 7861 6d70  ...        Examp
+00002dd0: 6c65 730a 2020 2020 2020 2020 3d3d 3d3d  les.        ====
+00002de0: 3d3d 3d3d 0a0a 2020 2020 2020 2020 3e3e  ====..        >>
+00002df0: 3e20 6672 6f6d 2073 796d 7079 2069 6d70  > from sympy imp
+00002e00: 6f72 7420 4669 6e69 7465 5365 742c 2045  ort FiniteSet, E
+00002e10: 6d70 7479 5365 740a 2020 2020 2020 2020  mptySet.        
+00002e20: 3e3e 3e20 4120 3d20 456d 7074 7953 6574  >>> A = EmptySet
+00002e30: 2829 0a20 2020 2020 2020 203e 3e3e 2041  ().        >>> A
+00002e40: 2e70 6f77 6572 7365 7428 290a 2020 2020  .powerset().    
+00002e50: 2020 2020 7b45 6d70 7479 5365 7428 297d      {EmptySet()}
+00002e60: 0a20 2020 2020 2020 203e 3e3e 2041 203d  .        >>> A =
+00002e70: 2046 696e 6974 6553 6574 2831 2c20 3229   FiniteSet(1, 2)
+00002e80: 0a20 2020 2020 2020 203e 3e3e 2061 2c20  .        >>> a, 
+00002e90: 622c 2063 203d 2046 696e 6974 6553 6574  b, c = FiniteSet
+00002ea0: 2831 292c 2046 696e 6974 6553 6574 2832  (1), FiniteSet(2
+00002eb0: 292c 2046 696e 6974 6553 6574 2831 2c20  ), FiniteSet(1, 
+00002ec0: 3229 0a20 2020 2020 2020 203e 3e3e 2041  2).        >>> A
+00002ed0: 2e70 6f77 6572 7365 7428 2920 3d3d 2046  .powerset() == F
+00002ee0: 696e 6974 6553 6574 2861 2c20 622c 2063  initeSet(a, b, c
+00002ef0: 2c20 456d 7074 7953 6574 2829 290a 2020  , EmptySet()).  
+00002f00: 2020 2020 2020 5472 7565 0a0a 2020 2020        True..    
+00002f10: 2020 2020 5265 6665 7265 6e63 6573 0a20      References. 
+00002f20: 2020 2020 2020 203d 3d3d 3d3d 3d3d 3d3d         =========
+00002f30: 3d0a 0a20 2020 2020 2020 202e 2e20 5b31  =..        .. [1
+00002f40: 5d20 6874 7470 733a 2f2f 656e 2e77 696b  ] https://en.wik
+00002f50: 6970 6564 6961 2e6f 7267 2f77 696b 692f  ipedia.org/wiki/
+00002f60: 506f 7765 725f 7365 740a 0a20 2020 2020  Power_set..     
+00002f70: 2020 2022 2222 0a20 2020 2020 2020 2072     """.        r
+00002f80: 6574 7572 6e20 7365 6c66 2e5f 6576 616c  eturn self._eval
+00002f90: 5f70 6f77 6572 7365 7428 290a 0a20 2020  _powerset()..   
+00002fa0: 2040 7072 6f70 6572 7479 0a20 2020 2064   @property.    d
+00002fb0: 6566 206d 6561 7375 7265 2873 656c 6629  ef measure(self)
+00002fc0: 3a0a 2020 2020 2020 2020 2222 220a 2020  :.        """.  
+00002fd0: 2020 2020 2020 5468 6520 284c 6562 6573        The (Lebes
+00002fe0: 6775 6529 206d 6561 7375 7265 206f 6620  gue) measure of 
+00002ff0: 2773 656c 6627 0a0a 2020 2020 2020 2020  'self'..        
+00003000: 4578 616d 706c 6573 0a20 2020 2020 2020  Examples.       
+00003010: 203d 3d3d 3d3d 3d3d 3d0a 0a20 2020 2020   ========..     
+00003020: 2020 203e 3e3e 2066 726f 6d20 7379 6d70     >>> from symp
+00003030: 7920 696d 706f 7274 2049 6e74 6572 7661  y import Interva
+00003040: 6c2c 2055 6e69 6f6e 0a20 2020 2020 2020  l, Union.       
+00003050: 203e 3e3e 2049 6e74 6572 7661 6c28 302c   >>> Interval(0,
+00003060: 2031 292e 6d65 6173 7572 650a 2020 2020   1).measure.    
+00003070: 2020 2020 310a 2020 2020 2020 2020 3e3e      1.        >>
+00003080: 3e20 556e 696f 6e28 496e 7465 7276 616c  > Union(Interval
+00003090: 2830 2c20 3129 2c20 496e 7465 7276 616c  (0, 1), Interval
+000030a0: 2832 2c20 3329 292e 6d65 6173 7572 650a  (2, 3)).measure.
+000030b0: 2020 2020 2020 2020 320a 0a20 2020 2020          2..     
+000030c0: 2020 2022 2222 0a20 2020 2020 2020 2072     """.        r
+000030d0: 6574 7572 6e20 7365 6c66 2e5f 6d65 6173  eturn self._meas
+000030e0: 7572 650a 0a20 2020 2040 7072 6f70 6572  ure..    @proper
+000030f0: 7479 0a20 2020 2064 6566 2062 6f75 6e64  ty.    def bound
+00003100: 6172 7928 7365 6c66 293a 0a20 2020 2020  ary(self):.     
+00003110: 2020 2022 2222 0a20 2020 2020 2020 2054     """.        T
+00003120: 6865 2062 6f75 6e64 6172 7920 6f72 2066  he boundary or f
+00003130: 726f 6e74 6965 7220 6f66 2061 2073 6574  rontier of a set
+00003140: 0a0a 2020 2020 2020 2020 4120 706f 696e  ..        A poin
+00003150: 7420 7820 6973 206f 6e20 7468 6520 626f  t x is on the bo
+00003160: 756e 6461 7279 206f 6620 6120 7365 7420  undary of a set 
+00003170: 5320 6966 0a0a 2020 2020 2020 2020 312e  S if..        1.
+00003180: 2020 7820 6973 2069 6e20 7468 6520 636c    x is in the cl
+00003190: 6f73 7572 6520 6f66 2053 2e0a 2020 2020  osure of S..    
+000031a0: 2020 2020 2020 2020 492e 652e 2045 7665          I.e. Eve
+000031b0: 7279 206e 6569 6768 626f 7268 6f6f 6420  ry neighborhood 
+000031c0: 6f66 2078 2063 6f6e 7461 696e 7320 6120  of x contains a 
+000031d0: 706f 696e 7420 696e 2053 2e0a 2020 2020  point in S..    
+000031e0: 2020 2020 322e 2020 7820 6973 206e 6f74      2.  x is not
+000031f0: 2069 6e20 7468 6520 696e 7465 7269 6f72   in the interior
+00003200: 206f 6620 532e 0a20 2020 2020 2020 2020   of S..         
+00003210: 2020 2049 2e65 2e20 5468 6572 6520 646f     I.e. There do
+00003220: 6573 206e 6f74 2065 7869 7374 2061 6e20  es not exist an 
+00003230: 6f70 656e 2073 6574 2063 656e 7465 7265  open set centere
+00003240: 6420 6f6e 2078 2063 6f6e 7461 696e 6564  d on x contained
+00003250: 0a20 2020 2020 2020 2020 2020 2065 6e74  .            ent
+00003260: 6972 656c 7920 7769 7468 696e 2053 2e0a  irely within S..
+00003270: 0a20 2020 2020 2020 2054 6865 7265 2061  .        There a
+00003280: 7265 2074 6865 2070 6f69 6e74 7320 6f6e  re the points on
+00003290: 2074 6865 206f 7574 6572 2072 696d 206f   the outer rim o
+000032a0: 6620 532e 2020 4966 2053 2069 7320 6f70  f S.  If S is op
+000032b0: 656e 2074 6865 6e20 7468 6573 650a 2020  en then these.  
+000032c0: 2020 2020 2020 706f 696e 7473 206e 6565        points nee
+000032d0: 6420 6e6f 7420 6163 7475 616c 6c79 2062  d not actually b
+000032e0: 6520 636f 6e74 6169 6e65 6420 7769 7468  e contained with
+000032f0: 696e 2053 2e0a 0a20 2020 2020 2020 2046  in S...        F
+00003300: 6f72 2065 7861 6d70 6c65 2c20 7468 6520  or example, the 
+00003310: 626f 756e 6461 7279 206f 6620 616e 2069  boundary of an i
+00003320: 6e74 6572 7661 6c20 6973 2069 7473 2073  nterval is its s
+00003330: 7461 7274 2061 6e64 2065 6e64 2070 6f69  tart and end poi
+00003340: 6e74 732e 0a20 2020 2020 2020 2054 6869  nts..        Thi
+00003350: 7320 6973 2074 7275 6520 7265 6761 7264  s is true regard
+00003360: 6c65 7373 206f 6620 7768 6574 6865 7220  less of whether 
+00003370: 6f72 206e 6f74 2074 6865 2069 6e74 6572  or not the inter
+00003380: 7661 6c20 6973 206f 7065 6e2e 0a0a 2020  val is open...  
+00003390: 2020 2020 2020 4578 616d 706c 6573 0a20        Examples. 
+000033a0: 2020 2020 2020 203d 3d3d 3d3d 3d3d 3d0a         ========.
+000033b0: 0a20 2020 2020 2020 203e 3e3e 2066 726f  .        >>> fro
+000033c0: 6d20 7379 6d70 7920 696d 706f 7274 2049  m sympy import I
+000033d0: 6e74 6572 7661 6c0a 2020 2020 2020 2020  nterval.        
+000033e0: 3e3e 3e20 496e 7465 7276 616c 2830 2c20  >>> Interval(0, 
+000033f0: 3129 2e62 6f75 6e64 6172 790a 2020 2020  1).boundary.    
+00003400: 2020 2020 7b30 2c20 317d 0a20 2020 2020      {0, 1}.     
+00003410: 2020 2022 2222 0a20 2020 2020 2020 2072     """.        r
+00003420: 6574 7572 6e20 7365 6c66 2e5f 626f 756e  eturn self._boun
+00003430: 6461 7279 0a0a 2020 2020 4070 726f 7065  dary..    @prope
+00003440: 7274 790a 2020 2020 6465 6620 6973 5f6f  rty.    def is_o
+00003450: 7065 6e28 7365 6c66 293a 0a20 2020 2020  pen(self):.     
+00003460: 2020 2022 2222 0a20 2020 2020 2020 2050     """.        P
+00003470: 726f 7065 7274 7920 6d65 7468 6f64 2074  roperty method t
+00003480: 6f20 6368 6563 6b20 7768 6574 6865 7220  o check whether 
+00003490: 6120 7365 7420 6973 206f 7065 6e2e 0a20  a set is open.. 
+000034a0: 2020 2020 2020 2041 2073 6574 2069 7320         A set is 
+000034b0: 6f70 656e 2069 6620 616e 6420 6f6e 6c79  open if and only
+000034c0: 2069 6620 6974 2068 6173 2061 6e20 656d   if it has an em
+000034d0: 7074 7920 696e 7465 7273 6563 7469 6f6e  pty intersection
+000034e0: 2077 6974 6820 6974 730a 2020 2020 2020   with its.      
+000034f0: 2020 626f 756e 6461 7279 2e0a 0a20 2020    boundary...   
+00003500: 2020 2020 2045 7861 6d70 6c65 730a 2020       Examples.  
+00003510: 2020 2020 2020 3d3d 3d3d 3d3d 3d3d 0a20        ========. 
+00003520: 2020 2020 2020 203e 3e3e 2066 726f 6d20         >>> from 
+00003530: 7379 6d70 7920 696d 706f 7274 2053 0a20  sympy import S. 
+00003540: 2020 2020 2020 203e 3e3e 2052 6561 6c73         >>> Reals
+00003550: 2e69 735f 6f70 656e 0a20 2020 2020 2020  .is_open.       
+00003560: 2054 7275 650a 2020 2020 2020 2020 2222   True.        ""
+00003570: 220a 2020 2020 2020 2020 6966 206e 6f74  ".        if not
+00003580: 2049 6e74 6572 7365 6374 696f 6e28 7365   Intersection(se
+00003590: 6c66 2c20 7365 6c66 2e62 6f75 6e64 6172  lf, self.boundar
+000035a0: 7929 3a0a 2020 2020 2020 2020 2020 2020  y):.            
+000035b0: 7265 7475 726e 2054 7275 650a 2020 2020  return True.    
+000035c0: 2020 2020 2320 5765 2063 616e 2774 2063      # We can't c
+000035d0: 6f6e 6669 6465 6e74 6c79 2063 6c61 696d  onfidently claim
+000035e0: 2074 6861 7420 616e 2069 6e74 6572 7365   that an interse
+000035f0: 6374 696f 6e20 6578 6973 7473 0a20 2020  ction exists.   
+00003600: 2020 2020 2072 6574 7572 6e20 4e6f 6e65       return None
+00003610: 0a0a 2020 2020 4070 726f 7065 7274 790a  ..    @property.
+00003620: 2020 2020 6465 6620 6973 5f63 6c6f 7365      def is_close
+00003630: 6428 7365 6c66 293a 0a20 2020 2020 2020  d(self):.       
+00003640: 2022 2222 0a20 2020 2020 2020 2041 2070   """.        A p
+00003650: 726f 7065 7274 7920 6d65 7468 6f64 2074  roperty method t
+00003660: 6f20 6368 6563 6b20 7768 6574 6865 7220  o check whether 
+00003670: 6120 7365 7420 6973 2063 6c6f 7365 642e  a set is closed.
+00003680: 2041 2073 6574 2069 7320 636c 6f73 6564   A set is closed
+00003690: 0a20 2020 2020 2020 2069 6620 6974 2773  .        if it's
+000036a0: 2063 6f6d 706c 656d 656e 7420 6973 2061   complement is a
+000036b0: 6e20 6f70 656e 2073 6574 2e0a 0a20 2020  n open set...   
+000036c0: 2020 2020 2045 7861 6d70 6c65 730a 2020       Examples.  
+000036d0: 2020 2020 2020 3d3d 3d3d 3d3d 3d3d 0a20        ========. 
+000036e0: 2020 2020 2020 203e 3e3e 2066 726f 6d20         >>> from 
+000036f0: 7379 6d70 7920 696d 706f 7274 2049 6e74  sympy import Int
+00003700: 6572 7661 6c0a 2020 2020 2020 2020 3e3e  erval.        >>
+00003710: 3e20 496e 7465 7276 616c 2830 2c20 3129  > Interval(0, 1)
+00003720: 2e69 735f 636c 6f73 6564 0a20 2020 2020  .is_closed.     
+00003730: 2020 2054 7275 650a 2020 2020 2020 2020     True.        
+00003740: 2222 220a 2020 2020 2020 2020 7265 7475  """.        retu
+00003750: 726e 2073 656c 662e 626f 756e 6461 7279  rn self.boundary
+00003760: 2e69 735f 7375 6273 6574 2873 656c 6629  .is_subset(self)
+00003770: 0a0a 2020 2020 4070 726f 7065 7274 790a  ..    @property.
+00003780: 2020 2020 6465 6620 636c 6f73 7572 6528      def closure(
+00003790: 7365 6c66 293a 0a20 2020 2020 2020 2022  self):.        "
+000037a0: 2222 0a20 2020 2020 2020 2050 726f 7065  "".        Prope
+000037b0: 7274 7920 6d65 7468 6f64 2077 6869 6368  rty method which
+000037c0: 2072 6574 7572 6e73 2074 6865 2063 6c6f   returns the clo
+000037d0: 7375 7265 206f 6620 6120 7365 742e 0a20  sure of a set.. 
+000037e0: 2020 2020 2020 2054 6865 2063 6c6f 7375         The closu
+000037f0: 7265 2069 7320 6465 6669 6e65 6420 6173  re is defined as
+00003800: 2074 6865 2075 6e69 6f6e 206f 6620 7468   the union of th
+00003810: 6520 7365 7420 6974 7365 6c66 2061 6e64  e set itself and
+00003820: 2069 7473 0a20 2020 2020 2020 2062 6f75   its.        bou
+00003830: 6e64 6172 792e 0a0a 2020 2020 2020 2020  ndary...        
+00003840: 4578 616d 706c 6573 0a20 2020 2020 2020  Examples.       
+00003850: 203d 3d3d 3d3d 3d3d 3d0a 2020 2020 2020   ========.      
+00003860: 2020 3e3e 3e20 6672 6f6d 2073 796d 7079    >>> from sympy
+00003870: 2069 6d70 6f72 7420 532c 2049 6e74 6572   import S, Inter
+00003880: 7661 6c0a 2020 2020 2020 2020 3e3e 3e20  val.        >>> 
+00003890: 5265 616c 732e 636c 6f73 7572 650a 2020  Reals.closure.  
+000038a0: 2020 2020 2020 5265 616c 730a 2020 2020        Reals.    
+000038b0: 2020 2020 3e3e 3e20 496e 7465 7276 616c      >>> Interval
+000038c0: 2830 2c20 3129 2e63 6c6f 7375 7265 0a20  (0, 1).closure. 
+000038d0: 2020 2020 2020 2049 6e74 6572 7661 6c28         Interval(
+000038e0: 302c 2031 290a 2020 2020 2020 2020 2222  0, 1).        ""
+000038f0: 220a 2020 2020 2020 2020 7265 7475 726e  ".        return
+00003900: 2073 656c 6620 2b20 7365 6c66 2e62 6f75   self + self.bou
+00003910: 6e64 6172 790a 0a20 2020 2040 7072 6f70  ndary..    @prop
+00003920: 6572 7479 0a20 2020 2064 6566 2069 6e74  erty.    def int
+00003930: 6572 696f 7228 7365 6c66 293a 0a20 2020  erior(self):.   
+00003940: 2020 2020 2022 2222 0a20 2020 2020 2020       """.       
+00003950: 2050 726f 7065 7274 7920 6d65 7468 6f64   Property method
+00003960: 2077 6869 6368 2072 6574 7572 6e73 2074   which returns t
+00003970: 6865 2069 6e74 6572 696f 7220 6f66 2061  he interior of a
+00003980: 2073 6574 2e0a 2020 2020 2020 2020 5468   set..        Th
+00003990: 6520 696e 7465 7269 6f72 206f 6620 6120  e interior of a 
+000039a0: 7365 7420 5320 636f 6e73 6973 7473 2061  set S consists a
+000039b0: 6c6c 2070 6f69 6e74 7320 6f66 2053 2074  ll points of S t
+000039c0: 6861 7420 646f 206e 6f74 0a20 2020 2020  hat do not.     
+000039d0: 2020 2062 656c 6f6e 6720 746f 2074 6865     belong to the
+000039e0: 2062 6f75 6e64 6172 7920 6f66 2053 2e0a   boundary of S..
+000039f0: 0a20 2020 2020 2020 2045 7861 6d70 6c65  .        Example
+00003a00: 730a 2020 2020 2020 2020 3d3d 3d3d 3d3d  s.        ======
+00003a10: 3d3d 0a20 2020 2020 2020 203e 3e3e 2066  ==.        >>> f
+00003a20: 726f 6d20 7379 6d70 7920 696d 706f 7274  rom sympy import
+00003a30: 2049 6e74 6572 7661 6c0a 2020 2020 2020   Interval.      
+00003a40: 2020 3e3e 3e20 496e 7465 7276 616c 2830    >>> Interval(0
+00003a50: 2c20 3129 2e69 6e74 6572 696f 720a 2020  , 1).interior.  
+00003a60: 2020 2020 2020 496e 7465 7276 616c 2e6f        Interval.o
+00003a70: 7065 6e28 302c 2031 290a 2020 2020 2020  pen(0, 1).      
+00003a80: 2020 3e3e 3e20 496e 7465 7276 616c 2830    >>> Interval(0
+00003a90: 2c20 3129 2e62 6f75 6e64 6172 792e 696e  , 1).boundary.in
+00003aa0: 7465 7269 6f72 0a20 2020 2020 2020 2045  terior.        E
+00003ab0: 6d70 7479 5365 7428 290a 2020 2020 2020  mptySet().      
+00003ac0: 2020 2222 220a 2020 2020 2020 2020 7265    """.        re
+00003ad0: 7475 726e 2073 656c 6620 2d20 7365 6c66  turn self - self
+00003ae0: 2e62 6f75 6e64 6172 790a 0a20 2020 2040  .boundary..    @
+00003af0: 7072 6f70 6572 7479 0a20 2020 2064 6566  property.    def
+00003b00: 205f 626f 756e 6461 7279 2873 656c 6629   _boundary(self)
+00003b10: 3a0a 2020 2020 2020 2020 7261 6973 6520  :.        raise 
+00003b20: 4e6f 7449 6d70 6c65 6d65 6e74 6564 4572  NotImplementedEr
+00003b30: 726f 7228 290a 0a20 2020 2040 7072 6f70  ror()..    @prop
+00003b40: 6572 7479 0a20 2020 2064 6566 205f 6d65  erty.    def _me
+00003b50: 6173 7572 6528 7365 6c66 293a 0a20 2020  asure(self):.   
+00003b60: 2020 2020 2072 6169 7365 204e 6f74 496d       raise NotIm
+00003b70: 706c 656d 656e 7465 6445 7272 6f72 2822  plementedError("
+00003b80: 2825 7329 2e5f 6d65 6173 7572 6522 2025  (%s)._measure" %
+00003b90: 2073 656c 6629 0a0a 2020 2020 6465 6620   self)..    def 
+00003ba0: 5f5f 6164 645f 5f28 7365 6c66 2c20 6f74  __add__(self, ot
+00003bb0: 6865 7229 3a0a 2020 2020 2020 2020 7261  her):.        ra
+00003bc0: 6973 6520 4578 6365 7074 696f 6e28 2263  ise Exception("c
+00003bd0: 6f75 6c64 206e 6f74 2061 6464 2025 732c  ould not add %s,
+00003be0: 2025 7322 2025 2028 7365 6c66 2c20 6f74   %s" % (self, ot
+00003bf0: 6865 7229 290a 0a20 2020 2064 6566 205f  her))..    def _
+00003c00: 5f6f 725f 5f28 7365 6c66 2c20 6f74 6865  _or__(self, othe
+00003c10: 7229 3a0a 2020 2020 2020 2020 7265 7475  r):.        retu
+00003c20: 726e 2073 656c 662e 756e 696f 6e28 6f74  rn self.union(ot
+00003c30: 6865 7229 0a0a 2020 2020 6465 6620 5f5f  her)..    def __
+00003c40: 616e 645f 5f28 7365 6c66 2c20 6f74 6865  and__(self, othe
+00003c50: 7229 3a0a 2020 2020 2020 2020 7265 7475  r):.        retu
+00003c60: 726e 2073 656c 662e 696e 7465 7273 6563  rn self.intersec
+00003c70: 7428 6f74 6865 7229 0a0a 2020 2020 6465  t(other)..    de
+00003c80: 6620 5f5f 6d61 746d 756c 5f5f 2873 656c  f __matmul__(sel
+00003c90: 662c 206f 7468 6572 293a 0a20 2020 2020  f, other):.     
+00003ca0: 2020 2072 6574 7572 6e20 5072 6f64 7563     return Produc
+00003cb0: 7453 6574 2873 656c 662c 206f 7468 6572  tSet(self, other
+00003cc0: 290a 0a20 2020 2064 6566 205f 5f6d 756c  )..    def __mul
+00003cd0: 5f5f 2873 656c 662c 206f 7468 6572 293a  __(self, other):
+00003ce0: 0a20 2020 2020 2020 2072 6169 7365 2045  .        raise E
+00003cf0: 7863 6570 7469 6f6e 2822 636f 756c 6420  xception("could 
+00003d00: 6e6f 7420 6d75 6c74 6970 6c79 2025 732c  not multiply %s,
+00003d10: 2025 7322 2025 2028 7365 6c66 2c20 6f74   %s" % (self, ot
+00003d20: 6865 7229 290a 0a20 2020 2064 6566 205f  her))..    def _
+00003d30: 5f78 6f72 5f5f 2873 656c 662c 206f 7468  _xor__(self, oth
+00003d40: 6572 293a 0a20 2020 2020 2020 2072 6574  er):.        ret
+00003d50: 7572 6e20 5379 6d6d 6574 7269 6344 6966  urn SymmetricDif
+00003d60: 6665 7265 6e63 6528 7365 6c66 2c20 6f74  ference(self, ot
+00003d70: 6865 7229 0a0a 2020 2020 6465 6620 5f5f  her)..    def __
+00003d80: 706f 775f 5f28 7365 6c66 2c20 6578 7029  pow__(self, exp)
+00003d90: 3a0a 2020 2020 2020 2020 6966 206e 6f74  :.        if not
+00003da0: 2073 796d 7069 6679 2865 7870 292e 6973   sympify(exp).is
+00003db0: 5f49 6e74 6567 6572 2061 6e64 2065 7870  _Integer and exp
+00003dc0: 203e 3d20 303a 0a20 2020 2020 2020 2020   >= 0:.         
+00003dd0: 2020 2072 6169 7365 2056 616c 7565 4572     raise ValueEr
+00003de0: 726f 7228 2225 733a 2045 7870 6f6e 656e  ror("%s: Exponen
+00003df0: 7420 6d75 7374 2062 6520 6120 706f 7369  t must be a posi
+00003e00: 7469 7665 2049 6e74 6567 6572 2220 2520  tive Integer" % 
+00003e10: 6578 7029 0a20 2020 2020 2020 2072 6574  exp).        ret
+00003e20: 7572 6e20 5072 6f64 7563 7453 6574 285b  urn ProductSet([
+00003e30: 7365 6c66 5d20 2a20 6578 7029 0a0a 2020  self] * exp)..  
+00003e40: 2020 6465 6620 5f5f 7375 625f 5f28 7365    def __sub__(se
+00003e50: 6c66 2c20 6f74 6865 7229 3a20 0a20 2020  lf, other): .   
+00003e60: 2020 2020 2072 6574 7572 6e20 436f 6d70       return Comp
+00003e70: 6c65 6d65 6e74 2873 656c 662c 206f 7468  lement(self, oth
+00003e80: 6572 290a 0a20 2020 2023 2070 6572 666f  er)..    # perfo
+00003e90: 726d 696e 6720 6f74 6865 7220 696e 2073  rming other in s
+00003ea0: 656c 660a 2020 2020 6465 6620 5f5f 636f  elf.    def __co
+00003eb0: 6e74 6169 6e73 5f5f 2873 656c 662c 206f  ntains__(self, o
+00003ec0: 7468 6572 293a 0a20 2020 2020 2020 2063  ther):.        c
+00003ed0: 6f6e 7461 696e 7320 3d20 7365 6c66 2e63  ontains = self.c
+00003ee0: 6f6e 7461 696e 735f 7769 7468 5f73 7562  ontains_with_sub
+00003ef0: 7365 7428 6f74 6865 7229 0a20 2020 2020  set(other).     
+00003f00: 2020 2069 6620 636f 6e74 6169 6e73 2069     if contains i
+00003f10: 7320 6e6f 7420 4e6f 6e65 3a0a 2020 2020  s not None:.    
+00003f20: 2020 2020 2020 2020 7265 7475 726e 2063          return c
+00003f30: 6f6e 7461 696e 730a 2020 2020 2020 2020  ontains.        
+00003f40: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
+00003f50: 7379 6d70 6966 7928 7365 6c66 2e63 6f6e  sympify(self.con
+00003f60: 7461 696e 7328 6f74 6865 7229 290a 0a20  tains(other)).. 
+00003f70: 2020 2064 6566 2063 6f6e 6a75 6761 7465     def conjugate
+00003f80: 2873 656c 6629 3a0a 2020 2020 2020 2020  (self):.        
+00003f90: 6672 6f6d 2073 796d 7079 2e66 756e 6374  from sympy.funct
+00003fa0: 696f 6e73 2e65 6c65 6d65 6e74 6172 792e  ions.elementary.
+00003fb0: 636f 6d70 6c65 7865 7320 696d 706f 7274  complexes import
+00003fc0: 2063 6f6e 6a75 6761 7465 0a20 2020 2020   conjugate.     
+00003fd0: 2020 2072 6574 7572 6e20 636f 6e6a 7567     return conjug
+00003fe0: 6174 6528 7365 6c66 290a 0a20 2020 2064  ate(self)..    d
+00003ff0: 6566 205f 6576 616c 5f63 6f6e 6a75 6761  ef _eval_conjuga
+00004000: 7465 2873 656c 6629 3a0a 2020 2020 2020  te(self):.      
+00004010: 2020 7265 7475 726e 0a0a 0a63 6c61 7373    return...class
+00004020: 2050 726f 6475 6374 5365 7428 5365 7429   ProductSet(Set)
+00004030: 3a0a 2020 2020 2222 220a 2020 2020 5265  :.    """.    Re
+00004040: 7072 6573 656e 7473 2061 2043 6172 7465  presents a Carte
+00004050: 7369 616e 2050 726f 6475 6374 206f 6620  sian Product of 
+00004060: 5365 7473 2e0a 0a20 2020 2052 6574 7572  Sets...    Retur
+00004070: 6e73 2061 2043 6172 7465 7369 616e 2070  ns a Cartesian p
+00004080: 726f 6475 6374 2067 6976 656e 2073 6576  roduct given sev
+00004090: 6572 616c 2073 6574 7320 6173 2065 6974  eral sets as eit
+000040a0: 6865 7220 616e 2069 7465 7261 626c 650a  her an iterable.
+000040b0: 2020 2020 6f72 2069 6e64 6976 6964 7561      or individua
+000040c0: 6c20 6172 6775 6d65 6e74 732e 0a0a 2020  l arguments...  
+000040d0: 2020 4361 6e20 7573 6520 272a 2720 6f70    Can use '*' op
+000040e0: 6572 6174 6f72 206f 6e20 616e 7920 7365  erator on any se
+000040f0: 7473 2066 6f72 2063 6f6e 7665 6e69 656e  ts for convenien
+00004100: 7420 7368 6f72 7468 616e 642e 0a0a 2020  t shorthand...  
+00004110: 2020 4578 616d 706c 6573 0a20 2020 203d    Examples.    =
+00004120: 3d3d 3d3d 3d3d 3d0a 0a20 2020 203e 3e3e  =======..    >>>
+00004130: 2066 726f 6d20 7379 6d70 7920 696d 706f   from sympy impo
+00004140: 7274 2049 6e74 6572 7661 6c2c 2046 696e  rt Interval, Fin
+00004150: 6974 6553 6574 2c20 5072 6f64 7563 7453  iteSet, ProductS
+00004160: 6574 0a20 2020 203e 3e3e 2049 203d 2049  et.    >>> I = I
+00004170: 6e74 6572 7661 6c28 302c 2035 293b 2053  nterval(0, 5); S
+00004180: 203d 2046 696e 6974 6553 6574 2831 2c20   = FiniteSet(1, 
+00004190: 322c 2033 290a 2020 2020 3e3e 3e20 5072  2, 3).    >>> Pr
+000041a0: 6f64 7563 7453 6574 2849 2c20 5329 0a20  oductSet(I, S). 
+000041b0: 2020 2049 6e74 6572 7661 6c28 302c 2035     Interval(0, 5
+000041c0: 2920 7820 7b31 2c20 322c 2033 7d0a 0a20  ) x {1, 2, 3}.. 
+000041d0: 2020 203e 3e3e 2028 322c 2032 2920 696e     >>> (2, 2) in
+000041e0: 2050 726f 6475 6374 5365 7428 492c 2053   ProductSet(I, S
+000041f0: 290a 2020 2020 5472 7565 0a0a 2020 2020  ).    True..    
+00004200: 3e3e 3e20 496e 7465 7276 616c 2830 2c20  >>> Interval(0, 
+00004210: 3129 202a 2049 6e74 6572 7661 6c28 302c  1) * Interval(0,
+00004220: 2031 2920 2320 5468 6520 756e 6974 2073   1) # The unit s
+00004230: 7175 6172 650a 2020 2020 496e 7465 7276  quare.    Interv
+00004240: 616c 2830 2c20 3129 2078 2049 6e74 6572  al(0, 1) x Inter
+00004250: 7661 6c28 302c 2031 290a 0a20 2020 203e  val(0, 1)..    >
+00004260: 3e3e 2063 6f69 6e20 3d20 4669 6e69 7465  >> coin = Finite
+00004270: 5365 7428 2748 272c 2027 5427 290a 2020  Set('H', 'T').  
+00004280: 2020 3e3e 3e20 7365 7428 636f 696e 2a2a    >>> set(coin**
+00004290: 3229 0a20 2020 207b 2848 2c20 4829 2c20  2).    {(H, H), 
+000042a0: 2848 2c20 5429 2c20 2854 2c20 4829 2c20  (H, T), (T, H), 
+000042b0: 2854 2c20 5429 7d0a 0a0a 2020 2020 4e6f  (T, T)}...    No
+000042c0: 7465 730a 2020 2020 3d3d 3d3d 3d0a 0a20  tes.    =====.. 
+000042d0: 2020 202d 2050 6173 7365 7320 6d6f 7374     - Passes most
+000042e0: 206f 7065 7261 7469 6f6e 7320 646f 776e   operations down
+000042f0: 2074 6f20 7468 6520 6172 6775 6d65 6e74   to the argument
+00004300: 2073 6574 730a 2020 2020 2d20 466c 6174   sets.    - Flat
+00004310: 7465 6e73 2050 726f 6475 6374 7320 6f66  tens Products of
+00004320: 2050 726f 6475 6374 5365 7473 0a0a 2020   ProductSets..  
+00004330: 2020 5265 6665 7265 6e63 6573 0a20 2020    References.   
+00004340: 203d 3d3d 3d3d 3d3d 3d3d 3d0a 0a20 2020   ==========..   
+00004350: 202e 2e20 5b31 5d20 6874 7470 733a 2f2f   .. [1] https://
+00004360: 656e 2e77 696b 6970 6564 6961 2e6f 7267  en.wikipedia.org
+00004370: 2f77 696b 692f 4361 7274 6573 6961 6e5f  /wiki/Cartesian_
+00004380: 7072 6f64 7563 740a 2020 2020 2222 220a  product.    """.
+00004390: 2020 2020 6973 5f50 726f 6475 6374 5365      is_ProductSe
+000043a0: 7420 3d20 5472 7565 0a0a 2020 2020 6465  t = True..    de
+000043b0: 6620 696e 7465 7273 6563 7469 6f6e 5f73  f intersection_s
+000043c0: 6574 7328 7365 6c66 2c20 6229 3a0a 2020  ets(self, b):.  
+000043d0: 2020 2020 2020 6966 206e 6f74 2062 2e69        if not b.i
+000043e0: 735f 5072 6f64 7563 7453 6574 3a0a 2020  s_ProductSet:.  
+000043f0: 2020 2020 2020 2020 2020 7265 7475 726e            return
+00004400: 204e 6f6e 650a 0a20 2020 2020 2020 2069   None..        i
+00004410: 6620 6c65 6e28 622e 6172 6773 2920 213d  f len(b.args) !=
+00004420: 206c 656e 2873 656c 662e 6172 6773 293a   len(self.args):
+00004430: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
+00004440: 7572 6e20 456d 7074 7953 6574 2829 0a20  urn EmptySet(). 
+00004450: 2020 2020 2020 2072 6574 7572 6e20 5072         return Pr
+00004460: 6f64 7563 7453 6574 2869 2e69 6e74 6572  oductSet(i.inter
+00004470: 7365 6374 286a 290a 2020 2020 2020 2020  sect(j).        
+00004480: 2020 2020 2020 2020 666f 7220 692c 206a          for i, j
+00004490: 2069 6e20 7a69 7028 7365 6c66 2e73 6574   in zip(self.set
+000044a0: 732c 2062 2e73 6574 7329 290a 0a20 2020  s, b.sets))..   
+000044b0: 2064 6566 2075 6e69 6f6e 5f73 6574 7328   def union_sets(
+000044c0: 7365 6c66 2c20 6229 3a0a 2020 2020 2020  self, b):.      
+000044d0: 2020 6966 2062 2e69 735f 5072 6f64 7563    if b.is_Produc
+000044e0: 7453 6574 3a0a 2020 2020 2020 2020 2020  tSet:.          
+000044f0: 2020 6966 2062 2e69 735f 7375 6273 6574    if b.is_subset
+00004500: 2873 656c 6629 3a0a 2020 2020 2020 2020  (self):.        
+00004510: 2020 2020 2020 2020 7265 7475 726e 2073          return s
+00004520: 656c 660a 2020 2020 2020 2020 2020 2020  elf.            
+00004530: 6966 206c 656e 2862 2e61 7267 7329 2021  if len(b.args) !
+00004540: 3d20 6c65 6e28 7365 6c66 2e61 7267 7329  = len(self.args)
+00004550: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+00004560: 2020 7265 7475 726e 204e 6f6e 650a 2020    return None.  
+00004570: 2020 2020 2020 2020 2020 6966 2073 656c            if sel
+00004580: 662e 6172 6773 5b30 5d20 3d3d 2062 2e61  f.args[0] == b.a
+00004590: 7267 735b 305d 3a0a 2020 2020 2020 2020  rgs[0]:.        
+000045a0: 2020 2020 2020 2020 7265 7475 726e 2073          return s
+000045b0: 656c 662e 6172 6773 5b30 5d20 2a20 556e  elf.args[0] * Un
+000045c0: 696f 6e28 5072 6f64 7563 7453 6574 2873  ion(ProductSet(s
+000045d0: 656c 662e 6172 6773 5b31 3a5d 292c 0a20  elf.args[1:]),. 
+000045e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000045f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004600: 2020 2020 2020 2020 2020 2050 726f 6475             Produ
+00004610: 6374 5365 7428 622e 6172 6773 5b31 3a5d  ctSet(b.args[1:]
+00004620: 2929 0a20 2020 2020 2020 2020 2020 2069  )).            i
+00004630: 6620 7365 6c66 2e61 7267 735b 2d31 5d20  f self.args[-1] 
+00004640: 3d3d 2062 2e61 7267 735b 2d31 5d3a 0a20  == b.args[-1]:. 
+00004650: 2020 2020 2020 2020 2020 2020 2020 2072                 r
+00004660: 6574 7572 6e20 556e 696f 6e28 5072 6f64  eturn Union(Prod
+00004670: 7563 7453 6574 2873 656c 662e 6172 6773  uctSet(self.args
+00004680: 5b3a 2d31 5d29 2c0a 2020 2020 2020 2020  [:-1]),.        
 00004690: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000046a0: 2020 2050 726f 6475 6374 5365 7428 622e     ProductSet(b.
-000046b0: 6172 6773 5b31 3a5d 2929 0a20 2020 2020  args[1:])).     
-000046c0: 2020 2020 2020 2069 6620 7365 6c66 2e61         if self.a
-000046d0: 7267 735b 2d31 5d20 3d3d 2062 2e61 7267  rgs[-1] == b.arg
-000046e0: 735b 2d31 5d3a 0a20 2020 2020 2020 2020  s[-1]:.         
-000046f0: 2020 2020 2020 2072 6574 7572 6e20 556e         return Un
-00004700: 696f 6e28 5072 6f64 7563 7453 6574 2873  ion(ProductSet(s
-00004710: 656c 662e 6172 6773 5b3a 2d31 5d29 2c0a  elf.args[:-1]),.
-00004720: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004730: 2020 2020 2020 2020 2020 2020 2050 726f               Pro
-00004740: 6475 6374 5365 7428 622e 6172 6773 5b3a  ductSet(b.args[:
-00004750: 2d31 5d29 2920 2a20 7365 6c66 2e61 7267  -1])) * self.arg
-00004760: 735b 2d31 5d0a 2020 2020 2020 2020 2020  s[-1].          
-00004770: 2020 7265 7475 726e 204e 6f6e 650a 2020    return None.  
-00004780: 2020 2020 2020 6966 2062 2e69 735f 7375        if b.is_su
-00004790: 6273 6574 2873 656c 6629 3a0a 2020 2020  bset(self):.    
-000047a0: 2020 2020 2020 2020 7265 7475 726e 2073          return s
-000047b0: 656c 660a 2020 2020 2020 2020 7265 7475  elf.        retu
-000047c0: 726e 204e 6f6e 650a 0a20 2020 2064 6566  rn None..    def
-000047d0: 205f 5f6e 6577 5f5f 2863 6c73 2c20 2a73   __new__(cls, *s
-000047e0: 6574 732c 202a 2a61 7373 756d 7074 696f  ets, **assumptio
-000047f0: 6e73 293a 0a0a 2020 2020 2020 2020 6465  ns):..        de
-00004800: 6620 666c 6174 7465 6e28 6172 6729 3a0a  f flatten(arg):.
-00004810: 2020 2020 2020 2020 2020 2020 6966 2069              if i
-00004820: 7369 6e73 7461 6e63 6528 6172 672c 2053  sinstance(arg, S
-00004830: 6574 293a 0a20 2020 2020 2020 2020 2020  et):.           
-00004840: 2020 2020 2069 6620 6172 672e 6973 5f50       if arg.is_P
-00004850: 726f 6475 6374 5365 743a 0a20 2020 2020  roductSet:.     
-00004860: 2020 2020 2020 2020 2020 2020 2020 2072                 r
-00004870: 6574 7572 6e20 7375 6d28 6d61 7028 666c  eturn sum(map(fl
-00004880: 6174 7465 6e2c 2061 7267 2e61 7267 7329  atten, arg.args)
-00004890: 2c20 5b5d 290a 2020 2020 2020 2020 2020  , []).          
-000048a0: 2020 2020 2020 656c 7365 3a0a 2020 2020        else:.    
-000048b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000048c0: 7265 7475 726e 205b 6172 675d 0a20 2020  return [arg].   
-000048d0: 2020 2020 2020 2020 2065 6c69 6620 6974           elif it
-000048e0: 6572 6162 6c65 2861 7267 293a 0a20 2020  erable(arg):.   
-000048f0: 2020 2020 2020 2020 2020 2020 2072 6574               ret
-00004900: 7572 6e20 7375 6d28 6d61 7028 666c 6174  urn sum(map(flat
-00004910: 7465 6e2c 2061 7267 292c 205b 5d29 0a0a  ten, arg), [])..
-00004920: 2020 2020 2020 2020 2020 2020 6966 2061              if a
-00004930: 7267 2e69 735f 7365 743a 0a20 2020 2020  rg.is_set:.     
-00004940: 2020 2020 2020 2020 2020 2072 6574 7572             retur
-00004950: 6e20 5b61 7267 5d0a 0a20 2020 2020 2020  n [arg]..       
-00004960: 2020 2020 2072 6169 7365 2054 7970 6545       raise TypeE
-00004970: 7272 6f72 2822 496e 7075 7420 6d75 7374  rror("Input must
-00004980: 2062 6520 5365 7473 206f 7220 6974 6572   be Sets or iter
-00004990: 6162 6c65 7320 6f66 2053 6574 7322 290a  ables of Sets").
-000049a0: 0a20 2020 2020 2020 2073 6574 7320 3d20  .        sets = 
-000049b0: 666c 6174 7465 6e28 6c69 7374 2873 6574  flatten(list(set
-000049c0: 7329 290a 0a20 2020 2020 2020 2069 6620  s))..        if 
-000049d0: 456d 7074 7953 6574 2829 2069 6e20 7365  EmptySet() in se
-000049e0: 7473 206f 7220 6c65 6e28 7365 7473 2920  ts or len(sets) 
-000049f0: 3d3d 2030 3a0a 2020 2020 2020 2020 2020  == 0:.          
-00004a00: 2020 7265 7475 726e 2045 6d70 7479 5365    return EmptySe
-00004a10: 7428 290a 0a20 2020 2020 2020 2069 6620  t()..        if 
-00004a20: 6c65 6e28 7365 7473 2920 3d3d 2031 3a0a  len(sets) == 1:.
+000046a0: 2020 2020 2050 726f 6475 6374 5365 7428       ProductSet(
+000046b0: 622e 6172 6773 5b3a 2d31 5d29 2920 2a20  b.args[:-1])) * 
+000046c0: 7365 6c66 2e61 7267 735b 2d31 5d0a 2020  self.args[-1].  
+000046d0: 2020 2020 2020 2020 2020 7265 7475 726e            return
+000046e0: 204e 6f6e 650a 2020 2020 2020 2020 6966   None.        if
+000046f0: 2062 2e69 735f 7375 6273 6574 2873 656c   b.is_subset(sel
+00004700: 6629 3a0a 2020 2020 2020 2020 2020 2020  f):.            
+00004710: 7265 7475 726e 2073 656c 660a 2020 2020  return self.    
+00004720: 2020 2020 7265 7475 726e 204e 6f6e 650a      return None.
+00004730: 0a20 2020 2064 6566 205f 5f6e 6577 5f5f  .    def __new__
+00004740: 2863 6c73 2c20 2a73 6574 732c 202a 2a61  (cls, *sets, **a
+00004750: 7373 756d 7074 696f 6e73 293a 0a0a 2020  ssumptions):..  
+00004760: 2020 2020 2020 6465 6620 666c 6174 7465        def flatte
+00004770: 6e28 6172 6729 3a0a 2020 2020 2020 2020  n(arg):.        
+00004780: 2020 2020 6966 2069 7369 6e73 7461 6e63      if isinstanc
+00004790: 6528 6172 672c 2053 6574 293a 0a20 2020  e(arg, Set):.   
+000047a0: 2020 2020 2020 2020 2020 2020 2069 6620               if 
+000047b0: 6172 672e 6973 5f50 726f 6475 6374 5365  arg.is_ProductSe
+000047c0: 743a 0a20 2020 2020 2020 2020 2020 2020  t:.             
+000047d0: 2020 2020 2020 2072 6574 7572 6e20 7375         return su
+000047e0: 6d28 6d61 7028 666c 6174 7465 6e2c 2061  m(map(flatten, a
+000047f0: 7267 2e61 7267 7329 2c20 5b5d 290a 2020  rg.args), []).  
+00004800: 2020 2020 2020 2020 2020 2020 2020 656c                el
+00004810: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
+00004820: 2020 2020 2020 2020 7265 7475 726e 205b          return [
+00004830: 6172 675d 0a20 2020 2020 2020 2020 2020  arg].           
+00004840: 2065 6c69 6620 6974 6572 6162 6c65 2861   elif iterable(a
+00004850: 7267 293a 0a20 2020 2020 2020 2020 2020  rg):.           
+00004860: 2020 2020 2072 6574 7572 6e20 7375 6d28       return sum(
+00004870: 6d61 7028 666c 6174 7465 6e2c 2061 7267  map(flatten, arg
+00004880: 292c 205b 5d29 0a0a 2020 2020 2020 2020  ), [])..        
+00004890: 2020 2020 6966 2061 7267 2e69 735f 7365      if arg.is_se
+000048a0: 743a 0a20 2020 2020 2020 2020 2020 2020  t:.             
+000048b0: 2020 2072 6574 7572 6e20 5b61 7267 5d0a     return [arg].
+000048c0: 0a20 2020 2020 2020 2020 2020 2072 6169  .            rai
+000048d0: 7365 2054 7970 6545 7272 6f72 2822 496e  se TypeError("In
+000048e0: 7075 7420 6d75 7374 2062 6520 5365 7473  put must be Sets
+000048f0: 206f 7220 6974 6572 6162 6c65 7320 6f66   or iterables of
+00004900: 2053 6574 7322 290a 0a20 2020 2020 2020   Sets")..       
+00004910: 2073 6574 7320 3d20 666c 6174 7465 6e28   sets = flatten(
+00004920: 6c69 7374 2873 6574 7329 290a 0a20 2020  list(sets))..   
+00004930: 2020 2020 2069 6620 456d 7074 7953 6574       if EmptySet
+00004940: 2829 2069 6e20 7365 7473 206f 7220 6c65  () in sets or le
+00004950: 6e28 7365 7473 2920 3d3d 2030 3a0a 2020  n(sets) == 0:.  
+00004960: 2020 2020 2020 2020 2020 7265 7475 726e            return
+00004970: 2045 6d70 7479 5365 7428 290a 0a20 2020   EmptySet()..   
+00004980: 2020 2020 2069 6620 6c65 6e28 7365 7473       if len(sets
+00004990: 2920 3d3d 2031 3a0a 2020 2020 2020 2020  ) == 1:.        
+000049a0: 2020 2020 7265 7475 726e 2073 6574 735b      return sets[
+000049b0: 305d 0a0a 2020 2020 2020 2020 7265 7475  0]..        retu
+000049c0: 726e 2042 6173 6963 2e5f 5f6e 6577 5f5f  rn Basic.__new__
+000049d0: 2863 6c73 2c20 2a73 6574 732c 202a 2a61  (cls, *sets, **a
+000049e0: 7373 756d 7074 696f 6e73 290a 0a20 2020  ssumptions)..   
+000049f0: 2064 6566 205f 6576 616c 5f45 7128 7365   def _eval_Eq(se
+00004a00: 6c66 2c20 6f74 6865 7229 3a0a 2020 2020  lf, other):.    
+00004a10: 2020 2020 6966 206e 6f74 206f 7468 6572      if not other
+00004a20: 2e69 735f 5072 6f64 7563 7453 6574 3a0a  .is_ProductSet:.
 00004a30: 2020 2020 2020 2020 2020 2020 7265 7475              retu
-00004a40: 726e 2073 6574 735b 305d 0a0a 2020 2020  rn sets[0]..    
-00004a50: 2020 2020 7265 7475 726e 2042 6173 6963      return Basic
-00004a60: 2e5f 5f6e 6577 5f5f 2863 6c73 2c20 2a73  .__new__(cls, *s
-00004a70: 6574 732c 202a 2a61 7373 756d 7074 696f  ets, **assumptio
-00004a80: 6e73 290a 0a20 2020 2064 6566 205f 6576  ns)..    def _ev
-00004a90: 616c 5f45 7128 7365 6c66 2c20 6f74 6865  al_Eq(self, othe
-00004aa0: 7229 3a0a 2020 2020 2020 2020 6966 206e  r):.        if n
-00004ab0: 6f74 206f 7468 6572 2e69 735f 5072 6f64  ot other.is_Prod
-00004ac0: 7563 7453 6574 3a0a 2020 2020 2020 2020  uctSet:.        
-00004ad0: 2020 2020 7265 7475 726e 0a0a 2020 2020      return..    
-00004ae0: 2020 2020 6966 206c 656e 2873 656c 662e      if len(self.
-00004af0: 6172 6773 2920 213d 206c 656e 286f 7468  args) != len(oth
-00004b00: 6572 2e61 7267 7329 3a0a 2020 2020 2020  er.args):.      
-00004b10: 2020 2020 2020 7265 7475 726e 2053 2e66        return S.f
-00004b20: 616c 7365 0a0a 2020 2020 2020 2020 7265  alse..        re
-00004b30: 7475 726e 2041 6e64 282a 2845 7128 782c  turn And(*(Eq(x,
-00004b40: 2079 2920 666f 7220 782c 2079 2069 6e20   y) for x, y in 
-00004b50: 7a69 7028 7365 6c66 2e61 7267 732c 206f  zip(self.args, o
-00004b60: 7468 6572 2e61 7267 7329 2929 0a0a 2020  ther.args)))..  
-00004b70: 2020 6465 6620 5f63 6f6e 7461 696e 7328    def _contains(
-00004b80: 7365 6c66 2c20 656c 656d 656e 7429 3a0a  self, element):.
-00004b90: 2020 2020 2020 2020 2222 220a 2020 2020          """.    
-00004ba0: 2020 2020 2769 6e27 206f 7065 7261 746f      'in' operato
-00004bb0: 7220 666f 7220 5072 6f64 7563 7453 6574  r for ProductSet
-00004bc0: 730a 0a20 2020 2020 2020 2045 7861 6d70  s..        Examp
-00004bd0: 6c65 730a 2020 2020 2020 2020 3d3d 3d3d  les.        ====
-00004be0: 3d3d 3d3d 0a0a 2020 2020 2020 2020 3e3e  ====..        >>
-00004bf0: 3e20 6672 6f6d 2073 796d 7079 2069 6d70  > from sympy imp
-00004c00: 6f72 7420 496e 7465 7276 616c 0a20 2020  ort Interval.   
-00004c10: 2020 2020 203e 3e3e 2028 322c 2033 2920       >>> (2, 3) 
-00004c20: 696e 2049 6e74 6572 7661 6c28 302c 2035  in Interval(0, 5
-00004c30: 2920 2a20 496e 7465 7276 616c 2830 2c20  ) * Interval(0, 
-00004c40: 3529 0a20 2020 2020 2020 2054 7275 650a  5).        True.
-00004c50: 0a20 2020 2020 2020 203e 3e3e 2028 3130  .        >>> (10
-00004c60: 2c20 3130 2920 696e 2049 6e74 6572 7661  , 10) in Interva
-00004c70: 6c28 302c 2035 2920 2a20 496e 7465 7276  l(0, 5) * Interv
-00004c80: 616c 2830 2c20 3529 0a20 2020 2020 2020  al(0, 5).       
-00004c90: 2046 616c 7365 0a0a 2020 2020 2020 2020   False..        
-00004ca0: 5061 7373 6573 206f 7065 7261 7469 6f6e  Passes operation
-00004cb0: 206f 6e20 746f 2063 6f6e 7374 6974 7565   on to constitue
-00004cc0: 6e74 2073 6574 730a 2020 2020 2020 2020  nt sets.        
-00004cd0: 2222 220a 2020 2020 2020 2020 7472 793a  """.        try:
-00004ce0: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
-00004cf0: 6c65 6e28 656c 656d 656e 7429 2021 3d20  len(element) != 
-00004d00: 6c65 6e28 7365 6c66 2e61 7267 7329 3a0a  len(self.args):.
-00004d10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004d20: 7265 7475 726e 2053 2e66 616c 7365 0a20  return S.false. 
-00004d30: 2020 2020 2020 2065 7863 6570 7420 5479         except Ty
-00004d40: 7065 4572 726f 723a 2020 2320 6d61 7962  peError:  # mayb
-00004d50: 6520 656c 656d 656e 7420 6973 6e27 7420  e element isn't 
-00004d60: 616e 2069 7465 7261 626c 650a 2020 2020  an iterable.    
-00004d70: 2020 2020 2020 2020 7265 7475 726e 2053          return S
-00004d80: 2e66 616c 7365 0a20 2020 2020 2020 2072  .false.        r
-00004d90: 6574 7572 6e20 416e 6428 2a5b 732e 636f  eturn And(*[s.co
-00004da0: 6e74 6169 6e73 2869 7465 6d29 2066 6f72  ntains(item) for
-00004db0: 2073 2c20 6974 656d 2069 6e20 7a69 7028   s, item in zip(
-00004dc0: 7365 6c66 2e73 6574 732c 2065 6c65 6d65  self.sets, eleme
-00004dd0: 6e74 295d 290a 0a20 2020 2040 7072 6f70  nt)])..    @prop
-00004de0: 6572 7479 0a20 2020 2064 6566 2073 6574  erty.    def set
-00004df0: 7328 7365 6c66 293a 0a20 2020 2020 2020  s(self):.       
-00004e00: 2072 6574 7572 6e20 7365 6c66 2e61 7267   return self.arg
-00004e10: 730a 0a20 2020 2040 7072 6f70 6572 7479  s..    @property
-00004e20: 0a20 2020 2064 6566 205f 626f 756e 6461  .    def _bounda
-00004e30: 7279 2873 656c 6629 3a0a 2020 2020 2020  ry(self):.      
-00004e40: 2020 7265 7475 726e 2055 6e69 6f6e 282a    return Union(*
-00004e50: 2850 726f 6475 6374 5365 7428 6220 2b20  (ProductSet(b + 
-00004e60: 622e 626f 756e 6461 7279 2069 6620 6920  b.boundary if i 
-00004e70: 213d 206a 2065 6c73 6520 622e 626f 756e  != j else b.boun
-00004e80: 6461 7279 0a20 2020 2020 2020 2020 2020  dary.           
-00004e90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004ea0: 2020 2020 2066 6f72 206a 2c20 6220 696e       for j, b in
-00004eb0: 2065 6e75 6d65 7261 7465 2873 656c 662e   enumerate(self.
-00004ec0: 7365 7473 2929 0a20 2020 2020 2020 2020  sets)).         
-00004ed0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004ee0: 2020 2020 2020 2066 6f72 2069 2c20 6120         for i, a 
-00004ef0: 696e 2065 6e75 6d65 7261 7465 2873 656c  in enumerate(sel
-00004f00: 662e 7365 7473 2929 290a 0a20 2020 2040  f.sets)))..    @
-00004f10: 7072 6f70 6572 7479 0a20 2020 2064 6566  property.    def
-00004f20: 2069 735f 6974 6572 6162 6c65 2873 656c   is_iterable(sel
-00004f30: 6629 3a0a 2020 2020 2020 2020 2222 220a  f):.        """.
-00004f40: 2020 2020 2020 2020 4120 7072 6f70 6572          A proper
-00004f50: 7479 206d 6574 686f 6420 7768 6963 6820  ty method which 
-00004f60: 7465 7374 7320 7768 6574 6865 7220 6120  tests whether a 
-00004f70: 7365 7420 6973 2069 7465 7261 626c 6520  set is iterable 
-00004f80: 6f72 206e 6f74 2e0a 2020 2020 2020 2020  or not..        
-00004f90: 5265 7475 726e 7320 5472 7565 2069 6620  Returns True if 
-00004fa0: 7365 7420 6973 2069 7465 7261 626c 652c  set is iterable,
-00004fb0: 206f 7468 6572 7769 7365 2072 6574 7572   otherwise retur
-00004fc0: 6e73 2046 616c 7365 2e0a 0a20 2020 2020  ns False...     
-00004fd0: 2020 2045 7861 6d70 6c65 730a 2020 2020     Examples.    
-00004fe0: 2020 2020 3d3d 3d3d 3d3d 3d3d 0a0a 2020      ========..  
-00004ff0: 2020 2020 2020 3e3e 3e20 6672 6f6d 2073        >>> from s
-00005000: 796d 7079 2069 6d70 6f72 7420 4669 6e69  ympy import Fini
-00005010: 7465 5365 742c 2049 6e74 6572 7661 6c2c  teSet, Interval,
-00005020: 2050 726f 6475 6374 5365 740a 2020 2020   ProductSet.    
-00005030: 2020 2020 3e3e 3e20 4920 3d20 496e 7465      >>> I = Inte
-00005040: 7276 616c 2830 2c20 3129 0a20 2020 2020  rval(0, 1).     
-00005050: 2020 203e 3e3e 2041 203d 2046 696e 6974     >>> A = Finit
-00005060: 6553 6574 2831 2c20 322c 2033 2c20 342c  eSet(1, 2, 3, 4,
-00005070: 2035 290a 2020 2020 2020 2020 3e3e 3e20   5).        >>> 
-00005080: 492e 6973 5f69 7465 7261 626c 650a 2020  I.is_iterable.  
-00005090: 2020 2020 2020 4661 6c73 650a 2020 2020        False.    
-000050a0: 2020 2020 3e3e 3e20 412e 6973 5f69 7465      >>> A.is_ite
-000050b0: 7261 626c 650a 2020 2020 2020 2020 5472  rable.        Tr
-000050c0: 7565 0a0a 2020 2020 2020 2020 2222 220a  ue..        """.
-000050d0: 2020 2020 2020 2020 7265 7475 726e 2061          return a
-000050e0: 6c6c 2873 2e69 735f 6974 6572 6162 6c65  ll(s.is_iterable
-000050f0: 2066 6f72 2073 2069 6e20 7365 6c66 2e73   for s in self.s
-00005100: 6574 7329 0a0a 2020 2020 6465 6620 5f5f  ets)..    def __
-00005110: 6974 6572 5f5f 2873 656c 6629 3a0a 2020  iter__(self):.  
-00005120: 2020 2020 2020 2222 220a 2020 2020 2020        """.      
-00005130: 2020 4120 6d65 7468 6f64 2077 6869 6368    A method which
-00005140: 2069 6d70 6c65 6d65 6e74 7320 6973 5f69   implements is_i
-00005150: 7465 7261 626c 6520 7072 6f70 6572 7479  terable property
-00005160: 206d 6574 686f 642e 0a20 2020 2020 2020   method..       
-00005170: 2049 6620 7365 6c66 2e69 735f 6974 6572   If self.is_iter
-00005180: 6162 6c65 2072 6574 7572 6e73 2054 7275  able returns Tru
-00005190: 6520 2862 6f74 6820 636f 6e73 7469 7475  e (both constitu
-000051a0: 656e 7420 7365 7473 2061 7265 2069 7465  ent sets are ite
-000051b0: 7261 626c 6529 2c0a 2020 2020 2020 2020  rable),.        
-000051c0: 7468 656e 2072 6574 7572 6e20 7468 6520  then return the 
-000051d0: 4361 7274 6573 6961 6e20 5072 6f64 7563  Cartesian Produc
-000051e0: 742e 204f 7468 6572 7769 7365 2c20 7261  t. Otherwise, ra
-000051f0: 6973 6520 5479 7065 4572 726f 722e 0a20  ise TypeError.. 
-00005200: 2020 2020 2020 2022 2222 0a20 2020 2020         """.     
-00005210: 2020 2069 6620 7365 6c66 2e69 735f 6974     if self.is_it
-00005220: 6572 6162 6c65 3a0a 2020 2020 2020 2020  erable:.        
-00005230: 2020 2020 7265 7475 726e 2070 726f 6475      return produ
-00005240: 6374 282a 7365 6c66 2e73 6574 7329 0a20  ct(*self.sets). 
-00005250: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
-00005260: 2020 2020 2020 2020 2072 6169 7365 2054           raise T
-00005270: 7970 6545 7272 6f72 2822 4e6f 7420 616c  ypeError("Not al
-00005280: 6c20 636f 6e73 7469 7475 656e 7420 7365  l constituent se
-00005290: 7473 2061 7265 2069 7465 7261 626c 6522  ts are iterable"
-000052a0: 290a 0a20 2020 2040 7072 6f70 6572 7479  )..    @property
-000052b0: 0a20 2020 2064 6566 205f 6d65 6173 7572  .    def _measur
-000052c0: 6528 7365 6c66 293a 0a20 2020 2020 2020  e(self):.       
-000052d0: 206d 6561 7375 7265 203d 2031 0a20 2020   measure = 1.   
-000052e0: 2020 2020 2066 6f72 2073 2069 6e20 7365       for s in se
-000052f0: 6c66 2e73 6574 733a 0a20 2020 2020 2020  lf.sets:.       
-00005300: 2020 2020 206d 6561 7375 7265 202a 3d20       measure *= 
-00005310: 732e 6d65 6173 7572 650a 2020 2020 2020  s.measure.      
-00005320: 2020 7265 7475 726e 206d 6561 7375 7265    return measure
-00005330: 0a0a 2020 2020 6465 6620 5f5f 6c65 6e5f  ..    def __len_
-00005340: 5f28 7365 6c66 293a 0a20 2020 2020 2020  _(self):.       
-00005350: 2072 6574 7572 6e20 4d75 6c28 2a5b 6c65   return Mul(*[le
-00005360: 6e28 7329 2066 6f72 2073 2069 6e20 7365  n(s) for s in se
-00005370: 6c66 2e61 7267 735d 290a 0a20 2020 2064  lf.args])..    d
-00005380: 6566 205f 5f62 6f6f 6c5f 5f28 7365 6c66  ef __bool__(self
-00005390: 293a 0a20 2020 2020 2020 2072 6574 7572  ):.        retur
-000053a0: 6e20 616c 6c28 5b62 6f6f 6c28 7329 2066  n all([bool(s) f
-000053b0: 6f72 2073 2069 6e20 7365 6c66 2e61 7267  or s in self.arg
-000053c0: 735d 290a 0a20 2020 205f 5f6e 6f6e 7a65  s])..    __nonze
-000053d0: 726f 5f5f 203d 205f 5f62 6f6f 6c5f 5f0a  ro__ = __bool__.
-000053e0: 0a20 2020 2064 6566 205f 5f6e 6567 5f5f  .    def __neg__
-000053f0: 2873 656c 6629 3a0a 2020 2020 2020 2020  (self):.        
-00005400: 7265 7475 726e 2073 656c 662e 6675 6e63  return self.func
-00005410: 282a 282d 6172 6720 666f 7220 6172 6720  (*(-arg for arg 
-00005420: 696e 2073 656c 662e 6172 6773 2929 0a0a  in self.args))..
-00005430: 0a63 6c61 7373 2043 6172 7465 7369 616e  .class Cartesian
-00005440: 5370 6163 6528 5365 7429 3a0a 0a20 2020  Space(Set):..   
-00005450: 2064 6566 205f 5f6e 6577 5f5f 2863 6c73   def __new__(cls
-00005460: 2c20 646f 6d61 696e 2c20 2a64 696d 656e  , domain, *dimen
-00005470: 7369 6f6e 293a 0a20 2020 2020 2020 2069  sion):.        i
-00005480: 6620 6e6f 7420 6469 6d65 6e73 696f 6e3a  f not dimension:
-00005490: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
-000054a0: 7572 6e20 646f 6d61 696e 0a20 2020 2020  urn domain.     
-000054b0: 2020 2069 6620 6c65 6e28 6469 6d65 6e73     if len(dimens
-000054c0: 696f 6e29 203d 3d20 313a 0a20 2020 2020  ion) == 1:.     
-000054d0: 2020 2020 2020 2064 203d 2064 696d 656e         d = dimen
-000054e0: 7369 6f6e 5b30 5d0a 2020 2020 2020 2020  sion[0].        
-000054f0: 2020 2020 6173 7365 7274 2064 2c20 2264      assert d, "d
-00005500: 696d 656e 7369 6f6e 206d 7573 7420 6265  imension must be
-00005510: 206e 6f6e 7a65 726f 220a 2020 2020 2020   nonzero".      
-00005520: 2020 2020 2020 6966 2064 696d 656e 7369        if dimensi
-00005530: 6f6e 5b30 5d20 3d3d 2031 3a0a 2020 2020  on[0] == 1:.    
-00005540: 2020 2020 2020 2020 2020 2020 7265 7475              retu
-00005550: 726e 2064 6f6d 6169 6e0a 2020 2020 2020  rn domain.      
-00005560: 2020 2020 2020 6966 2069 7369 6e73 7461        if isinsta
-00005570: 6e63 6528 642c 2069 6e74 293a 0a20 2020  nce(d, int):.   
-00005580: 2020 2020 2020 2020 2020 2020 2064 696d               dim
-00005590: 656e 7369 6f6e 203d 2028 7379 6d70 6966  ension = (sympif
-000055a0: 7928 6429 2c29 0a20 2020 2020 2020 2072  y(d),).        r
-000055b0: 6574 7572 6e20 5365 742e 5f5f 6e65 775f  eturn Set.__new_
-000055c0: 5f28 636c 732c 2064 6f6d 6169 6e2c 202a  _(cls, domain, *
-000055d0: 6469 6d65 6e73 696f 6e29 0a0a 2020 2020  dimension)..    
-000055e0: 4063 6163 6865 6974 0a20 2020 2064 6566  @cacheit.    def
-000055f0: 205f 6576 616c 5f64 6f6d 6169 6e5f 6465   _eval_domain_de
-00005600: 6669 6e65 6428 7365 6c66 2c20 782c 202a  fined(self, x, *
-00005610: 2a5f 293a 200a 2020 2020 2020 2020 7265  *_): .        re
-00005620: 7475 726e 2073 656c 662e 7370 6163 652e  turn self.space.
-00005630: 646f 6d61 696e 5f64 6566 696e 6564 2878  domain_defined(x
-00005640: 2920 2620 496e 7465 7273 6563 7469 6f6e  ) & Intersection
-00005650: 282a 2878 2e64 6f6d 6169 6e5f 636f 6e64  (*(x.domain_cond
-00005660: 6974 696f 6e65 6428 6420 3e20 3029 2066  itioned(d > 0) f
-00005670: 6f72 2064 2069 6e20 7365 6c66 2e73 7061  or d in self.spa
-00005680: 6365 5f73 6861 7065 2929 0a0a 2020 2020  ce_shape))..    
-00005690: 4070 726f 7065 7274 790a 2020 2020 6465  @property.    de
-000056a0: 6620 646f 6d61 696e 2873 656c 6629 3a0a  f domain(self):.
-000056b0: 2020 2020 2020 2020 7265 7475 726e 2073          return s
-000056c0: 656c 662e 756e 6976 6572 7361 6c53 6574  elf.universalSet
-000056d0: 0a20 2020 200a 2020 2020 4070 726f 7065  .    .    @prope
-000056e0: 7274 790a 2020 2020 6465 6620 7370 6163  rty.    def spac
-000056f0: 6528 7365 6c66 293a 0a20 2020 2020 2020  e(self):.       
-00005700: 2072 6574 7572 6e20 7365 6c66 2e61 7267   return self.arg
-00005710: 735b 305d 0a0a 2020 2020 6465 6620 5f65  s[0]..    def _e
-00005720: 7661 6c5f 7368 6170 6528 7365 6c66 293a  val_shape(self):
-00005730: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
-00005740: 2829 0a20 2020 200a 2020 2020 4070 726f  ().    .    @pro
-00005750: 7065 7274 790a 2020 2020 6465 6620 6574  perty.    def et
-00005760: 7970 6528 7365 6c66 293a 0a20 2020 2020  ype(self):.     
-00005770: 2020 2072 6574 7572 6e20 7365 6c66 2e73     return self.s
-00005780: 7061 6365 2e65 7479 7065 202a 2073 656c  pace.etype * sel
-00005790: 662e 7370 6163 655f 7368 6170 650a 0a20  f.space_shape.. 
-000057a0: 2020 2040 7072 6f70 6572 7479 0a20 2020     @property.   
-000057b0: 2064 6566 2073 7061 6365 5f73 6861 7065   def space_shape
-000057c0: 2873 656c 6629 3a0a 2020 2020 2020 2020  (self):.        
-000057d0: 7265 7475 726e 2073 656c 662e 6172 6773  return self.args
-000057e0: 5b31 3a5d 0a0a 2020 2020 6465 6620 5f65  [1:]..    def _e
-000057f0: 7661 6c5f 6973 5f65 7874 656e 6465 645f  val_is_extended_
-00005800: 696e 7465 6765 7228 7365 6c66 293a 0a20  integer(self):. 
-00005810: 2020 2020 2020 2072 6574 7572 6e20 7365         return se
-00005820: 6c66 2e73 7061 6365 2e69 735f 6578 7465  lf.space.is_exte
-00005830: 6e64 6564 5f69 6e74 6567 6572 0a0a 2020  nded_integer..  
-00005840: 2020 6465 6620 5f63 6f6e 7461 696e 7328    def _contains(
-00005850: 7365 6c66 2c20 6f74 6865 7229 3a0a 2020  self, other):.  
-00005860: 2020 2020 2020 6672 6f6d 2073 796d 7079        from sympy
-00005870: 2069 6d70 6f72 7420 5261 6e67 650a 2020   import Range.  
-00005880: 2020 2020 2020 6173 7365 7274 2074 7570        assert tup
-00005890: 6c65 2873 656c 662e 6574 7970 652e 7368  le(self.etype.sh
-000058a0: 6170 6529 203d 3d20 7475 706c 6528 6f74  ape) == tuple(ot
-000058b0: 6865 722e 7368 6170 6529 2c20 2273 656c  her.shape), "sel
-000058c0: 662e 6574 7970 652e 7368 6170 6520 3d20  f.etype.shape = 
-000058d0: 2573 2c20 6f74 6865 722e 7368 6170 6520  %s, other.shape 
-000058e0: 3d20 2573 2220 2520 2873 656c 662e 6574  = %s" % (self.et
-000058f0: 7970 652e 7368 6170 652c 206f 7468 6572  ype.shape, other
-00005900: 2e73 6861 7065 290a 2020 2020 2020 2020  .shape).        
-00005910: 0a20 2020 2020 2020 2069 6620 7365 6c66  .        if self
-00005920: 2e69 735f 556e 6976 6572 7361 6c53 6574  .is_UniversalSet
-00005930: 3a0a 2020 2020 2020 2020 2020 2020 7265  :.            re
-00005940: 7475 726e 2053 2e74 7275 650a 2020 2020  turn S.true.    
-00005950: 2020 2020 6966 206f 7468 6572 2e69 735f      if other.is_
-00005960: 536c 6963 6564 206f 7220 6f74 6865 722e  Sliced or other.
-00005970: 6973 5f53 796d 626f 6c3a 0a20 2020 2020  is_Symbol:.     
-00005980: 2020 2020 2020 206e 203d 206f 7468 6572         n = other
-00005990: 2e73 6861 7065 5b30 5d0a 2020 2020 2020  .shape[0].      
-000059a0: 2020 2020 2020 6920 3d20 4475 6d6d 7928        i = Dummy(
-000059b0: 2769 272c 2064 6f6d 6169 6e3d 5261 6e67  'i', domain=Rang
-000059c0: 6528 6e29 290a 2020 2020 2020 2020 2020  e(n)).          
-000059d0: 2020 7370 6163 655f 7368 6170 6520 3d20    space_shape = 
-000059e0: 7365 6c66 2e73 7061 6365 5f73 6861 7065  self.space_shape
-000059f0: 5b31 3a5d 0a20 2020 2020 2020 2020 2020  [1:].           
-00005a00: 2069 6620 7370 6163 655f 7368 6170 653a   if space_shape:
-00005a10: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00005a20: 2064 6f6d 6169 6e20 3d20 7365 6c66 2e66   domain = self.f
-00005a30: 756e 6328 7365 6c66 2e73 7061 6365 2c20  unc(self.space, 
-00005a40: 2a73 7061 6365 5f73 6861 7065 290a 2020  *space_shape).  
-00005a50: 2020 2020 2020 2020 2020 656c 7365 3a0a            else:.
-00005a60: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00005a70: 646f 6d61 696e 203d 2073 656c 662e 7370  domain = self.sp
-00005a80: 6163 650a 2020 2020 2020 2020 2020 2020  ace.            
-00005a90: 2020 2020 0a20 2020 2020 2020 2020 2020      .           
-00005aa0: 2063 6f6e 6420 3d20 456c 656d 656e 7428   cond = Element(
-00005ab0: 6f74 6865 725b 695d 2c20 646f 6d61 696e  other[i], domain
-00005ac0: 290a 2020 2020 2020 2020 2020 2020 6966  ).            if
-00005ad0: 2063 6f6e 643a 0a20 2020 2020 2020 2020   cond:.         
-00005ae0: 2020 2020 2020 2072 6574 7572 6e20 636f         return co
-00005af0: 6e64 0a20 2020 2020 2020 2020 2020 2069  nd.            i
-00005b00: 6620 636f 6e64 203d 3d20 4661 6c73 653a  f cond == False:
-00005b10: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00005b20: 2072 6574 7572 6e20 636f 6e64 0a20 2020   return cond.   
-00005b30: 2020 2020 2065 6c69 6620 6f74 6865 722e       elif other.
-00005b40: 6973 5f42 6c6f 636b 4d61 7472 6978 3a0a  is_BlockMatrix:.
-00005b50: 2020 2020 2020 2020 2020 2020 6966 206f              if o
-00005b60: 7468 6572 2e61 7869 7320 3d3d 2030 3a0a  ther.axis == 0:.
-00005b70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00005b80: 7370 6163 655f 7368 6170 6520 3d20 7365  space_shape = se
-00005b90: 6c66 2e73 7061 6365 5f73 6861 7065 5b31  lf.space_shape[1
-00005ba0: 3a5d 0a20 2020 2020 2020 2020 2020 2020  :].             
-00005bb0: 2020 2069 6620 7370 6163 655f 7368 6170     if space_shap
-00005bc0: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
-00005bd0: 2020 2020 2020 2064 6f6d 6169 6e20 3d20         domain = 
-00005be0: 7365 6c66 2e66 756e 6328 7365 6c66 2e73  self.func(self.s
-00005bf0: 7061 6365 2c20 2a73 7061 6365 5f73 6861  pace, *space_sha
-00005c00: 7065 290a 2020 2020 2020 2020 2020 2020  pe).            
-00005c10: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
-00005c20: 2020 2020 2020 2020 2020 2020 2020 646f                do
-00005c30: 6d61 696e 203d 2073 656c 662e 7370 6163  main = self.spac
-00005c40: 650a 2020 2020 2020 2020 2020 2020 2020  e.              
-00005c50: 2020 0a20 2020 2020 2020 2020 2020 2020    .             
-00005c60: 2020 2066 6f72 2062 6c6f 636b 2069 6e20     for block in 
-00005c70: 6f74 6865 722e 6172 6773 3a0a 2020 2020  other.args:.    
+00004a40: 726e 0a0a 2020 2020 2020 2020 6966 206c  rn..        if l
+00004a50: 656e 2873 656c 662e 6172 6773 2920 213d  en(self.args) !=
+00004a60: 206c 656e 286f 7468 6572 2e61 7267 7329   len(other.args)
+00004a70: 3a0a 2020 2020 2020 2020 2020 2020 7265  :.            re
+00004a80: 7475 726e 2053 2e66 616c 7365 0a0a 2020  turn S.false..  
+00004a90: 2020 2020 2020 7265 7475 726e 2041 6e64        return And
+00004aa0: 282a 2845 7128 782c 2079 2920 666f 7220  (*(Eq(x, y) for 
+00004ab0: 782c 2079 2069 6e20 7a69 7028 7365 6c66  x, y in zip(self
+00004ac0: 2e61 7267 732c 206f 7468 6572 2e61 7267  .args, other.arg
+00004ad0: 7329 2929 0a0a 2020 2020 6465 6620 5f63  s)))..    def _c
+00004ae0: 6f6e 7461 696e 7328 7365 6c66 2c20 656c  ontains(self, el
+00004af0: 656d 656e 7429 3a0a 2020 2020 2020 2020  ement):.        
+00004b00: 2222 220a 2020 2020 2020 2020 2769 6e27  """.        'in'
+00004b10: 206f 7065 7261 746f 7220 666f 7220 5072   operator for Pr
+00004b20: 6f64 7563 7453 6574 730a 0a20 2020 2020  oductSets..     
+00004b30: 2020 2045 7861 6d70 6c65 730a 2020 2020     Examples.    
+00004b40: 2020 2020 3d3d 3d3d 3d3d 3d3d 0a0a 2020      ========..  
+00004b50: 2020 2020 2020 3e3e 3e20 6672 6f6d 2073        >>> from s
+00004b60: 796d 7079 2069 6d70 6f72 7420 496e 7465  ympy import Inte
+00004b70: 7276 616c 0a20 2020 2020 2020 203e 3e3e  rval.        >>>
+00004b80: 2028 322c 2033 2920 696e 2049 6e74 6572   (2, 3) in Inter
+00004b90: 7661 6c28 302c 2035 2920 2a20 496e 7465  val(0, 5) * Inte
+00004ba0: 7276 616c 2830 2c20 3529 0a20 2020 2020  rval(0, 5).     
+00004bb0: 2020 2054 7275 650a 0a20 2020 2020 2020     True..       
+00004bc0: 203e 3e3e 2028 3130 2c20 3130 2920 696e   >>> (10, 10) in
+00004bd0: 2049 6e74 6572 7661 6c28 302c 2035 2920   Interval(0, 5) 
+00004be0: 2a20 496e 7465 7276 616c 2830 2c20 3529  * Interval(0, 5)
+00004bf0: 0a20 2020 2020 2020 2046 616c 7365 0a0a  .        False..
+00004c00: 2020 2020 2020 2020 5061 7373 6573 206f          Passes o
+00004c10: 7065 7261 7469 6f6e 206f 6e20 746f 2063  peration on to c
+00004c20: 6f6e 7374 6974 7565 6e74 2073 6574 730a  onstituent sets.
+00004c30: 2020 2020 2020 2020 2222 220a 2020 2020          """.    
+00004c40: 2020 2020 7472 793a 0a20 2020 2020 2020      try:.       
+00004c50: 2020 2020 2069 6620 6c65 6e28 656c 656d       if len(elem
+00004c60: 656e 7429 2021 3d20 6c65 6e28 7365 6c66  ent) != len(self
+00004c70: 2e61 7267 7329 3a0a 2020 2020 2020 2020  .args):.        
+00004c80: 2020 2020 2020 2020 7265 7475 726e 2053          return S
+00004c90: 2e66 616c 7365 0a20 2020 2020 2020 2065  .false.        e
+00004ca0: 7863 6570 7420 5479 7065 4572 726f 723a  xcept TypeError:
+00004cb0: 2020 2320 6d61 7962 6520 656c 656d 656e    # maybe elemen
+00004cc0: 7420 6973 6e27 7420 616e 2069 7465 7261  t isn't an itera
+00004cd0: 626c 650a 2020 2020 2020 2020 2020 2020  ble.            
+00004ce0: 7265 7475 726e 2053 2e66 616c 7365 0a20  return S.false. 
+00004cf0: 2020 2020 2020 2072 6574 7572 6e20 416e         return An
+00004d00: 6428 2a5b 732e 636f 6e74 6169 6e73 2869  d(*[s.contains(i
+00004d10: 7465 6d29 2066 6f72 2073 2c20 6974 656d  tem) for s, item
+00004d20: 2069 6e20 7a69 7028 7365 6c66 2e73 6574   in zip(self.set
+00004d30: 732c 2065 6c65 6d65 6e74 295d 290a 0a20  s, element)]).. 
+00004d40: 2020 2040 7072 6f70 6572 7479 0a20 2020     @property.   
+00004d50: 2064 6566 2073 6574 7328 7365 6c66 293a   def sets(self):
+00004d60: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
+00004d70: 7365 6c66 2e61 7267 730a 0a20 2020 2040  self.args..    @
+00004d80: 7072 6f70 6572 7479 0a20 2020 2064 6566  property.    def
+00004d90: 205f 626f 756e 6461 7279 2873 656c 6629   _boundary(self)
+00004da0: 3a0a 2020 2020 2020 2020 7265 7475 726e  :.        return
+00004db0: 2055 6e69 6f6e 282a 2850 726f 6475 6374   Union(*(Product
+00004dc0: 5365 7428 6220 2b20 622e 626f 756e 6461  Set(b + b.bounda
+00004dd0: 7279 2069 6620 6920 213d 206a 2065 6c73  ry if i != j els
+00004de0: 6520 622e 626f 756e 6461 7279 0a20 2020  e b.boundary.   
+00004df0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004e00: 2020 2020 2020 2020 2020 2020 2066 6f72               for
+00004e10: 206a 2c20 6220 696e 2065 6e75 6d65 7261   j, b in enumera
+00004e20: 7465 2873 656c 662e 7365 7473 2929 0a20  te(self.sets)). 
+00004e30: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004e40: 2020 2020 2020 2020 2020 2020 2020 2066                 f
+00004e50: 6f72 2069 2c20 6120 696e 2065 6e75 6d65  or i, a in enume
+00004e60: 7261 7465 2873 656c 662e 7365 7473 2929  rate(self.sets))
+00004e70: 290a 0a20 2020 2040 7072 6f70 6572 7479  )..    @property
+00004e80: 0a20 2020 2064 6566 2069 735f 6974 6572  .    def is_iter
+00004e90: 6162 6c65 2873 656c 6629 3a0a 2020 2020  able(self):.    
+00004ea0: 2020 2020 2222 220a 2020 2020 2020 2020      """.        
+00004eb0: 4120 7072 6f70 6572 7479 206d 6574 686f  A property metho
+00004ec0: 6420 7768 6963 6820 7465 7374 7320 7768  d which tests wh
+00004ed0: 6574 6865 7220 6120 7365 7420 6973 2069  ether a set is i
+00004ee0: 7465 7261 626c 6520 6f72 206e 6f74 2e0a  terable or not..
+00004ef0: 2020 2020 2020 2020 5265 7475 726e 7320          Returns 
+00004f00: 5472 7565 2069 6620 7365 7420 6973 2069  True if set is i
+00004f10: 7465 7261 626c 652c 206f 7468 6572 7769  terable, otherwi
+00004f20: 7365 2072 6574 7572 6e73 2046 616c 7365  se returns False
+00004f30: 2e0a 0a20 2020 2020 2020 2045 7861 6d70  ...        Examp
+00004f40: 6c65 730a 2020 2020 2020 2020 3d3d 3d3d  les.        ====
+00004f50: 3d3d 3d3d 0a0a 2020 2020 2020 2020 3e3e  ====..        >>
+00004f60: 3e20 6672 6f6d 2073 796d 7079 2069 6d70  > from sympy imp
+00004f70: 6f72 7420 4669 6e69 7465 5365 742c 2049  ort FiniteSet, I
+00004f80: 6e74 6572 7661 6c2c 2050 726f 6475 6374  nterval, Product
+00004f90: 5365 740a 2020 2020 2020 2020 3e3e 3e20  Set.        >>> 
+00004fa0: 4920 3d20 496e 7465 7276 616c 2830 2c20  I = Interval(0, 
+00004fb0: 3129 0a20 2020 2020 2020 203e 3e3e 2041  1).        >>> A
+00004fc0: 203d 2046 696e 6974 6553 6574 2831 2c20   = FiniteSet(1, 
+00004fd0: 322c 2033 2c20 342c 2035 290a 2020 2020  2, 3, 4, 5).    
+00004fe0: 2020 2020 3e3e 3e20 492e 6973 5f69 7465      >>> I.is_ite
+00004ff0: 7261 626c 650a 2020 2020 2020 2020 4661  rable.        Fa
+00005000: 6c73 650a 2020 2020 2020 2020 3e3e 3e20  lse.        >>> 
+00005010: 412e 6973 5f69 7465 7261 626c 650a 2020  A.is_iterable.  
+00005020: 2020 2020 2020 5472 7565 0a0a 2020 2020        True..    
+00005030: 2020 2020 2222 220a 2020 2020 2020 2020      """.        
+00005040: 7265 7475 726e 2061 6c6c 2873 2e69 735f  return all(s.is_
+00005050: 6974 6572 6162 6c65 2066 6f72 2073 2069  iterable for s i
+00005060: 6e20 7365 6c66 2e73 6574 7329 0a0a 2020  n self.sets)..  
+00005070: 2020 6465 6620 5f5f 6974 6572 5f5f 2873    def __iter__(s
+00005080: 656c 6629 3a0a 2020 2020 2020 2020 2222  elf):.        ""
+00005090: 220a 2020 2020 2020 2020 4120 6d65 7468  ".        A meth
+000050a0: 6f64 2077 6869 6368 2069 6d70 6c65 6d65  od which impleme
+000050b0: 6e74 7320 6973 5f69 7465 7261 626c 6520  nts is_iterable 
+000050c0: 7072 6f70 6572 7479 206d 6574 686f 642e  property method.
+000050d0: 0a20 2020 2020 2020 2049 6620 7365 6c66  .        If self
+000050e0: 2e69 735f 6974 6572 6162 6c65 2072 6574  .is_iterable ret
+000050f0: 7572 6e73 2054 7275 6520 2862 6f74 6820  urns True (both 
+00005100: 636f 6e73 7469 7475 656e 7420 7365 7473  constituent sets
+00005110: 2061 7265 2069 7465 7261 626c 6529 2c0a   are iterable),.
+00005120: 2020 2020 2020 2020 7468 656e 2072 6574          then ret
+00005130: 7572 6e20 7468 6520 4361 7274 6573 6961  urn the Cartesia
+00005140: 6e20 5072 6f64 7563 742e 204f 7468 6572  n Product. Other
+00005150: 7769 7365 2c20 7261 6973 6520 5479 7065  wise, raise Type
+00005160: 4572 726f 722e 0a20 2020 2020 2020 2022  Error..        "
+00005170: 2222 0a20 2020 2020 2020 2069 6620 7365  "".        if se
+00005180: 6c66 2e69 735f 6974 6572 6162 6c65 3a0a  lf.is_iterable:.
+00005190: 2020 2020 2020 2020 2020 2020 7265 7475              retu
+000051a0: 726e 2070 726f 6475 6374 282a 7365 6c66  rn product(*self
+000051b0: 2e73 6574 7329 0a20 2020 2020 2020 2065  .sets).        e
+000051c0: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
+000051d0: 2072 6169 7365 2054 7970 6545 7272 6f72   raise TypeError
+000051e0: 2822 4e6f 7420 616c 6c20 636f 6e73 7469  ("Not all consti
+000051f0: 7475 656e 7420 7365 7473 2061 7265 2069  tuent sets are i
+00005200: 7465 7261 626c 6522 290a 0a20 2020 2040  terable")..    @
+00005210: 7072 6f70 6572 7479 0a20 2020 2064 6566  property.    def
+00005220: 205f 6d65 6173 7572 6528 7365 6c66 293a   _measure(self):
+00005230: 0a20 2020 2020 2020 206d 6561 7375 7265  .        measure
+00005240: 203d 2031 0a20 2020 2020 2020 2066 6f72   = 1.        for
+00005250: 2073 2069 6e20 7365 6c66 2e73 6574 733a   s in self.sets:
+00005260: 0a20 2020 2020 2020 2020 2020 206d 6561  .            mea
+00005270: 7375 7265 202a 3d20 732e 6d65 6173 7572  sure *= s.measur
+00005280: 650a 2020 2020 2020 2020 7265 7475 726e  e.        return
+00005290: 206d 6561 7375 7265 0a0a 2020 2020 6465   measure..    de
+000052a0: 6620 5f5f 6c65 6e5f 5f28 7365 6c66 293a  f __len__(self):
+000052b0: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
+000052c0: 4d75 6c28 2a5b 6c65 6e28 7329 2066 6f72  Mul(*[len(s) for
+000052d0: 2073 2069 6e20 7365 6c66 2e61 7267 735d   s in self.args]
+000052e0: 290a 0a20 2020 2064 6566 205f 5f62 6f6f  )..    def __boo
+000052f0: 6c5f 5f28 7365 6c66 293a 0a20 2020 2020  l__(self):.     
+00005300: 2020 2072 6574 7572 6e20 616c 6c28 5b62     return all([b
+00005310: 6f6f 6c28 7329 2066 6f72 2073 2069 6e20  ool(s) for s in 
+00005320: 7365 6c66 2e61 7267 735d 290a 0a20 2020  self.args])..   
+00005330: 205f 5f6e 6f6e 7a65 726f 5f5f 203d 205f   __nonzero__ = _
+00005340: 5f62 6f6f 6c5f 5f0a 0a0a 636c 6173 7320  _bool__...class 
+00005350: 4361 7274 6573 6961 6e53 7061 6365 2853  CartesianSpace(S
+00005360: 6574 293a 0a0a 2020 2020 6465 6620 5f5f  et):..    def __
+00005370: 6e65 775f 5f28 636c 732c 2064 6f6d 6169  new__(cls, domai
+00005380: 6e2c 202a 6469 6d65 6e73 696f 6e29 3a0a  n, *dimension):.
+00005390: 2020 2020 2020 2020 6966 206e 6f74 2064          if not d
+000053a0: 696d 656e 7369 6f6e 3a0a 2020 2020 2020  imension:.      
+000053b0: 2020 2020 2020 7265 7475 726e 2064 6f6d        return dom
+000053c0: 6169 6e0a 2020 2020 2020 2020 6966 206c  ain.        if l
+000053d0: 656e 2864 696d 656e 7369 6f6e 2920 3d3d  en(dimension) ==
+000053e0: 2031 3a0a 2020 2020 2020 2020 2020 2020   1:.            
+000053f0: 6420 3d20 6469 6d65 6e73 696f 6e5b 305d  d = dimension[0]
+00005400: 0a20 2020 2020 2020 2020 2020 2061 7373  .            ass
+00005410: 6572 7420 642c 2022 6469 6d65 6e73 696f  ert d, "dimensio
+00005420: 6e20 6d75 7374 2062 6520 6e6f 6e7a 6572  n must be nonzer
+00005430: 6f22 0a20 2020 2020 2020 2020 2020 2069  o".            i
+00005440: 6620 6469 6d65 6e73 696f 6e5b 305d 203d  f dimension[0] =
+00005450: 3d20 313a 0a20 2020 2020 2020 2020 2020  = 1:.           
+00005460: 2020 2020 2072 6574 7572 6e20 646f 6d61       return doma
+00005470: 696e 0a20 2020 2020 2020 2020 2020 2069  in.            i
+00005480: 6620 6973 696e 7374 616e 6365 2864 2c20  f isinstance(d, 
+00005490: 696e 7429 3a0a 2020 2020 2020 2020 2020  int):.          
+000054a0: 2020 2020 2020 6469 6d65 6e73 696f 6e20        dimension 
+000054b0: 3d20 2873 796d 7069 6679 2864 292c 290a  = (sympify(d),).
+000054c0: 2020 2020 2020 2020 7265 7475 726e 2053          return S
+000054d0: 6574 2e5f 5f6e 6577 5f5f 2863 6c73 2c20  et.__new__(cls, 
+000054e0: 646f 6d61 696e 2c20 2a64 696d 656e 7369  domain, *dimensi
+000054f0: 6f6e 290a 0a20 2020 2040 6361 6368 6569  on)..    @cachei
+00005500: 740a 2020 2020 6465 6620 5f65 7661 6c5f  t.    def _eval_
+00005510: 646f 6d61 696e 5f64 6566 696e 6564 2873  domain_defined(s
+00005520: 656c 662c 2078 2c20 2a2a 5f29 3a20 0a20  elf, x, **_): . 
+00005530: 2020 2020 2020 2072 6574 7572 6e20 7365         return se
+00005540: 6c66 2e73 7061 6365 2e64 6f6d 6169 6e5f  lf.space.domain_
+00005550: 6465 6669 6e65 6428 7829 2026 2049 6e74  defined(x) & Int
+00005560: 6572 7365 6374 696f 6e28 2a28 782e 646f  ersection(*(x.do
+00005570: 6d61 696e 5f63 6f6e 6469 7469 6f6e 6564  main_conditioned
+00005580: 2864 203e 2030 2920 666f 7220 6420 696e  (d > 0) for d in
+00005590: 2073 656c 662e 7370 6163 655f 7368 6170   self.space_shap
+000055a0: 6529 290a 0a20 2020 2040 7072 6f70 6572  e))..    @proper
+000055b0: 7479 0a20 2020 2064 6566 2064 6f6d 6169  ty.    def domai
+000055c0: 6e28 7365 6c66 293a 0a20 2020 2020 2020  n(self):.       
+000055d0: 2072 6574 7572 6e20 7365 6c66 2e75 6e69   return self.uni
+000055e0: 7665 7273 616c 5365 740a 2020 2020 0a20  versalSet.    . 
+000055f0: 2020 2040 7072 6f70 6572 7479 0a20 2020     @property.   
+00005600: 2064 6566 2073 7061 6365 2873 656c 6629   def space(self)
+00005610: 3a0a 2020 2020 2020 2020 7265 7475 726e  :.        return
+00005620: 2073 656c 662e 6172 6773 5b30 5d0a 0a20   self.args[0].. 
+00005630: 2020 2064 6566 205f 6576 616c 5f73 6861     def _eval_sha
+00005640: 7065 2873 656c 6629 3a0a 2020 2020 2020  pe(self):.      
+00005650: 2020 7265 7475 726e 2028 290a 2020 2020    return ().    
+00005660: 0a20 2020 2040 7072 6f70 6572 7479 0a20  .    @property. 
+00005670: 2020 2064 6566 2065 7479 7065 2873 656c     def etype(sel
+00005680: 6629 3a0a 2020 2020 2020 2020 7265 7475  f):.        retu
+00005690: 726e 2073 656c 662e 7370 6163 652e 6574  rn self.space.et
+000056a0: 7970 6520 2a20 7365 6c66 2e73 7061 6365  ype * self.space
+000056b0: 5f73 6861 7065 0a0a 2020 2020 4070 726f  _shape..    @pro
+000056c0: 7065 7274 790a 2020 2020 6465 6620 7370  perty.    def sp
+000056d0: 6163 655f 7368 6170 6528 7365 6c66 293a  ace_shape(self):
+000056e0: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
+000056f0: 7365 6c66 2e61 7267 735b 313a 5d0a 0a20  self.args[1:].. 
+00005700: 2020 2064 6566 205f 6576 616c 5f69 735f     def _eval_is_
+00005710: 6578 7465 6e64 6564 5f69 6e74 6567 6572  extended_integer
+00005720: 2873 656c 6629 3a0a 2020 2020 2020 2020  (self):.        
+00005730: 7265 7475 726e 2073 656c 662e 7370 6163  return self.spac
+00005740: 652e 6973 5f65 7874 656e 6465 645f 696e  e.is_extended_in
+00005750: 7465 6765 720a 0a20 2020 2064 6566 205f  teger..    def _
+00005760: 636f 6e74 6169 6e73 2873 656c 662c 206f  contains(self, o
+00005770: 7468 6572 293a 0a20 2020 2020 2020 2066  ther):.        f
+00005780: 726f 6d20 7379 6d70 7920 696d 706f 7274  rom sympy import
+00005790: 2052 616e 6765 2020 2020 2020 2020 0a20   Range        . 
+000057a0: 2020 2020 2020 2061 7373 6572 7420 7475         assert tu
+000057b0: 706c 6528 7365 6c66 2e65 7479 7065 2e73  ple(self.etype.s
+000057c0: 6861 7065 2920 3d3d 2074 7570 6c65 286f  hape) == tuple(o
+000057d0: 7468 6572 2e73 6861 7065 292c 2022 7365  ther.shape), "se
+000057e0: 6c66 2e65 7479 7065 2e73 6861 7065 203d  lf.etype.shape =
+000057f0: 2025 732c 206f 7468 6572 2e73 6861 7065   %s, other.shape
+00005800: 203d 2025 7322 2025 2028 7365 6c66 2e65   = %s" % (self.e
+00005810: 7479 7065 2e73 6861 7065 2c20 6f74 6865  type.shape, othe
+00005820: 722e 7368 6170 6529 0a20 2020 2020 2020  r.shape).       
+00005830: 200a 2020 2020 2020 2020 6966 2073 656c   .        if sel
+00005840: 662e 6973 5f55 6e69 7665 7273 616c 5365  f.is_UniversalSe
+00005850: 743a 0a20 2020 2020 2020 2020 2020 2072  t:.            r
+00005860: 6574 7572 6e20 532e 7472 7565 0a20 2020  eturn S.true.   
+00005870: 2020 2020 2069 6620 6f74 6865 722e 6973       if other.is
+00005880: 5f53 6c69 6365 6420 6f72 206f 7468 6572  _Sliced or other
+00005890: 2e69 735f 5379 6d62 6f6c 3a0a 2020 2020  .is_Symbol:.    
+000058a0: 2020 2020 2020 2020 6e20 3d20 6f74 6865          n = othe
+000058b0: 722e 7368 6170 655b 305d 0a20 2020 2020  r.shape[0].     
+000058c0: 2020 2020 2020 2069 203d 2044 756d 6d79         i = Dummy
+000058d0: 2827 6927 2c20 646f 6d61 696e 3d52 616e  ('i', domain=Ran
+000058e0: 6765 286e 2929 0a20 2020 2020 2020 2020  ge(n)).         
+000058f0: 2020 2073 7061 6365 5f73 6861 7065 203d     space_shape =
+00005900: 2073 656c 662e 7370 6163 655f 7368 6170   self.space_shap
+00005910: 655b 313a 5d0a 2020 2020 2020 2020 2020  e[1:].          
+00005920: 2020 6966 2073 7061 6365 5f73 6861 7065    if space_shape
+00005930: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+00005940: 2020 646f 6d61 696e 203d 2073 656c 662e    domain = self.
+00005950: 6675 6e63 2873 656c 662e 7370 6163 652c  func(self.space,
+00005960: 202a 7370 6163 655f 7368 6170 6529 0a20   *space_shape). 
+00005970: 2020 2020 2020 2020 2020 2065 6c73 653a             else:
+00005980: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00005990: 2064 6f6d 6169 6e20 3d20 7365 6c66 2e73   domain = self.s
+000059a0: 7061 6365 0a20 2020 2020 2020 2020 2020  pace.           
+000059b0: 2020 2020 200a 2020 2020 2020 2020 2020       .          
+000059c0: 2020 636f 6e64 203d 2045 6c65 6d65 6e74    cond = Element
+000059d0: 286f 7468 6572 5b69 5d2c 2064 6f6d 6169  (other[i], domai
+000059e0: 6e29 0a20 2020 2020 2020 2020 2020 2069  n).            i
+000059f0: 6620 636f 6e64 3a0a 2020 2020 2020 2020  f cond:.        
+00005a00: 2020 2020 2020 2020 7265 7475 726e 2063          return c
+00005a10: 6f6e 640a 2020 2020 2020 2020 2020 2020  ond.            
+00005a20: 6966 2063 6f6e 6420 3d3d 2046 616c 7365  if cond == False
+00005a30: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+00005a40: 2020 7265 7475 726e 2063 6f6e 640a 2020    return cond.  
+00005a50: 2020 2020 2020 656c 6966 206f 7468 6572        elif other
+00005a60: 2e69 735f 426c 6f63 6b4d 6174 7269 783a  .is_BlockMatrix:
+00005a70: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
+00005a80: 6f74 6865 722e 6178 6973 203d 3d20 303a  other.axis == 0:
+00005a90: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00005aa0: 2073 7061 6365 5f73 6861 7065 203d 2073   space_shape = s
+00005ab0: 656c 662e 7370 6163 655f 7368 6170 655b  elf.space_shape[
+00005ac0: 313a 5d0a 2020 2020 2020 2020 2020 2020  1:].            
+00005ad0: 2020 2020 6966 2073 7061 6365 5f73 6861      if space_sha
+00005ae0: 7065 3a0a 2020 2020 2020 2020 2020 2020  pe:.            
+00005af0: 2020 2020 2020 2020 646f 6d61 696e 203d          domain =
+00005b00: 2073 656c 662e 6675 6e63 2873 656c 662e   self.func(self.
+00005b10: 7370 6163 652c 202a 7370 6163 655f 7368  space, *space_sh
+00005b20: 6170 6529 0a20 2020 2020 2020 2020 2020  ape).           
+00005b30: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
+00005b40: 2020 2020 2020 2020 2020 2020 2020 2064                 d
+00005b50: 6f6d 6169 6e20 3d20 7365 6c66 2e73 7061  omain = self.spa
+00005b60: 6365 0a20 2020 2020 2020 2020 2020 2020  ce.             
+00005b70: 2020 200a 2020 2020 2020 2020 2020 2020     .            
+00005b80: 2020 2020 666f 7220 626c 6f63 6b20 696e      for block in
+00005b90: 206f 7468 6572 2e61 7267 733a 0a20 2020   other.args:.   
+00005ba0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00005bb0: 2069 6620 626c 6f63 6b2e 7368 6170 653a   if block.shape:
+00005bc0: 200a 2020 2020 2020 2020 2020 2020 2020   .              
+00005bd0: 2020 2020 2020 2020 2020 6e20 3d20 626c            n = bl
+00005be0: 6f63 6b2e 7368 6170 655b 305d 0a20 2020  ock.shape[0].   
+00005bf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00005c00: 2020 2020 2069 203d 2044 756d 6d79 2827       i = Dummy('
+00005c10: 6927 2c20 646f 6d61 696e 3d52 616e 6765  i', domain=Range
+00005c20: 286e 2929 0a20 2020 2020 2020 2020 2020  (n)).           
+00005c30: 2020 2020 2020 2020 2020 2020 2063 6f6e               con
+00005c40: 6420 3d20 456c 656d 656e 7428 6f74 6865  d = Element(othe
+00005c50: 725b 695d 2c20 646f 6d61 696e 290a 2020  r[i], domain).  
+00005c60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00005c70: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
 00005c80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00005c90: 6966 2062 6c6f 636b 2e73 6861 7065 3a20  if block.shape: 
-00005ca0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00005cb0: 2020 2020 2020 2020 206e 203d 2062 6c6f           n = blo
-00005cc0: 636b 2e73 6861 7065 5b30 5d0a 2020 2020  ck.shape[0].    
-00005cd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00005ce0: 2020 2020 6920 3d20 4475 6d6d 7928 2769      i = Dummy('i
-00005cf0: 272c 2064 6f6d 6169 6e3d 5261 6e67 6528  ', domain=Range(
-00005d00: 6e29 290a 2020 2020 2020 2020 2020 2020  n)).            
-00005d10: 2020 2020 2020 2020 2020 2020 636f 6e64              cond
-00005d20: 203d 2045 6c65 6d65 6e74 286f 7468 6572   = Element(other
-00005d30: 5b69 5d2c 2064 6f6d 6169 6e29 0a20 2020  [i], domain).   
-00005d40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00005d50: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
-00005d60: 2020 2020 2020 2020 2020 2020 2020 2063                 c
-00005d70: 6f6e 6420 3d20 456c 656d 656e 7428 626c  ond = Element(bl
-00005d80: 6f63 6b2c 2064 6f6d 6169 6e29 0a20 2020  ock, domain).   
-00005d90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00005da0: 2020 2020 200a 2020 2020 2020 2020 2020       .          
-00005db0: 2020 2020 2020 2020 2020 6966 2063 6f6e            if con
-00005dc0: 643a 0a20 2020 2020 2020 2020 2020 2020  d:.             
-00005dd0: 2020 2020 2020 2020 2020 2063 6f6e 7469             conti
-00005de0: 6e75 650a 2020 2020 2020 2020 2020 2020  nue.            
-00005df0: 2020 2020 2020 2020 6966 2063 6f6e 6420          if cond 
-00005e00: 3d3d 2046 616c 7365 3a0a 2020 2020 2020  == False:.      
-00005e10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00005e20: 2020 7265 7475 726e 2063 6f6e 640a 2020    return cond.  
-00005e30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00005e40: 2020 7265 7475 726e 0a20 2020 2020 2020    return.       
-00005e50: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
-00005e60: 532e 7472 7565 0a20 2020 2020 2020 2065  S.true.        e
-00005e70: 6c69 6620 6f74 6865 722e 6973 5f44 656e  lif other.is_Den
-00005e80: 7365 4d61 7472 6978 3a0a 2020 2020 2020  seMatrix:.      
-00005e90: 2020 2020 2020 636f 6e74 6169 6e73 203d        contains =
-00005ea0: 204e 6f6e 650a 2020 2020 2020 2020 2020   None.          
-00005eb0: 2020 666f 7220 6172 6720 696e 206f 7468    for arg in oth
-00005ec0: 6572 2e61 7267 733a 0a20 2020 2020 2020  er.args:.       
-00005ed0: 2020 2020 2020 2020 2063 6f6e 6420 3d20           cond = 
-00005ee0: 456c 656d 656e 7428 6172 672c 2073 656c  Element(arg, sel
-00005ef0: 662e 7370 6163 6529 0a20 2020 2020 2020  f.space).       
-00005f00: 2020 2020 2020 2020 2069 6620 636f 6e64           if cond
-00005f10: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-00005f20: 2020 2020 2020 6966 2063 6f6e 7461 696e        if contain
-00005f30: 7320 6973 204e 6f6e 653a 0a20 2020 2020  s is None:.     
-00005f40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00005f50: 2020 2063 6f6e 7461 696e 7320 3d20 532e     contains = S.
-00005f60: 7472 7565 0a20 2020 2020 2020 2020 2020  true.           
-00005f70: 2020 2020 2020 2020 2065 6c69 6620 636f           elif co
-00005f80: 6e74 6169 6e73 203d 3d20 4661 6c73 653a  ntains == False:
-00005f90: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00005fa0: 2020 2020 2020 2020 2072 6574 7572 6e0a           return.
-00005fb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00005fc0: 656c 6966 2063 6f6e 6420 3d3d 2046 616c  elif cond == Fal
-00005fd0: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
-00005fe0: 2020 2020 2020 2020 6966 2063 6f6e 7461          if conta
-00005ff0: 696e 7320 6973 204e 6f6e 653a 0a20 2020  ins is None:.   
-00006000: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006010: 2020 2020 2063 6f6e 7461 696e 7320 3d20       contains = 
-00006020: 532e 6661 6c73 650a 2020 2020 2020 2020  S.false.        
-00006030: 2020 2020 2020 2020 2020 2020 656c 6966              elif
-00006040: 2063 6f6e 7461 696e 733a 0a20 2020 2020   contains:.     
-00006050: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006060: 2020 2072 6574 7572 6e0a 2020 2020 2020     return.      
-00006070: 2020 2020 2020 7265 7475 726e 2063 6f6e        return con
-00006080: 7461 696e 730a 0a20 2020 2064 6566 205f  tains..    def _
-00006090: 5f6d 756c 5f5f 2873 656c 662c 206f 7468  _mul__(self, oth
-000060a0: 6572 293a 0a20 2020 2020 2020 2069 6620  er):.        if 
-000060b0: 6f74 6865 722e 6973 5f73 6574 3a0a 2020  other.is_set:.  
-000060c0: 2020 2020 2020 2020 2020 6173 7365 7274            assert
-000060d0: 206c 656e 286f 7468 6572 2e65 7479 7065   len(other.etype
-000060e0: 2e73 6861 7065 2920 3c20 6c65 6e28 7365  .shape) < len(se
-000060f0: 6c66 2e65 7479 7065 2e73 6861 7065 290a  lf.etype.shape).
-00006100: 2020 2020 2020 2020 7265 7475 726e 2073          return s
-00006110: 656c 660a 2020 2020 0a20 2020 2064 6566  elf.    .    def
-00006120: 205f 5f61 6464 5f5f 2873 656c 662c 206f   __add__(self, o
-00006130: 7468 6572 293a 0a20 2020 2020 2020 2069  ther):.        i
-00006140: 6620 6f74 6865 722e 6973 5f43 6172 7465  f other.is_Carte
-00006150: 7369 616e 5370 6163 653a 0a20 2020 2020  sianSpace:.     
-00006160: 2020 2020 2020 2069 6620 6c65 6e28 7365         if len(se
-00006170: 6c66 2e73 7061 6365 5f73 6861 7065 2920  lf.space_shape) 
-00006180: 3e20 6c65 6e28 6f74 6865 722e 7370 6163  > len(other.spac
-00006190: 655f 7368 6170 6529 3a0a 2020 2020 2020  e_shape):.      
-000061a0: 2020 2020 2020 2020 2020 6173 7365 7274            assert
-000061b0: 2073 656c 662e 7370 6163 655f 7368 6170   self.space_shap
-000061c0: 655b 3a6c 656e 286f 7468 6572 2e73 7061  e[:len(other.spa
-000061d0: 6365 5f73 6861 7065 295d 203d 3d20 6f74  ce_shape)] == ot
-000061e0: 6865 722e 7370 6163 655f 7368 6170 650a  her.space_shape.
-000061f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006200: 7368 6170 6520 3d20 7365 6c66 2e73 7061  shape = self.spa
-00006210: 6365 5f73 6861 7065 0a20 2020 2020 2020  ce_shape.       
-00006220: 2020 2020 2065 6c69 6620 6c65 6e28 7365       elif len(se
-00006230: 6c66 2e73 7061 6365 5f73 6861 7065 2920  lf.space_shape) 
-00006240: 3c20 6c65 6e28 6f74 6865 722e 7370 6163  < len(other.spac
-00006250: 655f 7368 6170 6529 3a0a 2020 2020 2020  e_shape):.      
-00006260: 2020 2020 2020 2020 2020 6173 7365 7274            assert
-00006270: 2073 656c 662e 7370 6163 655f 7368 6170   self.space_shap
-00006280: 6520 3d3d 206f 7468 6572 2e73 7061 6365  e == other.space
-00006290: 5f73 6861 7065 5b6c 656e 2873 656c 662e  _shape[len(self.
-000062a0: 7370 6163 655f 7368 6170 6529 3a5d 0a20  space_shape):]. 
-000062b0: 2020 2020 2020 2020 2020 2020 2020 2073                 s
-000062c0: 6861 7065 203d 206f 7468 6572 2e73 7061  hape = other.spa
-000062d0: 6365 5f73 6861 7065 0a20 2020 2020 2020  ce_shape.       
-000062e0: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
-000062f0: 2020 2020 2020 2020 2020 2061 7373 6572             asser
-00006300: 7420 7365 6c66 2e73 7061 6365 5f73 6861  t self.space_sha
-00006310: 7065 203d 3d20 6f74 6865 722e 7370 6163  pe == other.spac
-00006320: 655f 7368 6170 650a 2020 2020 2020 2020  e_shape.        
-00006330: 2020 2020 2020 2020 7368 6170 6520 3d20          shape = 
-00006340: 7365 6c66 2e73 7061 6365 5f73 6861 7065  self.space_shape
-00006350: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
-00006360: 7572 6e20 7365 6c66 2e66 756e 6328 7365  urn self.func(se
-00006370: 6c66 2e73 7061 6365 202b 206f 7468 6572  lf.space + other
-00006380: 2e73 7061 6365 2c20 2a73 6861 7065 2920  .space, *shape) 
-00006390: 2020 2020 2020 200a 2020 2020 2020 2020         .        
-000063a0: 6966 206f 7468 6572 2e69 735f 7365 743a  if other.is_set:
-000063b0: 0a20 2020 2020 2020 2020 2020 2061 7373  .            ass
-000063c0: 6572 7420 6c65 6e28 6f74 6865 722e 6574  ert len(other.et
-000063d0: 7970 652e 7368 6170 6529 203c 206c 656e  ype.shape) < len
-000063e0: 2873 656c 662e 6574 7970 652e 7368 6170  (self.etype.shap
-000063f0: 6529 0a20 2020 2020 2020 2072 6574 7572  e).        retur
-00006400: 6e20 7365 6c66 0a20 2020 200a 2020 2020  n self.    .    
-00006410: 6465 6620 696e 7465 7273 6563 7469 6f6e  def intersection
-00006420: 5f73 6574 7328 7365 6c66 2c20 6229 3a0a  _sets(self, b):.
-00006430: 2020 2020 2020 2020 6966 2062 2e69 735f          if b.is_
-00006440: 4361 7274 6573 6961 6e53 7061 6365 3a0a  CartesianSpace:.
-00006450: 2020 2020 2020 2020 2020 2020 6173 7365              asse
-00006460: 7274 2073 656c 662e 7370 6163 655f 7368  rt self.space_sh
-00006470: 6170 6520 3d3d 2062 2e73 7061 6365 5f73  ape == b.space_s
-00006480: 6861 7065 0a20 2020 2020 2020 2020 2020  hape.           
-00006490: 2072 6574 7572 6e20 7365 6c66 2e66 756e   return self.fun
-000064a0: 6328 7365 6c66 2e73 7061 6365 2026 2062  c(self.space & b
-000064b0: 2e73 7061 6365 2c20 2a73 656c 662e 7370  .space, *self.sp
-000064c0: 6163 655f 7368 6170 6529 0a20 2020 2020  ace_shape).     
-000064d0: 2020 2065 6c69 6620 622e 6973 5f73 796d     elif b.is_sym
-000064e0: 626f 6c3a 0a20 2020 2020 2020 2020 2020  bol:.           
-000064f0: 2065 7479 7065 203d 2062 2e65 7479 7065   etype = b.etype
-00006500: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
-00006510: 6574 7970 652e 6173 5f53 6574 2829 2069  etype.as_Set() i
-00006520: 6e20 7365 6c66 3a0a 2020 2020 2020 2020  n self:.        
-00006530: 2020 2020 2020 2020 7265 7475 726e 2062          return b
-00006540: 0a0a 2020 2020 6465 6620 5f6c 6174 6578  ..    def _latex
-00006550: 2873 656c 662c 2070 293a 0a20 2020 2020  (self, p):.     
-00006560: 2020 2073 7061 6365 5f73 6861 7065 203d     space_shape =
-00006570: 2073 656c 662e 7370 6163 655f 7368 6170   self.space_shap
-00006580: 650a 2020 2020 2020 2020 6966 206c 656e  e.        if len
-00006590: 2873 7061 6365 5f73 6861 7065 2920 3d3d  (space_shape) ==
-000065a0: 2031 3a0a 2020 2020 2020 2020 2020 2020   1:.            
-000065b0: 7370 6163 655f 7368 6170 6520 3d20 7370  space_shape = sp
-000065c0: 6163 655f 7368 6170 655b 305d 0a20 2020  ace_shape[0].   
-000065d0: 2020 2020 2072 6574 7572 6e20 227b 2573       return "{%s
-000065e0: 7d5e 7b25 737d 2220 2520 2870 2e5f 7072  }^{%s}" % (p._pr
-000065f0: 696e 7428 7365 6c66 2e73 7061 6365 292c  int(self.space),
-00006600: 2070 2e5f 7072 696e 7428 7370 6163 655f   p._print(space_
-00006610: 7368 6170 6529 290a 0a20 2020 2040 636c  shape))..    @cl
-00006620: 6173 736d 6574 686f 640a 2020 2020 6465  assmethod.    de
-00006630: 6620 7369 6d70 6c69 6679 5f45 6c65 6d65  f simplify_Eleme
-00006640: 6e74 2863 6c73 2c20 7365 6c66 2c20 652c  nt(cls, self, e,
-00006650: 2073 293a 0a20 2020 2020 2020 206b 203d   s):.        k =
-00006660: 2073 656c 662e 6765 6e65 7261 7465 5f76   self.generate_v
-00006670: 6172 2869 6e74 6567 6572 3d54 7275 6529  ar(integer=True)
-00006680: 0a20 2020 2020 2020 206e 203d 2065 2e73  .        n = e.s
-00006690: 6861 7065 5b30 5d0a 2020 2020 2020 2020  hape[0].        
-000066a0: 6966 206e 2e69 735f 496e 6669 6e69 7479  if n.is_Infinity
-000066b0: 3a0a 2020 2020 2020 2020 2020 2020 7265  :.            re
-000066c0: 7475 726e 2073 656c 662e 6675 6e63 2865  turn self.func(e
-000066d0: 5b6b 5d2c 2063 6c73 2873 2e73 7061 6365  [k], cls(s.space
-000066e0: 2c20 2a73 2e73 7061 6365 5f73 6861 7065  , *s.space_shape
-000066f0: 5b31 3a5d 2929 0a20 2020 2020 2020 2065  [1:])).        e
-00006700: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
-00006710: 2066 726f 6d20 7379 6d70 792e 636f 6e63   from sympy.conc
-00006720: 7265 7465 2e66 6f72 616c 6c20 696d 706f  rete.forall impo
-00006730: 7274 2046 6f72 416c 6c0a 2020 2020 2020  rt ForAll.      
-00006740: 2020 2020 2020 7265 7475 726e 2046 6f72        return For
-00006750: 416c 6c5b 6b3a 6e5d 2873 656c 662e 6675  All[k:n](self.fu
-00006760: 6e63 2865 5b6b 5d2c 2063 6c73 2873 2e73  nc(e[k], cls(s.s
-00006770: 7061 6365 2c20 2a73 2e73 7061 6365 5f73  pace, *s.space_s
-00006780: 6861 7065 5b31 3a5d 2929 2e73 696d 706c  hape[1:])).simpl
-00006790: 6966 7928 2929 0a20 2020 200a 2020 2020  ify()).    .    
-000067a0: 4063 6c61 7373 6d65 7468 6f64 0a20 2020  @classmethod.   
-000067b0: 2064 6566 2073 696d 706c 6966 795f 4e6f   def simplify_No
-000067c0: 7445 6c65 6d65 6e74 2863 6c73 2c20 7365  tElement(cls, se
-000067d0: 6c66 2c20 652c 2073 293a 200a 2020 2020  lf, e, s): .    
-000067e0: 2020 2020 6b20 3d20 7365 6c66 2e67 656e      k = self.gen
-000067f0: 6572 6174 655f 7661 7228 696e 7465 6765  erate_var(intege
-00006800: 723d 5472 7565 290a 2020 2020 2020 2020  r=True).        
-00006810: 6e20 3d20 652e 7368 6170 655b 305d 0a20  n = e.shape[0]. 
-00006820: 2020 2020 2020 2069 6620 6e2e 6973 5f49         if n.is_I
-00006830: 6e66 696e 6974 793a 0a20 2020 2020 2020  nfinity:.       
-00006840: 2020 2020 2072 6574 7572 6e20 7365 6c66       return self
-00006850: 2e66 756e 6328 655b 6b5d 2c20 636c 7328  .func(e[k], cls(
-00006860: 732e 7370 6163 652c 202a 732e 7370 6163  s.space, *s.spac
-00006870: 655f 7368 6170 655b 313a 5d29 290a 2020  e_shape[1:])).  
-00006880: 2020 2020 2020 656c 7365 3a0a 2020 2020        else:.    
-00006890: 2020 2020 2020 2020 6672 6f6d 2073 796d          from sym
-000068a0: 7079 2069 6d70 6f72 7420 416e 790a 2020  py import Any.  
-000068b0: 2020 2020 2020 2020 2020 7265 7475 726e            return
-000068c0: 2041 6e79 5b6b 3a6e 5d28 7365 6c66 2e66   Any[k:n](self.f
-000068d0: 756e 6328 655b 6b5d 2c20 636c 7328 732e  unc(e[k], cls(s.
-000068e0: 7370 6163 652c 202a 732e 7370 6163 655f  space, *s.space_
-000068f0: 7368 6170 655b 313a 5d29 2929 0a20 2020  shape[1:]))).   
-00006900: 200a 2020 2020 6465 6620 5f65 7661 6c5f   .    def _eval_
-00006910: 5375 6273 6574 5f72 6576 6572 7365 6428  Subset_reversed(
-00006920: 7365 6c66 2c20 6c68 7329 3a20 0a20 2020  self, lhs): .   
-00006930: 2020 2020 2069 6620 6c68 732e 6973 5f53       if lhs.is_S
-00006940: 796d 626f 6c3a 0a20 2020 2020 2020 2020  ymbol:.         
-00006950: 2020 2069 6620 6c68 732e 6574 7970 652e     if lhs.etype.
-00006960: 6173 5f53 6574 2829 2069 6e20 7365 6c66  as_Set() in self
-00006970: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-00006980: 2020 7265 7475 726e 2053 2e74 7275 650a    return S.true.
-00006990: 0a20 2020 2040 7072 6f70 6572 7479 0a20  .    @property. 
-000069a0: 2020 2064 6566 2069 735f 556e 6976 6572     def is_Univer
-000069b0: 7361 6c53 6574 2873 656c 6629 3a0a 2020  salSet(self):.  
-000069c0: 2020 2020 2020 7265 7475 726e 2073 656c        return sel
-000069d0: 662e 7370 6163 652e 6973 5f55 6e69 7665  f.space.is_Unive
-000069e0: 7273 616c 5365 740a 0a20 2020 2064 6566  rsalSet..    def
-000069f0: 205f 6576 616c 5f69 735f 656d 7074 7928   _eval_is_empty(
-00006a00: 7365 6c66 293a 0a20 2020 2020 2020 2072  self):.        r
-00006a10: 6574 7572 6e20 7365 6c66 2e73 7061 6365  eturn self.space
-00006a20: 2e69 735f 656d 7074 790a 0a20 2020 2064  .is_empty..    d
-00006a30: 6566 205f 6576 616c 5f69 735f 6669 6e69  ef _eval_is_fini
-00006a40: 7465 7365 7428 7365 6c66 293a 0a20 2020  teset(self):.   
-00006a50: 2020 2020 2073 7061 6365 2c20 2a73 7061       space, *spa
-00006a60: 6365 5f73 6861 7065 203d 2073 656c 662e  ce_shape = self.
-00006a70: 6172 6773 0a20 2020 2020 2020 2069 735f  args.        is_
-00006a80: 6669 6e69 7465 7365 7420 3d20 7365 6c66  finiteset = self
-00006a90: 2e73 7061 6365 2e69 735f 6669 6e69 7465  .space.is_finite
-00006aa0: 7365 740a 2020 2020 2020 2020 6966 2069  set.        if i
-00006ab0: 735f 6669 6e69 7465 7365 743a 0a20 2020  s_finiteset:.   
-00006ac0: 2020 2020 2020 2020 2066 6f72 2064 2069           for d i
-00006ad0: 6e20 7370 6163 655f 7368 6170 653a 0a20  n space_shape:. 
-00006ae0: 2020 2020 2020 2020 2020 2020 2020 2069                 i
-00006af0: 735f 696e 6669 6e69 7465 203d 2064 2e69  s_infinite = d.i
-00006b00: 735f 696e 6669 6e69 7465 0a20 2020 2020  s_infinite.     
-00006b10: 2020 2020 2020 2020 2020 2069 6620 6973             if is
-00006b20: 5f69 6e66 696e 6974 653a 0a20 2020 2020  _infinite:.     
-00006b30: 2020 2020 2020 2020 2020 2020 2020 2072                 r
-00006b40: 6574 7572 6e20 4661 6c73 650a 2020 2020  eturn False.    
-00006b50: 2020 2020 2020 2020 2020 2020 0a20 2020              .   
-00006b60: 2020 2020 2020 2020 2020 2020 2069 6620               if 
-00006b70: 6973 5f69 6e66 696e 6974 6520 6973 204e  is_infinite is N
-00006b80: 6f6e 653a 0a20 2020 2020 2020 2020 2020  one:.           
-00006b90: 2020 2020 2020 2020 2072 6574 7572 6e0a           return.
-00006ba0: 2020 2020 2020 2020 2020 2020 7265 7475              retu
-00006bb0: 726e 2054 7275 650a 0a20 2020 2020 2020  rn True..       
-00006bc0: 2072 6574 7572 6e20 6973 5f66 696e 6974   return is_finit
-00006bd0: 6573 6574 0a0a 0a63 6c61 7373 2049 6e74  eset...class Int
-00006be0: 6572 7661 6c28 5365 742c 2045 7661 6c66  erval(Set, Evalf
-00006bf0: 4d69 7869 6e29 3a0a 2020 2020 2222 220a  Mixin):.    """.
-00006c00: 2020 2020 5265 7072 6573 656e 7473 2061      Represents a
-00006c10: 2072 6561 6c20 696e 7465 7276 616c 2061   real interval a
-00006c20: 7320 6120 5365 742e 0a0a 2020 2020 5573  s a Set...    Us
-00006c30: 6167 653a 0a20 2020 2020 2020 2052 6574  age:.        Ret
-00006c40: 7572 6e73 2061 6e20 696e 7465 7276 616c  urns an interval
-00006c50: 2077 6974 6820 656e 6420 706f 696e 7473   with end points
-00006c60: 2022 7374 6172 7422 2061 6e64 2022 656e   "start" and "en
-00006c70: 6422 2e0a 0a20 2020 2020 2020 2046 6f72  d"...        For
-00006c80: 206c 6566 745f 6f70 656e 3d54 7275 6520   left_open=True 
-00006c90: 2864 6566 6175 6c74 206c 6566 745f 6f70  (default left_op
-00006ca0: 656e 2069 7320 4661 6c73 6529 2074 6865  en is False) the
-00006cb0: 2069 6e74 6572 7661 6c0a 2020 2020 2020   interval.      
-00006cc0: 2020 7769 6c6c 2062 6520 6f70 656e 206f    will be open o
-00006cd0: 6e20 7468 6520 6c65 6674 2e20 5369 6d69  n the left. Simi
-00006ce0: 6c61 726c 792c 2066 6f72 2072 6967 6874  larly, for right
-00006cf0: 5f6f 7065 6e3d 5472 7565 2074 6865 2069  _open=True the i
-00006d00: 6e74 6572 7661 6c0a 2020 2020 2020 2020  nterval.        
-00006d10: 7769 6c6c 2062 6520 6f70 656e 206f 6e20  will be open on 
-00006d20: 7468 6520 7269 6768 742e 0a0a 2020 2020  the right...    
-00006d30: 4578 616d 706c 6573 0a20 2020 203d 3d3d  Examples.    ===
-00006d40: 3d3d 3d3d 3d0a 0a20 2020 203e 3e3e 2066  =====..    >>> f
-00006d50: 726f 6d20 7379 6d70 7920 696d 706f 7274  rom sympy import
-00006d60: 2053 796d 626f 6c2c 2049 6e74 6572 7661   Symbol, Interva
-00006d70: 6c0a 2020 2020 3e3e 3e20 496e 7465 7276  l.    >>> Interv
-00006d80: 616c 2830 2c20 3129 0a20 2020 2049 6e74  al(0, 1).    Int
-00006d90: 6572 7661 6c28 302c 2031 290a 2020 2020  erval(0, 1).    
-00006da0: 3e3e 3e20 496e 7465 7276 616c 2e52 6f70  >>> Interval.Rop
-00006db0: 656e 2830 2c20 3129 0a20 2020 2049 6e74  en(0, 1).    Int
-00006dc0: 6572 7661 6c2e 526f 7065 6e28 302c 2031  erval.Ropen(0, 1
-00006dd0: 290a 2020 2020 3e3e 3e20 496e 7465 7276  ).    >>> Interv
-00006de0: 616c 2e52 6f70 656e 2830 2c20 3129 0a20  al.Ropen(0, 1). 
-00006df0: 2020 2049 6e74 6572 7661 6c2e 526f 7065     Interval.Rope
-00006e00: 6e28 302c 2031 290a 2020 2020 3e3e 3e20  n(0, 1).    >>> 
-00006e10: 496e 7465 7276 616c 2e4c 6f70 656e 2830  Interval.Lopen(0
-00006e20: 2c20 3129 0a20 2020 2049 6e74 6572 7661  , 1).    Interva
-00006e30: 6c2e 4c6f 7065 6e28 302c 2031 290a 2020  l.Lopen(0, 1).  
-00006e40: 2020 3e3e 3e20 496e 7465 7276 616c 2e6f    >>> Interval.o
-00006e50: 7065 6e28 302c 2031 290a 2020 2020 496e  pen(0, 1).    In
-00006e60: 7465 7276 616c 2e6f 7065 6e28 302c 2031  terval.open(0, 1
-00006e70: 290a 0a20 2020 203e 3e3e 2061 203d 2053  )..    >>> a = S
-00006e80: 796d 626f 6c28 2761 272c 2072 6561 6c3d  ymbol('a', real=
-00006e90: 5472 7565 290a 2020 2020 3e3e 3e20 496e  True).    >>> In
-00006ea0: 7465 7276 616c 2830 2c20 6129 0a20 2020  terval(0, a).   
-00006eb0: 2049 6e74 6572 7661 6c28 302c 2061 290a   Interval(0, a).
-00006ec0: 0a20 2020 204e 6f74 6573 0a20 2020 203d  .    Notes.    =
-00006ed0: 3d3d 3d3d 0a20 2020 202d 204f 6e6c 7920  ====.    - Only 
-00006ee0: 7265 616c 2065 6e64 2070 6f69 6e74 7320  real end points 
-00006ef0: 6172 6520 7375 7070 6f72 7465 640a 2020  are supported.  
-00006f00: 2020 2d20 496e 7465 7276 616c 2861 2c20    - Interval(a, 
-00006f10: 6229 2077 6974 6820 6120 3e20 6220 7769  b) with a > b wi
-00006f20: 6c6c 2072 6574 7572 6e20 7468 6520 656d  ll return the em
-00006f30: 7074 7920 7365 740a 2020 2020 2d20 5573  pty set.    - Us
-00006f40: 6520 7468 6520 6576 616c 6628 2920 6d65  e the evalf() me
-00006f50: 7468 6f64 2074 6f20 7475 726e 2061 6e20  thod to turn an 
-00006f60: 496e 7465 7276 616c 2069 6e74 6f20 616e  Interval into an
-00006f70: 206d 706d 6174 680a 2020 2020 2020 276d   mpmath.      'm
-00006f80: 7069 2720 696e 7465 7276 616c 2069 6e73  pi' interval ins
-00006f90: 7461 6e63 650a 0a20 2020 2052 6566 6572  tance..    Refer
-00006fa0: 656e 6365 730a 2020 2020 3d3d 3d3d 3d3d  ences.    ======
-00006fb0: 3d3d 3d3d 0a0a 2020 2020 2e2e 205b 315d  ====..    .. [1]
-00006fc0: 2068 7474 7073 3a2f 2f65 6e2e 7769 6b69   https://en.wiki
-00006fd0: 7065 6469 612e 6f72 672f 7769 6b69 2f49  pedia.org/wiki/I
-00006fe0: 6e74 6572 7661 6c5f 2532 386d 6174 6865  nterval_%28mathe
-00006ff0: 6d61 7469 6373 2532 390a 2020 2020 2222  matics%29.    ""
-00007000: 220a 0a20 2020 2064 6566 2073 7472 7563  "..    def struc
-00007010: 7475 7261 6c6c 795f 6571 7561 6c28 7365  turally_equal(se
-00007020: 6c66 2c20 6f74 6865 7229 3a0a 2020 2020  lf, other):.    
-00007030: 2020 2020 6966 206e 6f74 2069 7369 6e73      if not isins
-00007040: 7461 6e63 6528 6f74 6865 722c 2073 656c  tance(other, sel
-00007050: 662e 6675 6e63 2920 6f72 206c 656e 2873  f.func) or len(s
-00007060: 656c 662e 6172 6773 2920 213d 206c 656e  elf.args) != len
-00007070: 286f 7468 6572 2e61 7267 7329 3a0a 2020  (other.args):.  
-00007080: 2020 2020 2020 2020 2020 7265 7475 726e            return
-00007090: 2046 616c 7365 0a20 2020 2020 2020 2069   False.        i
-000070a0: 6620 7365 6c66 2e6c 6566 745f 6f70 656e  f self.left_open
-000070b0: 2021 3d20 6f74 6865 722e 6c65 6674 5f6f   != other.left_o
-000070c0: 7065 6e20 6f72 2073 656c 662e 7269 6768  pen or self.righ
-000070d0: 745f 6f70 656e 2021 3d20 6f74 6865 722e  t_open != other.
-000070e0: 7269 6768 745f 6f70 656e 3a0a 2020 2020  right_open:.    
-000070f0: 2020 2020 2020 2020 7265 7475 726e 2046          return F
-00007100: 616c 7365 0a20 2020 2020 2020 2066 6f72  alse.        for
-00007110: 2078 2c20 7920 696e 207a 6970 2873 656c   x, y in zip(sel
-00007120: 662e 6172 6773 5b3a 335d 2c20 6f74 6865  f.args[:3], othe
-00007130: 722e 6172 6773 5b3a 335d 293a 0a20 2020  r.args[:3]):.   
-00007140: 2020 2020 2020 2020 2069 6620 6e6f 7420           if not 
-00007150: 782e 7374 7275 6374 7572 616c 6c79 5f65  x.structurally_e
-00007160: 7175 616c 2879 293a 0a20 2020 2020 2020  qual(y):.       
-00007170: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
-00007180: 4661 6c73 650a 2020 2020 2020 2020 7265  False.        re
-00007190: 7475 726e 2054 7275 650a 0a20 2020 2064  turn True..    d
-000071a0: 6566 2073 696d 706c 6966 7928 7365 6c66  ef simplify(self
-000071b0: 2c20 6465 6570 3d46 616c 7365 293a 0a20  , deep=False):. 
-000071c0: 2020 2020 2020 2069 6620 6465 6570 3a0a         if deep:.
-000071d0: 2020 2020 2020 2020 2020 2020 6869 7420              hit 
-000071e0: 3d20 4661 6c73 650a 2020 2020 2020 2020  = False.        
-000071f0: 2020 2020 6172 6773 203d 205b 2a73 656c      args = [*sel
-00007200: 662e 6172 6773 5d0a 2020 2020 2020 2020  f.args].        
-00007210: 2020 2020 666f 7220 692c 2061 7267 2069      for i, arg i
-00007220: 6e20 656e 756d 6572 6174 6528 7365 6c66  n enumerate(self
-00007230: 2e61 7267 735b 3a33 5d29 3a20 0a20 2020  .args[:3]): .   
-00007240: 2020 2020 2020 2020 2020 2020 205f 6172               _ar
-00007250: 6720 3d20 6172 672e 7369 6d70 6c69 6679  g = arg.simplify
-00007260: 2864 6565 703d 6465 6570 2920 2020 2020  (deep=deep)     
-00007270: 2020 2020 2020 2020 2020 200a 0a20 2020             ..   
-00007280: 2020 2020 2020 2020 2020 2020 2069 6620               if 
-00007290: 5f61 7267 2021 3d20 6172 673a 0a20 2020  _arg != arg:.   
-000072a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000072b0: 2068 6974 203d 2054 7275 650a 2020 2020   hit = True.    
-000072c0: 2020 2020 2020 2020 2020 2020 6172 6773              args
-000072d0: 5b69 5d20 3d20 5f61 7267 0a20 2020 2020  [i] = _arg.     
-000072e0: 2020 2020 2020 2069 6620 6869 743a 0a20         if hit:. 
-000072f0: 2020 2020 2020 2020 2020 2020 2020 2072                 r
-00007300: 6574 7572 6e20 7365 6c66 2e66 756e 6328  eturn self.func(
-00007310: 2a61 7267 7329 2e73 696d 706c 6966 7928  *args).simplify(
-00007320: 290a 2020 2020 2020 2020 0a20 2020 2020  ).        .     
-00007330: 2020 2072 6574 7572 6e20 7365 6c66 0a0a     return self..
-00007340: 2020 2020 4070 726f 7065 7274 790a 2020      @property.  
-00007350: 2020 6465 6620 6973 5f55 6e69 7665 7273    def is_Univers
-00007360: 616c 5365 7428 7365 6c66 293a 0a20 2020  alSet(self):.   
-00007370: 2020 2020 2072 6574 7572 6e20 7365 6c66       return self
-00007380: 2e73 7461 7274 2e69 735f 4e65 6761 7469  .start.is_Negati
-00007390: 7665 496e 6669 6e69 7479 2061 6e64 2073  veInfinity and s
-000073a0: 656c 662e 7374 6f70 2e69 735f 496e 6669  elf.stop.is_Infi
-000073b0: 6e69 7479 2061 6e64 205c 0a20 2020 2020  nity and \.     
-000073c0: 2020 2020 2020 2028 7365 6c66 2e6c 6566         (self.lef
-000073d0: 745f 6f70 656e 2061 6e64 2073 656c 662e  t_open and self.
-000073e0: 7269 6768 745f 6f70 656e 206f 7220 6e6f  right_open or no
-000073f0: 7420 7365 6c66 2e6c 6566 745f 6f70 656e  t self.left_open
-00007400: 2061 6e64 206e 6f74 2073 656c 662e 7269   and not self.ri
-00007410: 6768 745f 6f70 656e 290a 2020 2020 0a20  ght_open).    . 
-00007420: 2020 2064 6566 2069 6e74 6572 7365 6374     def intersect
-00007430: 696f 6e5f 7365 7473 2873 656c 662c 2062  ion_sets(self, b
-00007440: 293a 0a20 2020 2020 2020 2069 6620 6e6f  ):.        if no
-00007450: 7420 2862 2e69 735f 496e 7465 7276 616c  t (b.is_Interval
-00007460: 206f 7220 622e 6973 5f52 616e 6765 293a   or b.is_Range):
-00007470: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
-00007480: 7365 6c66 2e69 735f 556e 6976 6572 7361  self.is_Universa
-00007490: 6c53 6574 3a0a 2020 2020 2020 2020 2020  lSet:.          
-000074a0: 2020 2020 2020 6966 2062 2e65 7479 7065        if b.etype
-000074b0: 2069 6e20 7365 6c66 2e65 7479 7065 3a0a   in self.etype:.
-000074c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000074d0: 2020 2020 7265 7475 726e 2062 0a20 2020      return b.   
-000074e0: 2020 2020 2020 2020 2072 6574 7572 6e0a           return.
-000074f0: 2020 2020 2020 2020 2320 6861 6e64 6c65          # handle
-00007500: 2063 6173 6573 206c 696b 6520 282d 6f6f   cases like (-oo
-00007510: 2c20 6f6f 2920 616e 6420 5b2d 6f6f 2c20  , oo) and [-oo, 
-00007520: 6f6f 5d0a 2020 2020 2020 2020 6966 2073  oo].        if s
-00007530: 656c 662e 7374 6172 742e 6973 5f4e 6567  elf.start.is_Neg
-00007540: 6174 6976 6549 6e66 696e 6974 7920 616e  ativeInfinity an
-00007550: 6420 7365 6c66 2e73 746f 702e 6973 5f49  d self.stop.is_I
-00007560: 6e66 696e 6974 793a 0a20 2020 2020 2020  nfinity:.       
-00007570: 2020 2020 2069 6620 622e 6574 7970 652e       if b.etype.
-00007580: 6973 5f72 6561 6c3a 0a20 2020 2020 2020  is_real:.       
-00007590: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
-000075a0: 620a 2020 2020 2020 2020 2020 2020 0a20  b.            . 
-000075b0: 2020 2020 2020 2020 2020 2069 6620 622e             if b.
-000075c0: 6574 7970 652e 6973 5f65 7874 656e 6465  etype.is_extende
-000075d0: 645f 7265 616c 3a0a 2020 2020 2020 2020  d_real:.        
-000075e0: 2020 2020 2020 2020 6672 6f6d 2073 796d          from sym
-000075f0: 7079 2069 6d70 6f72 7420 4e6f 7445 6c65  py import NotEle
-00007600: 6d65 6e74 0a20 2020 2020 2020 2020 2020  ment.           
-00007610: 2020 2020 2069 6620 7365 6c66 2e6c 6566       if self.lef
-00007620: 745f 6f70 656e 3a0a 2020 2020 2020 2020  t_open:.        
-00007630: 2020 2020 2020 2020 2020 2020 6966 2073              if s
-00007640: 656c 662e 7269 6768 745f 6f70 656e 3a0a  elf.right_open:.
-00007650: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007660: 2020 2020 2020 2020 2320 7365 6c66 203d          # self =
-00007670: 2028 2d6f 6f2c 206f 6f29 0a20 2020 2020   (-oo, oo).     
-00007680: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007690: 2020 202e 2e2e 0a20 2020 2020 2020 2020     ....         
-000076a0: 2020 2020 2020 2020 2020 2065 6c73 653a             else:
-000076b0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000076c0: 2020 2020 2020 2020 2023 2073 656c 6620           # self 
-000076d0: 3d20 282d 6f6f 2c20 6f6f 5d0a 2020 2020  = (-oo, oo].    
+00005c90: 636f 6e64 203d 2045 6c65 6d65 6e74 2862  cond = Element(b
+00005ca0: 6c6f 636b 2c20 646f 6d61 696e 290a 2020  lock, domain).  
+00005cb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00005cc0: 2020 2020 2020 0a20 2020 2020 2020 2020        .         
+00005cd0: 2020 2020 2020 2020 2020 2069 6620 636f             if co
+00005ce0: 6e64 3a0a 2020 2020 2020 2020 2020 2020  nd:.            
+00005cf0: 2020 2020 2020 2020 2020 2020 636f 6e74              cont
+00005d00: 696e 7565 2020 2020 2020 2020 2020 2020  inue            
+00005d10: 2020 2020 2020 2020 2020 2020 0a20 2020              .   
+00005d20: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00005d30: 2069 6620 636f 6e64 203d 3d20 4661 6c73   if cond == Fals
+00005d40: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
+00005d50: 2020 2020 2020 2020 2020 2072 6574 7572             retur
+00005d60: 6e20 636f 6e64 0a20 2020 2020 2020 2020  n cond.         
+00005d70: 2020 2020 2020 2020 2020 2072 6574 7572             retur
+00005d80: 6e0a 2020 2020 2020 2020 2020 2020 2020  n.              
+00005d90: 2020 7265 7475 726e 2053 2e74 7275 650a    return S.true.
+00005da0: 2020 2020 2020 2020 656c 6966 206f 7468          elif oth
+00005db0: 6572 2e69 735f 4465 6e73 654d 6174 7269  er.is_DenseMatri
+00005dc0: 783a 0a20 2020 2020 2020 2020 2020 2063  x:.            c
+00005dd0: 6f6e 7461 696e 7320 3d20 4e6f 6e65 0a20  ontains = None. 
+00005de0: 2020 2020 2020 2020 2020 2066 6f72 2061             for a
+00005df0: 7267 2069 6e20 6f74 6865 722e 6172 6773  rg in other.args
+00005e00: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+00005e10: 2020 636f 6e64 203d 2045 6c65 6d65 6e74    cond = Element
+00005e20: 2861 7267 2c20 7365 6c66 2e73 7061 6365  (arg, self.space
+00005e30: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
+00005e40: 2020 6966 2063 6f6e 643a 0a20 2020 2020    if cond:.     
+00005e50: 2020 2020 2020 2020 2020 2020 2020 2069                 i
+00005e60: 6620 636f 6e74 6169 6e73 2069 7320 4e6f  f contains is No
+00005e70: 6e65 3a0a 2020 2020 2020 2020 2020 2020  ne:.            
+00005e80: 2020 2020 2020 2020 2020 2020 636f 6e74              cont
+00005e90: 6169 6e73 203d 2053 2e74 7275 650a 2020  ains = S.true.  
+00005ea0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00005eb0: 2020 656c 6966 2063 6f6e 7461 696e 7320    elif contains 
+00005ec0: 3d3d 2046 616c 7365 3a0a 2020 2020 2020  == False:.      
+00005ed0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00005ee0: 2020 7265 7475 726e 0a20 2020 2020 2020    return.       
+00005ef0: 2020 2020 2020 2020 2065 6c69 6620 636f           elif co
+00005f00: 6e64 203d 3d20 4661 6c73 653a 0a20 2020  nd == False:.   
+00005f10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00005f20: 2069 6620 636f 6e74 6169 6e73 2069 7320   if contains is 
+00005f30: 4e6f 6e65 3a0a 2020 2020 2020 2020 2020  None:.          
+00005f40: 2020 2020 2020 2020 2020 2020 2020 636f                co
+00005f50: 6e74 6169 6e73 203d 2053 2e66 616c 7365  ntains = S.false
+00005f60: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00005f70: 2020 2020 2065 6c69 6620 636f 6e74 6169       elif contai
+00005f80: 6e73 3a0a 2020 2020 2020 2020 2020 2020  ns:.            
+00005f90: 2020 2020 2020 2020 2020 2020 7265 7475              retu
+00005fa0: 726e 0a20 2020 2020 2020 2020 2020 2072  rn.            r
+00005fb0: 6574 7572 6e20 636f 6e74 6169 6e73 0a0a  eturn contains..
+00005fc0: 2020 2020 6465 6620 5f5f 6d75 6c5f 5f28      def __mul__(
+00005fd0: 7365 6c66 2c20 6f74 6865 7229 3a0a 2020  self, other):.  
+00005fe0: 2020 2020 2020 6966 206f 7468 6572 2e69        if other.i
+00005ff0: 735f 7365 743a 0a20 2020 2020 2020 2020  s_set:.         
+00006000: 2020 2061 7373 6572 7420 6c65 6e28 6f74     assert len(ot
+00006010: 6865 722e 6574 7970 652e 7368 6170 6529  her.etype.shape)
+00006020: 203c 206c 656e 2873 656c 662e 6574 7970   < len(self.etyp
+00006030: 652e 7368 6170 6529 0a20 2020 2020 2020  e.shape).       
+00006040: 2072 6574 7572 6e20 7365 6c66 0a20 2020   return self.   
+00006050: 200a 2020 2020 6465 6620 5f5f 6164 645f   .    def __add_
+00006060: 5f28 7365 6c66 2c20 6f74 6865 7229 3a0a  _(self, other):.
+00006070: 2020 2020 2020 2020 6966 206f 7468 6572          if other
+00006080: 2e69 735f 4361 7274 6573 6961 6e53 7061  .is_CartesianSpa
+00006090: 6365 3a0a 2020 2020 2020 2020 2020 2020  ce:.            
+000060a0: 6966 206c 656e 2873 656c 662e 7370 6163  if len(self.spac
+000060b0: 655f 7368 6170 6529 203e 206c 656e 286f  e_shape) > len(o
+000060c0: 7468 6572 2e73 7061 6365 5f73 6861 7065  ther.space_shape
+000060d0: 293a 0a20 2020 2020 2020 2020 2020 2020  ):.             
+000060e0: 2020 2061 7373 6572 7420 7365 6c66 2e73     assert self.s
+000060f0: 7061 6365 5f73 6861 7065 5b3a 6c65 6e28  pace_shape[:len(
+00006100: 6f74 6865 722e 7370 6163 655f 7368 6170  other.space_shap
+00006110: 6529 5d20 3d3d 206f 7468 6572 2e73 7061  e)] == other.spa
+00006120: 6365 5f73 6861 7065 0a20 2020 2020 2020  ce_shape.       
+00006130: 2020 2020 2020 2020 2073 6861 7065 203d           shape =
+00006140: 2073 656c 662e 7370 6163 655f 7368 6170   self.space_shap
+00006150: 650a 2020 2020 2020 2020 2020 2020 656c  e.            el
+00006160: 6966 206c 656e 2873 656c 662e 7370 6163  if len(self.spac
+00006170: 655f 7368 6170 6529 203c 206c 656e 286f  e_shape) < len(o
+00006180: 7468 6572 2e73 7061 6365 5f73 6861 7065  ther.space_shape
+00006190: 293a 0a20 2020 2020 2020 2020 2020 2020  ):.             
+000061a0: 2020 2061 7373 6572 7420 7365 6c66 2e73     assert self.s
+000061b0: 7061 6365 5f73 6861 7065 203d 3d20 6f74  pace_shape == ot
+000061c0: 6865 722e 7370 6163 655f 7368 6170 655b  her.space_shape[
+000061d0: 6c65 6e28 7365 6c66 2e73 7061 6365 5f73  len(self.space_s
+000061e0: 6861 7065 293a 5d0a 2020 2020 2020 2020  hape):].        
+000061f0: 2020 2020 2020 2020 7368 6170 6520 3d20          shape = 
+00006200: 6f74 6865 722e 7370 6163 655f 7368 6170  other.space_shap
+00006210: 650a 2020 2020 2020 2020 2020 2020 656c  e.            el
+00006220: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
+00006230: 2020 2020 6173 7365 7274 2073 656c 662e      assert self.
+00006240: 7370 6163 655f 7368 6170 6520 3d3d 206f  space_shape == o
+00006250: 7468 6572 2e73 7061 6365 5f73 6861 7065  ther.space_shape
+00006260: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00006270: 2073 6861 7065 203d 2073 656c 662e 7370   shape = self.sp
+00006280: 6163 655f 7368 6170 650a 2020 2020 2020  ace_shape.      
+00006290: 2020 2020 2020 7265 7475 726e 2073 656c        return sel
+000062a0: 662e 6675 6e63 2873 656c 662e 7370 6163  f.func(self.spac
+000062b0: 6520 2b20 6f74 6865 722e 7370 6163 652c  e + other.space,
+000062c0: 202a 7368 6170 6529 2020 2020 2020 2020   *shape)        
+000062d0: 0a20 2020 2020 2020 2069 6620 6f74 6865  .        if othe
+000062e0: 722e 6973 5f73 6574 3a0a 2020 2020 2020  r.is_set:.      
+000062f0: 2020 2020 2020 6173 7365 7274 206c 656e        assert len
+00006300: 286f 7468 6572 2e65 7479 7065 2e73 6861  (other.etype.sha
+00006310: 7065 2920 3c20 6c65 6e28 7365 6c66 2e65  pe) < len(self.e
+00006320: 7479 7065 2e73 6861 7065 290a 2020 2020  type.shape).    
+00006330: 2020 2020 7265 7475 726e 2073 656c 660a      return self.
+00006340: 2020 2020 0a20 2020 2064 6566 2069 6e74      .    def int
+00006350: 6572 7365 6374 696f 6e5f 7365 7473 2873  ersection_sets(s
+00006360: 656c 662c 2062 293a 0a20 2020 2020 2020  elf, b):.       
+00006370: 2069 6620 622e 6973 5f43 6172 7465 7369   if b.is_Cartesi
+00006380: 616e 5370 6163 653a 0a20 2020 2020 2020  anSpace:.       
+00006390: 2020 2020 2061 7373 6572 7420 7365 6c66       assert self
+000063a0: 2e73 7061 6365 5f73 6861 7065 203d 3d20  .space_shape == 
+000063b0: 622e 7370 6163 655f 7368 6170 6520 2020  b.space_shape   
+000063c0: 2020 2020 2020 2020 200a 2020 2020 2020           .      
+000063d0: 2020 2020 2020 7265 7475 726e 2073 656c        return sel
+000063e0: 662e 6675 6e63 2873 656c 662e 7370 6163  f.func(self.spac
+000063f0: 6520 2620 622e 7370 6163 652c 202a 7365  e & b.space, *se
+00006400: 6c66 2e73 7061 6365 5f73 6861 7065 290a  lf.space_shape).
+00006410: 2020 2020 2020 2020 656c 6966 2062 2e69          elif b.i
+00006420: 735f 7379 6d62 6f6c 3a0a 2020 2020 2020  s_symbol:.      
+00006430: 2020 2020 2020 6574 7970 6520 3d20 622e        etype = b.
+00006440: 6574 7970 650a 2020 2020 2020 2020 2020  etype.          
+00006450: 2020 6966 2065 7479 7065 2e61 735f 5365    if etype.as_Se
+00006460: 7428 2920 696e 2073 656c 663a 0a20 2020  t() in self:.   
+00006470: 2020 2020 2020 2020 2020 2020 2072 6574               ret
+00006480: 7572 6e20 6220 0a0a 2020 2020 6465 6620  urn b ..    def 
+00006490: 5f6c 6174 6578 2873 656c 662c 2070 293a  _latex(self, p):
+000064a0: 0a20 2020 2020 2020 2073 7061 6365 5f73  .        space_s
+000064b0: 6861 7065 203d 2073 656c 662e 7370 6163  hape = self.spac
+000064c0: 655f 7368 6170 650a 2020 2020 2020 2020  e_shape.        
+000064d0: 6966 206c 656e 2873 7061 6365 5f73 6861  if len(space_sha
+000064e0: 7065 2920 3d3d 2031 3a0a 2020 2020 2020  pe) == 1:.      
+000064f0: 2020 2020 2020 7370 6163 655f 7368 6170        space_shap
+00006500: 6520 3d20 7370 6163 655f 7368 6170 655b  e = space_shape[
+00006510: 305d 0a20 2020 2020 2020 2072 6574 7572  0].        retur
+00006520: 6e20 227b 2573 7d5e 7b25 737d 2220 2520  n "{%s}^{%s}" % 
+00006530: 2870 2e5f 7072 696e 7428 7365 6c66 2e73  (p._print(self.s
+00006540: 7061 6365 292c 2070 2e5f 7072 696e 7428  pace), p._print(
+00006550: 7370 6163 655f 7368 6170 6529 290a 0a20  space_shape)).. 
+00006560: 2020 2040 636c 6173 736d 6574 686f 640a     @classmethod.
+00006570: 2020 2020 6465 6620 7369 6d70 6c69 6679      def simplify
+00006580: 5f45 6c65 6d65 6e74 2863 6c73 2c20 7365  _Element(cls, se
+00006590: 6c66 2c20 652c 2073 293a 0a20 2020 2020  lf, e, s):.     
+000065a0: 2020 206b 203d 2073 656c 662e 6765 6e65     k = self.gene
+000065b0: 7261 7465 5f76 6172 2869 6e74 6567 6572  rate_var(integer
+000065c0: 3d54 7275 6529 0a20 2020 2020 2020 206e  =True).        n
+000065d0: 203d 2065 2e73 6861 7065 5b30 5d0a 2020   = e.shape[0].  
+000065e0: 2020 2020 2020 6966 206e 2e69 735f 496e        if n.is_In
+000065f0: 6669 6e69 7479 3a0a 2020 2020 2020 2020  finity:.        
+00006600: 2020 2020 7265 7475 726e 2073 656c 662e      return self.
+00006610: 6675 6e63 2865 5b6b 5d2c 2063 6c73 2873  func(e[k], cls(s
+00006620: 2e73 7061 6365 2c20 2a73 2e73 7061 6365  .space, *s.space
+00006630: 5f73 6861 7065 5b31 3a5d 2929 0a20 2020  _shape[1:])).   
+00006640: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
+00006650: 2020 2020 2020 2066 726f 6d20 7379 6d70         from symp
+00006660: 792e 636f 6e63 7265 7465 2e66 6f72 616c  y.concrete.foral
+00006670: 6c20 696d 706f 7274 2046 6f72 416c 6c20  l import ForAll 
+00006680: 2020 2020 2020 2020 2020 200a 2020 2020             .    
+00006690: 2020 2020 2020 2020 7265 7475 726e 2046          return F
+000066a0: 6f72 416c 6c5b 6b3a 6e5d 2873 656c 662e  orAll[k:n](self.
+000066b0: 6675 6e63 2865 5b6b 5d2c 2063 6c73 2873  func(e[k], cls(s
+000066c0: 2e73 7061 6365 2c20 2a73 2e73 7061 6365  .space, *s.space
+000066d0: 5f73 6861 7065 5b31 3a5d 2929 2e73 696d  _shape[1:])).sim
+000066e0: 706c 6966 7928 2929 0a20 2020 200a 2020  plify()).    .  
+000066f0: 2020 4063 6c61 7373 6d65 7468 6f64 0a20    @classmethod. 
+00006700: 2020 2064 6566 2073 696d 706c 6966 795f     def simplify_
+00006710: 4e6f 7445 6c65 6d65 6e74 2863 6c73 2c20  NotElement(cls, 
+00006720: 7365 6c66 2c20 652c 2073 293a 200a 2020  self, e, s): .  
+00006730: 2020 2020 2020 6b20 3d20 7365 6c66 2e67        k = self.g
+00006740: 656e 6572 6174 655f 7661 7228 696e 7465  enerate_var(inte
+00006750: 6765 723d 5472 7565 290a 2020 2020 2020  ger=True).      
+00006760: 2020 6e20 3d20 652e 7368 6170 655b 305d    n = e.shape[0]
+00006770: 0a20 2020 2020 2020 2069 6620 6e2e 6973  .        if n.is
+00006780: 5f49 6e66 696e 6974 793a 0a20 2020 2020  _Infinity:.     
+00006790: 2020 2020 2020 2072 6574 7572 6e20 7365         return se
+000067a0: 6c66 2e66 756e 6328 655b 6b5d 2c20 636c  lf.func(e[k], cl
+000067b0: 7328 732e 7370 6163 652c 202a 732e 7370  s(s.space, *s.sp
+000067c0: 6163 655f 7368 6170 655b 313a 5d29 290a  ace_shape[1:])).
+000067d0: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
+000067e0: 2020 2020 2020 2020 2020 6672 6f6d 2073            from s
+000067f0: 796d 7079 2069 6d70 6f72 7420 416e 790a  ympy import Any.
+00006800: 2020 2020 2020 2020 2020 2020 7265 7475              retu
+00006810: 726e 2041 6e79 5b6b 3a6e 5d28 7365 6c66  rn Any[k:n](self
+00006820: 2e66 756e 6328 655b 6b5d 2c20 636c 7328  .func(e[k], cls(
+00006830: 732e 7370 6163 652c 202a 732e 7370 6163  s.space, *s.spac
+00006840: 655f 7368 6170 655b 313a 5d29 2929 0a20  e_shape[1:]))). 
+00006850: 2020 200a 2020 2020 6465 6620 5f65 7661     .    def _eva
+00006860: 6c5f 5375 6273 6574 5f72 6576 6572 7365  l_Subset_reverse
+00006870: 6428 7365 6c66 2c20 6c68 7329 3a20 0a20  d(self, lhs): . 
+00006880: 2020 2020 2020 2069 6620 6c68 732e 6973         if lhs.is
+00006890: 5f53 796d 626f 6c3a 0a20 2020 2020 2020  _Symbol:.       
+000068a0: 2020 2020 2069 6620 6c68 732e 6574 7970       if lhs.etyp
+000068b0: 652e 6173 5f53 6574 2829 2069 6e20 7365  e.as_Set() in se
+000068c0: 6c66 3a0a 2020 2020 2020 2020 2020 2020  lf:.            
+000068d0: 2020 2020 7265 7475 726e 2053 2e74 7275      return S.tru
+000068e0: 650a 0a20 2020 2040 7072 6f70 6572 7479  e..    @property
+000068f0: 0a20 2020 2064 6566 2069 735f 556e 6976  .    def is_Univ
+00006900: 6572 7361 6c53 6574 2873 656c 6629 3a0a  ersalSet(self):.
+00006910: 2020 2020 2020 2020 7265 7475 726e 2073          return s
+00006920: 656c 662e 7370 6163 652e 6973 5f55 6e69  elf.space.is_Uni
+00006930: 7665 7273 616c 5365 740a 0a20 2020 200a  versalSet..    .
+00006940: 636c 6173 7320 496e 7465 7276 616c 2853  class Interval(S
+00006950: 6574 2c20 4576 616c 664d 6978 696e 293a  et, EvalfMixin):
+00006960: 0a20 2020 2022 2222 0a20 2020 2052 6570  .    """.    Rep
+00006970: 7265 7365 6e74 7320 6120 7265 616c 2069  resents a real i
+00006980: 6e74 6572 7661 6c20 6173 2061 2053 6574  nterval as a Set
+00006990: 2e0a 0a20 2020 2055 7361 6765 3a0a 2020  ...    Usage:.  
+000069a0: 2020 2020 2020 5265 7475 726e 7320 616e        Returns an
+000069b0: 2069 6e74 6572 7661 6c20 7769 7468 2065   interval with e
+000069c0: 6e64 2070 6f69 6e74 7320 2273 7461 7274  nd points "start
+000069d0: 2220 616e 6420 2265 6e64 222e 0a0a 2020  " and "end"...  
+000069e0: 2020 2020 2020 466f 7220 6c65 6674 5f6f        For left_o
+000069f0: 7065 6e3d 5472 7565 2028 6465 6661 756c  pen=True (defaul
+00006a00: 7420 6c65 6674 5f6f 7065 6e20 6973 2046  t left_open is F
+00006a10: 616c 7365 2920 7468 6520 696e 7465 7276  alse) the interv
+00006a20: 616c 0a20 2020 2020 2020 2077 696c 6c20  al.        will 
+00006a30: 6265 206f 7065 6e20 6f6e 2074 6865 206c  be open on the l
+00006a40: 6566 742e 2053 696d 696c 6172 6c79 2c20  eft. Similarly, 
+00006a50: 666f 7220 7269 6768 745f 6f70 656e 3d54  for right_open=T
+00006a60: 7275 6520 7468 6520 696e 7465 7276 616c  rue the interval
+00006a70: 0a20 2020 2020 2020 2077 696c 6c20 6265  .        will be
+00006a80: 206f 7065 6e20 6f6e 2074 6865 2072 6967   open on the rig
+00006a90: 6874 2e0a 0a20 2020 2045 7861 6d70 6c65  ht...    Example
+00006aa0: 730a 2020 2020 3d3d 3d3d 3d3d 3d3d 0a0a  s.    ========..
+00006ab0: 2020 2020 3e3e 3e20 6672 6f6d 2073 796d      >>> from sym
+00006ac0: 7079 2069 6d70 6f72 7420 5379 6d62 6f6c  py import Symbol
+00006ad0: 2c20 496e 7465 7276 616c 0a20 2020 203e  , Interval.    >
+00006ae0: 3e3e 2049 6e74 6572 7661 6c28 302c 2031  >> Interval(0, 1
+00006af0: 290a 2020 2020 496e 7465 7276 616c 2830  ).    Interval(0
+00006b00: 2c20 3129 0a20 2020 203e 3e3e 2049 6e74  , 1).    >>> Int
+00006b10: 6572 7661 6c2e 526f 7065 6e28 302c 2031  erval.Ropen(0, 1
+00006b20: 290a 2020 2020 496e 7465 7276 616c 2e52  ).    Interval.R
+00006b30: 6f70 656e 2830 2c20 3129 0a20 2020 203e  open(0, 1).    >
+00006b40: 3e3e 2049 6e74 6572 7661 6c2e 526f 7065  >> Interval.Rope
+00006b50: 6e28 302c 2031 290a 2020 2020 496e 7465  n(0, 1).    Inte
+00006b60: 7276 616c 2e52 6f70 656e 2830 2c20 3129  rval.Ropen(0, 1)
+00006b70: 0a20 2020 203e 3e3e 2049 6e74 6572 7661  .    >>> Interva
+00006b80: 6c2e 4c6f 7065 6e28 302c 2031 290a 2020  l.Lopen(0, 1).  
+00006b90: 2020 496e 7465 7276 616c 2e4c 6f70 656e    Interval.Lopen
+00006ba0: 2830 2c20 3129 0a20 2020 203e 3e3e 2049  (0, 1).    >>> I
+00006bb0: 6e74 6572 7661 6c2e 6f70 656e 2830 2c20  nterval.open(0, 
+00006bc0: 3129 0a20 2020 2049 6e74 6572 7661 6c2e  1).    Interval.
+00006bd0: 6f70 656e 2830 2c20 3129 0a0a 2020 2020  open(0, 1)..    
+00006be0: 3e3e 3e20 6120 3d20 5379 6d62 6f6c 2827  >>> a = Symbol('
+00006bf0: 6127 2c20 7265 616c 3d54 7275 6529 0a20  a', real=True). 
+00006c00: 2020 203e 3e3e 2049 6e74 6572 7661 6c28     >>> Interval(
+00006c10: 302c 2061 290a 2020 2020 496e 7465 7276  0, a).    Interv
+00006c20: 616c 2830 2c20 6129 0a0a 2020 2020 4e6f  al(0, a)..    No
+00006c30: 7465 730a 2020 2020 3d3d 3d3d 3d0a 2020  tes.    =====.  
+00006c40: 2020 2d20 4f6e 6c79 2072 6561 6c20 656e    - Only real en
+00006c50: 6420 706f 696e 7473 2061 7265 2073 7570  d points are sup
+00006c60: 706f 7274 6564 0a20 2020 202d 2049 6e74  ported.    - Int
+00006c70: 6572 7661 6c28 612c 2062 2920 7769 7468  erval(a, b) with
+00006c80: 2061 203e 2062 2077 696c 6c20 7265 7475   a > b will retu
+00006c90: 726e 2074 6865 2065 6d70 7479 2073 6574  rn the empty set
+00006ca0: 0a20 2020 202d 2055 7365 2074 6865 2065  .    - Use the e
+00006cb0: 7661 6c66 2829 206d 6574 686f 6420 746f  valf() method to
+00006cc0: 2074 7572 6e20 616e 2049 6e74 6572 7661   turn an Interva
+00006cd0: 6c20 696e 746f 2061 6e20 6d70 6d61 7468  l into an mpmath
+00006ce0: 0a20 2020 2020 2027 6d70 6927 2069 6e74  .      'mpi' int
+00006cf0: 6572 7661 6c20 696e 7374 616e 6365 0a0a  erval instance..
+00006d00: 2020 2020 5265 6665 7265 6e63 6573 0a20      References. 
+00006d10: 2020 203d 3d3d 3d3d 3d3d 3d3d 3d0a 0a20     ==========.. 
+00006d20: 2020 202e 2e20 5b31 5d20 6874 7470 733a     .. [1] https:
+00006d30: 2f2f 656e 2e77 696b 6970 6564 6961 2e6f  //en.wikipedia.o
+00006d40: 7267 2f77 696b 692f 496e 7465 7276 616c  rg/wiki/Interval
+00006d50: 5f25 3238 6d61 7468 656d 6174 6963 7325  _%28mathematics%
+00006d60: 3239 0a20 2020 2022 2222 0a0a 2020 2020  29.    """..    
+00006d70: 6465 6620 7374 7275 6374 7572 616c 6c79  def structurally
+00006d80: 5f65 7175 616c 2873 656c 662c 206f 7468  _equal(self, oth
+00006d90: 6572 293a 0a20 2020 2020 2020 2069 6620  er):.        if 
+00006da0: 6e6f 7420 6973 696e 7374 616e 6365 286f  not isinstance(o
+00006db0: 7468 6572 2c20 7365 6c66 2e66 756e 6329  ther, self.func)
+00006dc0: 206f 7220 6c65 6e28 7365 6c66 2e61 7267   or len(self.arg
+00006dd0: 7329 2021 3d20 6c65 6e28 6f74 6865 722e  s) != len(other.
+00006de0: 6172 6773 293a 0a20 2020 2020 2020 2020  args):.         
+00006df0: 2020 2072 6574 7572 6e20 4661 6c73 650a     return False.
+00006e00: 2020 2020 2020 2020 6966 2073 656c 662e          if self.
+00006e10: 6c65 6674 5f6f 7065 6e20 213d 206f 7468  left_open != oth
+00006e20: 6572 2e6c 6566 745f 6f70 656e 206f 7220  er.left_open or 
+00006e30: 7365 6c66 2e72 6967 6874 5f6f 7065 6e20  self.right_open 
+00006e40: 213d 206f 7468 6572 2e72 6967 6874 5f6f  != other.right_o
+00006e50: 7065 6e20 6f72 2073 656c 662e 6973 5f69  pen or self.is_i
+00006e60: 6e74 6567 6572 2021 3d20 6f74 6865 722e  nteger != other.
+00006e70: 6973 5f69 6e74 6567 6572 3a0a 2020 2020  is_integer:.    
+00006e80: 2020 2020 2020 2020 7265 7475 726e 2046          return F
+00006e90: 616c 7365 0a20 2020 2020 2020 2066 6f72  alse.        for
+00006ea0: 2078 2c20 7920 696e 207a 6970 2873 656c   x, y in zip(sel
+00006eb0: 662e 6172 6773 5b3a 335d 2c20 6f74 6865  f.args[:3], othe
+00006ec0: 722e 6172 6773 5b3a 335d 293a 0a20 2020  r.args[:3]):.   
+00006ed0: 2020 2020 2020 2020 2069 6620 6e6f 7420           if not 
+00006ee0: 782e 7374 7275 6374 7572 616c 6c79 5f65  x.structurally_e
+00006ef0: 7175 616c 2879 293a 0a20 2020 2020 2020  qual(y):.       
+00006f00: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
+00006f10: 4661 6c73 650a 2020 2020 2020 2020 7265  False.        re
+00006f20: 7475 726e 2054 7275 650a 0a20 2020 2064  turn True..    d
+00006f30: 6566 2073 696d 706c 6966 7928 7365 6c66  ef simplify(self
+00006f40: 2c20 6465 6570 3d46 616c 7365 293a 0a20  , deep=False):. 
+00006f50: 2020 2020 2020 2069 6620 6465 6570 3a0a         if deep:.
+00006f60: 2020 2020 2020 2020 2020 2020 6869 7420              hit 
+00006f70: 3d20 4661 6c73 650a 2020 2020 2020 2020  = False.        
+00006f80: 2020 2020 6172 6773 203d 205b 2a73 656c      args = [*sel
+00006f90: 662e 6172 6773 5d0a 2020 2020 2020 2020  f.args].        
+00006fa0: 2020 2020 666f 7220 692c 2061 7267 2069      for i, arg i
+00006fb0: 6e20 656e 756d 6572 6174 6528 7365 6c66  n enumerate(self
+00006fc0: 2e61 7267 735b 3a33 5d29 3a20 0a20 2020  .args[:3]): .   
+00006fd0: 2020 2020 2020 2020 2020 2020 205f 6172               _ar
+00006fe0: 6720 3d20 6172 672e 7369 6d70 6c69 6679  g = arg.simplify
+00006ff0: 2864 6565 703d 6465 6570 2920 2020 2020  (deep=deep)     
+00007000: 2020 2020 2020 2020 2020 200a 0a20 2020             ..   
+00007010: 2020 2020 2020 2020 2020 2020 2069 6620               if 
+00007020: 5f61 7267 2021 3d20 6172 673a 0a20 2020  _arg != arg:.   
+00007030: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00007040: 2068 6974 203d 2054 7275 650a 2020 2020   hit = True.    
+00007050: 2020 2020 2020 2020 2020 2020 6172 6773              args
+00007060: 5b69 5d20 3d20 5f61 7267 0a20 2020 2020  [i] = _arg.     
+00007070: 2020 2020 2020 2069 6620 6869 743a 0a20         if hit:. 
+00007080: 2020 2020 2020 2020 2020 2020 2020 2072                 r
+00007090: 6574 7572 6e20 7365 6c66 2e66 756e 6328  eturn self.func(
+000070a0: 2a61 7267 7329 2e73 696d 706c 6966 7928  *args).simplify(
+000070b0: 290a 2020 2020 2020 2020 0a20 2020 2020  ).        .     
+000070c0: 2020 2069 6620 7365 6c66 2e69 735f 696e     if self.is_in
+000070d0: 7465 6765 723a 0a20 2020 2020 2020 2020  teger:.         
+000070e0: 2020 2069 6620 7365 6c66 2e6c 6566 745f     if self.left_
+000070f0: 6f70 656e 3a0a 2020 2020 2020 2020 2020  open:.          
+00007100: 2020 2020 2020 7265 7475 726e 2073 656c        return sel
+00007110: 662e 636f 7079 2873 7461 7274 3d73 656c  f.copy(start=sel
+00007120: 662e 7374 6172 7420 2b20 312c 206c 6566  f.start + 1, lef
+00007130: 745f 6f70 656e 3d46 616c 7365 290a 2020  t_open=False).  
+00007140: 2020 2020 2020 7265 7475 726e 2073 656c        return sel
+00007150: 660a 0a20 2020 2040 7072 6f70 6572 7479  f..    @property
+00007160: 0a20 2020 2064 6566 2069 735f 556e 6976  .    def is_Univ
+00007170: 6572 7361 6c53 6574 2873 656c 6629 3a0a  ersalSet(self):.
+00007180: 2020 2020 2020 2020 7265 7475 726e 2073          return s
+00007190: 656c 662e 7374 6172 742e 6973 5f4e 6567  elf.start.is_Neg
+000071a0: 6174 6976 6549 6e66 696e 6974 7920 616e  ativeInfinity an
+000071b0: 6420 7365 6c66 2e73 746f 702e 6973 5f49  d self.stop.is_I
+000071c0: 6e66 696e 6974 7920 616e 6420 5c0a 2020  nfinity and \.  
+000071d0: 2020 2020 2020 2020 2020 2873 656c 662e            (self.
+000071e0: 6c65 6674 5f6f 7065 6e20 616e 6420 7365  left_open and se
+000071f0: 6c66 2e72 6967 6874 5f6f 7065 6e20 6f72  lf.right_open or
+00007200: 206e 6f74 2073 656c 662e 6c65 6674 5f6f   not self.left_o
+00007210: 7065 6e20 616e 6420 6e6f 7420 7365 6c66  pen and not self
+00007220: 2e72 6967 6874 5f6f 7065 6e29 0a20 2020  .right_open).   
+00007230: 200a 2020 2020 6465 6620 696e 7465 7273   .    def inters
+00007240: 6563 7469 6f6e 5f73 6574 7328 7365 6c66  ection_sets(self
+00007250: 2c20 6229 3a0a 2020 2020 2020 2020 6966  , b):.        if
+00007260: 206e 6f74 2028 622e 6973 5f49 6e74 6572   not (b.is_Inter
+00007270: 7661 6c20 6f72 2062 2e69 735f 5261 6e67  val or b.is_Rang
+00007280: 6529 3a0a 2020 2020 2020 2020 2020 2020  e):.            
+00007290: 6966 2073 656c 662e 6973 5f55 6e69 7665  if self.is_Unive
+000072a0: 7273 616c 5365 743a 0a20 2020 2020 2020  rsalSet:.       
+000072b0: 2020 2020 2020 2020 2069 6620 622e 6574           if b.et
+000072c0: 7970 6520 696e 2073 656c 662e 6574 7970  ype in self.etyp
+000072d0: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
+000072e0: 2020 2020 2020 2072 6574 7572 6e20 620a         return b.
+000072f0: 2020 2020 2020 2020 2020 2020 7265 7475              retu
+00007300: 726e 0a20 2020 2020 2020 2023 2068 616e  rn.        # han
+00007310: 646c 6520 6361 7365 7320 6c69 6b65 2028  dle cases like (
+00007320: 2d6f 6f2c 206f 6f29 2061 6e64 205b 2d6f  -oo, oo) and [-o
+00007330: 6f2c 206f 6f5d 0a20 2020 2020 2020 2069  o, oo].        i
+00007340: 6620 7365 6c66 2e73 7461 7274 2e69 735f  f self.start.is_
+00007350: 4e65 6761 7469 7665 496e 6669 6e69 7479  NegativeInfinity
+00007360: 2061 6e64 2073 656c 662e 7374 6f70 2e69   and self.stop.i
+00007370: 735f 496e 6669 6e69 7479 3a0a 2020 2020  s_Infinity:.    
+00007380: 2020 2020 2020 2020 6966 2062 2e65 7479          if b.ety
+00007390: 7065 2e69 735f 7265 616c 3a0a 2020 2020  pe.is_real:.    
+000073a0: 2020 2020 2020 2020 2020 2020 7265 7475              retu
+000073b0: 726e 2062 0a20 2020 2020 2020 2020 2020  rn b.           
+000073c0: 200a 2020 2020 2020 2020 2020 2020 6966   .            if
+000073d0: 2062 2e65 7479 7065 2e69 735f 6578 7465   b.etype.is_exte
+000073e0: 6e64 6564 5f72 6561 6c3a 0a20 2020 2020  nded_real:.     
+000073f0: 2020 2020 2020 2020 2020 2066 726f 6d20             from 
+00007400: 7379 6d70 7920 696d 706f 7274 204e 6f74  sympy import Not
+00007410: 456c 656d 656e 7420 2020 200a 2020 2020  Element    .    
+00007420: 2020 2020 2020 2020 2020 2020 6966 2073              if s
+00007430: 656c 662e 6c65 6674 5f6f 7065 6e3a 0a20  elf.left_open:. 
+00007440: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00007450: 2020 2069 6620 7365 6c66 2e72 6967 6874     if self.right
+00007460: 5f6f 7065 6e3a 0a20 2020 2020 2020 2020  _open:.         
+00007470: 2020 2020 2020 2020 2020 2020 2020 2023                 #
+00007480: 2073 656c 6620 3d20 282d 6f6f 2c20 6f6f   self = (-oo, oo
+00007490: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
+000074a0: 2020 2020 2020 2020 2020 2e2e 2e0a 2020            ....  
+000074b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000074c0: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
+000074d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000074e0: 2320 7365 6c66 203d 2028 2d6f 6f2c 206f  # self = (-oo, o
+000074f0: 6f5d 0a20 2020 2020 2020 2020 2020 2020  o].             
+00007500: 2020 2020 2020 2020 2020 2069 6620 532e             if S.
+00007510: 496e 6669 6e69 7479 2069 6e20 6220 616e  Infinity in b an
+00007520: 6420 4e6f 7445 6c65 6d65 6e74 2853 2e4e  d NotElement(S.N
+00007530: 6567 6174 6976 6549 6e66 696e 6974 792c  egativeInfinity,
+00007540: 2062 293a 0a20 2020 2020 2020 2020 2020   b):.           
+00007550: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00007560: 2072 6574 7572 6e20 620a 2020 2020 2020   return b.      
+00007570: 2020 2020 2020 2020 2020 656c 7365 3a0a            else:.
+00007580: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00007590: 2020 2020 6966 2073 656c 662e 7269 6768      if self.righ
+000075a0: 745f 6f70 656e 3a0a 2020 2020 2020 2020  t_open:.        
+000075b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000075c0: 2320 7365 6c66 203d 205b 2d6f 6f2c 206f  # self = [-oo, o
+000075d0: 6f29 0a20 2020 2020 2020 2020 2020 2020  o).             
+000075e0: 2020 2020 2020 2020 2020 2069 6620 532e             if S.
+000075f0: 4e65 6761 7469 7665 496e 6669 6e69 7479  NegativeInfinity
+00007600: 2069 6e20 6220 616e 6420 4e6f 7445 6c65   in b and NotEle
+00007610: 6d65 6e74 2853 2e49 6e66 696e 6974 792c  ment(S.Infinity,
+00007620: 2062 293a 0a20 2020 2020 2020 2020 2020   b):.           
+00007630: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00007640: 2072 6574 7572 6e20 620a 2020 2020 2020   return b.      
+00007650: 2020 2020 2020 2020 2020 2020 2020 656c                el
+00007660: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
+00007670: 2020 2020 2020 2020 2020 2020 2320 7365              # se
+00007680: 6c66 203d 205b 2d6f 6f2c 206f 6f5d 0a20  lf = [-oo, oo]. 
+00007690: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000076a0: 2020 2020 2020 2069 6620 532e 496e 6669         if S.Infi
+000076b0: 6e69 7479 2069 6e20 6220 616e 6420 532e  nity in b and S.
+000076c0: 4e65 6761 7469 7665 496e 6669 6e69 7479  NegativeInfinity
+000076d0: 2069 6e20 623a 0a20 2020 2020 2020 2020   in b:.         
 000076e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000076f0: 2020 2020 6966 2053 2e49 6e66 696e 6974      if S.Infinit
-00007700: 7920 696e 2062 2061 6e64 204e 6f74 456c  y in b and NotEl
-00007710: 656d 656e 7428 532e 4e65 6761 7469 7665  ement(S.Negative
-00007720: 496e 6669 6e69 7479 2c20 6229 3a0a 2020  Infinity, b):.  
-00007730: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007740: 2020 2020 2020 2020 2020 7265 7475 726e            return
-00007750: 2062 0a20 2020 2020 2020 2020 2020 2020   b.             
-00007760: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
-00007770: 2020 2020 2020 2020 2020 2020 2069 6620               if 
-00007780: 7365 6c66 2e72 6967 6874 5f6f 7065 6e3a  self.right_open:
+000076f0: 2020 2072 6574 7572 6e20 620a 0a20 2020     return b..   
+00007700: 2020 2020 2023 2057 6520 6361 6e27 7420       # We can't 
+00007710: 696e 7465 7273 6563 7420 5b30 2c33 5d20  intersect [0,3] 
+00007720: 7769 7468 205b 782c 365d 202d 2d20 7765  with [x,6] -- we
+00007730: 2064 6f6e 2774 206b 6e6f 7720 6966 2078   don't know if x
+00007740: 3e30 206f 7220 783c 300a 2020 2020 2020  >0 or x<0.      
+00007750: 2020 6966 206e 6f74 2073 656c 662e 5f69    if not self._i
+00007760: 735f 636f 6d70 6172 6162 6c65 2862 293a  s_comparable(b):
+00007770: 200a 200a 2020 2020 2020 2020 2020 2020   . .            
+00007780: 6966 2062 2e69 735f 696e 7465 6765 723a  if b.is_integer:
 00007790: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000077a0: 2020 2020 2020 2020 2023 2073 656c 6620           # self 
-000077b0: 3d20 5b2d 6f6f 2c20 6f6f 290a 2020 2020  = [-oo, oo).    
-000077c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000077d0: 2020 2020 6966 2053 2e4e 6567 6174 6976      if S.Negativ
-000077e0: 6549 6e66 696e 6974 7920 696e 2062 2061  eInfinity in b a
-000077f0: 6e64 204e 6f74 456c 656d 656e 7428 532e  nd NotElement(S.
-00007800: 496e 6669 6e69 7479 2c20 6229 3a0a 2020  Infinity, b):.  
-00007810: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007820: 2020 2020 2020 2020 2020 7265 7475 726e            return
-00007830: 2062 0a20 2020 2020 2020 2020 2020 2020   b.             
-00007840: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
-00007850: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007860: 2020 2020 2023 2073 656c 6620 3d20 5b2d       # self = [-
-00007870: 6f6f 2c20 6f6f 5d0a 2020 2020 2020 2020  oo, oo].        
+000077a0: 2072 6574 7572 6e20 7365 6c66 2e63 6f70   return self.cop
+000077b0: 7928 696e 7465 6765 723d 5472 7565 2920  y(integer=True) 
+000077c0: 2620 6220 2020 2020 2020 2020 2020 2020  & b             
+000077d0: 2020 200a 2020 2020 2020 2020 2020 2020     .            
+000077e0: 0a20 2020 2020 2020 2020 2020 2066 726f  .            fro
+000077f0: 6d20 7379 6d70 7920 696d 706f 7274 204d  m sympy import M
+00007800: 696e 2c20 4d61 780a 2020 2020 2020 2020  in, Max.        
+00007810: 2020 2020 6966 2073 656c 662e 6c65 6674      if self.left
+00007820: 5f6f 7065 6e3a 0a20 2020 2020 2020 2020  _open:.         
+00007830: 2020 2020 2020 2069 6620 622e 6c65 6674         if b.left
+00007840: 5f6f 7065 6e3a 0a20 2020 2020 2020 2020  _open:.         
+00007850: 2020 2020 2020 2020 2020 2073 7461 7274             start
+00007860: 203d 204d 6178 2873 656c 662e 7374 6172   = Max(self.star
+00007870: 742c 2062 2e73 7461 7274 2920 0a20 2020  t, b.start) .   
 00007880: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007890: 6966 2053 2e49 6e66 696e 6974 7920 696e  if S.Infinity in
-000078a0: 2062 2061 6e64 2053 2e4e 6567 6174 6976   b and S.Negativ
-000078b0: 6549 6e66 696e 6974 7920 696e 2062 3a0a  eInfinity in b:.
-000078c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000078d0: 2020 2020 2020 2020 2020 2020 7265 7475              retu
-000078e0: 726e 2062 0a0a 2020 2020 2020 2020 2320  rn b..        # 
-000078f0: 5765 2063 616e 2774 2069 6e74 6572 7365  We can't interse
-00007900: 6374 205b 302c 335d 2077 6974 6820 5b78  ct [0,3] with [x
-00007910: 2c36 5d20 2d2d 2077 6520 646f 6e27 7420  ,6] -- we don't 
-00007920: 6b6e 6f77 2069 6620 783e 3020 6f72 2078  know if x>0 or x
-00007930: 3c30 0a20 2020 2020 2020 2069 6620 6e6f  <0.        if no
-00007940: 7420 7365 6c66 2e5f 6973 5f63 6f6d 7061  t self._is_compa
-00007950: 7261 626c 6528 6229 3a20 0a20 0a20 2020  rable(b): . .   
-00007960: 2020 2020 2020 2020 2069 6620 622e 6574           if b.et
-00007970: 7970 652e 6973 5f69 6e74 6567 6572 3a0a  ype.is_integer:.
-00007980: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007990: 7265 7475 726e 2073 656c 662e 636f 7079  return self.copy
-000079a0: 2869 6e74 6567 6572 3d54 7275 6529 2026  (integer=True) &
-000079b0: 2062 0a20 2020 2020 2020 2020 2020 200a   b.            .
-000079c0: 2020 2020 2020 2020 2020 2020 6672 6f6d              from
-000079d0: 2073 796d 7079 2069 6d70 6f72 7420 4d69   sympy import Mi
-000079e0: 6e2c 204d 6178 0a20 2020 2020 2020 2020  n, Max.         
-000079f0: 2020 2069 6620 7365 6c66 2e6c 6566 745f     if self.left_
-00007a00: 6f70 656e 3a0a 2020 2020 2020 2020 2020  open:.          
-00007a10: 2020 2020 2020 6966 2062 2e6c 6566 745f        if b.left_
-00007a20: 6f70 656e 3a0a 2020 2020 2020 2020 2020  open:.          
-00007a30: 2020 2020 2020 2020 2020 7374 6172 7420            start 
-00007a40: 3d20 4d61 7828 7365 6c66 2e73 7461 7274  = Max(self.start
-00007a50: 2c20 622e 7374 6172 7429 200a 2020 2020  , b.start) .    
-00007a60: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007a70: 6c65 6674 5f6f 7065 6e20 3d20 5472 7565  left_open = True
-00007a80: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00007a90: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
-00007aa0: 2020 2020 2020 2020 2020 2069 6620 7365             if se
-00007ab0: 6c66 2e73 7461 7274 203c 2062 2e73 7461  lf.start < b.sta
-00007ac0: 7274 3a0a 2020 2020 2020 2020 2020 2020  rt:.            
-00007ad0: 2020 2020 2020 2020 2020 2020 7374 6172              star
-00007ae0: 7420 3d20 622e 7374 6172 740a 2020 2020  t = b.start.    
-00007af0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007b00: 2020 2020 6c65 6674 5f6f 7065 6e20 3d20      left_open = 
-00007b10: 4661 6c73 650a 2020 2020 2020 2020 2020  False.          
-00007b20: 2020 2020 2020 2020 2020 656c 6966 2073            elif s
-00007b30: 656c 662e 7374 6172 7420 3e3d 2062 2e73  elf.start >= b.s
-00007b40: 7461 7274 3a0a 2320 2020 2020 2020 2020  tart:.#         
-00007b50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007b60: 2020 2020 2861 2c20 6229 2c20 5b61 272c      (a, b), [a',
-00007b70: 2062 275d 0a20 2020 2020 2020 2020 2020   b'].           
-00007b80: 2020 2020 2020 2020 2020 2020 2073 7461               sta
-00007b90: 7274 203d 2073 656c 662e 7374 6172 740a  rt = self.start.
-00007ba0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007bb0: 2020 2020 2020 2020 6c65 6674 5f6f 7065          left_ope
-00007bc0: 6e20 3d20 5472 7565 0a20 2020 2020 2020  n = True.       
-00007bd0: 2020 2020 2020 2020 2020 2020 2065 6c73               els
-00007be0: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
-00007bf0: 2020 2020 2020 2020 2020 2072 6574 7572             retur
-00007c00: 6e0a 2020 2020 2020 2020 2020 2020 2020  n.              
-00007c10: 2020 2020 2020 2020 2020 0a20 2020 2020            .     
-00007c20: 2020 2020 2020 2020 2020 2069 6620 7365             if se
-00007c30: 6c66 2e72 6967 6874 5f6f 7065 6e3a 200a  lf.right_open: .
+00007890: 206c 6566 745f 6f70 656e 203d 2054 7275   left_open = Tru
+000078a0: 650a 2020 2020 2020 2020 2020 2020 2020  e.              
+000078b0: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
+000078c0: 2020 2020 2020 2020 2020 2020 6966 2073              if s
+000078d0: 656c 662e 7374 6172 7420 3c20 622e 7374  elf.start < b.st
+000078e0: 6172 743a 0a20 2020 2020 2020 2020 2020  art:.           
+000078f0: 2020 2020 2020 2020 2020 2020 2073 7461               sta
+00007900: 7274 203d 2062 2e73 7461 7274 0a20 2020  rt = b.start.   
+00007910: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00007920: 2020 2020 206c 6566 745f 6f70 656e 203d       left_open =
+00007930: 2046 616c 7365 0a20 2020 2020 2020 2020   False.         
+00007940: 2020 2020 2020 2020 2020 2065 6c69 6620             elif 
+00007950: 7365 6c66 2e73 7461 7274 203e 3d20 622e  self.start >= b.
+00007960: 7374 6172 743a 0a23 2020 2020 2020 2020  start:.#        
+00007970: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00007980: 2020 2020 2028 612c 2062 292c 205b 6127       (a, b), [a'
+00007990: 2c20 6227 5d0a 2020 2020 2020 2020 2020  , b'].          
+000079a0: 2020 2020 2020 2020 2020 2020 2020 7374                st
+000079b0: 6172 7420 3d20 7365 6c66 2e73 7461 7274  art = self.start
+000079c0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000079d0: 2020 2020 2020 2020 206c 6566 745f 6f70           left_op
+000079e0: 656e 203d 2054 7275 650a 2020 2020 2020  en = True.      
+000079f0: 2020 2020 2020 2020 2020 2020 2020 656c                el
+00007a00: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
+00007a10: 2020 2020 2020 2020 2020 2020 7265 7475              retu
+00007a20: 726e 0a20 2020 2020 2020 2020 2020 2020  rn.             
+00007a30: 2020 2020 2020 2020 2020 200a 2020 2020             .    
+00007a40: 2020 2020 2020 2020 2020 2020 6966 2073              if s
+00007a50: 656c 662e 7269 6768 745f 6f70 656e 3a20  elf.right_open: 
+00007a60: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00007a70: 2020 2020 2069 6620 622e 7269 6768 745f       if b.right_
+00007a80: 6f70 656e 3a20 0a20 2020 2020 2020 2020  open: .         
+00007a90: 2020 2020 2020 2020 2020 2020 2020 2073                 s
+00007aa0: 746f 7020 3d20 4d69 6e28 7365 6c66 2e73  top = Min(self.s
+00007ab0: 746f 702c 2062 2e73 746f 7029 0a20 2020  top, b.stop).   
+00007ac0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00007ad0: 2020 2020 2072 6967 6874 5f6f 7065 6e20       right_open 
+00007ae0: 3d20 5472 7565 0a20 2020 2020 2020 2020  = True.         
+00007af0: 2020 2020 2020 2020 2020 2065 6c73 653a             else:
+00007b00: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00007b10: 2020 2020 2020 2020 2069 6620 622e 7374           if b.st
+00007b20: 6f70 203c 2073 656c 662e 7374 6f70 3a0a  op < self.stop:.
+00007b30: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00007b40: 2020 2020 2020 2020 2020 2020 7374 6f70              stop
+00007b50: 203d 2062 2e73 746f 700a 2020 2020 2020   = b.stop.      
+00007b60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00007b70: 2020 2020 2020 7269 6768 745f 6f70 656e        right_open
+00007b80: 203d 2046 616c 7365 0a20 2020 2020 2020   = False.       
+00007b90: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00007ba0: 2065 6c69 6620 622e 7374 6f70 203e 3d20   elif b.stop >= 
+00007bb0: 7365 6c66 2e73 746f 703a 0a20 2020 2020  self.stop:.     
+00007bc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00007bd0: 2020 2020 2020 2073 746f 7020 3d20 7365         stop = se
+00007be0: 6c66 2e73 746f 700a 2020 2020 2020 2020  lf.stop.        
+00007bf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00007c00: 2020 2020 7269 6768 745f 6f70 656e 203d      right_open =
+00007c10: 2054 7275 650a 2020 2020 2020 2020 2020   True.          
+00007c20: 2020 2020 2020 2020 2020 2020 2020 656c                el
+00007c30: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
 00007c40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007c50: 2020 2020 6966 2062 2e72 6967 6874 5f6f      if b.right_o
-00007c60: 7065 6e3a 200a 2020 2020 2020 2020 2020  pen: .          
-00007c70: 2020 2020 2020 2020 2020 2020 2020 7374                st
-00007c80: 6f70 203d 204d 696e 2873 656c 662e 7374  op = Min(self.st
-00007c90: 6f70 2c20 622e 7374 6f70 290a 2020 2020  op, b.stop).    
-00007ca0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007cb0: 2020 2020 7269 6768 745f 6f70 656e 203d      right_open =
-00007cc0: 2054 7275 650a 2020 2020 2020 2020 2020   True.          
-00007cd0: 2020 2020 2020 2020 2020 656c 7365 3a0a            else:.
-00007ce0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007cf0: 2020 2020 2020 2020 6966 2062 2e73 746f          if b.sto
-00007d00: 7020 3c20 7365 6c66 2e73 746f 703a 0a20  p < self.stop:. 
-00007d10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007d20: 2020 2020 2020 2020 2020 2073 746f 7020             stop 
-00007d30: 3d20 622e 7374 6f70 0a20 2020 2020 2020  = b.stop.       
-00007d40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007d50: 2020 2020 2072 6967 6874 5f6f 7065 6e20       right_open 
-00007d60: 3d20 4661 6c73 650a 2020 2020 2020 2020  = False.        
-00007d70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007d80: 656c 6966 2062 2e73 746f 7020 3e3d 2073  elif b.stop >= s
-00007d90: 656c 662e 7374 6f70 3a0a 2020 2020 2020  elf.stop:.      
-00007da0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007db0: 2020 2020 2020 7374 6f70 203d 2073 656c        stop = sel
-00007dc0: 662e 7374 6f70 0a20 2020 2020 2020 2020  f.stop.         
+00007c50: 7265 7475 726e 0a20 2020 2020 2020 2020  return.         
+00007c60: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
+00007c70: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00007c80: 2069 6620 622e 7269 6768 745f 6f70 656e   if b.right_open
+00007c90: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+00007ca0: 2020 2020 2020 2020 2020 6966 2073 656c            if sel
+00007cb0: 662e 7374 6f70 203e 3d20 622e 7374 6f70  f.stop >= b.stop
+00007cc0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+00007cd0: 2020 2020 2020 2020 2020 2020 2020 7374                st
+00007ce0: 6f70 203d 2062 2e73 746f 700a 2020 2020  op = b.stop.    
+00007cf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00007d00: 2020 2020 2020 2020 7269 6768 745f 6f70          right_op
+00007d10: 656e 203d 2054 7275 650a 2020 2020 2020  en = True.      
+00007d20: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00007d30: 2020 656c 6966 2073 656c 662e 7374 6f70    elif self.stop
+00007d40: 203c 2062 2e73 746f 703a 0a20 2020 2020   < b.stop:.     
+00007d50: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00007d60: 2020 2020 2020 2073 746f 7020 3d20 7365         stop = se
+00007d70: 6c66 2e73 746f 700a 2020 2020 2020 2020  lf.stop.        
+00007d80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00007d90: 2020 2020 7269 6768 745f 6f70 656e 203d      right_open =
+00007da0: 2046 616c 7365 0a20 2020 2020 2020 2020   False.         
+00007db0: 2020 2020 2020 2020 2020 2020 2020 2065                 e
+00007dc0: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
 00007dd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007de0: 2020 2072 6967 6874 5f6f 7065 6e20 3d20     right_open = 
-00007df0: 5472 7565 0a20 2020 2020 2020 2020 2020  True.           
-00007e00: 2020 2020 2020 2020 2020 2020 2065 6c73               els
-00007e10: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
-00007e20: 2020 2020 2020 2020 2020 2020 2020 2072                 r
-00007e30: 6574 7572 6e0a 2020 2020 2020 2020 2020  eturn.          
-00007e40: 2020 2020 2020 656c 7365 3a0a 2020 2020        else:.    
-00007e50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007e60: 6966 2062 2e72 6967 6874 5f6f 7065 6e3a  if b.right_open:
-00007e70: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00007e80: 2020 2020 2020 2020 2069 6620 7365 6c66           if self
-00007e90: 2e73 746f 7020 3e3d 2062 2e73 746f 703a  .stop >= b.stop:
-00007ea0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00007eb0: 2020 2020 2020 2020 2020 2020 2073 746f               sto
-00007ec0: 7020 3d20 622e 7374 6f70 0a20 2020 2020  p = b.stop.     
-00007ed0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007ee0: 2020 2020 2020 2072 6967 6874 5f6f 7065         right_ope
-00007ef0: 6e20 3d20 5472 7565 0a20 2020 2020 2020  n = True.       
-00007f00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007f10: 2065 6c69 6620 7365 6c66 2e73 746f 7020   elif self.stop 
-00007f20: 3c20 622e 7374 6f70 3a0a 2020 2020 2020  < b.stop:.      
-00007f30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007f40: 2020 2020 2020 7374 6f70 203d 2073 656c        stop = sel
-00007f50: 662e 7374 6f70 0a20 2020 2020 2020 2020  f.stop.         
-00007f60: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007f70: 2020 2072 6967 6874 5f6f 7065 6e20 3d20     right_open = 
-00007f80: 4661 6c73 650a 2020 2020 2020 2020 2020  False.          
-00007f90: 2020 2020 2020 2020 2020 2020 2020 656c                el
-00007fa0: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
-00007fb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007fc0: 7265 7475 726e 0a20 2020 2020 2020 2020  return.         
-00007fd0: 2020 2020 2020 2020 2020 2065 6c73 653a             else:
-00007fe0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00007ff0: 2020 2020 2020 2020 2073 746f 7020 3d20           stop = 
-00008000: 4d69 6e28 7365 6c66 2e73 746f 702c 2062  Min(self.stop, b
-00008010: 2e73 746f 7029 0a20 2020 2020 2020 2020  .stop).         
-00008020: 2020 2020 2020 2020 2020 2020 2020 2072                 r
-00008030: 6967 6874 5f6f 7065 6e20 3d20 4661 6c73  ight_open = Fals
-00008040: 650a 2020 2020 2020 2020 2020 2020 656c  e.            el
-00008050: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
-00008060: 2020 2020 6966 2062 2e6c 6566 745f 6f70      if b.left_op
-00008070: 656e 3a0a 2020 2020 2020 2020 2020 2020  en:.            
-00008080: 2020 2020 2020 2020 6966 2073 656c 662e          if self.
-00008090: 7374 6172 7420 3c3d 2062 2e73 7461 7274  start <= b.start
-000080a0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-000080b0: 2020 2020 2020 2020 2020 7374 6172 7420            start 
-000080c0: 3d20 622e 7374 6172 740a 2020 2020 2020  = b.start.      
-000080d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000080e0: 2020 6c65 6674 5f6f 7065 6e20 3d20 5472    left_open = Tr
-000080f0: 7565 0a20 2020 2020 2020 2020 2020 2020  ue.             
-00008100: 2020 2020 2020 2065 6c69 6620 7365 6c66         elif self
-00008110: 2e73 7461 7274 203e 2062 2e73 7461 7274  .start > b.start
-00008120: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-00008130: 2020 2020 2020 2020 2020 7374 6172 7420            start 
-00008140: 3d20 7365 6c66 2e73 7461 7274 0a20 2020  = self.start.   
-00008150: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008160: 2020 2020 206c 6566 745f 6f70 656e 203d       left_open =
-00008170: 2046 616c 7365 0a20 2020 2020 2020 2020   False.         
-00008180: 2020 2020 2020 2020 2020 2065 6c73 653a             else:
+00007de0: 2072 6574 7572 6e0a 2020 2020 2020 2020   return.        
+00007df0: 2020 2020 2020 2020 2020 2020 656c 7365              else
+00007e00: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+00007e10: 2020 2020 2020 2020 2020 7374 6f70 203d            stop =
+00007e20: 204d 696e 2873 656c 662e 7374 6f70 2c20   Min(self.stop, 
+00007e30: 622e 7374 6f70 290a 2020 2020 2020 2020  b.stop).        
+00007e40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00007e50: 7269 6768 745f 6f70 656e 203d 2046 616c  right_open = Fal
+00007e60: 7365 0a20 2020 2020 2020 2020 2020 2065  se.            e
+00007e70: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
+00007e80: 2020 2020 2069 6620 622e 6c65 6674 5f6f       if b.left_o
+00007e90: 7065 6e3a 0a20 2020 2020 2020 2020 2020  pen:.           
+00007ea0: 2020 2020 2020 2020 2069 6620 7365 6c66           if self
+00007eb0: 2e73 7461 7274 203c 3d20 622e 7374 6172  .start <= b.star
+00007ec0: 743a 0a20 2020 2020 2020 2020 2020 2020  t:.             
+00007ed0: 2020 2020 2020 2020 2020 2073 7461 7274             start
+00007ee0: 203d 2062 2e73 7461 7274 0a20 2020 2020   = b.start.     
+00007ef0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00007f00: 2020 206c 6566 745f 6f70 656e 203d 2054     left_open = T
+00007f10: 7275 650a 2020 2020 2020 2020 2020 2020  rue.            
+00007f20: 2020 2020 2020 2020 656c 6966 2073 656c          elif sel
+00007f30: 662e 7374 6172 7420 3e20 622e 7374 6172  f.start > b.star
+00007f40: 743a 0a20 2020 2020 2020 2020 2020 2020  t:.             
+00007f50: 2020 2020 2020 2020 2020 2073 7461 7274             start
+00007f60: 203d 2073 656c 662e 7374 6172 740a 2020   = self.start.  
+00007f70: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00007f80: 2020 2020 2020 6c65 6674 5f6f 7065 6e20        left_open 
+00007f90: 3d20 4661 6c73 650a 2020 2020 2020 2020  = False.        
+00007fa0: 2020 2020 2020 2020 2020 2020 656c 7365              else
+00007fb0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+00007fc0: 2020 2020 2020 2020 2020 7265 7475 726e            return
+00007fd0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00007fe0: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
+00007ff0: 2020 2020 2020 2020 2020 2073 7461 7274             start
+00008000: 203d 204d 6178 2873 656c 662e 7374 6172   = Max(self.star
+00008010: 742c 2062 2e73 7461 7274 290a 2020 2020  t, b.start).    
+00008020: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00008030: 6c65 6674 5f6f 7065 6e20 3d20 4661 6c73  left_open = Fals
+00008040: 650a 2020 2020 2020 2020 2020 2020 2020  e.              
+00008050: 2020 2020 2020 0a20 2020 2020 2020 2020        .         
+00008060: 2020 2020 2020 2069 6620 7365 6c66 2e72         if self.r
+00008070: 6967 6874 5f6f 7065 6e3a 200a 2020 2020  ight_open: .    
+00008080: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00008090: 6966 2062 2e72 6967 6874 5f6f 7065 6e3a  if b.right_open:
+000080a0: 200a 2020 2020 2020 2020 2020 2020 2020   .              
+000080b0: 2020 2020 2020 2020 2020 7374 6f70 203d            stop =
+000080c0: 204d 696e 2873 656c 662e 7374 6f70 2c20   Min(self.stop, 
+000080d0: 622e 7374 6f70 290a 2020 2020 2020 2020  b.stop).        
+000080e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000080f0: 7269 6768 745f 6f70 656e 203d 2054 7275  right_open = Tru
+00008100: 6520 2020 2020 2020 2020 2020 2020 2020  e               
+00008110: 2020 2020 2020 2020 2020 2020 200a 2020               .  
+00008120: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00008130: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
+00008140: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00008150: 6966 2073 656c 662e 7374 6f70 203e 2062  if self.stop > b
+00008160: 2e73 746f 703a 0a20 2020 2020 2020 2020  .stop:.         
+00008170: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00008180: 2020 2073 746f 7020 3d20 622e 7374 6f70     stop = b.stop
 00008190: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000081a0: 2020 2020 2020 2020 2072 6574 7572 6e0a           return.
-000081b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000081c0: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
-000081d0: 2020 2020 2020 2020 2020 7374 6172 7420            start 
-000081e0: 3d20 4d61 7828 7365 6c66 2e73 7461 7274  = Max(self.start
-000081f0: 2c20 622e 7374 6172 7429 0a20 2020 2020  , b.start).     
-00008200: 2020 2020 2020 2020 2020 2020 2020 206c                 l
-00008210: 6566 745f 6f70 656e 203d 2046 616c 7365  eft_open = False
-00008220: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00008230: 2020 2020 200a 2020 2020 2020 2020 2020       .          
-00008240: 2020 2020 2020 6966 2073 656c 662e 7269        if self.ri
-00008250: 6768 745f 6f70 656e 3a20 0a20 2020 2020  ght_open: .     
-00008260: 2020 2020 2020 2020 2020 2020 2020 2069                 i
-00008270: 6620 622e 7269 6768 745f 6f70 656e 3a20  f b.right_open: 
-00008280: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00008290: 2020 2020 2020 2020 2073 746f 7020 3d20           stop = 
-000082a0: 4d69 6e28 7365 6c66 2e73 746f 702c 2062  Min(self.stop, b
-000082b0: 2e73 746f 7029 0a20 2020 2020 2020 2020  .stop).         
-000082c0: 2020 2020 2020 2020 2020 2020 2020 2072                 r
-000082d0: 6967 6874 5f6f 7065 6e20 3d20 5472 7565  ight_open = True
-000082e0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000082f0: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
-00008300: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008310: 2020 2069 6620 7365 6c66 2e73 746f 7020     if self.stop 
-00008320: 3e20 622e 7374 6f70 3a0a 2020 2020 2020  > b.stop:.      
-00008330: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008340: 2020 2020 2020 7374 6f70 203d 2062 2e73        stop = b.s
-00008350: 746f 700a 2020 2020 2020 2020 2020 2020  top.            
-00008360: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008370: 7269 6768 745f 6f70 656e 203d 2046 616c  right_open = Fal
-00008380: 7365 0a20 2020 2020 2020 2020 2020 2020  se.             
-00008390: 2020 2020 2020 2020 2020 2065 6c69 6620             elif 
-000083a0: 7365 6c66 2e73 746f 7020 3c3d 2062 2e73  self.stop <= b.s
-000083b0: 746f 703a 0a23 2020 2020 2020 2020 2020  top:.#          
-000083c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000083d0: 2020 2020 2020 205b 612c 2062 292c 205b         [a, b), [
-000083e0: 612c 2062 275d 0a20 2020 2020 2020 2020  a, b'].         
-000083f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008400: 2020 2073 746f 7020 3d20 7365 6c66 2e73     stop = self.s
-00008410: 746f 700a 2020 2020 2020 2020 2020 2020  top.            
-00008420: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008430: 7269 6768 745f 6f70 656e 203d 2054 7275  right_open = Tru
-00008440: 650a 2020 2020 2020 2020 2020 2020 2020  e.              
-00008450: 2020 2020 2020 2020 2020 656c 7365 3a20            else: 
-00008460: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00008470: 2020 2020 2020 2020 2020 2020 2072 6574               ret
-00008480: 7572 6e0a 2020 2020 2020 2020 2020 2020  urn.            
-00008490: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
-000084a0: 2020 2020 2020 2020 2020 2020 2020 6966                if
-000084b0: 2062 2e72 6967 6874 5f6f 7065 6e3a 0a20   b.right_open:. 
+000081a0: 2020 2020 2020 2020 2020 2020 2072 6967               rig
+000081b0: 6874 5f6f 7065 6e20 3d20 4661 6c73 650a  ht_open = False.
+000081c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000081d0: 2020 2020 2020 2020 656c 6966 2073 656c          elif sel
+000081e0: 662e 7374 6f70 203c 3d20 622e 7374 6f70  f.stop <= b.stop
+000081f0: 3a0a 2320 2020 2020 2020 2020 2020 2020  :.#             
+00008200: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00008210: 2020 2020 5b61 2c20 6229 2c20 5b61 2c20      [a, b), [a, 
+00008220: 6227 5d0a 2020 2020 2020 2020 2020 2020  b'].            
+00008230: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00008240: 7374 6f70 203d 2073 656c 662e 7374 6f70  stop = self.stop
+00008250: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00008260: 2020 2020 2020 2020 2020 2020 2072 6967               rig
+00008270: 6874 5f6f 7065 6e20 3d20 5472 7565 0a20  ht_open = True. 
+00008280: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00008290: 2020 2020 2020 2065 6c73 653a 200a 2020         else: .  
+000082a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000082b0: 2020 2020 2020 2020 2020 7265 7475 726e            return
+000082c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000082d0: 2020 2020 2020 2020 2020 2020 0a20 2020              .   
+000082e0: 2020 2020 2020 2020 2020 2020 2065 6c73               els
+000082f0: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
+00008300: 2020 2020 2020 2069 6620 622e 7269 6768         if b.righ
+00008310: 745f 6f70 656e 3a0a 2020 2020 2020 2020  t_open:.        
+00008320: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00008330: 6966 2073 656c 662e 7374 6f70 203c 2062  if self.stop < b
+00008340: 2e73 746f 703a 0a20 2020 2020 2020 2020  .stop:.         
+00008350: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00008360: 2020 2073 746f 7020 3d20 7365 6c66 2e73     stop = self.s
+00008370: 746f 700a 2020 2020 2020 2020 2020 2020  top.            
+00008380: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00008390: 7269 6768 745f 6f70 656e 203d 2046 616c  right_open = Fal
+000083a0: 7365 0a20 2020 2020 2020 2020 2020 2020  se.             
+000083b0: 2020 2020 2020 2020 2020 2065 6c69 6620             elif 
+000083c0: 7365 6c66 2e73 746f 7020 3e3d 2062 2e73  self.stop >= b.s
+000083d0: 746f 703a 0a20 2020 2020 2020 2020 2020  top:.           
+000083e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000083f0: 2073 746f 7020 3d20 622e 7374 6f70 0a20   stop = b.stop. 
+00008400: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00008410: 2020 2020 2020 2020 2020 2072 6967 6874             right
+00008420: 5f6f 7065 6e20 3d20 5472 7565 0a20 2020  _open = True.   
+00008430: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00008440: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
+00008450: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00008460: 2020 2020 2020 2072 6574 7572 6e20 0a20         return . 
+00008470: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00008480: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
+00008490: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000084a0: 2073 746f 7020 3d20 4d69 6e28 7365 6c66   stop = Min(self
+000084b0: 2e73 746f 702c 2062 2e73 746f 7029 0a20  .stop, b.stop). 
 000084c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000084d0: 2020 2020 2020 2069 6620 7365 6c66 2e73         if self.s
-000084e0: 746f 7020 3c20 622e 7374 6f70 3a0a 2020  top < b.stop:.  
+000084d0: 2020 2020 2020 2072 6967 6874 5f6f 7065         right_ope
+000084e0: 6e20 3d20 4661 6c73 650a 2020 2020 2020  n = False.      
 000084f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008500: 2020 2020 2020 2020 2020 7374 6f70 203d            stop =
-00008510: 2073 656c 662e 7374 6f70 0a20 2020 2020   self.stop.     
-00008520: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008530: 2020 2020 2020 2072 6967 6874 5f6f 7065         right_ope
-00008540: 6e20 3d20 4661 6c73 650a 2020 2020 2020  n = False.      
-00008550: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008560: 2020 656c 6966 2073 656c 662e 7374 6f70    elif self.stop
-00008570: 203e 3d20 622e 7374 6f70 3a0a 2020 2020   >= b.stop:.    
-00008580: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008590: 2020 2020 2020 2020 7374 6f70 203d 2062          stop = b
-000085a0: 2e73 746f 700a 2020 2020 2020 2020 2020  .stop.          
-000085b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000085c0: 2020 7269 6768 745f 6f70 656e 203d 2054    right_open = T
-000085d0: 7275 650a 2020 2020 2020 2020 2020 2020  rue.            
-000085e0: 2020 2020 2020 2020 2020 2020 656c 7365              else
-000085f0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-00008600: 2020 2020 2020 2020 2020 2020 2020 7265                re
-00008610: 7475 726e 0a20 2020 2020 2020 2020 2020  turn.           
-00008620: 2020 2020 2020 2020 2065 6c73 653a 0a20           else:. 
-00008630: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008640: 2020 2020 2020 2073 746f 7020 3d20 4d69         stop = Mi
-00008650: 6e28 7365 6c66 2e73 746f 702c 2062 2e73  n(self.stop, b.s
-00008660: 746f 7029 0a20 2020 2020 2020 2020 2020  top).           
-00008670: 2020 2020 2020 2020 2020 2020 2072 6967               rig
-00008680: 6874 5f6f 7065 6e20 3d20 4661 6c73 650a  ht_open = False.
-00008690: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000086a0: 2020 2020 2020 2020 0a20 2020 2020 2020          .       
-000086b0: 2020 2020 2072 6574 7572 6e20 496e 7465       return Inte
-000086c0: 7276 616c 2873 7461 7274 2c20 7374 6f70  rval(start, stop
-000086d0: 2c20 6c65 6674 5f6f 7065 6e3d 6c65 6674  , left_open=left
-000086e0: 5f6f 7065 6e2c 2072 6967 6874 5f6f 7065  _open, right_ope
-000086f0: 6e3d 7269 6768 745f 6f70 656e 2920 2020  n=right_open)   
-00008700: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008710: 2020 2020 2020 2020 200a 0a20 2020 2020           ..     
-00008720: 2020 2065 6d70 7479 203d 2046 616c 7365     empty = False
-00008730: 0a0a 2020 2020 2020 2020 6966 2073 656c  ..        if sel
-00008740: 662e 7374 6172 7420 3c3d 2062 2e73 746f  f.start <= b.sto
-00008750: 7020 616e 6420 622e 7374 6172 7420 3c3d  p and b.start <=
-00008760: 2073 656c 662e 7374 6f70 3a0a 2020 2020   self.stop:.    
-00008770: 2020 2020 2020 2020 2320 4765 7420 746f          # Get to
-00008780: 706f 6c6f 6779 2072 6967 6874 2e0a 2020  pology right..  
-00008790: 2020 2020 2020 2020 2020 6966 2073 656c            if sel
-000087a0: 662e 7374 6172 7420 3c20 622e 7374 6172  f.start < b.star
-000087b0: 743a 0a20 2020 2020 2020 2020 2020 2020  t:.             
-000087c0: 2020 2073 7461 7274 203d 2062 2e73 7461     start = b.sta
-000087d0: 7274 0a20 2020 2020 2020 2020 2020 2020  rt.             
-000087e0: 2020 206c 6566 745f 6f70 656e 203d 2062     left_open = b
-000087f0: 2e6c 6566 745f 6f70 656e 0a20 2020 2020  .left_open.     
-00008800: 2020 2020 2020 2065 6c69 6620 7365 6c66         elif self
-00008810: 2e73 7461 7274 203e 2062 2e73 7461 7274  .start > b.start
-00008820: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-00008830: 2020 7374 6172 7420 3d20 7365 6c66 2e73    start = self.s
-00008840: 7461 7274 0a20 2020 2020 2020 2020 2020  tart.           
-00008850: 2020 2020 206c 6566 745f 6f70 656e 203d       left_open =
-00008860: 2073 656c 662e 6c65 6674 5f6f 7065 6e0a   self.left_open.
-00008870: 2020 2020 2020 2020 2020 2020 656c 7365              else
-00008880: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-00008890: 2020 7374 6172 7420 3d20 7365 6c66 2e73    start = self.s
-000088a0: 7461 7274 0a20 2020 2020 2020 2020 2020  tart.           
-000088b0: 2020 2020 206c 6566 745f 6f70 656e 203d       left_open =
-000088c0: 2073 656c 662e 6c65 6674 5f6f 7065 6e20   self.left_open 
-000088d0: 6f72 2062 2e6c 6566 745f 6f70 656e 0a0a  or b.left_open..
-000088e0: 2020 2020 2020 2020 2020 2020 6966 2073              if s
-000088f0: 656c 662e 7374 6f70 203c 2062 2e73 746f  elf.stop < b.sto
-00008900: 703a 0a20 2020 2020 2020 2020 2020 2020  p:.             
-00008910: 2020 2073 746f 7020 3d20 7365 6c66 2e73     stop = self.s
-00008920: 746f 700a 2020 2020 2020 2020 2020 2020  top.            
-00008930: 2020 2020 7269 6768 745f 6f70 656e 203d      right_open =
-00008940: 2073 656c 662e 7269 6768 745f 6f70 656e   self.right_open
-00008950: 0a20 2020 2020 2020 2020 2020 2065 6c69  .            eli
-00008960: 6620 7365 6c66 2e73 746f 7020 3e20 622e  f self.stop > b.
-00008970: 7374 6f70 3a0a 2020 2020 2020 2020 2020  stop:.          
-00008980: 2020 2020 2020 7374 6f70 203d 2062 2e73        stop = b.s
-00008990: 746f 700a 2020 2020 2020 2020 2020 2020  top.            
-000089a0: 2020 2020 7269 6768 745f 6f70 656e 203d      right_open =
-000089b0: 2062 2e72 6967 6874 5f6f 7065 6e0a 2020   b.right_open.  
-000089c0: 2020 2020 2020 2020 2020 656c 7365 3a0a            else:.
-000089d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000089e0: 7374 6f70 203d 2073 656c 662e 7374 6f70  stop = self.stop
-000089f0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00008a00: 2072 6967 6874 5f6f 7065 6e20 3d20 7365   right_open = se
-00008a10: 6c66 2e72 6967 6874 5f6f 7065 6e20 6f72  lf.right_open or
-00008a20: 2062 2e72 6967 6874 5f6f 7065 6e0a 0a20   b.right_open.. 
-00008a30: 2020 2020 2020 2020 2020 2069 6620 7374             if st
-00008a40: 6f70 202d 2073 7461 7274 203d 3d20 3020  op - start == 0 
-00008a50: 616e 6420 286c 6566 745f 6f70 656e 206f  and (left_open o
-00008a60: 7220 7269 6768 745f 6f70 656e 293a 0a20  r right_open):. 
-00008a70: 2020 2020 2020 2020 2020 2020 2020 2065                 e
-00008a80: 6d70 7479 203d 2054 7275 650a 2020 2020  mpty = True.    
-00008a90: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
-00008aa0: 2020 2020 2020 656d 7074 7920 3d20 5472        empty = Tr
-00008ab0: 7565 0a0a 2020 2020 2020 2020 6966 2065  ue..        if e
-00008ac0: 6d70 7479 3a0a 2020 2020 2020 2020 2020  mpty:.          
-00008ad0: 2020 7265 7475 726e 2073 656c 662e 6574    return self.et
-00008ae0: 7970 652e 656d 7074 7953 6574 0a0a 2020  ype.emptySet..  
-00008af0: 2020 2020 2020 696e 7465 7276 616c 203d        interval =
-00008b00: 2073 656c 662e 6675 6e63 2873 7461 7274   self.func(start
-00008b10: 2c20 7374 6f70 2c20 6c65 6674 5f6f 7065  , stop, left_ope
-00008b20: 6e3d 6c65 6674 5f6f 7065 6e2c 2072 6967  n=left_open, rig
-00008b30: 6874 5f6f 7065 6e3d 7269 6768 745f 6f70  ht_open=right_op
-00008b40: 656e 290a 2020 2020 2020 2020 6966 2062  en).        if b
-00008b50: 2e65 7479 7065 2e69 735f 696e 7465 6765  .etype.is_intege
-00008b60: 723a 0a20 2020 2020 2020 2020 2020 2072  r:.            r
-00008b70: 6574 7572 6e20 696e 7465 7276 616c 2e63  eturn interval.c
-00008b80: 6f70 7928 696e 7465 6765 723d 5472 7565  opy(integer=True
-00008b90: 290a 2020 2020 2020 2020 7265 7475 726e  ).        return
-00008ba0: 2069 6e74 6572 7661 6c0a 0a20 2020 2064   interval..    d
-00008bb0: 6566 205f 756e 696f 6e5f 7365 7473 2873  ef _union_sets(s
-00008bc0: 656c 662c 2062 293a 200a 2020 2020 2020  elf, b): .      
-00008bd0: 2020 6966 2073 656c 662e 6d61 7828 2920    if self.max() 
-00008be0: 696e 2062 3a0a 2020 2020 2020 2020 2020  in b:.          
-00008bf0: 2020 6672 6f6d 2073 796d 7079 2069 6d70    from sympy imp
-00008c00: 6f72 7420 4d69 6e0a 2020 2020 2020 2020  ort Min.        
-00008c10: 2020 2020 7265 7475 726e 2062 2e63 6f70      return b.cop
-00008c20: 7928 7374 6172 743d 4d69 6e28 7365 6c66  y(start=Min(self
-00008c30: 2e6d 696e 2829 2c20 622e 6d69 6e28 2929  .min(), b.min())
-00008c40: 2c20 6c65 6674 5f6f 7065 6e3d 4661 6c73  , left_open=Fals
-00008c50: 652c 2069 6e74 6567 6572 3d4e 6f6e 6529  e, integer=None)
-00008c60: 0a20 2020 2020 2020 200a 2020 2020 2020  .        .      
-00008c70: 2020 6966 2073 656c 662e 6d69 6e28 2920    if self.min() 
-00008c80: 696e 2062 3a0a 2020 2020 2020 2020 2020  in b:.          
-00008c90: 2020 6672 6f6d 2073 796d 7079 2069 6d70    from sympy imp
-00008ca0: 6f72 7420 4d61 780a 2020 2020 2020 2020  ort Max.        
-00008cb0: 2020 2020 7265 7475 726e 2062 2e63 6f70      return b.cop
-00008cc0: 7928 7374 6f70 3d4d 6178 2873 656c 662e  y(stop=Max(self.
-00008cd0: 6d61 7828 292c 2062 2e6d 6178 2829 292c  max(), b.max()),
-00008ce0: 2072 6967 6874 5f6f 7065 6e3d 4661 6c73   right_open=Fals
-00008cf0: 652c 2069 6e74 6567 6572 3d4e 6f6e 6529  e, integer=None)
-00008d00: 0a20 2020 2020 2020 200a 2020 2020 2020  .        .      
-00008d10: 2020 6966 2073 656c 6620 696e 2062 3a0a    if self in b:.
-00008d20: 2020 2020 2020 2020 2020 2020 7265 7475              retu
-00008d30: 726e 2062 0a20 2020 2020 2020 200a 2020  rn b.        .  
-00008d40: 2020 2020 2020 6966 2062 2069 6e20 7365        if b in se
-00008d50: 6c66 3a0a 2020 2020 2020 2020 2020 2020  lf:.            
-00008d60: 7265 7475 726e 2073 656c 660a 2020 2020  return self.    
-00008d70: 2020 2020 0a20 2020 2020 2020 2069 6620      .        if 
-00008d80: 7365 6c66 2e72 6967 6874 5f6f 7065 6e20  self.right_open 
-00008d90: 616e 6420 6e6f 7420 622e 6c65 6674 5f6f  and not b.left_o
-00008da0: 7065 6e3a 0a20 2020 2020 2020 2020 2020  pen:.           
-00008db0: 2069 6620 7365 6c66 2e73 746f 7020 3d3d   if self.stop ==
-00008dc0: 2062 2e73 7461 7274 2061 6e64 2062 2e73   b.start and b.s
-00008dd0: 7461 7274 203c 3d20 622e 7374 6f70 3a0a  tart <= b.stop:.
-00008de0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008df0: 6966 2073 656c 662e 6c65 6674 5f6f 7065  if self.left_ope
-00008e00: 6e3a 0a20 2020 2020 2020 2020 2020 2020  n:.             
-00008e10: 2020 2020 2020 2069 6620 7365 6c66 2e73         if self.s
-00008e20: 746f 7020 3e20 7365 6c66 2e73 7461 7274  top > self.start
-00008e30: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-00008e40: 2020 2020 2020 2020 2020 7265 7475 726e            return
-00008e50: 2049 6e74 6572 7661 6c28 7365 6c66 2e73   Interval(self.s
-00008e60: 7461 7274 2c20 622e 7374 6f70 2c20 6c65  tart, b.stop, le
-00008e70: 6674 5f6f 7065 6e3d 5472 7565 2c20 7269  ft_open=True, ri
-00008e80: 6768 745f 6f70 656e 3d62 2e72 6967 6874  ght_open=b.right
-00008e90: 5f6f 7065 6e29 0a20 2020 2020 2020 2020  _open).         
-00008ea0: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
-00008eb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008ec0: 2069 6620 7365 6c66 2e73 746f 7020 3e3d   if self.stop >=
-00008ed0: 2073 656c 662e 7374 6172 743a 0a20 2020   self.start:.   
-00008ee0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008ef0: 2020 2020 2072 6574 7572 6e20 496e 7465       return Inte
-00008f00: 7276 616c 2873 656c 662e 7374 6172 742c  rval(self.start,
-00008f10: 2062 2e73 746f 702c 206c 6566 745f 6f70   b.stop, left_op
-00008f20: 656e 3d46 616c 7365 2c20 7269 6768 745f  en=False, right_
-00008f30: 6f70 656e 3d62 2e72 6967 6874 5f6f 7065  open=b.right_ope
-00008f40: 6e29 0a20 2020 2020 2020 2065 6c69 6620  n).        elif 
-00008f50: 6e6f 7420 7365 6c66 2e72 6967 6874 5f6f  not self.right_o
-00008f60: 7065 6e20 616e 6420 622e 6c65 6674 5f6f  pen and b.left_o
-00008f70: 7065 6e3a 0a20 2020 2020 2020 2020 2020  pen:.           
-00008f80: 2069 6620 7365 6c66 2e73 746f 7020 3d3d   if self.stop ==
-00008f90: 2062 2e73 7461 7274 2061 6e64 2073 656c   b.start and sel
-00008fa0: 662e 7374 6172 7420 3c3d 2073 656c 662e  f.start <= self.
-00008fb0: 7374 6f70 3a0a 2020 2020 2020 2020 2020  stop:.          
-00008fc0: 2020 2020 2020 6966 2062 2e72 6967 6874        if b.right
-00008fd0: 5f6f 7065 6e3a 0a20 2020 2020 2020 2020  _open:.         
-00008fe0: 2020 2020 2020 2020 2020 2069 6620 622e             if b.
-00008ff0: 7374 6f70 203e 2062 2e73 7461 7274 3a0a  stop > b.start:.
-00009000: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009010: 2020 2020 2020 2020 7265 7475 726e 2049          return I
-00009020: 6e74 6572 7661 6c28 7365 6c66 2e73 7461  nterval(self.sta
-00009030: 7274 2c20 622e 7374 6f70 2c20 6c65 6674  rt, b.stop, left
-00009040: 5f6f 7065 6e3d 7365 6c66 2e6c 6566 745f  _open=self.left_
-00009050: 6f70 656e 2c20 7269 6768 745f 6f70 656e  open, right_open
-00009060: 3d54 7275 6529 0a20 2020 2020 2020 2020  =True).         
-00009070: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
-00009080: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009090: 2069 6620 622e 7374 6f70 203e 3d20 622e   if b.stop >= b.
-000090a0: 7374 6172 743a 0a20 2020 2020 2020 2020  start:.         
-000090b0: 2020 2020 2020 2020 2020 2020 2020 2072                 r
-000090c0: 6574 7572 6e20 496e 7465 7276 616c 2873  eturn Interval(s
-000090d0: 656c 662e 7374 6172 742c 2062 2e73 746f  elf.start, b.sto
-000090e0: 702c 206c 6566 745f 6f70 656e 3d73 656c  p, left_open=sel
-000090f0: 662e 6c65 6674 5f6f 7065 6e2c 2072 6967  f.left_open, rig
-00009100: 6874 5f6f 7065 6e3d 4661 6c73 6529 0a20  ht_open=False). 
-00009110: 2020 2020 2020 2065 6c69 6620 6e6f 7420         elif not 
-00009120: 622e 7269 6768 745f 6f70 656e 2061 6e64  b.right_open and
-00009130: 2073 656c 662e 6c65 6674 5f6f 7065 6e3a   self.left_open:
-00009140: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
-00009150: 622e 7374 6f70 203d 3d20 7365 6c66 2e73  b.stop == self.s
-00009160: 7461 7274 2061 6e64 2062 2e73 7461 7274  tart and b.start
-00009170: 203c 3d20 622e 7374 6f70 3a0a 2020 2020   <= b.stop:.    
-00009180: 2020 2020 2020 2020 2020 2020 6966 2073              if s
-00009190: 656c 662e 7269 6768 745f 6f70 656e 3a0a  elf.right_open:.
-000091a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000091b0: 2020 2020 6966 2073 656c 662e 7374 6f70      if self.stop
-000091c0: 203e 2073 656c 662e 7374 6172 743a 0a20   > self.start:. 
-000091d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000091e0: 2020 2020 2020 2072 6574 7572 6e20 496e         return In
-000091f0: 7465 7276 616c 2862 2e73 7461 7274 2c20  terval(b.start, 
-00009200: 7365 6c66 2e73 746f 702c 206c 6566 745f  self.stop, left_
-00009210: 6f70 656e 3d62 2e6c 6566 745f 6f70 656e  open=b.left_open
-00009220: 2c20 7269 6768 745f 6f70 656e 3d54 7275  , right_open=Tru
-00009230: 6529 0a20 2020 2020 2020 2020 2020 2020  e).             
-00009240: 2020 2065 6c73 653a 200a 2020 2020 2020     else: .      
-00009250: 2020 2020 2020 2020 2020 2020 2020 6966                if
-00009260: 2073 656c 662e 7374 6f70 203e 3d20 7365   self.stop >= se
-00009270: 6c66 2e73 7461 7274 3a0a 2020 2020 2020  lf.start:.      
-00009280: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009290: 2020 7265 7475 726e 2049 6e74 6572 7661    return Interva
-000092a0: 6c28 622e 7374 6172 742c 2073 656c 662e  l(b.start, self.
-000092b0: 7374 6f70 2c20 6c65 6674 5f6f 7065 6e3d  stop, left_open=
-000092c0: 622e 6c65 6674 5f6f 7065 6e2c 2072 6967  b.left_open, rig
-000092d0: 6874 5f6f 7065 6e3d 4661 6c73 6529 0a20  ht_open=False). 
-000092e0: 2020 2020 2020 2065 6c69 6620 622e 7269         elif b.ri
-000092f0: 6768 745f 6f70 656e 2061 6e64 206e 6f74  ght_open and not
-00009300: 2073 656c 662e 6c65 6674 5f6f 7065 6e3a   self.left_open:
-00009310: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
-00009320: 622e 7374 6f70 203d 3d20 7365 6c66 2e73  b.stop == self.s
-00009330: 7461 7274 2061 6e64 2073 656c 662e 7374  tart and self.st
-00009340: 6172 7420 3c3d 2073 656c 662e 7374 6f70  art <= self.stop
-00009350: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-00009360: 2020 6966 2062 2e6c 6566 745f 6f70 656e    if b.left_open
-00009370: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-00009380: 2020 2020 2020 6966 2062 2e73 746f 7020        if b.stop 
-00009390: 3e20 622e 7374 6172 743a 0a20 2020 2020  > b.start:.     
-000093a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000093b0: 2020 2072 6574 7572 6e20 496e 7465 7276     return Interv
-000093c0: 616c 2862 2e73 7461 7274 2c20 7365 6c66  al(b.start, self
-000093d0: 2e73 746f 702c 206c 6566 745f 6f70 656e  .stop, left_open
-000093e0: 3d54 7275 652c 2072 6967 6874 5f6f 7065  =True, right_ope
-000093f0: 6e3d 7365 6c66 2e72 6967 6874 5f6f 7065  n=self.right_ope
-00009400: 6e29 0a20 2020 2020 2020 2020 2020 2020  n).             
-00009410: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
-00009420: 2020 2020 2020 2020 2020 2020 2069 6620               if 
-00009430: 622e 7374 6f70 203e 3d20 622e 7374 6172  b.stop >= b.star
-00009440: 743a 0a20 2020 2020 2020 2020 2020 2020  t:.             
-00009450: 2020 2020 2020 2020 2020 2072 6574 7572             retur
-00009460: 6e20 496e 7465 7276 616c 2862 2e73 7461  n Interval(b.sta
-00009470: 7274 2c20 7365 6c66 2e73 746f 702c 206c  rt, self.stop, l
-00009480: 6566 745f 6f70 656e 3d46 616c 7365 2c20  eft_open=False, 
-00009490: 7269 6768 745f 6f70 656e 3d73 656c 662e  right_open=self.
-000094a0: 7269 6768 745f 6f70 656e 290a 2020 2020  right_open).    
-000094b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000094c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000094d0: 200a 2020 2020 6465 6620 756e 696f 6e5f   .    def union_
-000094e0: 7365 7473 2873 656c 662c 2062 293a 0a20  sets(self, b):. 
-000094f0: 2020 2020 2020 2069 6620 622e 6973 5f49         if b.is_I
-00009500: 6e74 6572 7661 6c20 6f72 2062 2e69 735f  nterval or b.is_
-00009510: 5261 6e67 653a 0a20 2020 2020 2020 2020  Range:.         
-00009520: 2020 2069 6620 7365 6c66 2e5f 6973 5f63     if self._is_c
-00009530: 6f6d 7061 7261 626c 6528 6229 3a0a 2020  omparable(b):.  
-00009540: 2020 2020 2020 2020 2020 2020 2020 6672                fr
-00009550: 6f6d 2073 796d 7079 2e66 756e 6374 696f  om sympy.functio
-00009560: 6e73 2e65 6c65 6d65 6e74 6172 792e 6d69  ns.elementary.mi
-00009570: 7363 656c 6c61 6e65 6f75 7320 696d 706f  scellaneous impo
-00009580: 7274 204d 696e 2c20 4d61 780a 2020 2020  rt Min, Max.    
-00009590: 2020 2020 2020 2020 2020 2020 2320 4e6f              # No
-000095a0: 6e2d 6f76 6572 6c61 7070 696e 6720 696e  n-overlapping in
-000095b0: 7465 7276 616c 730a 2020 2020 2020 2020  tervals.        
-000095c0: 2020 2020 2020 2020 7374 6f70 203d 204d          stop = M
-000095d0: 696e 2873 656c 662e 7374 6f70 2c20 622e  in(self.stop, b.
-000095e0: 7374 6f70 290a 2020 2020 2020 2020 2020  stop).          
-000095f0: 2020 2020 2020 7374 6172 7420 3d20 4d61        start = Ma
-00009600: 7828 7365 6c66 2e73 7461 7274 2c20 622e  x(self.start, b.
-00009610: 7374 6172 7429 0a20 2020 2020 2020 2020  start).         
-00009620: 2020 2020 2020 2069 6620 2873 746f 7020         if (stop 
-00009630: 3c20 7374 6172 7420 6f72 0a20 2020 2020  < start or.     
-00009640: 2020 2020 2020 2020 2020 2020 2020 2873                (s
-00009650: 746f 7020 3d3d 2073 7461 7274 2061 6e64  top == start and
-00009660: 2028 7374 6f70 206e 6f74 2069 6e20 7365   (stop not in se
-00009670: 6c66 2061 6e64 2073 746f 7020 6e6f 7420  lf and stop not 
-00009680: 696e 2062 2929 293a 0a20 2020 2020 2020  in b))):.       
-00009690: 2020 2020 2020 2020 2020 2020 2072 6574               ret
-000096a0: 7572 6e20 4e6f 6e65 0a20 2020 2020 2020  urn None.       
-000096b0: 2020 2020 2020 2020 2065 6c73 653a 0a20           else:. 
-000096c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000096d0: 2020 2073 7461 7274 203d 204d 696e 2873     start = Min(s
-000096e0: 656c 662e 7374 6172 742c 2062 2e73 7461  elf.start, b.sta
-000096f0: 7274 290a 2020 2020 2020 2020 2020 2020  rt).            
-00009700: 2020 2020 2020 2020 7374 6f70 203d 204d          stop = M
-00009710: 6178 2873 656c 662e 7374 6f70 2c20 622e  ax(self.stop, b.
-00009720: 7374 6f70 290a 0a20 2020 2020 2020 2020  stop)..         
-00009730: 2020 2020 2020 2020 2020 206c 6566 745f             left_
-00009740: 6f70 656e 203d 2028 2873 656c 662e 7374  open = ((self.st
-00009750: 6172 7420 213d 2073 7461 7274 206f 7220  art != start or 
-00009760: 7365 6c66 2e6c 6566 745f 6f70 656e 2920  self.left_open) 
-00009770: 616e 640a 2020 2020 2020 2020 2020 2020  and.            
-00009780: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009790: 2020 2020 2028 622e 7374 6172 7420 213d       (b.start !=
-000097a0: 2073 7461 7274 206f 7220 622e 6c65 6674   start or b.left
-000097b0: 5f6f 7065 6e29 290a 2020 2020 2020 2020  _open)).        
-000097c0: 2020 2020 2020 2020 2020 2020 7269 6768              righ
-000097d0: 745f 6f70 656e 203d 2028 2873 656c 662e  t_open = ((self.
-000097e0: 7374 6f70 2021 3d20 7374 6f70 206f 7220  stop != stop or 
-000097f0: 7365 6c66 2e72 6967 6874 5f6f 7065 6e29  self.right_open)
-00009800: 2061 6e64 0a20 2020 2020 2020 2020 2020   and.           
-00009810: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009820: 2020 2020 2020 2028 622e 7374 6f70 2021         (b.stop !
-00009830: 3d20 7374 6f70 206f 7220 622e 7269 6768  = stop or b.righ
-00009840: 745f 6f70 656e 2929 0a20 2020 2020 2020  t_open)).       
-00009850: 2020 2020 2020 2020 2020 2020 2072 6574               ret
-00009860: 7572 6e20 7365 6c66 2e66 756e 6328 7374  urn self.func(st
-00009870: 6172 742c 2073 746f 702c 206c 6566 745f  art, stop, left_
-00009880: 6f70 656e 3d6c 6566 745f 6f70 656e 2c20  open=left_open, 
-00009890: 7269 6768 745f 6f70 656e 3d72 6967 6874  right_open=right
-000098a0: 5f6f 7065 6e29 0a20 2020 2020 2020 2020  _open).         
-000098b0: 2020 2065 6c69 6620 6e6f 7420 622e 6574     elif not b.et
-000098c0: 7970 652e 6973 5f69 6e74 6567 6572 3a0a  ype.is_integer:.
-000098d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000098e0: 7265 7475 726e 2073 656c 662e 5f75 6e69  return self._uni
-000098f0: 6f6e 5f73 6574 7328 6229 0a20 2020 2020  on_sets(b).     
-00009900: 2020 2069 6620 622e 6973 5f55 6e69 7665     if b.is_Unive
-00009910: 7273 616c 5365 743a 0a20 2020 2020 2020  rsalSet:.       
-00009920: 2020 2020 2072 6574 7572 6e20 620a 2020       return b.  
-00009930: 2020 2020 2020 6966 2062 2e69 735f 436f        if b.is_Co
-00009940: 6d70 6c65 6d65 6e74 3a0a 2020 2020 2020  mplement:.      
-00009950: 2020 2020 2020 552c 2041 203d 2062 2e61        U, A = b.a
-00009960: 7267 730a 2020 2020 2020 2020 2020 2020  rgs.            
-00009970: 6966 2028 552e 6973 5f49 6e74 6572 7661  if (U.is_Interva
-00009980: 6c20 6f72 2055 2e69 735f 5261 6e67 6529  l or U.is_Range)
-00009990: 2061 6e64 206e 6f74 2041 2026 2073 656c   and not A & sel
-000099a0: 663a 0a20 2020 2020 2020 2020 2020 2020  f:.             
-000099b0: 2020 2063 6f6d 6269 6e65 6420 3d20 7365     combined = se
-000099c0: 6c66 207c 2055 0a20 2020 2020 2020 2020  lf | U.         
-000099d0: 2020 2020 2020 2069 6620 636f 6d62 696e         if combin
-000099e0: 6564 2e69 735f 496e 7465 7276 616c 206f  ed.is_Interval o
-000099f0: 7220 636f 6d62 696e 6564 2e69 735f 5261  r combined.is_Ra
-00009a00: 6e67 653a 0a20 2020 2020 2020 2020 2020  nge:.           
-00009a10: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
-00009a20: 636f 6d62 696e 6564 202f 2f20 410a 0a20  combined // A.. 
-00009a30: 2020 2020 2020 2023 2049 6620 4920 6861         # If I ha
-00009a40: 7665 206f 7065 6e20 656e 6420 706f 696e  ve open end poin
-00009a50: 7473 2061 6e64 2074 6865 7365 2065 6e64  ts and these end
-00009a60: 706f 696e 7473 2061 7265 2063 6f6e 7461  points are conta
-00009a70: 696e 6564 2069 6e20 620a 2020 2020 2020  ined in b.      
-00009a80: 2020 2320 4275 7420 6f6e 6c79 2069 6e20    # But only in 
-00009a90: 6361 7365 2c20 7768 656e 2065 6e64 706f  case, when endpo
-00009aa0: 696e 7473 2061 7265 2066 696e 6974 652e  ints are finite.
-00009ab0: 2042 6563 6175 7365 0a20 2020 2020 2020   Because.       
-00009ac0: 2023 2069 6e74 6572 7661 6c20 646f 6573   # interval does
-00009ad0: 206e 6f74 2063 6f6e 7461 696e 206f 6f20   not contain oo 
-00009ae0: 6f72 202d 6f6f 2e0a 2020 2020 2020 2020  or -oo..        
-00009af0: 6f70 656e 5f6c 6566 745f 696e 5f62 5f61  open_left_in_b_a
-00009b00: 6e64 5f66 696e 6974 6520 3d20 2873 656c  nd_finite = (sel
-00009b10: 662e 6c65 6674 5f6f 7065 6e20 616e 640a  f.left_open and.
-00009b20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009b30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009b40: 2020 2020 2020 2020 2073 796d 7069 6679           sympify
-00009b50: 2862 2e63 6f6e 7461 696e 7328 7365 6c66  (b.contains(self
-00009b60: 2e73 7461 7274 2929 2069 7320 532e 7472  .start)) is S.tr
-00009b70: 7565 2061 6e64 0a20 2020 2020 2020 2020  ue and.         
-00009b80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009b90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009ba0: 7365 6c66 2e73 7461 7274 2e69 735f 6669  self.start.is_fi
-00009bb0: 6e69 7465 290a 2020 2020 2020 2020 6f70  nite).        op
-00009bc0: 656e 5f72 6967 6874 5f69 6e5f 625f 616e  en_right_in_b_an
-00009bd0: 645f 6669 6e69 7465 203d 2028 7365 6c66  d_finite = (self
-00009be0: 2e72 6967 6874 5f6f 7065 6e20 616e 640a  .right_open and.
-00009bf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009c00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009c10: 2020 2020 2020 2020 2020 7379 6d70 6966            sympif
-00009c20: 7928 622e 636f 6e74 6169 6e73 2873 656c  y(b.contains(sel
-00009c30: 662e 7374 6f70 2929 2069 7320 532e 7472  f.stop)) is S.tr
-00009c40: 7565 2061 6e64 0a20 2020 2020 2020 2020  ue and.         
-00009c50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009c60: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009c70: 2073 656c 662e 7374 6f70 2e69 735f 6669   self.stop.is_fi
-00009c80: 6e69 7465 290a 2020 2020 2020 2020 6966  nite).        if
-00009c90: 206f 7065 6e5f 6c65 6674 5f69 6e5f 625f   open_left_in_b_
-00009ca0: 616e 645f 6669 6e69 7465 206f 7220 6f70  and_finite or op
-00009cb0: 656e 5f72 6967 6874 5f69 6e5f 625f 616e  en_right_in_b_an
-00009cc0: 645f 6669 6e69 7465 3a0a 2020 2020 2020  d_finite:.      
-00009cd0: 2020 2020 2020 2320 4669 6c6c 2069 6e20        # Fill in 
-00009ce0: 6d79 2065 6e64 2070 6f69 6e74 7320 616e  my end points an
-00009cf0: 6420 7265 7475 726e 0a20 2020 2020 2020  d return.       
-00009d00: 2020 2020 206c 6566 745f 6f70 656e 203d       left_open =
-00009d10: 2073 656c 662e 6c65 6674 5f6f 7065 6e20   self.left_open 
-00009d20: 616e 6420 7365 6c66 2e73 7461 7274 206e  and self.start n
-00009d30: 6f74 2069 6e20 620a 2020 2020 2020 2020  ot in b.        
-00009d40: 2020 2020 7269 6768 745f 6f70 656e 203d      right_open =
-00009d50: 2073 656c 662e 7269 6768 745f 6f70 656e   self.right_open
-00009d60: 2061 6e64 2073 656c 662e 7374 6f70 206e   and self.stop n
-00009d70: 6f74 2069 6e20 620a 2020 2020 2020 2020  ot in b.        
-00009d80: 2020 2020 6e65 775f 6120 3d20 7365 6c66      new_a = self
-00009d90: 2e63 6f70 7928 6c65 6674 5f6f 7065 6e3d  .copy(left_open=
-00009da0: 6c65 6674 5f6f 7065 6e2c 2072 6967 6874  left_open, right
-00009db0: 5f6f 7065 6e3d 7269 6768 745f 6f70 656e  _open=right_open
-00009dc0: 290a 2020 2020 2020 2020 2020 2020 7265  ).            re
-00009dd0: 7475 726e 2073 6574 2828 6e65 775f 612c  turn set((new_a,
-00009de0: 2062 2929 0a0a 2020 2020 2020 2020 6966   b))..        if
-00009df0: 2073 656c 662e 6574 7970 652e 6973 5f69   self.etype.is_i
-00009e00: 6e74 6567 6572 3a0a 2020 2020 2020 2020  nteger:.        
-00009e10: 2020 2020 6472 6170 6561 7520 3d20 4661      drapeau = Fa
-00009e20: 6c73 650a 2020 2020 2020 2020 2020 2020  lse.            
-00009e30: 7374 6f70 203d 2073 656c 662e 7374 6f70  stop = self.stop
-00009e40: 0a20 2020 2020 2020 2020 2020 2072 6967  .            rig
-00009e50: 6874 5f6f 7065 6e20 3d20 7365 6c66 2e72  ht_open = self.r
-00009e60: 6967 6874 5f6f 7065 6e0a 2020 2020 2020  ight_open.      
-00009e70: 2020 2020 2020 6966 2072 6967 6874 5f6f        if right_o
-00009e80: 7065 6e3a 0a20 2020 2020 2020 2020 2020  pen:.           
-00009e90: 2020 2020 2069 6620 7374 6f70 2069 6e20       if stop in 
-00009ea0: 623a 0a20 2020 2020 2020 2020 2020 2020  b:.             
-00009eb0: 2020 2020 2020 2064 7261 7065 6175 203d         drapeau =
-00009ec0: 2054 7275 650a 2020 2020 2020 2020 2020   True.          
-00009ed0: 2020 2020 2020 2020 2020 7269 6768 745f            right_
-00009ee0: 6f70 656e 203d 2046 616c 7365 0a20 2020  open = False.   
-00009ef0: 2020 2020 2020 2020 2065 6c73 653a 200a           else: .
-00009f00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009f10: 6966 2073 746f 7020 2b20 3120 696e 2062  if stop + 1 in b
-00009f20: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-00009f30: 2020 2020 2020 6472 6170 6561 7520 3d20        drapeau = 
-00009f40: 5472 7565 0a20 2020 2020 2020 2020 2020  True.           
-00009f50: 2020 2020 2020 2020 2073 746f 7020 2b3d           stop +=
-00009f60: 2031 0a0a 2020 2020 2020 2020 2020 2020   1..            
-00009f70: 7374 6172 7420 3d20 7365 6c66 2e73 7461  start = self.sta
-00009f80: 7274 0a20 2020 2020 2020 2020 2020 206c  rt.            l
-00009f90: 6566 745f 6f70 656e 203d 2073 656c 662e  eft_open = self.
-00009fa0: 6c65 6674 5f6f 7065 6e0a 2020 2020 2020  left_open.      
-00009fb0: 2020 2020 2020 6966 206c 6566 745f 6f70        if left_op
-00009fc0: 656e 3a0a 2020 2020 2020 2020 2020 2020  en:.            
-00009fd0: 2020 2020 6966 2073 7461 7274 2069 6e20      if start in 
-00009fe0: 623a 0a20 2020 2020 2020 2020 2020 2020  b:.             
-00009ff0: 2020 2020 2020 2064 7261 7065 6175 203d         drapeau =
-0000a000: 2054 7275 650a 2020 2020 2020 2020 2020   True.          
-0000a010: 2020 2020 2020 2020 2020 6c65 6674 5f6f            left_o
-0000a020: 7065 6e20 3d20 4661 6c73 650a 2020 2020  pen = False.    
-0000a030: 2020 2020 2020 2020 656c 7365 3a20 0a20          else: . 
-0000a040: 2020 2020 2020 2020 2020 2020 2020 2069                 i
-0000a050: 6620 7374 6172 7420 2d20 3120 696e 2062  f start - 1 in b
-0000a060: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-0000a070: 2020 2020 2020 6472 6170 6561 7520 3d20        drapeau = 
-0000a080: 5472 7565 0a20 2020 2020 2020 2020 2020  True.           
-0000a090: 2020 2020 2020 2020 2073 7461 7274 202d           start -
-0000a0a0: 3d20 310a 0a20 2020 2020 2020 2020 2020  = 1..           
-0000a0b0: 2069 6620 6472 6170 6561 753a 0a20 2020   if drapeau:.   
-0000a0c0: 2020 2020 2020 2020 2020 2020 206e 6577               new
-0000a0d0: 5f61 203d 2073 656c 662e 6675 6e63 2873  _a = self.func(s
-0000a0e0: 7461 7274 2c20 7374 6f70 2c20 6c65 6674  tart, stop, left
-0000a0f0: 5f6f 7065 6e3d 6c65 6674 5f6f 7065 6e2c  _open=left_open,
-0000a100: 2072 6967 6874 5f6f 7065 6e3d 7269 6768   right_open=righ
-0000a110: 745f 6f70 656e 2c20 696e 7465 6765 723d  t_open, integer=
-0000a120: 5472 7565 290a 2020 2020 2020 2020 2020  True).          
-0000a130: 2020 2020 2020 7265 7475 726e 2073 6574        return set
-0000a140: 2828 6e65 775f 612c 2062 2929 0a20 2020  ((new_a, b)).   
-0000a150: 2020 2020 2069 6620 7365 6c66 2e69 735f       if self.is_
-0000a160: 556e 6976 6572 7361 6c53 6574 3a0a 2020  UniversalSet:.  
-0000a170: 2020 2020 2020 2020 2020 7265 7475 726e            return
-0000a180: 2073 656c 660a 0a20 2020 2064 6566 205f   self..    def _
-0000a190: 5f6e 6577 5f5f 2863 6c73 2c20 7374 6172  _new__(cls, star
-0000a1a0: 743d 4e6f 6e65 2c20 7374 6f70 3d4e 6f6e  t=None, stop=Non
-0000a1b0: 652c 202a 2a6b 7761 7267 7329 3a0a 2020  e, **kwargs):.  
-0000a1c0: 2020 2020 2020 6966 2073 7461 7274 2069        if start i
-0000a1d0: 7320 4e6f 6e65 206f 7220 7374 6f70 2069  s None or stop i
-0000a1e0: 7320 4e6f 6e65 3a0a 2020 2020 2020 2020  s None:.        
-0000a1f0: 2020 2020 6966 206b 7761 7267 732e 6765      if kwargs.ge
-0000a200: 7428 2770 6f73 6974 6976 6527 293a 0a20  t('positive'):. 
-0000a210: 2020 2020 2020 2020 2020 2020 2020 2073                 s
-0000a220: 746f 7020 3d20 532e 496e 6669 6e69 7479  top = S.Infinity
-0000a230: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000a240: 2073 7461 7274 203d 2053 2e5a 6572 6f0a   start = S.Zero.
-0000a250: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a260: 6b77 6172 6773 5b27 6c65 6674 5f6f 7065  kwargs['left_ope
-0000a270: 6e27 5d20 3d20 5472 7565 0a20 2020 2020  n'] = True.     
-0000a280: 2020 2020 2020 2065 6c69 6620 6b77 6172         elif kwar
-0000a290: 6773 2e67 6574 2827 6e6f 6e6e 6567 6174  gs.get('nonnegat
-0000a2a0: 6976 6527 293a 0a20 2020 2020 2020 2020  ive'):.         
-0000a2b0: 2020 2020 2020 2073 7461 7274 203d 2053         start = S
-0000a2c0: 2e5a 6572 6f0a 2020 2020 2020 2020 2020  .Zero.          
-0000a2d0: 2020 2020 2020 7374 6f70 203d 2053 2e49        stop = S.I
-0000a2e0: 6e66 696e 6974 790a 2020 2020 2020 2020  nfinity.        
-0000a2f0: 2020 2020 656c 6966 206b 7761 7267 732e      elif kwargs.
-0000a300: 6765 7428 276e 6567 6174 6976 6527 293a  get('negative'):
-0000a310: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000a320: 2073 7461 7274 203d 2053 2e4e 6567 6174   start = S.Negat
-0000a330: 6976 6549 6e66 696e 6974 790a 2020 2020  iveInfinity.    
-0000a340: 2020 2020 2020 2020 2020 2020 7374 6f70              stop
-0000a350: 203d 2053 2e5a 6572 6f0a 2020 2020 2020   = S.Zero.      
-0000a360: 2020 2020 2020 2020 2020 6b77 6172 6773            kwargs
-0000a370: 5b27 7269 6768 745f 6f70 656e 275d 203d  ['right_open'] =
-0000a380: 2054 7275 650a 2020 2020 2020 2020 2020   True.          
-0000a390: 2020 656c 6966 206b 7761 7267 732e 6765    elif kwargs.ge
-0000a3a0: 7428 276e 6f6e 706f 7369 7469 7665 2729  t('nonpositive')
-0000a3b0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-0000a3c0: 2020 7374 6172 7420 3d20 532e 4e65 6761    start = S.Nega
-0000a3d0: 7469 7665 496e 6669 6e69 7479 0a20 2020  tiveInfinity.   
-0000a3e0: 2020 2020 2020 2020 2020 2020 2073 746f               sto
-0000a3f0: 7020 3d20 532e 5a65 726f 0a20 2020 2020  p = S.Zero.     
-0000a400: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
-0000a410: 2020 2020 2020 2020 2020 2020 2073 7461               sta
-0000a420: 7274 203d 2053 2e4e 6567 6174 6976 6549  rt = S.NegativeI
-0000a430: 6e66 696e 6974 790a 2020 2020 2020 2020  nfinity.        
-0000a440: 2020 2020 2020 2020 7374 6f70 203d 2053          stop = S
-0000a450: 2e49 6e66 696e 6974 790a 2020 2020 2020  .Infinity.      
-0000a460: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
-0000a470: 2020 2020 7374 6172 7420 3d20 5f73 796d      start = _sym
-0000a480: 7069 6679 2873 7461 7274 290a 2020 2020  pify(start).    
-0000a490: 2020 2020 2020 2020 7374 6f70 203d 205f          stop = _
-0000a4a0: 7379 6d70 6966 7928 7374 6f70 290a 2020  sympify(stop).  
-0000a4b0: 2020 2020 2020 0a20 2020 2020 2020 2069        .        i
-0000a4c0: 6620 276c 6566 745f 6f70 656e 2720 696e  f 'left_open' in
-0000a4d0: 206b 7761 7267 733a 0a20 2020 2020 2020   kwargs:.       
-0000a4e0: 2020 2020 206c 6566 745f 6f70 656e 203d       left_open =
-0000a4f0: 206b 7761 7267 735b 276c 6566 745f 6f70   kwargs['left_op
-0000a500: 656e 275d 0a20 2020 2020 2020 2065 6c73  en'].        els
-0000a510: 653a 0a20 2020 2020 2020 2020 2020 2023  e:.            #
-0000a520: 2062 7920 6465 6661 756c 742c 2069 6e66   by default, inf
-0000a530: 696e 6974 6520 696e 7465 7276 616c 2073  inite interval s
-0000a540: 7461 7274 2070 6f69 6e74 7320 6172 6520  tart points are 
-0000a550: 6f70 656e 2e0a 2020 2020 2020 2020 2020  open..          
-0000a560: 2020 6966 2073 7461 7274 203d 3d20 532e    if start == S.
-0000a570: 4e65 6761 7469 7665 496e 6669 6e69 7479  NegativeInfinity
-0000a580: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-0000a590: 2020 6c65 6674 5f6f 7065 6e20 3d20 5472    left_open = Tr
-0000a5a0: 7565 0a20 2020 2020 2020 2020 2020 2065  ue.            e
-0000a5b0: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
-0000a5c0: 2020 2020 206c 6566 745f 6f70 656e 203d       left_open =
-0000a5d0: 2046 616c 7365 0a20 2020 2020 2020 2020   False.         
-0000a5e0: 2020 200a 2020 2020 2020 2020 6966 2027     .        if '
-0000a5f0: 7269 6768 745f 6f70 656e 2720 696e 206b  right_open' in k
-0000a600: 7761 7267 733a 0a20 2020 2020 2020 2020  wargs:.         
-0000a610: 2020 2072 6967 6874 5f6f 7065 6e20 3d20     right_open = 
-0000a620: 6b77 6172 6773 5b27 7269 6768 745f 6f70  kwargs['right_op
-0000a630: 656e 275d 0a20 2020 2020 2020 2065 6c73  en'].        els
-0000a640: 653a 0a20 2020 2020 2020 2020 2020 2023  e:.            #
-0000a650: 2062 7920 6465 6661 756c 742c 2069 6e66   by default, inf
-0000a660: 696e 6974 6520 696e 7465 7276 616c 2073  inite interval s
-0000a670: 746f 7020 706f 696e 7473 2061 7265 206f  top points are o
-0000a680: 7065 6e2e 0a20 2020 2020 2020 2020 2020  pen..           
-0000a690: 2069 6620 7374 6f70 203d 3d20 532e 496e   if stop == S.In
-0000a6a0: 6669 6e69 7479 3a0a 2020 2020 2020 2020  finity:.        
-0000a6b0: 2020 2020 2020 2020 7269 6768 745f 6f70          right_op
-0000a6c0: 656e 203d 2054 7275 650a 2020 2020 2020  en = True.      
-0000a6d0: 2020 2020 2020 656c 7365 3a0a 2020 2020        else:.    
-0000a6e0: 2020 2020 2020 2020 2020 2020 7269 6768              righ
-0000a6f0: 745f 6f70 656e 203d 2046 616c 7365 0a20  t_open = False. 
-0000a700: 2020 2020 2020 2020 2020 200a 2020 2020             .    
-0000a710: 2020 2020 2320 6576 616c 7561 7465 2069      # evaluate i
-0000a720: 6620 706f 7373 6962 6c65 0a20 2020 2020  f possible.     
-0000a730: 2020 2069 6620 7269 6768 745f 6f70 656e     if right_open
-0000a740: 2061 6e64 2073 746f 7020 3c3d 2073 7461   and stop <= sta
-0000a750: 7274 206f 7220 6e6f 7420 7269 6768 745f  rt or not right_
-0000a760: 6f70 656e 2061 6e64 2073 746f 7020 3c20  open and stop < 
-0000a770: 7374 6172 743a 0a20 2020 2020 2020 2020  start:.         
-0000a780: 2020 2072 6574 7572 6e20 7374 6172 742e     return start.
-0000a790: 656d 7074 7953 6574 0a0a 2020 2020 2020  emptySet..      
-0000a7a0: 2020 6966 2073 746f 7020 3d3d 2073 7461    if stop == sta
-0000a7b0: 7274 3a0a 2020 2020 2020 2020 2020 2020  rt:.            
-0000a7c0: 6966 206c 6566 745f 6f70 656e 206f 7220  if left_open or 
-0000a7d0: 7269 6768 745f 6f70 656e 3a0a 2020 2020  right_open:.    
-0000a7e0: 2020 2020 2020 2020 2020 2020 7265 7475              retu
-0000a7f0: 726e 2073 7461 7274 2e65 6d70 7479 5365  rn start.emptySe
-0000a800: 740a 2020 2020 2020 2020 2020 2020 656c  t.            el
-0000a810: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
-0000a820: 2020 2020 7265 7475 726e 2046 696e 6974      return Finit
-0000a830: 6553 6574 2873 746f 7029 0a0a 2020 2020  eSet(stop)..    
-0000a840: 2020 2020 696e 6669 6e69 7465 7369 6d61      infinitesima
-0000a850: 6c20 3d20 7374 6172 742e 6973 5f69 6e66  l = start.is_inf
-0000a860: 696e 6974 6573 696d 616c 0a20 2020 2020  initesimal.     
-0000a870: 2020 2069 6620 696e 6669 6e69 7465 7369     if infinitesi
-0000a880: 6d61 6c20 6973 2054 7275 653a 0a20 2020  mal is True:.   
-0000a890: 2020 2020 2020 2020 2073 7461 7274 203d           start =
-0000a8a0: 2073 7461 7274 2e63 6c65 6172 5f69 6e66   start.clear_inf
-0000a8b0: 696e 6974 6573 696d 616c 2829 5b30 5d0a  initesimal()[0].
-0000a8c0: 2020 2020 2020 2020 2020 2020 6c65 6674              left
-0000a8d0: 5f6f 7065 6e20 3d20 5472 7565 0a0a 2020  _open = True..  
-0000a8e0: 2020 2020 2020 696e 6669 6e69 7465 7369        infinitesi
-0000a8f0: 6d61 6c20 3d20 7374 6f70 2e69 735f 696e  mal = stop.is_in
-0000a900: 6669 6e69 7465 7369 6d61 6c0a 2020 2020  finitesimal.    
-0000a910: 2020 2020 6966 2069 6e66 696e 6974 6573      if infinites
-0000a920: 696d 616c 2069 7320 4661 6c73 653a 0a20  imal is False:. 
-0000a930: 2020 2020 2020 2020 2020 2073 746f 7020             stop 
-0000a940: 3d20 7374 6f70 2e63 6c65 6172 5f69 6e66  = stop.clear_inf
-0000a950: 696e 6974 6573 696d 616c 2829 5b30 5d0a  initesimal()[0].
-0000a960: 2020 2020 2020 2020 2020 2020 7269 6768              righ
-0000a970: 745f 6f70 656e 203d 2054 7275 650a 0a20  t_open = True.. 
-0000a980: 2020 2020 2020 2073 656c 6620 3d20 4261         self = Ba
-0000a990: 7369 632e 5f5f 6e65 775f 5f28 636c 732c  sic.__new__(cls,
-0000a9a0: 2073 7461 7274 2c20 7374 6f70 290a 2020   start, stop).  
-0000a9b0: 2020 2020 2020 7365 6c66 2e6c 6566 745f        self.left_
-0000a9c0: 6f70 656e 203d 2062 6f6f 6c28 6c65 6674  open = bool(left
-0000a9d0: 5f6f 7065 6e29 0a20 2020 2020 2020 2073  _open).        s
-0000a9e0: 656c 662e 7269 6768 745f 6f70 656e 203d  elf.right_open =
-0000a9f0: 2062 6f6f 6c28 7269 6768 745f 6f70 656e   bool(right_open
-0000aa00: 290a 2020 2020 2020 2020 7265 7475 726e  ).        return
-0000aa10: 2073 656c 660a 0a20 2020 2064 6566 2065   self..    def e
-0000aa20: 6c65 6d65 6e74 5f73 796d 626f 6c28 7365  lement_symbol(se
-0000aa30: 6c66 2c20 6578 636c 7564 6573 3d73 6574  lf, excludes=set
-0000aa40: 2829 293a 0a20 2020 2020 2020 2072 6574  ()):.        ret
-0000aa50: 7572 6e20 7365 6c66 2e67 656e 6572 6174  urn self.generat
-0000aa60: 655f 7661 7228 6578 636c 7564 6573 2c20  e_var(excludes, 
-0000aa70: 2a2a 7365 6c66 2e65 7479 7065 2e64 6963  **self.etype.dic
-0000aa80: 7429 0a0a 2020 2020 4070 726f 7065 7274  t)..    @propert
-0000aa90: 790a 2020 2020 6465 6620 7369 7a65 2873  y.    def size(s
-0000aaa0: 656c 6629 3a0a 2020 2020 2020 2020 6966  elf):.        if
-0000aab0: 2073 656c 662e 6574 7970 652e 6973 5f69   self.etype.is_i
-0000aac0: 6e74 6567 6572 3a0a 2020 2020 2020 2020  nteger:.        
-0000aad0: 2020 2020 6966 2073 656c 662e 6c65 6674      if self.left
-0000aae0: 5f6f 7065 6e3a 0a20 2020 2020 2020 2020  _open:.         
-0000aaf0: 2020 2020 2020 2073 7461 7274 203d 2073         start = s
-0000ab00: 656c 662e 7374 6172 7420 2b20 310a 2020  elf.start + 1.  
-0000ab10: 2020 2020 2020 2020 2020 656c 7365 3a0a            else:.
-0000ab20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ab30: 7374 6172 7420 3d20 7365 6c66 2e73 7461  start = self.sta
-0000ab40: 7274 0a20 2020 2020 2020 2020 2020 2069  rt.            i
-0000ab50: 6620 7365 6c66 2e72 6967 6874 5f6f 7065  f self.right_ope
-0000ab60: 6e3a 0a20 2020 2020 2020 2020 2020 2020  n:.             
-0000ab70: 2020 2073 746f 7020 3d20 7365 6c66 2e73     stop = self.s
-0000ab80: 746f 700a 2020 2020 2020 2020 2020 2020  top.            
-0000ab90: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
-0000aba0: 2020 2020 2020 7374 6f70 203d 2073 656c        stop = sel
-0000abb0: 662e 7374 6f70 202b 2031 0a20 2020 2020  f.stop + 1.     
-0000abc0: 2020 2020 2020 2072 6574 7572 6e20 7374         return st
-0000abd0: 6f70 202d 2073 7461 7274 0a20 2020 2020  op - start.     
-0000abe0: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
-0000abf0: 2020 2020 2072 6574 7572 6e20 7365 6c66       return self
-0000ac00: 2e73 746f 7020 2d20 7365 6c66 2e73 7461  .stop - self.sta
-0000ac10: 7274 0a0a 2020 2020 6465 6620 5f65 7661  rt..    def _eva
-0000ac20: 6c5f 4361 7264 2873 656c 6629 3a0a 2020  l_Card(self):.  
-0000ac30: 2020 2020 2020 2e2e 2e0a 0a20 2020 2040        .....    @
-0000ac40: 7072 6f70 6572 7479 0a20 2020 2064 6566  property.    def
-0000ac50: 2073 7461 7274 2873 656c 6629 3a0a 2020   start(self):.  
-0000ac60: 2020 2020 2020 2222 220a 2020 2020 2020        """.      
-0000ac70: 2020 5468 6520 6c65 6674 2065 6e64 2070    The left end p
-0000ac80: 6f69 6e74 206f 6620 2773 656c 6627 2e0a  oint of 'self'..
-0000ac90: 0a20 2020 2020 2020 2054 6869 7320 7072  .        This pr
-0000aca0: 6f70 6572 7479 2074 616b 6573 2074 6865  operty takes the
-0000acb0: 2073 616d 6520 7661 6c75 6520 6173 2074   same value as t
-0000acc0: 6865 2027 696e 6627 2070 726f 7065 7274  he 'inf' propert
-0000acd0: 792e 0a0a 2020 2020 2020 2020 4578 616d  y...        Exam
-0000ace0: 706c 6573 0a20 2020 2020 2020 203d 3d3d  ples.        ===
-0000acf0: 3d3d 3d3d 3d0a 0a20 2020 2020 2020 203e  =====..        >
-0000ad00: 3e3e 2066 726f 6d20 7379 6d70 7920 696d  >> from sympy im
-0000ad10: 706f 7274 2049 6e74 6572 7661 6c0a 2020  port Interval.  
-0000ad20: 2020 2020 2020 3e3e 3e20 496e 7465 7276        >>> Interv
-0000ad30: 616c 2830 2c20 3129 2e73 7461 7274 0a20  al(0, 1).start. 
-0000ad40: 2020 2020 2020 2030 0a0a 2020 2020 2020         0..      
-0000ad50: 2020 2222 220a 2020 2020 2020 2020 7265    """.        re
-0000ad60: 7475 726e 2073 656c 662e 5f61 7267 735b  turn self._args[
-0000ad70: 305d 0a0a 2020 2020 5f69 6e66 203d 206c  0]..    _inf = l
-0000ad80: 6566 7420 3d20 7374 6172 740a 0a20 2020  eft = start..   
-0000ad90: 2040 636c 6173 736d 6574 686f 640a 2020   @classmethod.  
-0000ada0: 2020 6465 6620 6f70 656e 2863 6c73 2c20    def open(cls, 
-0000adb0: 612c 2062 293a 0a20 2020 2020 2020 2022  a, b):.        "
-0000adc0: 2222 5265 7475 726e 2061 6e20 696e 7465  ""Return an inte
-0000add0: 7276 616c 2069 6e63 6c75 6469 6e67 206e  rval including n
-0000ade0: 6569 7468 6572 2062 6f75 6e64 6172 792e  either boundary.
-0000adf0: 2222 220a 2020 2020 2020 2020 7265 7475  """.        retu
-0000ae00: 726e 2063 6c73 2861 2c20 622c 206c 6566  rn cls(a, b, lef
-0000ae10: 745f 6f70 656e 3d54 7275 652c 2072 6967  t_open=True, rig
-0000ae20: 6874 5f6f 7065 6e3d 5472 7565 290a 0a20  ht_open=True).. 
-0000ae30: 2020 2040 636c 6173 736d 6574 686f 640a     @classmethod.
-0000ae40: 2020 2020 6465 6620 4c6f 7065 6e28 636c      def Lopen(cl
-0000ae50: 732c 2061 2c20 6229 3a0a 2020 2020 2020  s, a, b):.      
-0000ae60: 2020 2222 2252 6574 7572 6e20 616e 2069    """Return an i
-0000ae70: 6e74 6572 7661 6c20 6e6f 7420 696e 636c  nterval not incl
-0000ae80: 7564 696e 6720 7468 6520 6c65 6674 2062  uding the left b
-0000ae90: 6f75 6e64 6172 792e 2222 220a 2020 2020  oundary.""".    
-0000aea0: 2020 2020 7265 7475 726e 2063 6c73 2861      return cls(a
-0000aeb0: 2c20 622c 206c 6566 745f 6f70 656e 3d54  , b, left_open=T
-0000aec0: 7275 652c 2072 6967 6874 5f6f 7065 6e3d  rue, right_open=
-0000aed0: 4661 6c73 6529 0a0a 2020 2020 4063 6c61  False)..    @cla
-0000aee0: 7373 6d65 7468 6f64 0a20 2020 2064 6566  ssmethod.    def
-0000aef0: 2052 6f70 656e 2863 6c73 2c20 612c 2062   Ropen(cls, a, b
-0000af00: 293a 0a20 2020 2020 2020 2022 2222 5265  ):.        """Re
-0000af10: 7475 726e 2061 6e20 696e 7465 7276 616c  turn an interval
-0000af20: 206e 6f74 2069 6e63 6c75 6469 6e67 2074   not including t
-0000af30: 6865 2072 6967 6874 2062 6f75 6e64 6172  he right boundar
-0000af40: 792e 2222 220a 2020 2020 2020 2020 7265  y.""".        re
-0000af50: 7475 726e 2063 6c73 2861 2c20 622c 206c  turn cls(a, b, l
-0000af60: 6566 745f 6f70 656e 3d46 616c 7365 2c20  eft_open=False, 
-0000af70: 7269 6768 745f 6f70 656e 3d54 7275 6529  right_open=True)
-0000af80: 0a0a 2020 2020 4070 726f 7065 7274 790a  ..    @property.
-0000af90: 2020 2020 6465 6620 7374 6f70 2873 656c      def stop(sel
-0000afa0: 6629 3a0a 2020 2020 2020 2020 2222 220a  f):.        """.
-0000afb0: 2020 2020 2020 2020 5468 6520 7269 6768          The righ
-0000afc0: 7420 656e 6420 706f 696e 7420 6f66 2027  t end point of '
-0000afd0: 7365 6c66 272e 0a0a 2020 2020 2020 2020  self'...        
-0000afe0: 5468 6973 2070 726f 7065 7274 7920 7461  This property ta
-0000aff0: 6b65 7320 7468 6520 7361 6d65 2076 616c  kes the same val
-0000b000: 7565 2061 7320 7468 6520 2773 7570 2720  ue as the 'sup' 
-0000b010: 7072 6f70 6572 7479 2e0a 0a20 2020 2020  property...     
-0000b020: 2020 2045 7861 6d70 6c65 730a 2020 2020     Examples.    
-0000b030: 2020 2020 3d3d 3d3d 3d3d 3d3d 0a0a 2020      ========..  
-0000b040: 2020 2020 2020 3e3e 3e20 6672 6f6d 2073        >>> from s
-0000b050: 796d 7079 2069 6d70 6f72 7420 496e 7465  ympy import Inte
-0000b060: 7276 616c 0a20 2020 2020 2020 203e 3e3e  rval.        >>>
-0000b070: 2049 6e74 6572 7661 6c28 302c 2031 292e   Interval(0, 1).
-0000b080: 7374 6f70 0a20 2020 2020 2020 2031 0a0a  stop.        1..
-0000b090: 2020 2020 2020 2020 2222 220a 2020 2020          """.    
-0000b0a0: 2020 2020 7265 7475 726e 2073 656c 662e      return self.
-0000b0b0: 5f61 7267 735b 315d 0a0a 2020 2020 5f73  _args[1]..    _s
-0000b0c0: 7570 203d 2072 6967 6874 203d 2073 746f  up = right = sto
-0000b0d0: 700a 0a23 2020 2020 2074 7279 696e 6720  p..#     trying 
-0000b0e0: 746f 2065 7661 6c75 6174 6520 6f74 6865  to evaluate othe
-0000b0f0: 7220 2d20 7365 6c66 0a20 2020 2064 6566  r - self.    def
-0000b100: 205f 636f 6d70 6c65 6d65 6e74 2873 656c   _complement(sel
-0000b110: 662c 206f 7468 6572 293a 0a20 2020 2020  f, other):.     
-0000b120: 2020 2069 6620 6f74 6865 722e 6973 5f49     if other.is_I
-0000b130: 6e74 6572 7661 6c20 616e 6420 6f74 6865  nterval and othe
-0000b140: 722e 7374 6172 742e 6973 5f69 6e66 696e  r.start.is_infin
-0000b150: 6974 6520 616e 6420 6f74 6865 722e 7374  ite and other.st
-0000b160: 6f70 2e69 735f 696e 6669 6e69 7465 3a0a  op.is_infinite:.
-0000b170: 2020 2020 2020 2020 2020 2020 6120 3d20              a = 
-0000b180: 496e 7465 7276 616c 2853 2e4e 6567 6174  Interval(S.Negat
-0000b190: 6976 6549 6e66 696e 6974 792c 2073 656c  iveInfinity, sel
-0000b1a0: 662e 7374 6172 742c 206c 6566 745f 6f70  f.start, left_op
-0000b1b0: 656e 3d6f 7468 6572 2e6c 6566 745f 6f70  en=other.left_op
-0000b1c0: 656e 2c20 7269 6768 745f 6f70 656e 3d6e  en, right_open=n
-0000b1d0: 6f74 2073 656c 662e 6c65 6674 5f6f 7065  ot self.left_ope
-0000b1e0: 6e29 0a20 2020 2020 2020 2020 2020 2062  n).            b
-0000b1f0: 203d 2049 6e74 6572 7661 6c28 7365 6c66   = Interval(self
-0000b200: 2e73 746f 702c 2053 2e49 6e66 696e 6974  .stop, S.Infinit
-0000b210: 792c 206c 6566 745f 6f70 656e 3d6e 6f74  y, left_open=not
-0000b220: 2073 656c 662e 7269 6768 745f 6f70 656e   self.right_open
-0000b230: 2c20 7269 6768 745f 6f70 656e 3d6f 7468  , right_open=oth
-0000b240: 6572 2e72 6967 6874 5f6f 7065 6e29 0a20  er.right_open). 
-0000b250: 2020 2020 2020 2020 2020 2072 6574 7572             retur
-0000b260: 6e20 6120 7c20 620a 2020 2020 2020 2020  n a | b.        
-0000b270: 0a20 2020 2020 2020 2066 726f 6d20 7379  .        from sy
-0000b280: 6d70 792e 7365 7473 2069 6d70 6f72 7420  mpy.sets import 
-0000b290: 496e 7465 6765 7273 0a20 2020 2020 2020  Integers.       
-0000b2a0: 2069 6620 6f74 6865 7220 3d3d 2049 6e74   if other == Int
-0000b2b0: 6567 6572 733a 0a20 2020 2020 2020 2020  egers:.         
-0000b2c0: 2020 2073 7461 7274 2c20 7374 6f70 203d     start, stop =
-0000b2d0: 2053 2e4e 6567 6174 6976 6549 6e66 696e   S.NegativeInfin
-0000b2e0: 6974 792c 2073 656c 662e 7374 6172 740a  ity, self.start.
-0000b2f0: 2020 2020 2020 2020 2020 2020 6966 2073              if s
-0000b300: 656c 662e 6c65 6674 5f6f 7065 6e3a 0a20  elf.left_open:. 
-0000b310: 2020 2020 2020 2020 2020 2020 2020 2073                 s
-0000b320: 746f 7020 2b3d 2031 0a20 2020 2020 2020  top += 1.       
-0000b330: 2020 2020 2066 726f 6d20 7379 6d70 7920       from sympy 
-0000b340: 696d 706f 7274 2052 616e 6765 0a20 2020  import Range.   
-0000b350: 2020 2020 2020 2020 2061 203d 2052 616e           a = Ran
-0000b360: 6765 2873 7461 7274 2c20 7374 6f70 290a  ge(start, stop).
-0000b370: 2020 2020 2020 2020 2020 2020 0a20 2020              .   
-0000b380: 2020 2020 2020 2020 2073 7461 7274 2c20           start, 
-0000b390: 7374 6f70 203d 2073 656c 662e 7374 6f70  stop = self.stop
-0000b3a0: 2c20 532e 496e 6669 6e69 7479 0a20 2020  , S.Infinity.   
-0000b3b0: 2020 2020 2020 2020 2069 6620 6e6f 7420           if not 
-0000b3c0: 7365 6c66 2e72 6967 6874 5f6f 7065 6e3a  self.right_open:
-0000b3d0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000b3e0: 2073 7461 7274 202b 3d20 310a 2020 2020   start += 1.    
-0000b3f0: 2020 2020 2020 2020 6220 3d20 5261 6e67          b = Rang
-0000b400: 6528 7374 6172 742c 2073 746f 7029 0a20  e(start, stop). 
-0000b410: 2020 2020 2020 2020 2020 2072 6574 7572             retur
-0000b420: 6e20 6120 7c20 620a 0a20 2020 2020 2020  n a | b..       
-0000b430: 2069 6620 6f74 6865 722e 6973 5f46 696e   if other.is_Fin
-0000b440: 6974 6553 6574 3a0a 2020 2020 2020 2020  iteSet:.        
-0000b450: 2020 2020 6e75 6d73 203d 205b 6d20 666f      nums = [m fo
-0000b460: 7220 6d20 696e 206f 7468 6572 2e61 7267  r m in other.arg
-0000b470: 7320 6966 206d 2e69 735f 6e75 6d62 6572  s if m.is_number
-0000b480: 5d0a 2020 2020 2020 2020 2020 2020 6966  ].            if
-0000b490: 206e 756d 7320 3d3d 205b 5d3a 0a20 2020   nums == []:.   
-0000b4a0: 2020 2020 2020 2020 2020 2020 2072 6574               ret
-0000b4b0: 7572 6e0a 0a20 2020 2020 2020 2072 6574  urn..        ret
-0000b4c0: 7572 6e20 5365 742e 5f63 6f6d 706c 656d  urn Set._complem
-0000b4d0: 656e 7428 7365 6c66 2c20 6f74 6865 7229  ent(self, other)
-0000b4e0: 0a0a 2020 2020 4070 726f 7065 7274 790a  ..    @property.
-0000b4f0: 2020 2020 6465 6620 5f62 6f75 6e64 6172      def _boundar
-0000b500: 7928 7365 6c66 293a 0a20 2020 2020 2020  y(self):.       
-0000b510: 2066 726f 6d20 7379 6d70 7920 696d 706f   from sympy impo
-0000b520: 7274 2046 696e 6974 6553 6574 0a20 2020  rt FiniteSet.   
-0000b530: 2020 2020 2066 696e 6974 655f 706f 696e       finite_poin
-0000b540: 7473 203d 205b 7020 666f 7220 7020 696e  ts = [p for p in
-0000b550: 2028 7365 6c66 2e73 7461 7274 2c20 7365   (self.start, se
-0000b560: 6c66 2e73 746f 7029 2069 6620 6162 7328  lf.stop) if abs(
-0000b570: 7029 2021 3d20 532e 496e 6669 6e69 7479  p) != S.Infinity
-0000b580: 5d0a 2020 2020 2020 2020 7265 7475 726e  ].        return
-0000b590: 2046 696e 6974 6553 6574 282a 6669 6e69   FiniteSet(*fini
-0000b5a0: 7465 5f70 6f69 6e74 7329 0a0a 2020 2020  te_points)..    
-0000b5b0: 6465 6620 5f63 6f6e 7461 696e 7328 7365  def _contains(se
-0000b5c0: 6c66 2c20 6f74 6865 7229 3a0a 2020 2020  lf, other):.    
-0000b5d0: 2020 2020 6966 206e 6f74 2069 7369 6e73      if not isins
-0000b5e0: 7461 6e63 6528 6f74 6865 722c 2045 7870  tance(other, Exp
-0000b5f0: 7229 206f 7220 6f74 6865 7220 6973 2053  r) or other is S
-0000b600: 2e4e 614e 206f 7220 6f74 6865 7220 6973  .NaN or other is
-0000b610: 2053 2e43 6f6d 706c 6578 496e 6669 6e69   S.ComplexInfini
-0000b620: 7479 206f 7220 6f74 6865 722e 6973 5f65  ty or other.is_e
-0000b630: 7874 656e 6465 645f 7265 616c 203d 3d20  xtended_real == 
-0000b640: 4661 6c73 653a 0a20 2020 2020 2020 2020  False:.         
-0000b650: 2020 2072 6574 7572 6e20 532e 6661 6c73     return S.fals
-0000b660: 650a 0a20 2020 2020 2020 2069 6620 6f74  e..        if ot
-0000b670: 6865 722e 6973 5f49 6e66 696e 6974 793a  her.is_Infinity:
-0000b680: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
-0000b690: 6e6f 7420 7365 6c66 2e73 746f 702e 6973  not self.stop.is
-0000b6a0: 5f49 6e66 696e 6974 7920 6f72 2073 656c  _Infinity or sel
-0000b6b0: 662e 7269 6768 745f 6f70 656e 3a0a 2020  f.right_open:.  
-0000b6c0: 2020 2020 2020 2020 2020 2020 2020 7265                re
-0000b6d0: 7475 726e 2053 2e66 616c 7365 0a20 2020  turn S.false.   
-0000b6e0: 2020 2020 2020 2020 2020 2020 200a 2020               .  
-0000b6f0: 2020 2020 2020 6966 206f 7468 6572 2e69        if other.i
-0000b700: 735f 4e65 6761 7469 7665 496e 6669 6e69  s_NegativeInfini
-0000b710: 7479 3a0a 2020 2020 2020 2020 2020 2020  ty:.            
-0000b720: 6966 206e 6f74 2073 656c 662e 7374 6172  if not self.star
-0000b730: 742e 6973 5f4e 6567 6174 6976 6549 6e66  t.is_NegativeInf
-0000b740: 696e 6974 7920 6f72 2073 656c 662e 6c65  inity or self.le
-0000b750: 6674 5f6f 7065 6e3a 0a20 2020 2020 2020  ft_open:.       
-0000b760: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
-0000b770: 532e 6661 6c73 650a 2020 2020 2020 2020  S.false.        
-0000b780: 2020 2020 0a20 2020 2020 2020 2069 6620      .        if 
-0000b790: 7365 6c66 2e73 7461 7274 2069 7320 532e  self.start is S.
-0000b7a0: 4e65 6761 7469 7665 496e 6669 6e69 7479  NegativeInfinity
-0000b7b0: 2061 6e64 2073 656c 662e 7374 6f70 2069   and self.stop i
-0000b7c0: 7320 532e 496e 6669 6e69 7479 3a0a 2020  s S.Infinity:.  
-0000b7d0: 2020 2020 2020 2020 2020 6966 2073 656c            if sel
-0000b7e0: 662e 6c65 6674 5f6f 7065 6e3a 0a20 2020  f.left_open:.   
-0000b7f0: 2020 2020 2020 2020 2020 2020 2069 6620               if 
-0000b800: 7365 6c66 2e72 6967 6874 5f6f 7065 6e3a  self.right_open:
-0000b810: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000b820: 2020 2020 2023 2073 656c 6620 3d20 282d       # self = (-
-0000b830: 6f6f 2c20 6f6f 290a 2020 2020 2020 2020  oo, oo).        
-0000b840: 2020 2020 2020 2020 2020 2020 6966 206f              if o
-0000b850: 7468 6572 2e69 735f 7265 616c 3a0a 2020  ther.is_real:.  
-0000b860: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b870: 2020 2020 2020 7265 7475 726e 2053 2e74        return S.t
-0000b880: 7275 650a 2020 2020 2020 2020 2020 2020  rue.            
-0000b890: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
-0000b8a0: 2020 2020 2020 2020 2020 2020 2020 2320                # 
-0000b8b0: 7365 6c66 203d 2028 2d6f 6f2c 206f 6f5d  self = (-oo, oo]
-0000b8c0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000b8d0: 2020 2020 2069 6620 6f74 6865 722e 6973       if other.is
-0000b8e0: 5f6e 6f6e 706f 7369 7469 7665 206f 7220  _nonpositive or 
-0000b8f0: 6f74 6865 722e 6973 5f65 7874 656e 6465  other.is_extende
-0000b900: 645f 706f 7369 7469 7665 3a0a 2020 2020  d_positive:.    
-0000b910: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b920: 2020 2020 7265 7475 726e 2053 2e74 7275      return S.tru
-0000b930: 650a 2020 2020 2020 2020 2020 2020 656c  e.            el
-0000b940: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
-0000b950: 2020 2020 6966 2073 656c 662e 7269 6768      if self.righ
-0000b960: 745f 6f70 656e 3a0a 2020 2020 2020 2020  t_open:.        
-0000b970: 2020 2020 2020 2020 2020 2020 2320 7365              # se
-0000b980: 6c66 203d 205b 2d6f 6f2c 206f 6f29 0a20  lf = [-oo, oo). 
-0000b990: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b9a0: 2020 2069 6620 6f74 6865 722e 6973 5f6e     if other.is_n
-0000b9b0: 6f6e 6e65 6761 7469 7665 206f 7220 6f74  onnegative or ot
-0000b9c0: 6865 722e 6973 5f65 7874 656e 6465 645f  her.is_extended_
-0000b9d0: 6e65 6761 7469 7665 3a0a 2020 2020 2020  negative:.      
-0000b9e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b9f0: 2020 7265 7475 726e 2053 2e74 7275 650a    return S.true.
-0000ba00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ba10: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
-0000ba20: 2020 2020 2020 2020 2020 2320 7365 6c66            # self
-0000ba30: 203d 205b 2d6f 6f2c 206f 6f5d 0a20 2020   = [-oo, oo].   
-0000ba40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ba50: 2069 6620 6f74 6865 722e 6973 5f65 7874   if other.is_ext
-0000ba60: 656e 6465 645f 7265 616c 3a0a 2020 2020  ended_real:.    
-0000ba70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ba80: 2020 2020 7265 7475 726e 2053 2e74 7275      return S.tru
-0000ba90: 650a 0a20 2020 2020 2020 2069 6620 6f74  e..        if ot
-0000baa0: 6865 722e 6973 5f65 7874 656e 6465 645f  her.is_extended_
-0000bab0: 7265 616c 203d 3d20 4661 6c73 653a 0a20  real == False:. 
-0000bac0: 2020 2020 2020 2020 2020 2072 6574 7572             retur
-0000bad0: 6e20 532e 6661 6c73 650a 2020 2020 2020  n S.false.      
-0000bae0: 2020 0a20 2020 2020 2020 2069 6620 6f74    .        if ot
-0000baf0: 6865 722e 6973 5f65 7874 656e 6465 645f  her.is_extended_
-0000bb00: 7265 616c 2069 7320 4e6f 6e65 3a0a 2020  real is None:.  
-0000bb10: 2020 2020 2020 2020 2020 7265 7475 726e            return
-0000bb20: 0a20 2020 2020 2020 200a 2020 2020 2020  .        .      
-0000bb30: 2020 6966 2073 656c 662e 6c65 6674 5f6f    if self.left_o
-0000bb40: 7065 6e3a 0a20 2020 2020 2020 2020 2020  pen:.           
-0000bb50: 2065 7870 7220 3d20 6f74 6865 7220 3e20   expr = other > 
-0000bb60: 7365 6c66 2e73 7461 7274 0a20 2020 2020  self.start.     
-0000bb70: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
-0000bb80: 2020 2020 2065 7870 7220 3d20 6f74 6865       expr = othe
-0000bb90: 7220 3e3d 2073 656c 662e 7374 6172 740a  r >= self.start.
-0000bba0: 0a20 2020 2020 2020 2069 6620 7365 6c66  .        if self
-0000bbb0: 2e72 6967 6874 5f6f 7065 6e3a 0a20 2020  .right_open:.   
-0000bbc0: 2020 2020 2020 2020 2065 7870 7220 3d20           expr = 
-0000bbd0: 416e 6428 6578 7072 2c20 6f74 6865 7220  And(expr, other 
-0000bbe0: 3c20 7365 6c66 2e73 746f 7029 0a20 2020  < self.stop).   
-0000bbf0: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
-0000bc00: 2020 2020 2020 2065 7870 7220 3d20 416e         expr = An
-0000bc10: 6428 6578 7072 2c20 6f74 6865 7220 3c3d  d(expr, other <=
-0000bc20: 2073 656c 662e 7374 6f70 290a 0a20 2020   self.stop)..   
-0000bc30: 2020 2020 2072 6574 7572 6e20 5f73 796d       return _sym
-0000bc40: 7069 6679 2865 7870 7229 0a0a 2020 2020  pify(expr)..    
-0000bc50: 4070 726f 7065 7274 790a 2020 2020 6465  @property.    de
-0000bc60: 6620 5f6d 6561 7375 7265 2873 656c 6629  f _measure(self)
-0000bc70: 3a0a 2020 2020 2020 2020 7265 7475 726e  :.        return
-0000bc80: 2073 656c 662e 7374 6f70 202d 2073 656c   self.stop - sel
-0000bc90: 662e 7374 6172 740a 0a20 2020 2064 6566  f.start..    def
-0000bca0: 2064 6f69 7428 7365 6c66 2c20 6465 6570   doit(self, deep
-0000bcb0: 3d46 616c 7365 2c20 2a2a 5f29 3a0a 2020  =False, **_):.  
-0000bcc0: 2020 2020 2020 6966 2064 6565 703a 0a20        if deep:. 
-0000bcd0: 2020 2020 2020 2020 2020 2072 6574 7572             retur
-0000bce0: 6e20 7365 6c66 2e63 6f70 7928 7374 6172  n self.copy(star
-0000bcf0: 743d 7365 6c66 2e73 7461 7274 2e64 6f69  t=self.start.doi
-0000bd00: 7428 292c 2073 746f 703d 7365 6c66 2e73  t(), stop=self.s
-0000bd10: 746f 702e 646f 6974 2829 290a 2020 2020  top.doit()).    
-0000bd20: 2020 2020 7265 7475 726e 2073 656c 660a      return self.
-0000bd30: 0a20 2020 2064 6566 2074 6f5f 6d70 6928  .    def to_mpi(
-0000bd40: 7365 6c66 2c20 7072 6563 3d35 3329 3a0a  self, prec=53):.
-0000bd50: 2020 2020 2020 2020 7265 7475 726e 206d          return m
-0000bd60: 7069 286d 7066 2873 656c 662e 7374 6172  pi(mpf(self.star
-0000bd70: 742e 5f65 7661 6c5f 6576 616c 6628 7072  t._eval_evalf(pr
-0000bd80: 6563 2929 2c0a 2020 2020 2020 2020 2020  ec)),.          
-0000bd90: 2020 6d70 6628 7365 6c66 2e73 746f 702e    mpf(self.stop.
-0000bda0: 5f65 7661 6c5f 6576 616c 6628 7072 6563  _eval_evalf(prec
-0000bdb0: 2929 290a 0a20 2020 2064 6566 205f 6576  )))..    def _ev
-0000bdc0: 616c 5f65 7661 6c66 2873 656c 662c 2070  al_evalf(self, p
-0000bdd0: 7265 6329 3a0a 2020 2020 2020 2020 7265  rec):.        re
-0000bde0: 7475 726e 2049 6e74 6572 7661 6c28 7365  turn Interval(se
-0000bdf0: 6c66 2e6c 6566 742e 5f65 7661 6c5f 6576  lf.left._eval_ev
-0000be00: 616c 6628 7072 6563 292c 2073 656c 662e  alf(prec), self.
-0000be10: 7269 6768 742e 5f65 7661 6c5f 6576 616c  right._eval_eval
-0000be20: 6628 7072 6563 292c 0a20 2020 2020 2020  f(prec),.       
-0000be30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000be40: 206c 6566 745f 6f70 656e 3d73 656c 662e   left_open=self.
-0000be50: 6c65 6674 5f6f 7065 6e2c 2072 6967 6874  left_open, right
-0000be60: 5f6f 7065 6e3d 7365 6c66 2e72 6967 6874  _open=self.right
-0000be70: 5f6f 7065 6e29 0a0a 2020 2020 6465 6620  _open)..    def 
-0000be80: 5f69 735f 636f 6d70 6172 6162 6c65 2873  _is_comparable(s
-0000be90: 656c 662c 206f 7468 6572 293a 0a20 2020  elf, other):.   
-0000bea0: 2020 2020 2069 735f 636f 6d70 6172 6162       is_comparab
-0000beb0: 6c65 203d 2073 656c 662e 7374 6172 742e  le = self.start.
-0000bec0: 6973 5f63 6f6d 7061 7261 626c 650a 2020  is_comparable.  
-0000bed0: 2020 2020 2020 6973 5f63 6f6d 7061 7261        is_compara
-0000bee0: 626c 6520 263d 2073 656c 662e 7374 6f70  ble &= self.stop
-0000bef0: 2e69 735f 636f 6d70 6172 6162 6c65 0a20  .is_comparable. 
-0000bf00: 2020 2020 2020 2069 735f 636f 6d70 6172         is_compar
-0000bf10: 6162 6c65 2026 3d20 6f74 6865 722e 7374  able &= other.st
-0000bf20: 6172 742e 6973 5f63 6f6d 7061 7261 626c  art.is_comparabl
-0000bf30: 650a 2020 2020 2020 2020 6973 5f63 6f6d  e.        is_com
-0000bf40: 7061 7261 626c 6520 263d 206f 7468 6572  parable &= other
-0000bf50: 2e73 746f 702e 6973 5f63 6f6d 7061 7261  .stop.is_compara
-0000bf60: 626c 650a 0a20 2020 2020 2020 2072 6574  ble..        ret
-0000bf70: 7572 6e20 6973 5f63 6f6d 7061 7261 626c  urn is_comparabl
-0000bf80: 650a 0a20 2020 2040 7072 6f70 6572 7479  e..    @property
-0000bf90: 0a20 2020 2064 6566 2069 735f 6c65 6674  .    def is_left
-0000bfa0: 5f75 6e62 6f75 6e64 6564 2873 656c 6629  _unbounded(self)
-0000bfb0: 3a0a 2020 2020 2020 2020 2222 2252 6574  :.        """Ret
-0000bfc0: 7572 6e20 6060 5472 7565 6060 2069 6620  urn ``True`` if 
-0000bfd0: 7468 6520 6c65 6674 2065 6e64 706f 696e  the left endpoin
-0000bfe0: 7420 6973 206e 6567 6174 6976 6520 696e  t is negative in
-0000bff0: 6669 6e69 7479 2e20 2222 220a 2020 2020  finity. """.    
-0000c000: 2020 2020 6672 6f6d 2073 796d 7079 2e63      from sympy.c
-0000c010: 6f72 652e 6e75 6d62 6572 7320 696d 706f  ore.numbers impo
-0000c020: 7274 2046 6c6f 6174 0a20 2020 2020 2020  rt Float.       
-0000c030: 2072 6574 7572 6e20 7365 6c66 2e6c 6566   return self.lef
-0000c040: 7420 6973 2053 2e4e 6567 6174 6976 6549  t is S.NegativeI
-0000c050: 6e66 696e 6974 7920 6f72 2073 656c 662e  nfinity or self.
-0000c060: 6c65 6674 203d 3d20 466c 6f61 7428 222d  left == Float("-
-0000c070: 696e 6622 290a 0a20 2020 2040 7072 6f70  inf")..    @prop
-0000c080: 6572 7479 0a20 2020 2064 6566 2069 735f  erty.    def is_
-0000c090: 7269 6768 745f 756e 626f 756e 6465 6428  right_unbounded(
-0000c0a0: 7365 6c66 293a 0a20 2020 2020 2020 2022  self):.        "
-0000c0b0: 2222 5265 7475 726e 2060 6054 7275 6560  ""Return ``True`
-0000c0c0: 6020 6966 2074 6865 2072 6967 6874 2065  ` if the right e
-0000c0d0: 6e64 706f 696e 7420 6973 2070 6f73 6974  ndpoint is posit
-0000c0e0: 6976 6520 696e 6669 6e69 7479 2e20 2222  ive infinity. ""
-0000c0f0: 220a 2020 2020 2020 2020 6672 6f6d 2073  ".        from s
-0000c100: 796d 7079 2e63 6f72 652e 6e75 6d62 6572  ympy.core.number
-0000c110: 7320 696d 706f 7274 2046 6c6f 6174 0a20  s import Float. 
-0000c120: 2020 2020 2020 2072 6574 7572 6e20 7365         return se
-0000c130: 6c66 2e72 6967 6874 2069 7320 532e 496e  lf.right is S.In
-0000c140: 6669 6e69 7479 206f 7220 7365 6c66 2e72  finity or self.r
-0000c150: 6967 6874 203d 3d20 466c 6f61 7428 222b  ight == Float("+
-0000c160: 696e 6622 290a 0a20 2020 2064 6566 2061  inf")..    def a
-0000c170: 735f 7265 6c61 7469 6f6e 616c 2873 656c  s_relational(sel
-0000c180: 662c 2078 293a 0a20 2020 2020 2020 2022  f, x):.        "
-0000c190: 2222 5265 7772 6974 6520 616e 2069 6e74  ""Rewrite an int
-0000c1a0: 6572 7661 6c20 696e 2074 6572 6d73 206f  erval in terms o
-0000c1b0: 6620 696e 6571 7561 6c69 7469 6573 2061  f inequalities a
-0000c1c0: 6e64 206c 6f67 6963 206f 7065 7261 746f  nd logic operato
-0000c1d0: 7273 2e22 2222 0a20 2020 2020 2020 2078  rs.""".        x
-0000c1e0: 203d 2073 796d 7069 6679 2878 290a 2020   = sympify(x).  
-0000c1f0: 2020 2020 2020 6966 2073 656c 662e 7269        if self.ri
-0000c200: 6768 745f 6f70 656e 3a0a 2020 2020 2020  ght_open:.      
-0000c210: 2020 2020 2020 7269 6768 7420 3d20 7820        right = x 
-0000c220: 3c20 7365 6c66 2e73 746f 700a 2020 2020  < self.stop.    
-0000c230: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
-0000c240: 2020 2020 2020 7269 6768 7420 3d20 7820        right = x 
-0000c250: 3c3d 2073 656c 662e 7374 6f70 0a20 2020  <= self.stop.   
-0000c260: 2020 2020 2069 6620 7365 6c66 2e6c 6566       if self.lef
-0000c270: 745f 6f70 656e 3a0a 2020 2020 2020 2020  t_open:.        
-0000c280: 2020 2020 6c65 6674 203d 2073 656c 662e      left = self.
-0000c290: 7374 6172 7420 3c20 780a 2020 2020 2020  start < x.      
-0000c2a0: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
-0000c2b0: 2020 2020 6c65 6674 203d 2073 656c 662e      left = self.
-0000c2c0: 7374 6172 7420 3c3d 2078 0a20 2020 2020  start <= x.     
-0000c2d0: 2020 2072 6574 7572 6e20 416e 6428 6c65     return And(le
-0000c2e0: 6674 2c20 7269 6768 7429 0a0a 2020 2020  ft, right)..    
-0000c2f0: 6465 6620 5f65 7661 6c5f 4571 2873 656c  def _eval_Eq(sel
-0000c300: 662c 206f 7468 6572 293a 0a20 2020 2020  f, other):.     
-0000c310: 2020 2069 6620 6e6f 7420 6f74 6865 722e     if not other.
-0000c320: 6973 5f49 6e74 6572 7661 6c3a 0a20 2020  is_Interval:.   
-0000c330: 2020 2020 2020 2020 2069 6620 6f74 6865           if othe
-0000c340: 722e 6973 5f46 696e 6974 6553 6574 3a0a  r.is_FiniteSet:.
-0000c350: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c360: 6966 206f 7468 6572 2e69 735f 456d 7074  if other.is_Empt
-0000c370: 7953 6574 3a0a 2020 2020 2020 2020 2020  ySet:.          
-0000c380: 2020 2020 2020 2020 2020 6966 2073 656c            if sel
-0000c390: 662e 6c65 6674 5f6f 7065 6e20 6f72 2073  f.left_open or s
-0000c3a0: 656c 662e 7269 6768 745f 6f70 656e 3a0a  elf.right_open:.
-0000c3b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c3c0: 2020 2020 2020 2020 6966 2073 656c 662e          if self.
-0000c3d0: 7374 6172 7420 3c20 7365 6c66 2e73 746f  start < self.sto
-0000c3e0: 703a 0a20 2020 2020 2020 2020 2020 2020  p:.             
-0000c3f0: 2020 2020 2020 2020 2020 2020 2020 2072                 r
-0000c400: 6574 7572 6e20 532e 6661 6c73 650a 2020  eturn S.false.  
-0000c410: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c420: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
-0000c430: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c440: 6966 2073 656c 662e 7374 6172 7420 3c3d  if self.start <=
-0000c450: 2073 656c 662e 7374 6f70 3a0a 2020 2020   self.stop:.    
-0000c460: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c470: 2020 2020 2020 2020 7265 7475 726e 2053          return S
-0000c480: 2e66 616c 7365 0a20 2020 2020 2020 2020  .false.         
-0000c490: 2020 2020 2020 2072 6574 7572 6e0a 2020         return.  
-0000c4a0: 2020 2020 2020 2020 2020 656c 6966 206f            elif o
-0000c4b0: 7468 6572 2e69 735f 7365 743a 0a20 2020  ther.is_set:.   
-0000c4c0: 2020 2020 2020 2020 2020 2020 2072 6574               ret
-0000c4d0: 7572 6e0a 2020 2020 2020 2020 2020 2020  urn.            
-0000c4e0: 7265 7475 726e 2053 2e66 616c 7365 0a0a  return S.false..
-0000c4f0: 2020 2020 2020 2020 7265 7475 726e 2041          return A
-0000c500: 6e64 2845 7128 7365 6c66 2e6c 6566 742c  nd(Eq(self.left,
-0000c510: 206f 7468 6572 2e6c 6566 7429 2c20 4571   other.left), Eq
-0000c520: 2873 656c 662e 7269 6768 742c 206f 7468  (self.right, oth
-0000c530: 6572 2e72 6967 6874 292c 0a20 2020 2020  er.right),.     
-0000c540: 2020 2020 2020 2020 2020 2020 2020 7379                sy
-0000c550: 6d70 6966 7928 7365 6c66 2e6c 6566 745f  mpify(self.left_
-0000c560: 6f70 656e 203d 3d20 6f74 6865 722e 6c65  open == other.le
-0000c570: 6674 5f6f 7065 6e29 2c20 7379 6d70 6966  ft_open), sympif
-0000c580: 7928 7365 6c66 2e72 6967 6874 5f6f 7065  y(self.right_ope
-0000c590: 6e20 3d3d 206f 7468 6572 2e72 6967 6874  n == other.right
-0000c5a0: 5f6f 7065 6e29 290a 0a20 2020 2040 6361  _open))..    @ca
-0000c5b0: 6368 6569 740a 2020 2020 6465 6620 5f65  cheit.    def _e
-0000c5c0: 7661 6c5f 6672 6565 5f73 796d 626f 6c73  val_free_symbols
-0000c5d0: 2873 656c 6629 3a0a 2020 2020 2020 2020  (self):.        
-0000c5e0: 7265 7475 726e 2073 6574 2829 2e75 6e69  return set().uni
-0000c5f0: 6f6e 282a 5b61 2e66 7265 655f 7379 6d62  on(*[a.free_symb
-0000c600: 6f6c 7320 666f 7220 6120 696e 2073 656c  ols for a in sel
-0000c610: 662e 6172 6773 5b3a 325d 5d29 0a0a 2020  f.args[:2]])..  
-0000c620: 2020 6465 6620 6d61 7828 7365 6c66 293a    def max(self):
-0000c630: 0a20 2020 2020 2020 2069 6620 7365 6c66  .        if self
-0000c640: 2e72 6967 6874 5f6f 7065 6e3a 0a20 2020  .right_open:.   
-0000c650: 2020 2020 2020 2020 2066 726f 6d20 7379           from sy
-0000c660: 6d70 792e 636f 7265 2e6e 756d 6265 7273  mpy.core.numbers
-0000c670: 2069 6d70 6f72 7420 496e 6669 6e69 7479   import Infinity
-0000c680: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
-0000c690: 6973 696e 7374 616e 6365 2873 656c 662e  isinstance(self.
-0000c6a0: 7374 6f70 2c20 496e 6669 6e69 7479 293a  stop, Infinity):
-0000c6b0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000c6c0: 2072 6574 7572 6e20 7365 6c66 2e73 746f   return self.sto
-0000c6d0: 700a 2020 2020 2020 2020 2020 2020 2320  p.            # 
-0000c6e0: 6e65 6761 7469 7665 2069 6e66 696e 6974  negative infinit
-0000c6f0: 6573 696d 616c 0a20 2020 2020 2020 2020  esimal.         
-0000c700: 2020 2072 6574 7572 6e20 7365 6c66 2e73     return self.s
-0000c710: 746f 7020 2b20 532e 4e65 6761 7469 7665  top + S.Negative
-0000c720: 496e 6669 6e69 7465 7369 6d61 6c0a 2020  Infinitesimal.  
-0000c730: 2020 2020 2020 7265 7475 726e 2073 656c        return sel
-0000c740: 662e 7374 6f70 0a0a 2020 2020 6465 6620  f.stop..    def 
-0000c750: 6d69 6e28 7365 6c66 293a 0a20 2020 2020  min(self):.     
-0000c760: 2020 2069 6620 7365 6c66 2e6c 6566 745f     if self.left_
-0000c770: 6f70 656e 3a0a 2020 2020 2020 2020 2020  open:.          
-0000c780: 2020 6672 6f6d 2073 796d 7079 2e63 6f72    from sympy.cor
-0000c790: 652e 6e75 6d62 6572 7320 696d 706f 7274  e.numbers import
-0000c7a0: 204e 6567 6174 6976 6549 6e66 696e 6974   NegativeInfinit
-0000c7b0: 790a 2020 2020 2020 2020 2020 2020 6966  y.            if
-0000c7c0: 2069 7369 6e73 7461 6e63 6528 7365 6c66   isinstance(self
-0000c7d0: 2e73 7461 7274 2c20 4e65 6761 7469 7665  .start, Negative
-0000c7e0: 496e 6669 6e69 7479 293a 0a20 2020 2020  Infinity):.     
-0000c7f0: 2020 2020 2020 2020 2020 2072 6574 7572             retur
-0000c800: 6e20 7365 6c66 2e73 7461 7274 0a20 2020  n self.start.   
-0000c810: 2020 2020 2020 2020 2023 2070 6f73 6974           # posit
-0000c820: 6976 6520 696e 6669 6e69 7465 7369 6d61  ive infinitesima
-0000c830: 6c0a 2020 2020 2020 2020 2020 2020 7265  l.            re
-0000c840: 7475 726e 2073 656c 662e 7374 6172 7420  turn self.start 
-0000c850: 2b20 532e 496e 6669 6e69 7465 7369 6d61  + S.Infinitesima
-0000c860: 6c0a 2020 2020 2020 2020 7265 7475 726e  l.        return
-0000c870: 2073 656c 662e 7374 6172 740a 0a20 2020   self.start..   
-0000c880: 2064 6566 205f 5f6e 6567 5f5f 2873 656c   def __neg__(sel
-0000c890: 6629 3a20 0a20 2020 2020 2020 2072 6574  f): .        ret
-0000c8a0: 7572 6e20 7365 6c66 2e66 756e 6328 2d73  urn self.func(-s
-0000c8b0: 656c 662e 7374 6f70 2c20 2d73 656c 662e  elf.stop, -self.
-0000c8c0: 7374 6172 742c 206c 6566 745f 6f70 656e  start, left_open
-0000c8d0: 3d73 656c 662e 7269 6768 745f 6f70 656e  =self.right_open
-0000c8e0: 2c20 7269 6768 745f 6f70 656e 3d73 656c  , right_open=sel
-0000c8f0: 662e 6c65 6674 5f6f 7065 6e29 0a20 2020  f.left_open).   
-0000c900: 200a 2020 2020 6465 6620 5f5f 7375 625f   .    def __sub_
-0000c910: 5f28 7365 6c66 2c20 6f74 6865 7229 3a0a  _(self, other):.
-0000c920: 2020 2020 2020 2020 676c 6f62 616c 2069          global i
-0000c930: 735f 7365 740a 2020 2020 2020 2020 6966  s_set.        if
-0000c940: 206e 6f74 2069 735f 7365 7428 6f74 6865   not is_set(othe
-0000c950: 7229 3a0a 2020 2020 2020 2020 2020 2020  r):.            
-0000c960: 7265 7475 726e 2073 656c 6620 2b20 282d  return self + (-
-0000c970: 6f74 6865 7229 0a20 2020 2020 2020 2072  other).        r
-0000c980: 6574 7572 6e20 5365 742e 5f5f 7375 625f  eturn Set.__sub_
-0000c990: 5f28 7365 6c66 2c20 6f74 6865 7229 0a20  _(self, other). 
-0000c9a0: 2020 200a 2020 2020 6465 6620 5f5f 6164     .    def __ad
-0000c9b0: 645f 5f28 7365 6c66 2c20 6f74 6865 7229  d__(self, other)
-0000c9c0: 3a0a 2020 2020 2020 2020 6f74 6865 7220  :.        other 
-0000c9d0: 3d20 7379 6d70 6966 7928 6f74 6865 7229  = sympify(other)
-0000c9e0: 0a20 2020 2020 2020 2069 6620 6f74 6865  .        if othe
-0000c9f0: 722e 6973 5f49 6e74 6572 7661 6c3a 0a20  r.is_Interval:. 
-0000ca00: 2020 2020 2020 2020 2020 2069 6e74 6567             integ
-0000ca10: 6572 203d 204e 6f6e 650a 2020 2020 2020  er = None.      
-0000ca20: 2020 2020 2020 7374 6172 7420 3d20 7365        start = se
-0000ca30: 6c66 2e73 7461 7274 0a20 2020 2020 2020  lf.start.       
-0000ca40: 2020 2020 2073 746f 7020 3d20 7365 6c66       stop = self
-0000ca50: 2e73 746f 700a 2020 2020 2020 2020 2020  .stop.          
-0000ca60: 2020 6966 206f 7468 6572 2e65 7479 7065    if other.etype
-0000ca70: 2e69 735f 696e 7465 6765 723a 0a20 2020  .is_integer:.   
-0000ca80: 2020 2020 2020 2020 2020 2020 2073 7461               sta
-0000ca90: 7274 202b 3d20 6f74 6865 722e 6d69 6e28  rt += other.min(
-0000caa0: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
-0000cab0: 2020 7374 6f70 202b 3d20 6f74 6865 722e    stop += other.
-0000cac0: 6d61 7828 290a 2020 2020 2020 2020 2020  max().          
-0000cad0: 2020 2020 2020 6c65 6674 5f6f 7065 6e2c        left_open,
-0000cae0: 2072 6967 6874 5f6f 7065 6e20 3d20 7365   right_open = se
-0000caf0: 6c66 2e6c 6566 745f 6f70 656e 2c20 7365  lf.left_open, se
-0000cb00: 6c66 2e72 6967 6874 5f6f 7065 6e0a 2020  lf.right_open.  
-0000cb10: 2020 2020 2020 2020 2020 656c 7365 3a0a            else:.
-0000cb20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000cb30: 7374 6172 7420 2b3d 206f 7468 6572 2e73  start += other.s
-0000cb40: 7461 7274 0a20 2020 2020 2020 2020 2020  tart.           
-0000cb50: 2020 2020 2073 746f 7020 2b3d 206f 7468       stop += oth
-0000cb60: 6572 2e73 746f 700a 2020 2020 2020 2020  er.stop.        
-0000cb70: 2020 2020 2020 2020 0a20 2020 2020 2020          .       
-0000cb80: 2020 2020 2020 2020 2069 6620 6f74 6865           if othe
-0000cb90: 722e 7374 6172 742e 6973 5f69 6e66 696e  r.start.is_infin
-0000cba0: 6974 6520 616e 6420 6e6f 7420 6f74 6865  ite and not othe
-0000cbb0: 722e 6c65 6674 5f6f 7065 6e3a 0a20 2020  r.left_open:.   
-0000cbc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000cbd0: 206c 6566 745f 6f70 656e 203d 2046 616c   left_open = Fal
-0000cbe0: 7365 0a20 2020 2020 2020 2020 2020 2020  se.             
-0000cbf0: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
-0000cc00: 2020 2020 2020 2020 2020 2020 206c 6566               lef
-0000cc10: 745f 6f70 656e 203d 2073 656c 662e 6c65  t_open = self.le
-0000cc20: 6674 5f6f 7065 6e20 6f72 206f 7468 6572  ft_open or other
-0000cc30: 2e6c 6566 745f 6f70 656e 0a20 2020 2020  .left_open.     
-0000cc40: 2020 2020 2020 2020 2020 2020 2020 200a                 .
-0000cc50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000cc60: 6966 206f 7468 6572 2e73 746f 702e 6973  if other.stop.is
-0000cc70: 5f69 6e66 696e 6974 6520 616e 6420 6e6f  _infinite and no
-0000cc80: 7420 6f74 6865 722e 7269 6768 745f 6f70  t other.right_op
-0000cc90: 656e 3a0a 2020 2020 2020 2020 2020 2020  en:.            
-0000cca0: 2020 2020 2020 2020 7269 6768 745f 6f70          right_op
-0000ccb0: 656e 203d 2046 616c 7365 0a20 2020 2020  en = False.     
-0000ccc0: 2020 2020 2020 2020 2020 2065 6c73 653a             else:
-0000ccd0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000cce0: 2020 2020 2072 6967 6874 5f6f 7065 6e20       right_open 
-0000ccf0: 3d20 7365 6c66 2e72 6967 6874 5f6f 7065  = self.right_ope
-0000cd00: 6e20 6f72 206f 7468 6572 2e72 6967 6874  n or other.right
-0000cd10: 5f6f 7065 6e0a 2020 2020 2020 2020 2020  _open.          
-0000cd20: 2020 2020 2020 0a20 2020 2020 2020 2020        .         
-0000cd30: 2020 2072 6574 7572 6e20 7365 6c66 2e66     return self.f
-0000cd40: 756e 6328 7374 6172 742c 2073 746f 702c  unc(start, stop,
-0000cd50: 206c 6566 745f 6f70 656e 3d6c 6566 745f   left_open=left_
-0000cd60: 6f70 656e 2c20 7269 6768 745f 6f70 656e  open, right_open
-0000cd70: 3d72 6967 6874 5f6f 7065 6e29 0a20 2020  =right_open).   
-0000cd80: 2020 2020 200a 2020 2020 2020 2020 6966       .        if
-0000cd90: 206f 7468 6572 2e69 735f 436f 6d70 6c65   other.is_Comple
-0000cda0: 7852 6567 696f 6e3a 0a20 2020 2020 2020  xRegion:.       
-0000cdb0: 2020 2020 2070 726f 6475 6374 7365 7420       productset 
-0000cdc0: 3d20 6f74 6865 722e 6172 6773 5b30 5d2e  = other.args[0].
-0000cdd0: 6172 6773 0a20 2020 2020 2020 2020 2020  args.           
-0000cde0: 2072 6574 7572 6e20 6f74 6865 722e 6675   return other.fu
-0000cdf0: 6e63 2828 7365 6c66 202b 2070 726f 6475  nc((self + produ
-0000ce00: 6374 7365 745b 305d 2920 4020 7072 6f64  ctset[0]) @ prod
-0000ce10: 7563 7473 6574 5b31 5d29 0a20 2020 2020  uctset[1]).     
-0000ce20: 2020 200a 2020 2020 2020 2020 6966 206f     .        if o
-0000ce30: 7468 6572 2e69 735f 4669 6e69 7465 5365  ther.is_FiniteSe
-0000ce40: 743a 0a20 2020 2020 2020 2020 2020 206c  t:.            l
-0000ce50: 6566 745f 6f70 656e 2c20 7269 6768 745f  eft_open, right_
-0000ce60: 6f70 656e 203d 2073 656c 662e 6c65 6674  open = self.left
-0000ce70: 5f6f 7065 6e2c 2073 656c 662e 7269 6768  _open, self.righ
-0000ce80: 745f 6f70 656e 0a20 2020 2020 2020 2020  t_open.         
-0000ce90: 2020 2073 7461 7274 2c20 7374 6f70 203d     start, stop =
-0000cea0: 2073 656c 662e 7374 6172 742c 2073 656c   self.start, sel
-0000ceb0: 662e 7374 6f70 0a20 2020 2020 2020 2020  f.stop.         
-0000cec0: 2020 2073 7461 7274 202b 3d20 6f74 6865     start += othe
-0000ced0: 722e 6d69 6e28 290a 2020 2020 2020 2020  r.min().        
-0000cee0: 2020 2020 7374 6f70 202b 3d20 6f74 6865      stop += othe
-0000cef0: 722e 6d61 7828 2920 2020 2020 2020 2020  r.max()         
-0000cf00: 2020 2020 2020 2020 200a 2020 2020 2020           .      
-0000cf10: 2020 2020 2020 7265 7475 726e 2073 656c        return sel
-0000cf20: 662e 6675 6e63 2873 7461 7274 2c20 7374  f.func(start, st
-0000cf30: 6f70 2c20 6c65 6674 5f6f 7065 6e3d 6c65  op, left_open=le
-0000cf40: 6674 5f6f 7065 6e2c 2072 6967 6874 5f6f  ft_open, right_o
-0000cf50: 7065 6e3d 7269 6768 745f 6f70 656e 290a  pen=right_open).
-0000cf60: 2020 2020 2020 2020 2020 2020 0a20 2020              .   
-0000cf70: 2020 2020 2069 6620 6e6f 7420 6f74 6865       if not othe
-0000cf80: 722e 6973 5f73 6574 3a0a 2020 2020 2020  r.is_set:.      
-0000cf90: 2020 2020 2020 7374 6172 7420 3d20 7365        start = se
-0000cfa0: 6c66 2e73 7461 7274 202b 206f 7468 6572  lf.start + other
-0000cfb0: 0a20 2020 2020 2020 2020 2020 2073 746f  .            sto
-0000cfc0: 7020 3d20 7365 6c66 2e73 746f 7020 2b20  p = self.stop + 
-0000cfd0: 6f74 6865 720a 2020 2020 2020 2020 2020  other.          
-0000cfe0: 2020 7265 7475 726e 2073 656c 662e 6675    return self.fu
-0000cff0: 6e63 2873 7461 7274 2c20 7374 6f70 2c20  nc(start, stop, 
-0000d000: 6c65 6674 5f6f 7065 6e3d 7365 6c66 2e6c  left_open=self.l
-0000d010: 6566 745f 6f70 656e 2c20 7269 6768 745f  eft_open, right_
-0000d020: 6f70 656e 3d73 656c 662e 7269 6768 745f  open=self.right_
-0000d030: 6f70 656e 290a 0a20 2020 2020 2020 2069  open)..        i
-0000d040: 6620 6f74 6865 722e 6973 5f52 616e 6765  f other.is_Range
-0000d050: 3a20 0a20 2020 2020 2020 2020 2020 2073  : .            s
-0000d060: 7461 7274 203d 2073 656c 662e 7374 6172  tart = self.star
-0000d070: 740a 2020 2020 2020 2020 2020 2020 7374  t.            st
-0000d080: 6f70 203d 2073 656c 662e 7374 6f70 0a20  op = self.stop. 
-0000d090: 2020 2020 2020 2020 2020 200a 2020 2020             .    
-0000d0a0: 2020 2020 2020 2020 7374 6172 7420 2b3d          start +=
-0000d0b0: 206f 7468 6572 2e6d 696e 2829 0a20 2020   other.min().   
-0000d0c0: 2020 2020 2020 2020 2073 746f 7020 2b3d           stop +=
-0000d0d0: 206f 7468 6572 2e6d 6178 2829 0a20 2020   other.max().   
-0000d0e0: 2020 2020 2020 2020 206c 6566 745f 6f70           left_op
-0000d0f0: 656e 2c20 7269 6768 745f 6f70 656e 203d  en, right_open =
-0000d100: 2073 656c 662e 6c65 6674 5f6f 7065 6e2c   self.left_open,
-0000d110: 2073 656c 662e 7269 6768 745f 6f70 656e   self.right_open
-0000d120: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000d130: 200a 2020 2020 2020 2020 2020 2020 7265   .            re
-0000d140: 7475 726e 2073 656c 662e 6675 6e63 2873  turn self.func(s
-0000d150: 7461 7274 2c20 7374 6f70 2c20 6c65 6674  tart, stop, left
-0000d160: 5f6f 7065 6e3d 6c65 6674 5f6f 7065 6e2c  _open=left_open,
-0000d170: 2072 6967 6874 5f6f 7065 6e3d 7269 6768   right_open=righ
-0000d180: 745f 6f70 656e 290a 2020 2020 2020 2020  t_open).        
-0000d190: 0a20 2020 2020 2020 2069 6620 6f74 6865  .        if othe
-0000d1a0: 722e 6973 5f55 6e69 7665 7273 616c 5365  r.is_UniversalSe
-0000d1b0: 7420 616e 6420 286f 7468 6572 2e65 7479  t and (other.ety
-0000d1c0: 7065 2e69 735f 7375 7065 725f 7265 616c  pe.is_super_real
-0000d1d0: 206f 7220 6f74 6865 722e 6574 7970 652e   or other.etype.
-0000d1e0: 6973 5f73 7570 6572 5f63 6f6d 706c 6578  is_super_complex
-0000d1f0: 293a 0a20 2020 2020 2020 2020 2020 2072  ):.            r
-0000d200: 6574 7572 6e20 6f74 6865 720a 0a20 2020  eturn other..   
-0000d210: 2020 2020 2072 6574 7572 6e20 5365 742e       return Set.
-0000d220: 5f5f 6164 645f 5f28 7365 6c66 2c20 6f74  __add__(self, ot
-0000d230: 6865 7229 0a0a 2020 2020 6465 6620 5f5f  her)..    def __
-0000d240: 6d75 6c5f 5f28 7365 6c66 2c20 6f74 6865  mul__(self, othe
-0000d250: 7229 3a0a 2020 2020 2020 2020 6966 2069  r):.        if i
-0000d260: 7369 6e73 7461 6e63 6528 6f74 6865 722c  sinstance(other,
-0000d270: 2045 7870 7229 3a0a 2020 2020 2020 2020   Expr):.        
-0000d280: 2020 2020 7374 6172 7420 3d20 7365 6c66      start = self
-0000d290: 2e73 7461 7274 202a 206f 7468 6572 0a20  .start * other. 
-0000d2a0: 2020 2020 2020 2020 2020 2073 746f 7020             stop 
-0000d2b0: 3d20 7365 6c66 2e73 746f 7020 2a20 6f74  = self.stop * ot
-0000d2c0: 6865 720a 2020 2020 2020 2020 2020 2020  her.            
-0000d2d0: 6966 206f 7468 6572 203e 2030 3a0a 2020  if other > 0:.  
-0000d2e0: 2020 2020 2020 2020 2020 2020 2020 7265                re
-0000d2f0: 7475 726e 2073 656c 662e 6675 6e63 2873  turn self.func(s
-0000d300: 7461 7274 2c20 7374 6f70 2c20 6c65 6674  tart, stop, left
-0000d310: 5f6f 7065 6e3d 7365 6c66 2e6c 6566 745f  _open=self.left_
-0000d320: 6f70 656e 2c20 7269 6768 745f 6f70 656e  open, right_open
-0000d330: 3d73 656c 662e 7269 6768 745f 6f70 656e  =self.right_open
-0000d340: 290a 2020 2020 2020 2020 2020 2020 6966  ).            if
-0000d350: 206f 7468 6572 203c 2030 3a0a 2020 2020   other < 0:.    
-0000d360: 2020 2020 2020 2020 2020 2020 7265 7475              retu
-0000d370: 726e 2073 656c 662e 6675 6e63 2873 746f  rn self.func(sto
-0000d380: 702c 2073 7461 7274 2c20 6c65 6674 5f6f  p, start, left_o
-0000d390: 7065 6e3d 7365 6c66 2e72 6967 6874 5f6f  pen=self.right_o
-0000d3a0: 7065 6e2c 2072 6967 6874 5f6f 7065 6e3d  pen, right_open=
-0000d3b0: 7365 6c66 2e6c 6566 745f 6f70 656e 290a  self.left_open).
-0000d3c0: 2020 2020 2020 2020 2020 2020 6966 206f              if o
-0000d3d0: 7468 6572 203d 3d20 303a 0a20 2020 2020  ther == 0:.     
-0000d3e0: 2020 2020 2020 2020 2020 2066 726f 6d20             from 
-0000d3f0: 7379 6d70 7920 696d 706f 7274 2046 696e  sympy import Fin
-0000d400: 6974 6553 6574 0a20 2020 2020 2020 2020  iteSet.         
-0000d410: 2020 2020 2020 2072 6574 7572 6e20 4669         return Fi
-0000d420: 6e69 7465 5365 7428 3029 0a20 2020 2020  niteSet(0).     
-0000d430: 2020 2020 2020 2072 6574 7572 6e20 7365         return se
-0000d440: 6c66 2e66 756e 6328 532e 4e65 6761 7469  lf.func(S.Negati
-0000d450: 7665 496e 6669 6e69 7479 2c20 532e 496e  veInfinity, S.In
-0000d460: 6669 6e69 7479 290a 0a20 2020 2020 2020  finity)..       
-0000d470: 2072 6574 7572 6e20 5365 742e 5f5f 6d75   return Set.__mu
-0000d480: 6c5f 5f28 7365 6c66 2c20 6f74 6865 7229  l__(self, other)
-0000d490: 0a0a 2020 2020 6465 6620 636f 7328 7365  ..    def cos(se
-0000d4a0: 6c66 293a 0a20 2020 2020 2020 2066 726f  lf):.        fro
-0000d4b0: 6d20 7379 6d70 792e 636f 7265 2e6e 756d  m sympy.core.num
-0000d4c0: 6265 7273 2069 6d70 6f72 7420 6570 7369  bers import epsi
-0000d4d0: 6c6f 6e0a 2020 2020 2020 2020 7374 6172  lon.        star
-0000d4e0: 742c 2073 746f 7020 3d20 7365 6c66 2e61  t, stop = self.a
-0000d4f0: 7267 730a 2020 2020 2020 2020 6966 2073  rgs.        if s
-0000d500: 656c 662e 7269 6768 745f 6f70 656e 3a0a  elf.right_open:.
-0000d510: 2020 2020 2020 2020 2020 2020 7374 6f70              stop
-0000d520: 202d 3d20 6570 7369 6c6f 6e0a 0a20 2020   -= epsilon..   
-0000d530: 2020 2020 2066 726f 6d20 7379 6d70 7920       from sympy 
-0000d540: 696d 706f 7274 2063 6f73 2c20 666c 6f6f  import cos, floo
-0000d550: 720a 0a20 2020 2020 2020 206e 203d 2066  r..        n = f
-0000d560: 6c6f 6f72 2873 7461 7274 202f 2053 2e50  loor(start / S.P
-0000d570: 6929 0a0a 2020 2020 2020 2020 6d20 3d20  i)..        m = 
-0000d580: 666c 6f6f 7228 7374 6f70 202f 2053 2e50  floor(stop / S.P
-0000d590: 6929 0a0a 2020 2020 2020 2020 6966 206e  i)..        if n
-0000d5a0: 2e69 735f 6576 656e 3a0a 2020 2020 2020  .is_even:.      
-0000d5b0: 2020 2020 2020 6966 206e 203d 3d20 6d3a        if n == m:
-0000d5c0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000d5d0: 2072 6574 7572 6e20 7365 6c66 2e66 756e   return self.fun
-0000d5e0: 6328 636f 7328 7365 6c66 2e73 746f 7029  c(cos(self.stop)
-0000d5f0: 2c20 636f 7328 7374 6172 7429 2c0a 2020  , cos(start),.  
-0000d600: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d610: 2020 2020 2020 2020 2020 2020 2020 206c                 l
-0000d620: 6566 745f 6f70 656e 3d73 656c 662e 7269  eft_open=self.ri
-0000d630: 6768 745f 6f70 656e 2c0a 2020 2020 2020  ght_open,.      
-0000d640: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d650: 2020 2020 2020 2020 2020 2072 6967 6874             right
-0000d660: 5f6f 7065 6e3d 7365 6c66 2e6c 6566 745f  _open=self.left_
-0000d670: 6f70 656e 290a 2020 2020 2020 2020 656c  open).        el
-0000d680: 6966 206e 2e69 735f 6f64 643a 0a20 2020  if n.is_odd:.   
-0000d690: 2020 2020 2020 2020 2069 6620 6e20 3d3d           if n ==
-0000d6a0: 206d 3a0a 2020 2020 2020 2020 2020 2020   m:.            
-0000d6b0: 2020 2020 7265 7475 726e 2073 656c 662e      return self.
-0000d6c0: 636f 7079 2873 7461 7274 3d63 6f73 2873  copy(start=cos(s
-0000d6d0: 7461 7274 292c 2073 746f 703d 636f 7328  tart), stop=cos(
-0000d6e0: 7365 6c66 2e73 746f 7029 290a 0a20 2020  self.stop))..   
-0000d6f0: 2020 2020 2072 6574 7572 6e20 7365 6c66       return self
-0000d700: 2e66 756e 6328 2d31 2c20 3129 0a0a 2020  .func(-1, 1)..  
-0000d710: 2020 6465 6620 6163 6f73 2873 656c 6629    def acos(self)
-0000d720: 3a0a 2020 2020 2020 2020 6672 6f6d 2073  :.        from s
-0000d730: 796d 7079 2069 6d70 6f72 7420 6163 6f73  ympy import acos
-0000d740: 0a0a 2020 2020 2020 2020 7374 6172 742c  ..        start,
-0000d750: 2073 746f 7020 3d20 7365 6c66 2e61 7267   stop = self.arg
-0000d760: 730a 0a20 2020 2020 2020 2072 6574 7572  s..        retur
-0000d770: 6e20 7365 6c66 2e66 756e 6328 6163 6f73  n self.func(acos
-0000d780: 2873 746f 7029 2c20 6163 6f73 2873 7461  (stop), acos(sta
-0000d790: 7274 292c 206c 6566 745f 6f70 656e 3d73  rt), left_open=s
-0000d7a0: 656c 662e 7269 6768 745f 6f70 656e 2c20  elf.right_open, 
-0000d7b0: 7269 6768 745f 6f70 656e 3d73 656c 662e  right_open=self.
-0000d7c0: 6c65 6674 5f6f 7065 6e29 0a0a 2020 2020  left_open)..    
-0000d7d0: 6465 6620 5f5f 7472 7565 6469 765f 5f28  def __truediv__(
-0000d7e0: 7365 6c66 2c20 6f74 6865 7229 3a0a 2020  self, other):.  
-0000d7f0: 2020 2020 2020 6966 206f 7468 6572 2e69        if other.i
-0000d800: 735f 6578 7465 6e64 6564 5f70 6f73 6974  s_extended_posit
-0000d810: 6976 653a 200a 2020 2020 2020 2020 2020  ive: .          
-0000d820: 2020 7265 7475 726e 2073 656c 662e 636f    return self.co
-0000d830: 7079 2873 7461 7274 3d73 656c 662e 7374  py(start=self.st
-0000d840: 6172 7420 2f20 6f74 6865 722c 2073 746f  art / other, sto
-0000d850: 703d 7365 6c66 2e73 746f 7020 2f20 6f74  p=self.stop / ot
-0000d860: 6865 7229 0a20 2020 2020 2020 2069 6620  her).        if 
-0000d870: 6f74 6865 722e 6973 5f65 7874 656e 6465  other.is_extende
-0000d880: 645f 6e65 6761 7469 7665 3a20 0a20 2020  d_negative: .   
-0000d890: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
-0000d8a0: 7365 6c66 2e66 756e 6328 7365 6c66 2e73  self.func(self.s
-0000d8b0: 746f 7020 2f20 6f74 6865 722c 2073 656c  top / other, sel
-0000d8c0: 662e 7374 6172 7420 2f20 6f74 6865 722c  f.start / other,
-0000d8d0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000d8e0: 2020 2020 2020 2020 2020 2020 2020 6c65                le
-0000d8f0: 6674 5f6f 7065 6e3d 7365 6c66 2e72 6967  ft_open=self.rig
-0000d900: 6874 5f6f 7065 6e2c 2072 6967 6874 5f6f  ht_open, right_o
-0000d910: 7065 6e3d 7365 6c66 2e6c 6566 745f 6f70  pen=self.left_op
-0000d920: 656e 290a 0a20 2020 2040 6361 6368 6569  en)..    @cachei
-0000d930: 740a 2020 2020 6465 6620 5f68 6173 2873  t.    def _has(s
-0000d940: 656c 662c 2070 6174 7465 726e 293a 0a20  elf, pattern):. 
-0000d950: 2020 2020 2020 2072 6574 7572 6e20 7365         return se
-0000d960: 6c66 2e73 7461 7274 2e5f 6861 7328 7061  lf.start._has(pa
-0000d970: 7474 6572 6e29 206f 7220 7365 6c66 2e73  ttern) or self.s
-0000d980: 746f 702e 5f68 6173 2870 6174 7465 726e  top._has(pattern
-0000d990: 290a 0a20 2020 2064 6566 2063 6f70 7928  )..    def copy(
-0000d9a0: 7365 6c66 2c20 2a2a 6b77 6172 6773 293a  self, **kwargs):
-0000d9b0: 0a20 2020 2020 2020 2069 6620 2773 7461  .        if 'sta
-0000d9c0: 7274 2720 696e 206b 7761 7267 733a 0a20  rt' in kwargs:. 
-0000d9d0: 2020 2020 2020 2020 2020 2073 7461 7274             start
-0000d9e0: 203d 206b 7761 7267 735b 2773 7461 7274   = kwargs['start
-0000d9f0: 275d 0a20 2020 2020 2020 2065 6c73 653a  '].        else:
-0000da00: 0a20 2020 2020 2020 2020 2020 2073 7461  .            sta
-0000da10: 7274 203d 2073 656c 662e 7374 6172 740a  rt = self.start.
-0000da20: 0a20 2020 2020 2020 2069 6620 2773 746f  .        if 'sto
-0000da30: 7027 2069 6e20 6b77 6172 6773 3a0a 2020  p' in kwargs:.  
-0000da40: 2020 2020 2020 2020 2020 7374 6f70 203d            stop =
-0000da50: 206b 7761 7267 735b 2773 746f 7027 5d0a   kwargs['stop'].
-0000da60: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
-0000da70: 2020 2020 2020 2020 2020 7374 6f70 203d            stop =
-0000da80: 2073 656c 662e 7374 6f70 0a20 2020 2020   self.stop.     
-0000da90: 2020 2020 2020 200a 2020 2020 2020 2020         .        
-0000daa0: 6966 2027 6c65 6674 5f6f 7065 6e27 2069  if 'left_open' i
-0000dab0: 6e20 6b77 6172 6773 3a0a 2020 2020 2020  n kwargs:.      
-0000dac0: 2020 2020 2020 6c65 6674 5f6f 7065 6e20        left_open 
-0000dad0: 3d20 6b77 6172 6773 5b27 6c65 6674 5f6f  = kwargs['left_o
-0000dae0: 7065 6e27 5d0a 2020 2020 2020 2020 656c  pen'].        el
-0000daf0: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
-0000db00: 6c65 6674 5f6f 7065 6e20 3d20 7365 6c66  left_open = self
-0000db10: 2e6c 6566 745f 6f70 656e 0a0a 2020 2020  .left_open..    
-0000db20: 2020 2020 6966 2027 7269 6768 745f 6f70      if 'right_op
-0000db30: 656e 2720 696e 206b 7761 7267 733a 0a20  en' in kwargs:. 
-0000db40: 2020 2020 2020 2020 2020 2072 6967 6874             right
-0000db50: 5f6f 7065 6e20 3d20 6b77 6172 6773 5b27  _open = kwargs['
-0000db60: 7269 6768 745f 6f70 656e 275d 0a20 2020  right_open'].   
-0000db70: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
-0000db80: 2020 2020 2020 2072 6967 6874 5f6f 7065         right_ope
-0000db90: 6e20 3d20 7365 6c66 2e72 6967 6874 5f6f  n = self.right_o
-0000dba0: 7065 6e0a 2020 2020 2020 2020 2020 2020  pen.            
-0000dbb0: 0a20 2020 2020 2020 2069 6620 6b77 6172  .        if kwar
-0000dbc0: 6773 2e67 6574 2827 696e 7465 6765 7227  gs.get('integer'
-0000dbd0: 293a 0a20 2020 2020 2020 2020 2020 2066  ):.            f
-0000dbe0: 726f 6d20 7379 6d70 7920 696d 706f 7274  rom sympy import
-0000dbf0: 2052 616e 6765 0a20 2020 2020 2020 2020   Range.         
-0000dc00: 2020 2072 6574 7572 6e20 5261 6e67 6528     return Range(
-0000dc10: 7374 6172 742c 2073 746f 702c 206c 6566  start, stop, lef
-0000dc20: 745f 6f70 656e 3d6c 6566 745f 6f70 656e  t_open=left_open
-0000dc30: 2c20 7269 6768 745f 6f70 656e 3d72 6967  , right_open=rig
-0000dc40: 6874 5f6f 7065 6e29 0a20 2020 2020 2020  ht_open).       
-0000dc50: 200a 2020 2020 2020 2020 7265 7475 726e   .        return
-0000dc60: 2073 656c 662e 6675 6e63 2873 7461 7274   self.func(start
-0000dc70: 2c20 7374 6f70 2c20 6c65 6674 5f6f 7065  , stop, left_ope
-0000dc80: 6e3d 6c65 6674 5f6f 7065 6e2c 2072 6967  n=left_open, rig
-0000dc90: 6874 5f6f 7065 6e3d 7269 6768 745f 6f70  ht_open=right_op
-0000dca0: 656e 290a 0a20 2020 2064 6566 2072 6574  en)..    def ret
-0000dcb0: 6169 6e5f 6f64 6428 7365 6c66 293a 0a20  ain_odd(self):. 
-0000dcc0: 2020 2020 2020 2069 203d 2073 656c 662e         i = self.
-0000dcd0: 6765 6e65 7261 7465 5f76 6172 2869 6e74  generate_var(int
-0000dce0: 6567 6572 3d54 7275 6529 0a20 2020 2020  eger=True).     
-0000dcf0: 2020 2061 2c20 6220 3d20 7365 6c66 2e6d     a, b = self.m
-0000dd00: 696e 2829 2c20 7365 6c66 2e6d 6178 2829  in(), self.max()
-0000dd10: 0a20 2020 2020 2020 2069 6620 612e 6973  .        if a.is
-0000dd20: 5f66 696e 6974 653a 0a20 2020 2020 2020  _finite:.       
-0000dd30: 2020 2020 2061 203d 2028 6120 2f20 3229       a = (a / 2)
-0000dd40: 2e66 6c6f 6f72 2829 0a20 2020 2020 2020  .floor().       
-0000dd50: 2069 6620 622e 6973 5f66 696e 6974 653a   if b.is_finite:
-0000dd60: 0a20 2020 2020 2020 2020 2020 2062 203d  .            b =
-0000dd70: 2028 2862 202d 2031 2920 2f20 3229 2e66   ((b - 1) / 2).f
-0000dd80: 6c6f 6f72 2829 0a20 2020 2020 2020 2020  loor().         
-0000dd90: 2020 200a 2020 2020 2020 2020 6966 2061     .        if a
-0000dda0: 2e69 735f 696e 6669 6e69 7465 2061 6e64  .is_infinite and
-0000ddb0: 2062 2e69 735f 696e 6669 6e69 7465 3a0a   b.is_infinite:.
-0000ddc0: 2020 2020 2020 2020 2020 2020 646f 6d61              doma
-0000ddd0: 696e 203d 2073 656c 660a 2020 2020 2020  in = self.      
-0000dde0: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
-0000ddf0: 2020 2020 646f 6d61 696e 203d 2073 656c      domain = sel
-0000de00: 662e 6675 6e63 2861 2c20 622c 2069 6e74  f.func(a, b, int
-0000de10: 6567 6572 3d54 7275 6529 0a20 2020 2020  eger=True).     
-0000de20: 2020 2066 726f 6d20 7379 6d70 7920 696d     from sympy im
-0000de30: 706f 7274 2043 7570 0a20 2020 2020 2020  port Cup.       
-0000de40: 2072 6574 7572 6e20 4375 705b 693a 646f   return Cup[i:do
-0000de50: 6d61 696e 5d28 2832 202a 2069 202b 2031  main]((2 * i + 1
-0000de60: 292e 7365 7429 0a20 2020 2020 2020 200a  ).set).        .
-0000de70: 2020 2020 6465 6620 7265 7461 696e 5f65      def retain_e
-0000de80: 7665 6e28 7365 6c66 293a 0a20 2020 2020  ven(self):.     
-0000de90: 2020 2069 203d 2073 656c 662e 6765 6e65     i = self.gene
-0000dea0: 7261 7465 5f76 6172 2869 6e74 6567 6572  rate_var(integer
-0000deb0: 3d54 7275 6529 0a20 2020 2020 2020 2061  =True).        a
-0000dec0: 2c20 6220 3d20 7365 6c66 2e6d 696e 2829  , b = self.min()
-0000ded0: 2c20 7365 6c66 2e6d 6178 2829 0a20 2020  , self.max().   
-0000dee0: 2020 2020 2069 6620 612e 6973 5f66 696e       if a.is_fin
-0000def0: 6974 653a 0a20 2020 2020 2020 2020 2020  ite:.           
-0000df00: 2061 203d 2028 6120 2f20 3229 2e66 6c6f   a = (a / 2).flo
-0000df10: 6f72 2829 0a20 2020 2020 2020 2069 6620  or().        if 
-0000df20: 622e 6973 5f66 696e 6974 653a 0a20 2020  b.is_finite:.   
-0000df30: 2020 2020 2020 2020 2062 203d 2028 6220           b = (b 
-0000df40: 2f20 3229 2e66 6c6f 6f72 2829 0a20 2020  / 2).floor().   
-0000df50: 2020 2020 2020 2020 200a 2020 2020 2020           .      
-0000df60: 2020 6966 2061 2e69 735f 696e 6669 6e69    if a.is_infini
-0000df70: 7465 2061 6e64 2062 2e69 735f 696e 6669  te and b.is_infi
-0000df80: 6e69 7465 3a0a 2020 2020 2020 2020 2020  nite:.          
-0000df90: 2020 646f 6d61 696e 203d 2073 656c 660a    domain = self.
-0000dfa0: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
-0000dfb0: 2020 2020 2020 2020 2020 646f 6d61 696e            domain
-0000dfc0: 203d 2073 656c 662e 6675 6e63 2861 2c20   = self.func(a, 
-0000dfd0: 622c 2069 6e74 6567 6572 3d54 7275 6529  b, integer=True)
-0000dfe0: 0a20 2020 2020 2020 2066 726f 6d20 7379  .        from sy
-0000dff0: 6d70 7920 696d 706f 7274 2043 7570 0a20  mpy import Cup. 
-0000e000: 2020 2020 2020 2072 6574 7572 6e20 4375         return Cu
-0000e010: 705b 693a 646f 6d61 696e 5d28 2832 202a  p[i:domain]((2 *
-0000e020: 2069 292e 7365 7429 0a20 2020 2020 2020   i).set).       
-0000e030: 200a 2020 2020 6465 6620 5f73 7562 7328   .    def _subs(
-0000e040: 7365 6c66 2c20 6f6c 642c 206e 6577 2c20  self, old, new, 
-0000e050: 2a2a 6869 6e74 7329 3a0a 2020 2020 2020  **hints):.      
-0000e060: 2020 6173 7365 7274 206f 6c64 2021 3d20    assert old != 
-0000e070: 6e65 770a 2020 2020 2020 2020 6966 2073  new.        if s
-0000e080: 656c 6620 3d3d 206f 6c64 3a0a 2020 2020  elf == old:.    
-0000e090: 2020 2020 2020 2020 7265 7475 726e 206e          return n
-0000e0a0: 6577 0a20 2020 2020 2020 200a 2020 2020  ew.        .    
-0000e0b0: 2020 2020 6869 7420 3d20 4661 6c73 650a      hit = False.
-0000e0c0: 2020 2020 2020 2020 6172 6773 203d 206c          args = l
-0000e0d0: 6973 7428 7365 6c66 2e61 7267 735b 3a32  ist(self.args[:2
-0000e0e0: 5d29 0a20 2020 2020 2020 2066 6f72 2069  ]).        for i
-0000e0f0: 2c20 6172 6720 696e 2065 6e75 6d65 7261  , arg in enumera
-0000e100: 7465 2861 7267 7329 3a0a 2020 2020 2020  te(args):.      
-0000e110: 2020 2020 2020 6966 206e 6f74 2068 6173        if not has
-0000e120: 6174 7472 2861 7267 2c20 275f 6576 616c  attr(arg, '_eval
-0000e130: 5f73 7562 7327 293a 0a20 2020 2020 2020  _subs'):.       
-0000e140: 2020 2020 2020 2020 2063 6f6e 7469 6e75           continu
-0000e150: 650a 2020 2020 2020 2020 2020 2020 6172  e.            ar
-0000e160: 6720 3d20 6172 672e 5f73 7562 7328 6f6c  g = arg._subs(ol
-0000e170: 642c 206e 6577 2c20 2a2a 6869 6e74 7329  d, new, **hints)
-0000e180: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
-0000e190: 6172 6720 213d 2061 7267 735b 695d 3a0a  arg != args[i]:.
-0000e1a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e1b0: 6869 7420 3d20 5472 7565 0a20 2020 2020  hit = True.     
-0000e1c0: 2020 2020 2020 2020 2020 2061 7267 735b             args[
-0000e1d0: 695d 203d 2061 7267 0a20 2020 2020 2020  i] = arg.       
-0000e1e0: 2069 6620 6869 743a 0a20 2020 2020 2020   if hit:.       
-0000e1f0: 2020 2020 2073 7461 7274 2c20 7374 6f70       start, stop
-0000e200: 203d 2061 7267 730a 2020 2020 2020 2020   = args.        
-0000e210: 2020 2020 7265 7475 726e 2073 656c 662e      return self.
-0000e220: 636f 7079 2873 7461 7274 3d73 7461 7274  copy(start=start
-0000e230: 2c20 7374 6f70 3d73 746f 7029 0a20 2020  , stop=stop).   
-0000e240: 2020 2020 2072 6574 7572 6e20 7365 6c66       return self
-0000e250: 0a0a 2020 2020 4070 726f 7065 7274 790a  ..    @property.
-0000e260: 2020 2020 6465 6620 6574 7970 6528 7365      def etype(se
-0000e270: 6c66 293a 0a20 2020 2020 2020 2069 6620  lf):.        if 
-0000e280: 7365 6c66 2e73 7461 7274 2e69 735f 696e  self.start.is_in
-0000e290: 6669 6e69 7465 2061 6e64 206e 6f74 2073  finite and not s
-0000e2a0: 656c 662e 6c65 6674 5f6f 7065 6e20 6f72  elf.left_open or
-0000e2b0: 2073 656c 662e 7374 6f70 2e69 735f 696e   self.stop.is_in
-0000e2c0: 6669 6e69 7465 2061 6e64 206e 6f74 2073  finite and not s
-0000e2d0: 656c 662e 7269 6768 745f 6f70 656e 3a0a  elf.right_open:.
-0000e2e0: 2020 2020 2020 2020 2020 2020 7265 7475              retu
-0000e2f0: 726e 2064 7479 7065 2e65 7874 656e 6465  rn dtype.extende
-0000e300: 645f 7265 616c 0a20 2020 2020 2020 2072  d_real.        r
-0000e310: 6574 7572 6e20 6474 7970 652e 7265 616c  eturn dtype.real
-0000e320: 0a0a 2020 2020 6465 6620 5f70 7265 7474  ..    def _prett
-0000e330: 7928 7365 6c66 2c20 7029 3a20 0a20 2020  y(self, p): .   
-0000e340: 2020 2020 2069 6620 7365 6c66 2e73 7461       if self.sta
-0000e350: 7274 203d 3d20 7365 6c66 2e73 746f 703a  rt == self.stop:
-0000e360: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
-0000e370: 7572 6e20 702e 5f70 7269 6e74 5f73 6571  urn p._print_seq
-0000e380: 2873 656c 662e 6172 6773 5b3a 315d 2c20  (self.args[:1], 
-0000e390: 277b 272c 2027 7d27 290a 0a20 2020 2020  '{', '}')..     
-0000e3a0: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
-0000e3b0: 2020 2020 2069 6620 7365 6c66 2e6c 6566       if self.lef
-0000e3c0: 745f 6f70 656e 3a0a 2020 2020 2020 2020  t_open:.        
-0000e3d0: 2020 2020 2020 2020 6c65 6674 203d 2027          left = '
-0000e3e0: 2827 0a20 2020 2020 2020 2020 2020 2065  ('.            e
-0000e3f0: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
-0000e400: 2020 2020 206c 6566 7420 3d20 275b 270a       left = '['.
-0000e410: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
-0000e420: 7365 6c66 2e72 6967 6874 5f6f 7065 6e3a  self.right_open:
-0000e430: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000e440: 2072 6967 6874 203d 2027 2927 0a20 2020   right = ')'.   
-0000e450: 2020 2020 2020 2020 2065 6c73 653a 0a20           else:. 
-0000e460: 2020 2020 2020 2020 2020 2020 2020 2072                 r
-0000e470: 6967 6874 203d 2027 5d27 0a0a 2020 2020  ight = ']'..    
-0000e480: 2020 2020 2020 2020 7265 7475 726e 2070          return p
-0000e490: 2e5f 7072 696e 745f 7365 7128 7365 6c66  ._print_seq(self
-0000e4a0: 2e61 7267 735b 3a32 5d2c 206c 6566 742c  .args[:2], left,
-0000e4b0: 2072 6967 6874 2c20 6465 6c69 6d69 7465   right, delimite
-0000e4c0: 723d 272c 2027 290a 0a20 2020 2064 6566  r=', ')..    def
-0000e4d0: 205f 7379 6d70 7973 7472 2873 656c 662c   _sympystr(self,
-0000e4e0: 205f 293a 200a 2020 2020 2020 2020 7265   _): .        re
-0000e4f0: 7475 726e 2027 7b6c 6566 745f 6f70 656e  turn '{left_open
-0000e500: 7d7b 7374 6172 747d 7b73 6570 7d20 7b73  }{start}{sep} {s
-0000e510: 746f 707d 7b72 6967 6874 5f6f 7065 6e7d  top}{right_open}
-0000e520: 272e 666f 726d 6174 282a 2a7b 2773 7461  '.format(**{'sta
-0000e530: 7274 273a 2073 656c 662e 7374 6172 742c  rt': self.start,
-0000e540: 2027 7374 6f70 273a 2073 656c 662e 7374   'stop': self.st
-0000e550: 6f70 2c20 2773 6570 273a 2027 2c27 2c0a  op, 'sep': ',',.
-0000e560: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e570: 2020 2020 2020 2020 2020 2020 2027 6c65               'le
-0000e580: 6674 5f6f 7065 6e27 3a20 2728 2720 6966  ft_open': '(' if
-0000e590: 2073 656c 662e 6c65 6674 5f6f 7065 6e20   self.left_open 
-0000e5a0: 656c 7365 2027 5b27 2c0a 2020 2020 2020  else '[',.      
-0000e5b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e5c0: 2020 2020 2020 2027 7269 6768 745f 6f70         'right_op
-0000e5d0: 656e 273a 2027 2927 2069 6620 7365 6c66  en': ')' if self
-0000e5e0: 2e72 6967 6874 5f6f 7065 6e20 656c 7365  .right_open else
-0000e5f0: 2027 5d27 7d29 0a0a 2020 2020 6465 6620   ']'})..    def 
-0000e600: 6861 6e64 6c65 5f66 696e 6974 655f 7365  handle_finite_se
-0000e610: 7473 2873 656c 662c 2075 6e6b 293a 0a20  ts(self, unk):. 
-0000e620: 2020 2020 2020 2069 6620 616c 6c28 6172         if all(ar
-0000e630: 672e 646f 6d61 696e 2069 6e20 7365 6c66  g.domain in self
-0000e640: 2066 6f72 2061 7267 2069 6e20 756e 6b2e   for arg in unk.
-0000e650: 6172 6773 293a 0a20 2020 2020 2020 2020  args):.         
-0000e660: 2020 2072 6574 7572 6e20 756e 6b0a 0a20     return unk.. 
-0000e670: 2020 2064 6566 205f 6861 7368 6162 6c65     def _hashable
-0000e680: 5f63 6f6e 7465 6e74 2873 656c 6629 3a0a  _content(self):.
-0000e690: 2020 2020 2020 2020 2222 2252 6574 7572          """Retur
-0000e6a0: 6e20 6120 7475 706c 6520 6f66 2069 6e66  n a tuple of inf
-0000e6b0: 6f72 6d61 7469 6f6e 2061 626f 7574 2073  ormation about s
-0000e6c0: 656c 6620 7468 6174 2063 616e 2062 6520  elf that can be 
-0000e6d0: 7573 6564 2074 6f0a 2020 2020 2020 2020  used to.        
-0000e6e0: 636f 6d70 7574 6520 7468 6520 6861 7368  compute the hash
-0000e6f0: 2e20 4966 2061 2063 6c61 7373 2064 6566  . If a class def
-0000e700: 696e 6573 2061 6464 6974 696f 6e61 6c20  ines additional 
-0000e710: 6174 7472 6962 7574 6573 2c0a 2020 2020  attributes,.    
-0000e720: 2020 2020 6c69 6b65 2060 606e 616d 6560      like ``name`
-0000e730: 6020 696e 2053 796d 626f 6c2c 2074 6865  ` in Symbol, the
-0000e740: 6e20 7468 6973 206d 6574 686f 6420 7368  n this method sh
-0000e750: 6f75 6c64 2062 6520 7570 6461 7465 640a  ould be updated.
-0000e760: 2020 2020 2020 2020 6163 636f 7264 696e          accordin
-0000e770: 676c 7920 746f 2072 6574 7572 6e20 7375  gly to return su
-0000e780: 6368 2072 656c 6576 616e 7420 6174 7472  ch relevant attr
-0000e790: 6962 7574 6573 2e0a 0a20 2020 2020 2020  ibutes...       
-0000e7a0: 2044 6566 696e 696e 6720 6d6f 7265 2074   Defining more t
-0000e7b0: 6861 6e20 5f68 6173 6861 626c 655f 636f  han _hashable_co
-0000e7c0: 6e74 656e 7420 6973 206e 6563 6573 7361  ntent is necessa
-0000e7d0: 7279 2069 6620 5f5f 6571 5f5f 2068 6173  ry if __eq__ has
-0000e7e0: 0a20 2020 2020 2020 2062 6565 6e20 6465  .        been de
-0000e7f0: 6669 6e65 6420 6279 2061 2063 6c61 7373  fined by a class
-0000e800: 2e20 5365 6520 6e6f 7465 2061 626f 7574  . See note about
-0000e810: 2074 6869 7320 696e 2042 6173 6963 2e5f   this in Basic._
-0000e820: 5f65 715f 5f2e 2222 220a 0a20 2020 2020  _eq__."""..     
-0000e830: 2020 2072 6574 7572 6e20 7365 6c66 2e5f     return self._
-0000e840: 6172 6773 202b 2028 7365 6c66 2e6c 6566  args + (self.lef
-0000e850: 745f 6f70 656e 2c20 7365 6c66 2e72 6967  t_open, self.rig
-0000e860: 6874 5f6f 7065 6e29 0a0a 2020 2020 6465  ht_open)..    de
-0000e870: 6620 5f65 7661 6c5f 6973 5f65 7874 656e  f _eval_is_exten
-0000e880: 6465 645f 7261 7469 6f6e 616c 2873 656c  ded_rational(sel
-0000e890: 6629 3a0a 2020 2020 2020 2020 2e2e 2e0a  f):.        ....
-0000e8a0: 2020 2020 0a20 2020 2064 6566 205f 6576      .    def _ev
-0000e8b0: 616c 5f69 735f 6578 7465 6e64 6564 5f72  al_is_extended_r
-0000e8c0: 6561 6c28 7365 6c66 293a 0a20 2020 2020  eal(self):.     
-0000e8d0: 2020 2072 6574 7572 6e20 5472 7565 0a20     return True. 
-0000e8e0: 2020 2020 2020 200a 2020 2020 6465 6620         .    def 
-0000e8f0: 5f65 7661 6c5f 6973 5f68 7970 6572 5f72  _eval_is_hyper_r
-0000e900: 6561 6c28 7365 6c66 293a 0a20 2020 2020  eal(self):.     
-0000e910: 2020 2072 6574 7572 6e20 5472 7565 0a20     return True. 
-0000e920: 2020 200a 2020 2020 6465 6620 5f65 7661     .    def _eva
-0000e930: 6c5f 6973 5f65 7874 656e 6465 645f 6e65  l_is_extended_ne
-0000e940: 6761 7469 7665 2873 656c 6629 3a0a 2020  gative(self):.  
-0000e950: 2020 2020 2020 6966 2073 656c 662e 6d69        if self.mi
-0000e960: 6e28 292e 6973 5f65 7874 656e 6465 645f  n().is_extended_
-0000e970: 6e6f 6e6e 6567 6174 6976 653a 0a20 2020  nonnegative:.   
-0000e980: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
-0000e990: 4661 6c73 650a 2020 2020 2020 2020 6966  False.        if
-0000e9a0: 2073 656c 662e 6d61 7828 292e 6973 5f65   self.max().is_e
-0000e9b0: 7874 656e 6465 645f 6e65 6761 7469 7665  xtended_negative
-0000e9c0: 3a0a 2020 2020 2020 2020 2020 2020 7265  :.            re
-0000e9d0: 7475 726e 2054 7275 650a 0a20 2020 2064  turn True..    d
-0000e9e0: 6566 205f 6576 616c 5f69 735f 6578 7465  ef _eval_is_exte
-0000e9f0: 6e64 6564 5f70 6f73 6974 6976 6528 7365  nded_positive(se
-0000ea00: 6c66 293a 0a20 2020 2020 2020 2069 6620  lf):.        if 
-0000ea10: 7365 6c66 2e6d 6178 2829 2e69 735f 6578  self.max().is_ex
-0000ea20: 7465 6e64 6564 5f6e 6f6e 706f 7369 7469  tended_nonpositi
-0000ea30: 7665 3a0a 2020 2020 2020 2020 2020 2020  ve:.            
-0000ea40: 7265 7475 726e 2046 616c 7365 0a20 2020  return False.   
-0000ea50: 2020 2020 2069 6620 7365 6c66 2e6d 696e       if self.min
-0000ea60: 2829 2e69 735f 6578 7465 6e64 6564 5f70  ().is_extended_p
-0000ea70: 6f73 6974 6976 653a 0a20 2020 2020 2020  ositive:.       
-0000ea80: 2020 2020 2072 6574 7572 6e20 5472 7565       return True
-0000ea90: 0a0a 2020 2020 6465 6620 5f65 7661 6c5f  ..    def _eval_
-0000eaa0: 6973 5f7a 6572 6f28 7365 6c66 293a 0a20  is_zero(self):. 
-0000eab0: 2020 2020 2020 2069 6620 7365 6c66 2e6d         if self.m
-0000eac0: 696e 2829 2e69 735f 6578 7465 6e64 6564  in().is_extended
-0000ead0: 5f70 6f73 6974 6976 653a 0a20 2020 2020  _positive:.     
-0000eae0: 2020 2020 2020 2072 6574 7572 6e20 4661         return Fa
-0000eaf0: 6c73 650a 2020 2020 2020 2020 6966 2073  lse.        if s
-0000eb00: 656c 662e 6d61 7828 292e 6973 5f65 7874  elf.max().is_ext
-0000eb10: 656e 6465 645f 6e65 6761 7469 7665 3a0a  ended_negative:.
-0000eb20: 2020 2020 2020 2020 2020 2020 7265 7475              retu
-0000eb30: 726e 2046 616c 7365 0a0a 2020 2020 6465  rn False..    de
-0000eb40: 6620 5f65 7661 6c5f 6973 5f65 6d70 7479  f _eval_is_empty
-0000eb50: 2873 656c 6629 3a0a 2020 2020 2020 2020  (self):.        
-0000eb60: 7374 6172 742c 2073 746f 7020 3d20 7365  start, stop = se
-0000eb70: 6c66 2e61 7267 730a 2020 2020 2020 2020  lf.args.        
-0000eb80: 6966 2073 7461 7274 203c 2073 746f 703a  if start < stop:
-0000eb90: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
-0000eba0: 7572 6e20 4661 6c73 650a 0a20 2020 2064  urn False..    d
-0000ebb0: 6566 205f 6c61 7465 7828 7365 6c66 2c20  ef _latex(self, 
-0000ebc0: 7029 3a0a 2020 2020 2020 2020 6966 2073  p):.        if s
-0000ebd0: 656c 662e 7374 6172 7420 3d3d 2073 656c  elf.start == sel
-0000ebe0: 662e 7374 6f70 3a0a 2020 2020 2020 2020  f.stop:.        
-0000ebf0: 2020 2020 7265 7475 726e 2072 225c 6c65      return r"\le
-0000ec00: 6674 5c7b 2573 5c72 6967 6874 5c7d 2220  ft\{%s\right\}" 
-0000ec10: 2520 7365 6c66 2e5f 7072 696e 7428 7365  % self._print(se
-0000ec20: 6c66 2e73 7461 7274 290a 2020 2020 2020  lf.start).      
-0000ec30: 2020 656c 6966 2073 656c 662e 7374 6172    elif self.star
-0000ec40: 742e 6973 5f4e 6567 6174 6976 6549 6e66  t.is_NegativeInf
-0000ec50: 696e 6974 793a 0a20 2020 2020 2020 2020  inity:.         
-0000ec60: 2020 2069 6620 7365 6c66 2e73 746f 702e     if self.stop.
-0000ec70: 6973 5f49 6e66 696e 6974 793a 0a20 2020  is_Infinity:.   
-0000ec80: 2020 2020 2020 2020 2020 2020 2069 6620               if 
-0000ec90: 7365 6c66 2e6c 6566 745f 6f70 656e 2061  self.left_open a
-0000eca0: 6e64 2073 656c 662e 7269 6768 745f 6f70  nd self.right_op
-0000ecb0: 656e 3a20 0a20 2020 2020 2020 2020 2020  en: .           
-0000ecc0: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
-0000ecd0: 7222 5c6d 6174 6862 627b 527d 220a 2020  r"\mathbb{R}".  
-0000ece0: 2020 2020 2020 2020 2020 2020 2020 0a20                . 
-0000ecf0: 2020 2020 2020 2020 2020 2065 6c69 6620             elif 
-0000ed00: 7365 6c66 2e73 746f 702e 6973 5f5a 6572  self.stop.is_Zer
-0000ed10: 6f3a 0a20 2020 2020 2020 2020 2020 2020  o:.             
-0000ed20: 2020 2069 6620 7365 6c66 2e6c 6566 745f     if self.left_
-0000ed30: 6f70 656e 2061 6e64 2073 656c 662e 7269  open and self.ri
-0000ed40: 6768 745f 6f70 656e 3a0a 2020 2020 2020  ght_open:.      
-0000ed50: 2020 2020 2020 2020 2020 2020 2020 7265                re
-0000ed60: 7475 726e 2072 225c 6d61 7468 6262 7b52  turn r"\mathbb{R
-0000ed70: 7d5e 2d22 0a20 2020 2020 2020 2020 2020  }^-".           
-0000ed80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ed90: 2020 2020 2020 2020 200a 2020 2020 2020           .      
-0000eda0: 2020 656c 6966 2073 656c 662e 7374 6f70    elif self.stop
-0000edb0: 2e69 735f 496e 6669 6e69 7479 3a0a 2020  .is_Infinity:.  
-0000edc0: 2020 2020 2020 2020 2020 6966 2073 656c            if sel
-0000edd0: 662e 7374 6172 742e 6973 5f5a 6572 6f3a  f.start.is_Zero:
-0000ede0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000edf0: 2069 6620 7365 6c66 2e6c 6566 745f 6f70   if self.left_op
-0000ee00: 656e 2061 6e64 2073 656c 662e 7269 6768  en and self.righ
-0000ee10: 745f 6f70 656e 3a0a 2020 2020 2020 2020  t_open:.        
-0000ee20: 2020 2020 2020 2020 2020 2020 7265 7475              retu
-0000ee30: 726e 2072 225c 6d61 7468 6262 7b52 7d5e  rn r"\mathbb{R}^
-0000ee40: 2b22 0a20 2020 2020 2020 200a 2020 2020  +".        .    
-0000ee50: 2020 2020 6966 2073 656c 662e 6c65 6674      if self.left
-0000ee60: 5f6f 7065 6e3a 0a20 2020 2020 2020 2020  _open:.         
-0000ee70: 2020 206c 6566 7420 3d20 2728 270a 2020     left = '('.  
-0000ee80: 2020 2020 2020 656c 7365 3a0a 2020 2020        else:.    
-0000ee90: 2020 2020 2020 2020 6c65 6674 203d 2027          left = '
-0000eea0: 5b27 0a0a 2020 2020 2020 2020 6966 2073  ['..        if s
-0000eeb0: 656c 662e 7269 6768 745f 6f70 656e 3a0a  elf.right_open:.
-0000eec0: 2020 2020 2020 2020 2020 2020 7269 6768              righ
-0000eed0: 7420 3d20 2729 270a 2020 2020 2020 2020  t = ')'.        
-0000eee0: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
-0000eef0: 2020 7269 6768 7420 3d20 275d 270a 0a20    right = ']'.. 
-0000ef00: 2020 2020 2020 2072 6574 7572 6e20 7222         return r"
-0000ef10: 5c6c 6566 7425 7325 732c 2025 735c 7269  \left%s%s, %s\ri
-0000ef20: 6768 7425 7322 2025 2028 6c65 6674 2c20  ght%s" % (left, 
-0000ef30: 702e 5f70 7269 6e74 2873 656c 662e 7374  p._print(self.st
-0000ef40: 6172 7429 2c20 702e 5f70 7269 6e74 2873  art), p._print(s
-0000ef50: 656c 662e 7374 6f70 292c 2072 6967 6874  elf.stop), right
-0000ef60: 290a 0a20 2020 2040 636c 6173 736d 6574  )..    @classmet
-0000ef70: 686f 640a 2020 2020 6465 6620 7369 6d70  hod.    def simp
-0000ef80: 6c69 6679 5f45 6c65 6d65 6e74 2863 6c73  lify_Element(cls
-0000ef90: 2c20 7365 6c66 2c20 652c 2073 293a 200a  , self, e, s): .
-0000efa0: 2020 2020 2020 2020 6966 2073 2e73 7461          if s.sta
-0000efb0: 7274 2e69 735f 4e65 6761 7469 7665 496e  rt.is_NegativeIn
-0000efc0: 6669 6e69 7479 3a0a 2020 2020 2020 2020  finity:.        
-0000efd0: 2020 2020 6672 6f6d 2073 796d 7079 2069      from sympy i
-0000efe0: 6d70 6f72 7420 4c65 7373 2c20 4c65 7373  mport Less, Less
-0000eff0: 4571 7561 6c0a 2020 2020 2020 2020 2020  Equal.          
-0000f000: 2020 6675 6e63 203d 204c 6573 7320 6966    func = Less if
-0000f010: 2073 2e72 6967 6874 5f6f 7065 6e20 656c   s.right_open el
-0000f020: 7365 204c 6573 7345 7175 616c 0a20 2020  se LessEqual.   
-0000f030: 2020 2020 2020 2020 2069 6620 6e6f 7420           if not 
-0000f040: 626f 6f6c 2873 2e6c 6566 745f 6f70 656e  bool(s.left_open
-0000f050: 2920 5e20 626f 6f6c 2865 2e69 735f 6669  ) ^ bool(e.is_fi
-0000f060: 6e69 7465 293a 0a20 2020 2020 2020 2020  nite):.         
-0000f070: 2020 2020 2020 2072 6574 7572 6e20 6675         return fu
-0000f080: 6e63 2865 2c20 732e 7374 6f70 292e 7369  nc(e, s.stop).si
-0000f090: 6d70 6c69 6679 2829 0a20 2020 2020 2020  mplify().       
-0000f0a0: 2020 2020 200a 2020 2020 2020 2020 6966       .        if
-0000f0b0: 2073 2e73 746f 702e 6973 5f49 6e66 696e   s.stop.is_Infin
-0000f0c0: 6974 793a 0a20 2020 2020 2020 2020 2020  ity:.           
-0000f0d0: 2066 726f 6d20 7379 6d70 7920 696d 706f   from sympy impo
-0000f0e0: 7274 2047 7265 6174 6572 2c20 4772 6561  rt Greater, Grea
-0000f0f0: 7465 7245 7175 616c 0a20 2020 2020 2020  terEqual.       
-0000f100: 2020 2020 2066 756e 6320 3d20 4772 6561       func = Grea
-0000f110: 7465 7220 6966 2073 2e6c 6566 745f 6f70  ter if s.left_op
-0000f120: 656e 2065 6c73 6520 4772 6561 7465 7245  en else GreaterE
-0000f130: 7175 616c 0a20 2020 2020 2020 2020 2020  qual.           
-0000f140: 2069 6620 6e6f 7420 626f 6f6c 2873 2e72   if not bool(s.r
-0000f150: 6967 6874 5f6f 7065 6e29 205e 2062 6f6f  ight_open) ^ boo
-0000f160: 6c28 652e 6973 5f66 696e 6974 6529 3a0a  l(e.is_finite):.
-0000f170: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000f180: 7265 7475 726e 2066 756e 6328 652c 2073  return func(e, s
-0000f190: 2e73 7461 7274 292e 7369 6d70 6c69 6679  .start).simplify
-0000f1a0: 2829 0a20 2020 2020 2020 200a 2020 2020  ().        .    
-0000f1b0: 2020 2020 6669 6e69 7465 7365 7420 3d20      finiteset = 
-0000f1c0: 652e 646f 6d61 696e 202d 2073 0a20 2020  e.domain - s.   
-0000f1d0: 2020 2020 2069 6620 6669 6e69 7465 7365       if finitese
-0000f1e0: 742e 6973 5f46 696e 6974 6553 6574 3a0a  t.is_FiniteSet:.
-0000f1f0: 2020 2020 2020 2020 2020 2020 7265 7475              retu
-0000f200: 726e 2073 656c 662e 696e 7665 7274 5f74  rn self.invert_t
-0000f210: 7970 6528 652c 2066 696e 6974 6573 6574  ype(e, finiteset
-0000f220: 292e 7369 6d70 6c69 6679 2829 0a20 2020  ).simplify().   
-0000f230: 2020 2020 2020 2020 200a 2020 2020 4063           .    @c
-0000f240: 6c61 7373 6d65 7468 6f64 0a20 2020 2064  lassmethod.    d
-0000f250: 6566 2073 696d 706c 6966 795f 4e6f 7445  ef simplify_NotE
-0000f260: 6c65 6d65 6e74 2863 6c73 2c20 7365 6c66  lement(cls, self
-0000f270: 2c20 652c 2073 293a 0a20 2020 2020 2020  , e, s):.       
-0000f280: 2069 6620 652e 6973 5f72 6561 6c3a 0a20   if e.is_real:. 
-0000f290: 2020 2020 2020 2020 2020 2069 6620 732e             if s.
-0000f2a0: 7374 6f70 2e69 735f 696e 6669 6e69 7465  stop.is_infinite
-0000f2b0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-0000f2c0: 2020 6966 2073 2e6c 6566 745f 6f70 656e    if s.left_open
-0000f2d0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-0000f2e0: 2020 2020 2020 7265 7475 726e 2065 203c        return e <
-0000f2f0: 3d20 732e 7374 6172 740a 2020 2020 2020  = s.start.      
-0000f300: 2020 2020 2020 2020 2020 656c 7365 3a0a            else:.
-0000f310: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000f320: 2020 2020 7265 7475 726e 2065 203c 2073      return e < s
-0000f330: 2e73 7461 7274 0a20 2020 2020 2020 2020  .start.         
-0000f340: 2020 2065 6c69 6620 732e 7374 6172 742e     elif s.start.
-0000f350: 6973 5f69 6e66 696e 6974 653a 0a20 2020  is_infinite:.   
-0000f360: 2020 2020 2020 2020 2020 2020 2069 6620               if 
-0000f370: 732e 7269 6768 745f 6f70 656e 3a0a 2020  s.right_open:.  
-0000f380: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000f390: 2020 7265 7475 726e 2065 203e 3d20 732e    return e >= s.
-0000f3a0: 7374 6172 740a 2020 2020 2020 2020 2020  start.          
-0000f3b0: 2020 2020 2020 656c 7365 3a0a 2020 2020        else:.    
+00008500: 2020 0a20 2020 2020 2020 2020 2020 2072    .            r
+00008510: 6574 7572 6e20 496e 7465 7276 616c 2873  eturn Interval(s
+00008520: 7461 7274 2c20 7374 6f70 2c20 6c65 6674  tart, stop, left
+00008530: 5f6f 7065 6e3d 6c65 6674 5f6f 7065 6e2c  _open=left_open,
+00008540: 2072 6967 6874 5f6f 7065 6e3d 7269 6768   right_open=righ
+00008550: 745f 6f70 656e 2920 2020 2020 2020 2020  t_open)         
+00008560: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00008570: 2020 200a 0a20 2020 2020 2020 2065 6d70     ..        emp
+00008580: 7479 203d 2046 616c 7365 0a0a 2020 2020  ty = False..    
+00008590: 2020 2020 6966 2073 656c 662e 7374 6172      if self.star
+000085a0: 7420 3c3d 2062 2e73 746f 7020 616e 6420  t <= b.stop and 
+000085b0: 622e 7374 6172 7420 3c3d 2073 656c 662e  b.start <= self.
+000085c0: 7374 6f70 3a0a 2020 2020 2020 2020 2020  stop:.          
+000085d0: 2020 2320 4765 7420 746f 706f 6c6f 6779    # Get topology
+000085e0: 2072 6967 6874 2e0a 2020 2020 2020 2020   right..        
+000085f0: 2020 2020 6966 2073 656c 662e 7374 6172      if self.star
+00008600: 7420 3c20 622e 7374 6172 743a 0a20 2020  t < b.start:.   
+00008610: 2020 2020 2020 2020 2020 2020 2073 7461               sta
+00008620: 7274 203d 2062 2e73 7461 7274 0a20 2020  rt = b.start.   
+00008630: 2020 2020 2020 2020 2020 2020 206c 6566               lef
+00008640: 745f 6f70 656e 203d 2062 2e6c 6566 745f  t_open = b.left_
+00008650: 6f70 656e 0a20 2020 2020 2020 2020 2020  open.           
+00008660: 2065 6c69 6620 7365 6c66 2e73 7461 7274   elif self.start
+00008670: 203e 2062 2e73 7461 7274 3a0a 2020 2020   > b.start:.    
+00008680: 2020 2020 2020 2020 2020 2020 7374 6172              star
+00008690: 7420 3d20 7365 6c66 2e73 7461 7274 0a20  t = self.start. 
+000086a0: 2020 2020 2020 2020 2020 2020 2020 206c                 l
+000086b0: 6566 745f 6f70 656e 203d 2073 656c 662e  eft_open = self.
+000086c0: 6c65 6674 5f6f 7065 6e0a 2020 2020 2020  left_open.      
+000086d0: 2020 2020 2020 656c 7365 3a0a 2020 2020        else:.    
+000086e0: 2020 2020 2020 2020 2020 2020 7374 6172              star
+000086f0: 7420 3d20 7365 6c66 2e73 7461 7274 0a20  t = self.start. 
+00008700: 2020 2020 2020 2020 2020 2020 2020 206c                 l
+00008710: 6566 745f 6f70 656e 203d 2073 656c 662e  eft_open = self.
+00008720: 6c65 6674 5f6f 7065 6e20 6f72 2062 2e6c  left_open or b.l
+00008730: 6566 745f 6f70 656e 0a0a 2020 2020 2020  eft_open..      
+00008740: 2020 2020 2020 6966 2073 656c 662e 7374        if self.st
+00008750: 6f70 203c 2062 2e73 746f 703a 0a20 2020  op < b.stop:.   
+00008760: 2020 2020 2020 2020 2020 2020 2073 746f               sto
+00008770: 7020 3d20 7365 6c66 2e73 746f 700a 2020  p = self.stop.  
+00008780: 2020 2020 2020 2020 2020 2020 2020 7269                ri
+00008790: 6768 745f 6f70 656e 203d 2073 656c 662e  ght_open = self.
+000087a0: 7269 6768 745f 6f70 656e 0a20 2020 2020  right_open.     
+000087b0: 2020 2020 2020 2065 6c69 6620 7365 6c66         elif self
+000087c0: 2e73 746f 7020 3e20 622e 7374 6f70 3a0a  .stop > b.stop:.
+000087d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000087e0: 7374 6f70 203d 2062 2e73 746f 700a 2020  stop = b.stop.  
+000087f0: 2020 2020 2020 2020 2020 2020 2020 7269                ri
+00008800: 6768 745f 6f70 656e 203d 2062 2e72 6967  ght_open = b.rig
+00008810: 6874 5f6f 7065 6e0a 2020 2020 2020 2020  ht_open.        
+00008820: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
+00008830: 2020 2020 2020 2020 2020 7374 6f70 203d            stop =
+00008840: 2073 656c 662e 7374 6f70 0a20 2020 2020   self.stop.     
+00008850: 2020 2020 2020 2020 2020 2072 6967 6874             right
+00008860: 5f6f 7065 6e20 3d20 7365 6c66 2e72 6967  _open = self.rig
+00008870: 6874 5f6f 7065 6e20 6f72 2062 2e72 6967  ht_open or b.rig
+00008880: 6874 5f6f 7065 6e0a 0a20 2020 2020 2020  ht_open..       
+00008890: 2020 2020 2069 6620 7374 6f70 202d 2073       if stop - s
+000088a0: 7461 7274 203d 3d20 3020 616e 6420 286c  tart == 0 and (l
+000088b0: 6566 745f 6f70 656e 206f 7220 7269 6768  eft_open or righ
+000088c0: 745f 6f70 656e 293a 0a20 2020 2020 2020  t_open):.       
+000088d0: 2020 2020 2020 2020 2065 6d70 7479 203d           empty =
+000088e0: 2054 7275 650a 2020 2020 2020 2020 656c   True.        el
+000088f0: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
+00008900: 656d 7074 7920 3d20 5472 7565 0a0a 2020  empty = True..  
+00008910: 2020 2020 2020 6966 2065 6d70 7479 3a0a        if empty:.
+00008920: 2020 2020 2020 2020 2020 2020 7265 7475              retu
+00008930: 726e 2073 656c 662e 6574 7970 652e 656d  rn self.etype.em
+00008940: 7074 7953 6574 0a0a 2020 2020 2020 2020  ptySet..        
+00008950: 696e 7465 7276 616c 203d 2073 656c 662e  interval = self.
+00008960: 6675 6e63 2873 7461 7274 2c20 7374 6f70  func(start, stop
+00008970: 2c20 6c65 6674 5f6f 7065 6e3d 6c65 6674  , left_open=left
+00008980: 5f6f 7065 6e2c 2072 6967 6874 5f6f 7065  _open, right_ope
+00008990: 6e3d 7269 6768 745f 6f70 656e 290a 2020  n=right_open).  
+000089a0: 2020 2020 2020 6966 2062 2e69 735f 696e        if b.is_in
+000089b0: 7465 6765 723a 0a20 2020 2020 2020 2020  teger:.         
+000089c0: 2020 2072 6574 7572 6e20 696e 7465 7276     return interv
+000089d0: 616c 2e63 6f70 7928 696e 7465 6765 723d  al.copy(integer=
+000089e0: 5472 7565 290a 2020 2020 2020 2020 7265  True).        re
+000089f0: 7475 726e 2069 6e74 6572 7661 6c0a 0a20  turn interval.. 
+00008a00: 2020 2064 6566 205f 756e 696f 6e5f 7365     def _union_se
+00008a10: 7473 2873 656c 662c 2062 293a 200a 2020  ts(self, b): .  
+00008a20: 2020 2020 2020 6966 2073 656c 662e 6d61        if self.ma
+00008a30: 7828 2920 696e 2062 3a0a 2020 2020 2020  x() in b:.      
+00008a40: 2020 2020 2020 6672 6f6d 2073 796d 7079        from sympy
+00008a50: 2069 6d70 6f72 7420 4d69 6e0a 2020 2020   import Min.    
+00008a60: 2020 2020 2020 2020 7265 7475 726e 2062          return b
+00008a70: 2e63 6f70 7928 7374 6172 743d 4d69 6e28  .copy(start=Min(
+00008a80: 7365 6c66 2e6d 696e 2829 2c20 622e 6d69  self.min(), b.mi
+00008a90: 6e28 2929 2c20 6c65 6674 5f6f 7065 6e3d  n()), left_open=
+00008aa0: 4661 6c73 652c 2069 6e74 6567 6572 3d4e  False, integer=N
+00008ab0: 6f6e 6529 0a20 2020 2020 2020 200a 2020  one).        .  
+00008ac0: 2020 2020 2020 6966 2073 656c 662e 6d69        if self.mi
+00008ad0: 6e28 2920 696e 2062 3a0a 2020 2020 2020  n() in b:.      
+00008ae0: 2020 2020 2020 6672 6f6d 2073 796d 7079        from sympy
+00008af0: 2069 6d70 6f72 7420 4d61 780a 2020 2020   import Max.    
+00008b00: 2020 2020 2020 2020 7265 7475 726e 2062          return b
+00008b10: 2e63 6f70 7928 7374 6f70 3d4d 6178 2873  .copy(stop=Max(s
+00008b20: 656c 662e 6d61 7828 292c 2062 2e6d 6178  elf.max(), b.max
+00008b30: 2829 292c 2072 6967 6874 5f6f 7065 6e3d  ()), right_open=
+00008b40: 4661 6c73 652c 2069 6e74 6567 6572 3d4e  False, integer=N
+00008b50: 6f6e 6529 0a20 2020 2020 2020 200a 2020  one).        .  
+00008b60: 2020 2020 2020 6966 2073 656c 6620 696e        if self in
+00008b70: 2062 3a0a 2020 2020 2020 2020 2020 2020   b:.            
+00008b80: 7265 7475 726e 2062 0a20 2020 2020 2020  return b.       
+00008b90: 200a 2020 2020 2020 2020 6966 2062 2069   .        if b i
+00008ba0: 6e20 7365 6c66 3a0a 2020 2020 2020 2020  n self:.        
+00008bb0: 2020 2020 7265 7475 726e 2073 656c 660a      return self.
+00008bc0: 2020 2020 2020 2020 0a20 2020 2020 2020          .       
+00008bd0: 2069 6620 7365 6c66 2e72 6967 6874 5f6f   if self.right_o
+00008be0: 7065 6e20 616e 6420 6e6f 7420 622e 6c65  pen and not b.le
+00008bf0: 6674 5f6f 7065 6e3a 0a20 2020 2020 2020  ft_open:.       
+00008c00: 2020 2020 2069 6620 7365 6c66 2e73 746f       if self.sto
+00008c10: 7020 3d3d 2062 2e73 7461 7274 2061 6e64  p == b.start and
+00008c20: 2062 2e73 7461 7274 203c 3d20 622e 7374   b.start <= b.st
+00008c30: 6f70 3a0a 2020 2020 2020 2020 2020 2020  op:.            
+00008c40: 2020 2020 6966 2073 656c 662e 6c65 6674      if self.left
+00008c50: 5f6f 7065 6e3a 0a20 2020 2020 2020 2020  _open:.         
+00008c60: 2020 2020 2020 2020 2020 2069 6620 7365             if se
+00008c70: 6c66 2e73 746f 7020 3e20 7365 6c66 2e73  lf.stop > self.s
+00008c80: 7461 7274 3a0a 2020 2020 2020 2020 2020  tart:.          
+00008c90: 2020 2020 2020 2020 2020 2020 2020 7265                re
+00008ca0: 7475 726e 2049 6e74 6572 7661 6c28 7365  turn Interval(se
+00008cb0: 6c66 2e73 7461 7274 2c20 622e 7374 6f70  lf.start, b.stop
+00008cc0: 2c20 6c65 6674 5f6f 7065 6e3d 5472 7565  , left_open=True
+00008cd0: 2c20 7269 6768 745f 6f70 656e 3d62 2e72  , right_open=b.r
+00008ce0: 6967 6874 5f6f 7065 6e29 0a20 2020 2020  ight_open).     
+00008cf0: 2020 2020 2020 2020 2020 2065 6c73 653a             else:
+00008d00: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00008d10: 2020 2020 2069 6620 7365 6c66 2e73 746f       if self.sto
+00008d20: 7020 3e3d 2073 656c 662e 7374 6172 743a  p >= self.start:
+00008d30: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00008d40: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
+00008d50: 496e 7465 7276 616c 2873 656c 662e 7374  Interval(self.st
+00008d60: 6172 742c 2062 2e73 746f 702c 206c 6566  art, b.stop, lef
+00008d70: 745f 6f70 656e 3d46 616c 7365 2c20 7269  t_open=False, ri
+00008d80: 6768 745f 6f70 656e 3d62 2e72 6967 6874  ght_open=b.right
+00008d90: 5f6f 7065 6e29 0a20 2020 2020 2020 2065  _open).        e
+00008da0: 6c69 6620 6e6f 7420 7365 6c66 2e72 6967  lif not self.rig
+00008db0: 6874 5f6f 7065 6e20 616e 6420 622e 6c65  ht_open and b.le
+00008dc0: 6674 5f6f 7065 6e3a 0a20 2020 2020 2020  ft_open:.       
+00008dd0: 2020 2020 2069 6620 7365 6c66 2e73 746f       if self.sto
+00008de0: 7020 3d3d 2062 2e73 7461 7274 2061 6e64  p == b.start and
+00008df0: 2073 656c 662e 7374 6172 7420 3c3d 2073   self.start <= s
+00008e00: 656c 662e 7374 6f70 3a0a 2020 2020 2020  elf.stop:.      
+00008e10: 2020 2020 2020 2020 2020 6966 2062 2e72            if b.r
+00008e20: 6967 6874 5f6f 7065 6e3a 0a20 2020 2020  ight_open:.     
+00008e30: 2020 2020 2020 2020 2020 2020 2020 2069                 i
+00008e40: 6620 622e 7374 6f70 203e 2062 2e73 7461  f b.stop > b.sta
+00008e50: 7274 3a0a 2020 2020 2020 2020 2020 2020  rt:.            
+00008e60: 2020 2020 2020 2020 2020 2020 7265 7475              retu
+00008e70: 726e 2049 6e74 6572 7661 6c28 7365 6c66  rn Interval(self
+00008e80: 2e73 7461 7274 2c20 622e 7374 6f70 2c20  .start, b.stop, 
+00008e90: 6c65 6674 5f6f 7065 6e3d 7365 6c66 2e6c  left_open=self.l
+00008ea0: 6566 745f 6f70 656e 2c20 7269 6768 745f  eft_open, right_
+00008eb0: 6f70 656e 3d54 7275 6529 0a20 2020 2020  open=True).     
+00008ec0: 2020 2020 2020 2020 2020 2065 6c73 653a             else:
+00008ed0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00008ee0: 2020 2020 2069 6620 622e 7374 6f70 203e       if b.stop >
+00008ef0: 3d20 622e 7374 6172 743a 0a20 2020 2020  = b.start:.     
+00008f00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00008f10: 2020 2072 6574 7572 6e20 496e 7465 7276     return Interv
+00008f20: 616c 2873 656c 662e 7374 6172 742c 2062  al(self.start, b
+00008f30: 2e73 746f 702c 206c 6566 745f 6f70 656e  .stop, left_open
+00008f40: 3d73 656c 662e 6c65 6674 5f6f 7065 6e2c  =self.left_open,
+00008f50: 2072 6967 6874 5f6f 7065 6e3d 4661 6c73   right_open=Fals
+00008f60: 6529 0a20 2020 2020 2020 2065 6c69 6620  e).        elif 
+00008f70: 6e6f 7420 622e 7269 6768 745f 6f70 656e  not b.right_open
+00008f80: 2061 6e64 2073 656c 662e 6c65 6674 5f6f   and self.left_o
+00008f90: 7065 6e3a 0a20 2020 2020 2020 2020 2020  pen:.           
+00008fa0: 2069 6620 622e 7374 6f70 203d 3d20 7365   if b.stop == se
+00008fb0: 6c66 2e73 7461 7274 2061 6e64 2062 2e73  lf.start and b.s
+00008fc0: 7461 7274 203c 3d20 622e 7374 6f70 3a0a  tart <= b.stop:.
+00008fd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00008fe0: 6966 2073 656c 662e 7269 6768 745f 6f70  if self.right_op
+00008ff0: 656e 3a0a 2020 2020 2020 2020 2020 2020  en:.            
+00009000: 2020 2020 2020 2020 6966 2073 656c 662e          if self.
+00009010: 7374 6f70 203e 2073 656c 662e 7374 6172  stop > self.star
+00009020: 743a 0a20 2020 2020 2020 2020 2020 2020  t:.             
+00009030: 2020 2020 2020 2020 2020 2072 6574 7572             retur
+00009040: 6e20 496e 7465 7276 616c 2862 2e73 7461  n Interval(b.sta
+00009050: 7274 2c20 7365 6c66 2e73 746f 702c 206c  rt, self.stop, l
+00009060: 6566 745f 6f70 656e 3d62 2e6c 6566 745f  eft_open=b.left_
+00009070: 6f70 656e 2c20 7269 6768 745f 6f70 656e  open, right_open
+00009080: 3d54 7275 6529 0a20 2020 2020 2020 2020  =True).         
+00009090: 2020 2020 2020 2065 6c73 653a 200a 2020         else: .  
+000090a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000090b0: 2020 6966 2073 656c 662e 7374 6f70 203e    if self.stop >
+000090c0: 3d20 7365 6c66 2e73 7461 7274 3a0a 2020  = self.start:.  
+000090d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000090e0: 2020 2020 2020 7265 7475 726e 2049 6e74        return Int
+000090f0: 6572 7661 6c28 622e 7374 6172 742c 2073  erval(b.start, s
+00009100: 656c 662e 7374 6f70 2c20 6c65 6674 5f6f  elf.stop, left_o
+00009110: 7065 6e3d 622e 6c65 6674 5f6f 7065 6e2c  pen=b.left_open,
+00009120: 2072 6967 6874 5f6f 7065 6e3d 4661 6c73   right_open=Fals
+00009130: 6529 0a20 2020 2020 2020 2065 6c69 6620  e).        elif 
+00009140: 622e 7269 6768 745f 6f70 656e 2061 6e64  b.right_open and
+00009150: 206e 6f74 2073 656c 662e 6c65 6674 5f6f   not self.left_o
+00009160: 7065 6e3a 0a20 2020 2020 2020 2020 2020  pen:.           
+00009170: 2069 6620 622e 7374 6f70 203d 3d20 7365   if b.stop == se
+00009180: 6c66 2e73 7461 7274 2061 6e64 2073 656c  lf.start and sel
+00009190: 662e 7374 6172 7420 3c3d 2073 656c 662e  f.start <= self.
+000091a0: 7374 6f70 3a0a 2020 2020 2020 2020 2020  stop:.          
+000091b0: 2020 2020 2020 6966 2062 2e6c 6566 745f        if b.left_
+000091c0: 6f70 656e 3a0a 2020 2020 2020 2020 2020  open:.          
+000091d0: 2020 2020 2020 2020 2020 6966 2062 2e73            if b.s
+000091e0: 746f 7020 3e20 622e 7374 6172 743a 0a20  top > b.start:. 
+000091f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009200: 2020 2020 2020 2072 6574 7572 6e20 496e         return In
+00009210: 7465 7276 616c 2862 2e73 7461 7274 2c20  terval(b.start, 
+00009220: 7365 6c66 2e73 746f 702c 206c 6566 745f  self.stop, left_
+00009230: 6f70 656e 3d54 7275 652c 2072 6967 6874  open=True, right
+00009240: 5f6f 7065 6e3d 7365 6c66 2e72 6967 6874  _open=self.right
+00009250: 5f6f 7065 6e29 0a20 2020 2020 2020 2020  _open).         
+00009260: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
+00009270: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009280: 2069 6620 622e 7374 6f70 203e 3d20 622e   if b.stop >= b.
+00009290: 7374 6172 743a 0a20 2020 2020 2020 2020  start:.         
+000092a0: 2020 2020 2020 2020 2020 2020 2020 2072                 r
+000092b0: 6574 7572 6e20 496e 7465 7276 616c 2862  eturn Interval(b
+000092c0: 2e73 7461 7274 2c20 7365 6c66 2e73 746f  .start, self.sto
+000092d0: 702c 206c 6566 745f 6f70 656e 3d46 616c  p, left_open=Fal
+000092e0: 7365 2c20 7269 6768 745f 6f70 656e 3d73  se, right_open=s
+000092f0: 656c 662e 7269 6768 745f 6f70 656e 290a  elf.right_open).
+00009300: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009310: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009320: 2020 2020 200a 2020 2020 6465 6620 756e       .    def un
+00009330: 696f 6e5f 7365 7473 2873 656c 662c 2062  ion_sets(self, b
+00009340: 293a 0a20 2020 2020 2020 2069 6620 622e  ):.        if b.
+00009350: 6973 5f49 6e74 6572 7661 6c20 6f72 2062  is_Interval or b
+00009360: 2e69 735f 5261 6e67 653a 0a20 2020 2020  .is_Range:.     
+00009370: 2020 2020 2020 2069 6620 7365 6c66 2e5f         if self._
+00009380: 6973 5f63 6f6d 7061 7261 626c 6528 6229  is_comparable(b)
+00009390: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+000093a0: 2020 6672 6f6d 2073 796d 7079 2e66 756e    from sympy.fun
+000093b0: 6374 696f 6e73 2e65 6c65 6d65 6e74 6172  ctions.elementar
+000093c0: 792e 6d69 7363 656c 6c61 6e65 6f75 7320  y.miscellaneous 
+000093d0: 696d 706f 7274 204d 696e 2c20 4d61 780a  import Min, Max.
+000093e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000093f0: 2320 4e6f 6e2d 6f76 6572 6c61 7070 696e  # Non-overlappin
+00009400: 6720 696e 7465 7276 616c 730a 2020 2020  g intervals.    
+00009410: 2020 2020 2020 2020 2020 2020 7374 6f70              stop
+00009420: 203d 204d 696e 2873 656c 662e 7374 6f70   = Min(self.stop
+00009430: 2c20 622e 7374 6f70 290a 2020 2020 2020  , b.stop).      
+00009440: 2020 2020 2020 2020 2020 7374 6172 7420            start 
+00009450: 3d20 4d61 7828 7365 6c66 2e73 7461 7274  = Max(self.start
+00009460: 2c20 622e 7374 6172 7429 0a20 2020 2020  , b.start).     
+00009470: 2020 2020 2020 2020 2020 2069 6620 2873             if (s
+00009480: 746f 7020 3c20 7374 6172 7420 6f72 0a20  top < start or. 
+00009490: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000094a0: 2020 2873 746f 7020 3d3d 2073 7461 7274    (stop == start
+000094b0: 2061 6e64 2028 7374 6f70 206e 6f74 2069   and (stop not i
+000094c0: 6e20 7365 6c66 2061 6e64 2073 746f 7020  n self and stop 
+000094d0: 6e6f 7420 696e 2062 2929 293a 0a20 2020  not in b))):.   
+000094e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000094f0: 2072 6574 7572 6e20 4e6f 6e65 0a20 2020   return None.   
+00009500: 2020 2020 2020 2020 2020 2020 2065 6c73               els
+00009510: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
+00009520: 2020 2020 2020 2073 7461 7274 203d 204d         start = M
+00009530: 696e 2873 656c 662e 7374 6172 742c 2062  in(self.start, b
+00009540: 2e73 7461 7274 290a 2020 2020 2020 2020  .start).        
+00009550: 2020 2020 2020 2020 2020 2020 7374 6f70              stop
+00009560: 203d 204d 6178 2873 656c 662e 7374 6f70   = Max(self.stop
+00009570: 2c20 622e 7374 6f70 290a 0a20 2020 2020  , b.stop)..     
+00009580: 2020 2020 2020 2020 2020 2020 2020 206c                 l
+00009590: 6566 745f 6f70 656e 203d 2028 2873 656c  eft_open = ((sel
+000095a0: 662e 7374 6172 7420 213d 2073 7461 7274  f.start != start
+000095b0: 206f 7220 7365 6c66 2e6c 6566 745f 6f70   or self.left_op
+000095c0: 656e 2920 616e 640a 2020 2020 2020 2020  en) and.        
+000095d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000095e0: 2020 2020 2020 2020 2028 622e 7374 6172           (b.star
+000095f0: 7420 213d 2073 7461 7274 206f 7220 622e  t != start or b.
+00009600: 6c65 6674 5f6f 7065 6e29 290a 2020 2020  left_open)).    
+00009610: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009620: 7269 6768 745f 6f70 656e 203d 2028 2873  right_open = ((s
+00009630: 656c 662e 7374 6f70 2021 3d20 7374 6f70  elf.stop != stop
+00009640: 206f 7220 7365 6c66 2e72 6967 6874 5f6f   or self.right_o
+00009650: 7065 6e29 2061 6e64 0a20 2020 2020 2020  pen) and.       
+00009660: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009670: 2020 2020 2020 2020 2020 2028 622e 7374             (b.st
+00009680: 6f70 2021 3d20 7374 6f70 206f 7220 622e  op != stop or b.
+00009690: 7269 6768 745f 6f70 656e 2929 0a20 2020  right_open)).   
+000096a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000096b0: 2072 6574 7572 6e20 7365 6c66 2e66 756e   return self.fun
+000096c0: 6328 7374 6172 742c 2073 746f 702c 206c  c(start, stop, l
+000096d0: 6566 745f 6f70 656e 3d6c 6566 745f 6f70  eft_open=left_op
+000096e0: 656e 2c20 7269 6768 745f 6f70 656e 3d72  en, right_open=r
+000096f0: 6967 6874 5f6f 7065 6e29 0a20 2020 2020  ight_open).     
+00009700: 2020 2020 2020 2065 6c69 6620 6e6f 7420         elif not 
+00009710: 622e 6973 5f69 6e74 6567 6572 3a0a 2020  b.is_integer:.  
+00009720: 2020 2020 2020 2020 2020 2020 2020 7265                re
+00009730: 7475 726e 2073 656c 662e 5f75 6e69 6f6e  turn self._union
+00009740: 5f73 6574 7328 6229 0a20 2020 2020 2020  _sets(b).       
+00009750: 2069 6620 622e 6973 5f55 6e69 7665 7273   if b.is_Univers
+00009760: 616c 5365 743a 0a20 2020 2020 2020 2020  alSet:.         
+00009770: 2020 2072 6574 7572 6e20 620a 2020 2020     return b.    
+00009780: 2020 2020 6966 2062 2e69 735f 436f 6d70      if b.is_Comp
+00009790: 6c65 6d65 6e74 3a0a 2020 2020 2020 2020  lement:.        
+000097a0: 2020 2020 552c 2041 203d 2062 2e61 7267      U, A = b.arg
+000097b0: 7320 2020 2020 2020 2020 2020 2020 0a20  s             . 
+000097c0: 2020 2020 2020 2020 2020 2069 6620 2855             if (U
+000097d0: 2e69 735f 496e 7465 7276 616c 206f 7220  .is_Interval or 
+000097e0: 552e 6973 5f52 616e 6765 2920 616e 6420  U.is_Range) and 
+000097f0: 6e6f 7420 4120 2620 7365 6c66 3a0a 2020  not A & self:.  
+00009800: 2020 2020 2020 2020 2020 2020 2020 636f                co
+00009810: 6d62 696e 6564 203d 2073 656c 6620 7c20  mbined = self | 
+00009820: 550a 2020 2020 2020 2020 2020 2020 2020  U.              
+00009830: 2020 6966 2063 6f6d 6269 6e65 642e 6973    if combined.is
+00009840: 5f49 6e74 6572 7661 6c20 6f72 2063 6f6d  _Interval or com
+00009850: 6269 6e65 642e 6973 5f52 616e 6765 3a0a  bined.is_Range:.
+00009860: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009870: 2020 2020 7265 7475 726e 2063 6f6d 6269      return combi
+00009880: 6e65 6420 2f2f 2041 200a 0a20 2020 2020  ned // A ..     
+00009890: 2020 2023 2049 6620 4920 6861 7665 206f     # If I have o
+000098a0: 7065 6e20 656e 6420 706f 696e 7473 2061  pen end points a
+000098b0: 6e64 2074 6865 7365 2065 6e64 706f 696e  nd these endpoin
+000098c0: 7473 2061 7265 2063 6f6e 7461 696e 6564  ts are contained
+000098d0: 2069 6e20 620a 2020 2020 2020 2020 2320   in b.        # 
+000098e0: 4275 7420 6f6e 6c79 2069 6e20 6361 7365  But only in case
+000098f0: 2c20 7768 656e 2065 6e64 706f 696e 7473  , when endpoints
+00009900: 2061 7265 2066 696e 6974 652e 2042 6563   are finite. Bec
+00009910: 6175 7365 0a20 2020 2020 2020 2023 2069  ause.        # i
+00009920: 6e74 6572 7661 6c20 646f 6573 206e 6f74  nterval does not
+00009930: 2063 6f6e 7461 696e 206f 6f20 6f72 202d   contain oo or -
+00009940: 6f6f 2e0a 2020 2020 2020 2020 6f70 656e  oo..        open
+00009950: 5f6c 6566 745f 696e 5f62 5f61 6e64 5f66  _left_in_b_and_f
+00009960: 696e 6974 6520 3d20 2873 656c 662e 6c65  inite = (self.le
+00009970: 6674 5f6f 7065 6e20 616e 640a 2020 2020  ft_open and.    
+00009980: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009990: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000099a0: 2020 2020 2073 796d 7069 6679 2862 2e63       sympify(b.c
+000099b0: 6f6e 7461 696e 7328 7365 6c66 2e73 7461  ontains(self.sta
+000099c0: 7274 2929 2069 7320 532e 7472 7565 2061  rt)) is S.true a
+000099d0: 6e64 0a20 2020 2020 2020 2020 2020 2020  nd.             
+000099e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000099f0: 2020 2020 2020 2020 2020 2020 7365 6c66              self
+00009a00: 2e73 7461 7274 2e69 735f 6669 6e69 7465  .start.is_finite
+00009a10: 290a 2020 2020 2020 2020 6f70 656e 5f72  ).        open_r
+00009a20: 6967 6874 5f69 6e5f 625f 616e 645f 6669  ight_in_b_and_fi
+00009a30: 6e69 7465 203d 2028 7365 6c66 2e72 6967  nite = (self.rig
+00009a40: 6874 5f6f 7065 6e20 616e 640a 2020 2020  ht_open and.    
+00009a50: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009a60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009a70: 2020 2020 2020 7379 6d70 6966 7928 622e        sympify(b.
+00009a80: 636f 6e74 6169 6e73 2873 656c 662e 7374  contains(self.st
+00009a90: 6f70 2929 2069 7320 532e 7472 7565 2061  op)) is S.true a
+00009aa0: 6e64 0a20 2020 2020 2020 2020 2020 2020  nd.             
+00009ab0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009ac0: 2020 2020 2020 2020 2020 2020 2073 656c               sel
+00009ad0: 662e 7374 6f70 2e69 735f 6669 6e69 7465  f.stop.is_finite
+00009ae0: 290a 2020 2020 2020 2020 6966 206f 7065  ).        if ope
+00009af0: 6e5f 6c65 6674 5f69 6e5f 625f 616e 645f  n_left_in_b_and_
+00009b00: 6669 6e69 7465 206f 7220 6f70 656e 5f72  finite or open_r
+00009b10: 6967 6874 5f69 6e5f 625f 616e 645f 6669  ight_in_b_and_fi
+00009b20: 6e69 7465 3a0a 2020 2020 2020 2020 2020  nite:.          
+00009b30: 2020 2320 4669 6c6c 2069 6e20 6d79 2065    # Fill in my e
+00009b40: 6e64 2070 6f69 6e74 7320 616e 6420 7265  nd points and re
+00009b50: 7475 726e 0a20 2020 2020 2020 2020 2020  turn.           
+00009b60: 206c 6566 745f 6f70 656e 203d 2073 656c   left_open = sel
+00009b70: 662e 6c65 6674 5f6f 7065 6e20 616e 6420  f.left_open and 
+00009b80: 7365 6c66 2e73 7461 7274 206e 6f74 2069  self.start not i
+00009b90: 6e20 620a 2020 2020 2020 2020 2020 2020  n b.            
+00009ba0: 7269 6768 745f 6f70 656e 203d 2073 656c  right_open = sel
+00009bb0: 662e 7269 6768 745f 6f70 656e 2061 6e64  f.right_open and
+00009bc0: 2073 656c 662e 7374 6f70 206e 6f74 2069   self.stop not i
+00009bd0: 6e20 6220 2020 2020 2020 2020 2020 200a  n b            .
+00009be0: 2020 2020 2020 2020 2020 2020 6e65 775f              new_
+00009bf0: 6120 3d20 7365 6c66 2e63 6f70 7928 6c65  a = self.copy(le
+00009c00: 6674 5f6f 7065 6e3d 6c65 6674 5f6f 7065  ft_open=left_ope
+00009c10: 6e2c 2072 6967 6874 5f6f 7065 6e3d 7269  n, right_open=ri
+00009c20: 6768 745f 6f70 656e 290a 2020 2020 2020  ght_open).      
+00009c30: 2020 2020 2020 7265 7475 726e 2073 6574        return set
+00009c40: 2828 6e65 775f 612c 2062 2929 0a20 2020  ((new_a, b)).   
+00009c50: 2020 2020 2069 6620 7365 6c66 2e69 735f       if self.is_
+00009c60: 696e 7465 6765 723a 0a20 2020 2020 2020  integer:.       
+00009c70: 2020 2020 2064 7261 7065 6175 203d 2046       drapeau = F
+00009c80: 616c 7365 0a20 2020 2020 2020 2020 2020  alse.           
+00009c90: 2073 746f 7020 3d20 7365 6c66 2e73 746f   stop = self.sto
+00009ca0: 700a 2020 2020 2020 2020 2020 2020 7269  p.            ri
+00009cb0: 6768 745f 6f70 656e 203d 2073 656c 662e  ght_open = self.
+00009cc0: 7269 6768 745f 6f70 656e 0a20 2020 2020  right_open.     
+00009cd0: 2020 2020 2020 2069 6620 7269 6768 745f         if right_
+00009ce0: 6f70 656e 3a0a 2020 2020 2020 2020 2020  open:.          
+00009cf0: 2020 2020 2020 6966 2073 746f 7020 696e        if stop in
+00009d00: 2062 3a0a 2020 2020 2020 2020 2020 2020   b:.            
+00009d10: 2020 2020 2020 2020 6472 6170 6561 7520          drapeau 
+00009d20: 3d20 5472 7565 0a20 2020 2020 2020 2020  = True.         
+00009d30: 2020 2020 2020 2020 2020 2072 6967 6874             right
+00009d40: 5f6f 7065 6e20 3d20 4661 6c73 650a 2020  _open = False.  
+00009d50: 2020 2020 2020 2020 2020 656c 7365 3a20            else: 
+00009d60: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00009d70: 2069 6620 7374 6f70 202b 2031 2069 6e20   if stop + 1 in 
+00009d80: 623a 0a20 2020 2020 2020 2020 2020 2020  b:.             
+00009d90: 2020 2020 2020 2064 7261 7065 6175 203d         drapeau =
+00009da0: 2054 7275 650a 2020 2020 2020 2020 2020   True.          
+00009db0: 2020 2020 2020 2020 2020 7374 6f70 202b            stop +
+00009dc0: 3d20 3120 2020 2020 2020 2020 2020 2020  = 1             
+00009dd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009de0: 2020 2020 2020 0a0a 2020 2020 2020 2020        ..        
+00009df0: 2020 2020 7374 6172 7420 3d20 7365 6c66      start = self
+00009e00: 2e73 7461 7274 0a20 2020 2020 2020 2020  .start.         
+00009e10: 2020 206c 6566 745f 6f70 656e 203d 2073     left_open = s
+00009e20: 656c 662e 6c65 6674 5f6f 7065 6e0a 2020  elf.left_open.  
+00009e30: 2020 2020 2020 2020 2020 6966 206c 6566            if lef
+00009e40: 745f 6f70 656e 3a0a 2020 2020 2020 2020  t_open:.        
+00009e50: 2020 2020 2020 2020 6966 2073 7461 7274          if start
+00009e60: 2069 6e20 623a 0a20 2020 2020 2020 2020   in b:.         
+00009e70: 2020 2020 2020 2020 2020 2064 7261 7065             drape
+00009e80: 6175 203d 2054 7275 650a 2020 2020 2020  au = True.      
+00009e90: 2020 2020 2020 2020 2020 2020 2020 6c65                le
+00009ea0: 6674 5f6f 7065 6e20 3d20 4661 6c73 650a  ft_open = False.
+00009eb0: 2020 2020 2020 2020 2020 2020 656c 7365              else
+00009ec0: 3a20 0a20 2020 2020 2020 2020 2020 2020  : .             
+00009ed0: 2020 2069 6620 7374 6172 7420 2d20 3120     if start - 1 
+00009ee0: 696e 2062 3a0a 2020 2020 2020 2020 2020  in b:.          
+00009ef0: 2020 2020 2020 2020 2020 6472 6170 6561            drapea
+00009f00: 7520 3d20 5472 7565 0a20 2020 2020 2020  u = True.       
+00009f10: 2020 2020 2020 2020 2020 2020 2073 7461               sta
+00009f20: 7274 202d 3d20 3120 2020 2020 2020 2020  rt -= 1         
+00009f30: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009f40: 2020 2020 2020 2020 2020 200a 0a20 2020             ..   
+00009f50: 2020 2020 2020 2020 2069 6620 6472 6170           if drap
+00009f60: 6561 753a 0a20 2020 2020 2020 2020 2020  eau:.           
+00009f70: 2020 2020 206e 6577 5f61 203d 2073 656c       new_a = sel
+00009f80: 662e 6675 6e63 2873 7461 7274 2c20 7374  f.func(start, st
+00009f90: 6f70 2c20 6c65 6674 5f6f 7065 6e3d 6c65  op, left_open=le
+00009fa0: 6674 5f6f 7065 6e2c 2072 6967 6874 5f6f  ft_open, right_o
+00009fb0: 7065 6e3d 7269 6768 745f 6f70 656e 2c20  pen=right_open, 
+00009fc0: 696e 7465 6765 723d 5472 7565 290a 2020  integer=True).  
+00009fd0: 2020 2020 2020 2020 2020 2020 2020 7265                re
+00009fe0: 7475 726e 2073 6574 2828 6e65 775f 612c  turn set((new_a,
+00009ff0: 2062 2929 0a20 2020 2020 2020 2069 6620   b)).        if 
+0000a000: 7365 6c66 2e69 735f 556e 6976 6572 7361  self.is_Universa
+0000a010: 6c53 6574 3a0a 2020 2020 2020 2020 2020  lSet:.          
+0000a020: 2020 7265 7475 726e 2073 656c 660a 0a20    return self.. 
+0000a030: 2020 2064 6566 205f 5f6e 6577 5f5f 2863     def __new__(c
+0000a040: 6c73 2c20 7374 6172 743d 4e6f 6e65 2c20  ls, start=None, 
+0000a050: 7374 6f70 3d4e 6f6e 652c 202a 2a6b 7761  stop=None, **kwa
+0000a060: 7267 7329 3a0a 2020 2020 2020 2020 6966  rgs):.        if
+0000a070: 2073 7461 7274 2069 7320 4e6f 6e65 206f   start is None o
+0000a080: 7220 7374 6f70 2069 7320 4e6f 6e65 3a0a  r stop is None:.
+0000a090: 2020 2020 2020 2020 2020 2020 6966 206b              if k
+0000a0a0: 7761 7267 732e 6765 7428 2770 6f73 6974  wargs.get('posit
+0000a0b0: 6976 6527 293a 0a20 2020 2020 2020 2020  ive'):.         
+0000a0c0: 2020 2020 2020 2073 746f 7020 3d20 532e         stop = S.
+0000a0d0: 496e 6669 6e69 7479 0a20 2020 2020 2020  Infinity.       
+0000a0e0: 2020 2020 2020 2020 2073 7461 7274 203d           start =
+0000a0f0: 2053 2e5a 6572 6f20 2020 0a20 2020 2020   S.Zero   .     
+0000a100: 2020 2020 2020 2020 2020 206b 7761 7267             kwarg
+0000a110: 735b 276c 6566 745f 6f70 656e 275d 203d  s['left_open'] =
+0000a120: 2054 7275 6520 2020 2020 2020 2020 2020   True           
+0000a130: 200a 2020 2020 2020 2020 2020 2020 656c   .            el
+0000a140: 6966 206b 7761 7267 732e 6765 7428 276e  if kwargs.get('n
+0000a150: 6f6e 6e65 6761 7469 7665 2729 3a0a 2020  onnegative'):.  
+0000a160: 2020 2020 2020 2020 2020 2020 2020 7374                st
+0000a170: 6172 7420 3d20 532e 5a65 726f 0a20 2020  art = S.Zero.   
+0000a180: 2020 2020 2020 2020 2020 2020 2073 746f               sto
+0000a190: 7020 3d20 532e 496e 6669 6e69 7479 0a20  p = S.Infinity. 
+0000a1a0: 2020 2020 2020 2020 2020 2065 6c69 6620             elif 
+0000a1b0: 6b77 6172 6773 2e67 6574 2827 6e65 6761  kwargs.get('nega
+0000a1c0: 7469 7665 2729 3a0a 2020 2020 2020 2020  tive'):.        
+0000a1d0: 2020 2020 2020 2020 7374 6172 7420 3d20          start = 
+0000a1e0: 532e 4e65 6761 7469 7665 496e 6669 6e69  S.NegativeInfini
+0000a1f0: 7479 0a20 2020 2020 2020 2020 2020 2020  ty.             
+0000a200: 2020 2073 746f 7020 3d20 532e 5a65 726f     stop = S.Zero
+0000a210: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000a220: 206b 7761 7267 735b 2772 6967 6874 5f6f   kwargs['right_o
+0000a230: 7065 6e27 5d20 3d20 5472 7565 2020 2020  pen'] = True    
+0000a240: 2020 2020 2020 0a20 2020 2020 2020 2020        .         
+0000a250: 2020 2065 6c69 6620 6b77 6172 6773 2e67     elif kwargs.g
+0000a260: 6574 2827 6e6f 6e70 6f73 6974 6976 6527  et('nonpositive'
+0000a270: 293a 0a20 2020 2020 2020 2020 2020 2020  ):.             
+0000a280: 2020 2073 7461 7274 203d 2053 2e4e 6567     start = S.Neg
+0000a290: 6174 6976 6549 6e66 696e 6974 790a 2020  ativeInfinity.  
+0000a2a0: 2020 2020 2020 2020 2020 2020 2020 7374                st
+0000a2b0: 6f70 203d 2053 2e5a 6572 6f0a 2020 2020  op = S.Zero.    
+0000a2c0: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
+0000a2d0: 2020 2020 2020 2020 2020 2020 2020 7374                st
+0000a2e0: 6172 7420 3d20 532e 4e65 6761 7469 7665  art = S.Negative
+0000a2f0: 496e 6669 6e69 7479 0a20 2020 2020 2020  Infinity.       
+0000a300: 2020 2020 2020 2020 2073 746f 7020 3d20           stop = 
+0000a310: 532e 496e 6669 6e69 7479 0a20 2020 2020  S.Infinity.     
+0000a320: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
+0000a330: 2020 2020 2073 7461 7274 203d 205f 7379       start = _sy
+0000a340: 6d70 6966 7928 7374 6172 7429 0a20 2020  mpify(start).   
+0000a350: 2020 2020 2020 2020 2073 746f 7020 3d20           stop = 
+0000a360: 5f73 796d 7069 6679 2873 746f 7029 0a20  _sympify(stop). 
+0000a370: 2020 2020 2020 200a 2020 2020 2020 2020         .        
+0000a380: 6966 2027 6c65 6674 5f6f 7065 6e27 2069  if 'left_open' i
+0000a390: 6e20 6b77 6172 6773 3a0a 2020 2020 2020  n kwargs:.      
+0000a3a0: 2020 2020 2020 6c65 6674 5f6f 7065 6e20        left_open 
+0000a3b0: 3d20 6b77 6172 6773 5b27 6c65 6674 5f6f  = kwargs['left_o
+0000a3c0: 7065 6e27 5d0a 2020 2020 2020 2020 656c  pen'].        el
+0000a3d0: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
+0000a3e0: 2320 6279 2064 6566 6175 6c74 2c20 696e  # by default, in
+0000a3f0: 6669 6e69 7465 2069 6e74 6572 7661 6c20  finite interval 
+0000a400: 7374 6172 7420 706f 696e 7473 2061 7265  start points are
+0000a410: 206f 7065 6e2e 0a20 2020 2020 2020 2020   open..         
+0000a420: 2020 2069 6620 7374 6172 7420 3d3d 2053     if start == S
+0000a430: 2e4e 6567 6174 6976 6549 6e66 696e 6974  .NegativeInfinit
+0000a440: 793a 0a20 2020 2020 2020 2020 2020 2020  y:.             
+0000a450: 2020 206c 6566 745f 6f70 656e 203d 2054     left_open = T
+0000a460: 7275 650a 2020 2020 2020 2020 2020 2020  rue.            
+0000a470: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
+0000a480: 2020 2020 2020 6c65 6674 5f6f 7065 6e20        left_open 
+0000a490: 3d20 4661 6c73 650a 2020 2020 2020 2020  = False.        
+0000a4a0: 2020 2020 0a20 2020 2020 2020 2069 6620      .        if 
+0000a4b0: 2772 6967 6874 5f6f 7065 6e27 2069 6e20  'right_open' in 
+0000a4c0: 6b77 6172 6773 3a0a 2020 2020 2020 2020  kwargs:.        
+0000a4d0: 2020 2020 7269 6768 745f 6f70 656e 203d      right_open =
+0000a4e0: 206b 7761 7267 735b 2772 6967 6874 5f6f   kwargs['right_o
+0000a4f0: 7065 6e27 5d0a 2020 2020 2020 2020 656c  pen'].        el
+0000a500: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
+0000a510: 2320 6279 2064 6566 6175 6c74 2c20 696e  # by default, in
+0000a520: 6669 6e69 7465 2069 6e74 6572 7661 6c20  finite interval 
+0000a530: 7374 6f70 2070 6f69 6e74 7320 6172 6520  stop points are 
+0000a540: 6f70 656e 2e0a 2020 2020 2020 2020 2020  open..          
+0000a550: 2020 6966 2073 746f 7020 3d3d 2053 2e49    if stop == S.I
+0000a560: 6e66 696e 6974 793a 0a20 2020 2020 2020  nfinity:.       
+0000a570: 2020 2020 2020 2020 2072 6967 6874 5f6f           right_o
+0000a580: 7065 6e20 3d20 5472 7565 0a20 2020 2020  pen = True.     
+0000a590: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
+0000a5a0: 2020 2020 2020 2020 2020 2020 2072 6967               rig
+0000a5b0: 6874 5f6f 7065 6e20 3d20 4661 6c73 650a  ht_open = False.
+0000a5c0: 2020 2020 2020 2020 2020 2020 0a20 2020              .   
+0000a5d0: 2020 2020 2023 2065 7661 6c75 6174 6520       # evaluate 
+0000a5e0: 6966 2070 6f73 7369 626c 650a 2020 2020  if possible.    
+0000a5f0: 2020 2020 6966 2072 6967 6874 5f6f 7065      if right_ope
+0000a600: 6e20 616e 6420 7374 6f70 203c 3d20 7374  n and stop <= st
+0000a610: 6172 7420 6f72 206e 6f74 2072 6967 6874  art or not right
+0000a620: 5f6f 7065 6e20 616e 6420 7374 6f70 203c  _open and stop <
+0000a630: 2073 7461 7274 3a0a 2020 2020 2020 2020   start:.        
+0000a640: 2020 2020 7265 7475 726e 2073 7461 7274      return start
+0000a650: 2e65 6d70 7479 5365 740a 0a20 2020 2020  .emptySet..     
+0000a660: 2020 2069 6620 7374 6f70 203d 3d20 7374     if stop == st
+0000a670: 6172 743a 0a20 2020 2020 2020 2020 2020  art:.           
+0000a680: 2069 6620 6c65 6674 5f6f 7065 6e20 6f72   if left_open or
+0000a690: 2072 6967 6874 5f6f 7065 6e3a 0a20 2020   right_open:.   
+0000a6a0: 2020 2020 2020 2020 2020 2020 2072 6574               ret
+0000a6b0: 7572 6e20 7374 6172 742e 656d 7074 7953  urn start.emptyS
+0000a6c0: 6574 0a20 2020 2020 2020 2020 2020 2065  et.            e
+0000a6d0: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
+0000a6e0: 2020 2020 2072 6574 7572 6e20 4669 6e69       return Fini
+0000a6f0: 7465 5365 7428 7374 6f70 290a 0a20 2020  teSet(stop)..   
+0000a700: 2020 2020 2069 6e66 696e 6974 6573 696d       infinitesim
+0000a710: 616c 203d 2073 7461 7274 2e69 735f 696e  al = start.is_in
+0000a720: 6669 6e69 7465 7369 6d61 6c0a 2020 2020  finitesimal.    
+0000a730: 2020 2020 6966 2069 6e66 696e 6974 6573      if infinites
+0000a740: 696d 616c 2069 7320 5472 7565 3a0a 2020  imal is True:.  
+0000a750: 2020 2020 2020 2020 2020 7374 6172 7420            start 
+0000a760: 3d20 7374 6172 742e 636c 6561 725f 696e  = start.clear_in
+0000a770: 6669 6e69 7465 7369 6d61 6c28 295b 305d  finitesimal()[0]
+0000a780: 0a20 2020 2020 2020 2020 2020 206c 6566  .            lef
+0000a790: 745f 6f70 656e 203d 2054 7275 650a 0a20  t_open = True.. 
+0000a7a0: 2020 2020 2020 2069 6e66 696e 6974 6573         infinites
+0000a7b0: 696d 616c 203d 2073 746f 702e 6973 5f69  imal = stop.is_i
+0000a7c0: 6e66 696e 6974 6573 696d 616c 0a20 2020  nfinitesimal.   
+0000a7d0: 2020 2020 2069 6620 696e 6669 6e69 7465       if infinite
+0000a7e0: 7369 6d61 6c20 6973 2046 616c 7365 3a0a  simal is False:.
+0000a7f0: 2020 2020 2020 2020 2020 2020 7374 6f70              stop
+0000a800: 203d 2073 746f 702e 636c 6561 725f 696e   = stop.clear_in
+0000a810: 6669 6e69 7465 7369 6d61 6c28 295b 305d  finitesimal()[0]
+0000a820: 0a20 2020 2020 2020 2020 2020 2072 6967  .            rig
+0000a830: 6874 5f6f 7065 6e20 3d20 5472 7565 0a0a  ht_open = True..
+0000a840: 2020 2020 2020 2020 7365 6c66 203d 2042          self = B
+0000a850: 6173 6963 2e5f 5f6e 6577 5f5f 2863 6c73  asic.__new__(cls
+0000a860: 2c20 7374 6172 742c 2073 746f 7029 0a20  , start, stop). 
+0000a870: 2020 2020 2020 2073 656c 662e 6c65 6674         self.left
+0000a880: 5f6f 7065 6e20 3d20 626f 6f6c 286c 6566  _open = bool(lef
+0000a890: 745f 6f70 656e 290a 2020 2020 2020 2020  t_open).        
+0000a8a0: 7365 6c66 2e72 6967 6874 5f6f 7065 6e20  self.right_open 
+0000a8b0: 3d20 626f 6f6c 2872 6967 6874 5f6f 7065  = bool(right_ope
+0000a8c0: 6e29 0a20 2020 2020 2020 2072 6574 7572  n).        retur
+0000a8d0: 6e20 7365 6c66 2020 2020 2020 2020 0a0a  n self        ..
+0000a8e0: 2020 2020 6465 6620 656c 656d 656e 745f      def element_
+0000a8f0: 7379 6d62 6f6c 2873 656c 662c 2065 7863  symbol(self, exc
+0000a900: 6c75 6465 733d 7365 7428 2929 3a0a 2020  ludes=set()):.  
+0000a910: 2020 2020 2020 7265 7475 726e 2073 656c        return sel
+0000a920: 662e 6765 6e65 7261 7465 5f76 6172 2865  f.generate_var(e
+0000a930: 7863 6c75 6465 732c 202a 2a73 656c 662e  xcludes, **self.
+0000a940: 6574 7970 652e 6469 6374 290a 0a20 2020  etype.dict)..   
+0000a950: 2040 7072 6f70 6572 7479 0a20 2020 2064   @property.    d
+0000a960: 6566 2073 697a 6528 7365 6c66 293a 0a20  ef size(self):. 
+0000a970: 2020 2020 2020 2069 6620 7365 6c66 2e69         if self.i
+0000a980: 735f 696e 7465 6765 723a 0a20 2020 2020  s_integer:.     
+0000a990: 2020 2020 2020 2069 6620 7365 6c66 2e6c         if self.l
+0000a9a0: 6566 745f 6f70 656e 3a0a 2020 2020 2020  eft_open:.      
+0000a9b0: 2020 2020 2020 2020 2020 7374 6172 7420            start 
+0000a9c0: 3d20 7365 6c66 2e73 7461 7274 202b 2031  = self.start + 1
+0000a9d0: 0a20 2020 2020 2020 2020 2020 2065 6c73  .            els
+0000a9e0: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
+0000a9f0: 2020 2073 7461 7274 203d 2073 656c 662e     start = self.
+0000aa00: 7374 6172 740a 2020 2020 2020 2020 2020  start.          
+0000aa10: 2020 6966 2073 656c 662e 7269 6768 745f    if self.right_
+0000aa20: 6f70 656e 3a0a 2020 2020 2020 2020 2020  open:.          
+0000aa30: 2020 2020 2020 7374 6f70 203d 2073 656c        stop = sel
+0000aa40: 662e 7374 6f70 0a20 2020 2020 2020 2020  f.stop.         
+0000aa50: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
+0000aa60: 2020 2020 2020 2020 2073 746f 7020 3d20           stop = 
+0000aa70: 7365 6c66 2e73 746f 7020 2b20 310a 2020  self.stop + 1.  
+0000aa80: 2020 2020 2020 2020 2020 7265 7475 726e            return
+0000aa90: 2073 746f 7020 2d20 7374 6172 740a 2020   stop - start.  
+0000aaa0: 2020 2020 2020 656c 7365 3a0a 2020 2020        else:.    
+0000aab0: 2020 2020 2020 2020 7265 7475 726e 2073          return s
+0000aac0: 656c 662e 7374 6f70 202d 2073 656c 662e  elf.stop - self.
+0000aad0: 7374 6172 740a 0a20 2020 2064 6566 205f  start..    def _
+0000aae0: 6576 616c 5f43 6172 6428 7365 6c66 293a  eval_Card(self):
+0000aaf0: 0a20 2020 2020 2020 202e 2e2e 0a0a 2020  .        .....  
+0000ab00: 2020 4070 726f 7065 7274 790a 2020 2020    @property.    
+0000ab10: 6465 6620 7374 6172 7428 7365 6c66 293a  def start(self):
+0000ab20: 0a20 2020 2020 2020 2022 2222 0a20 2020  .        """.   
+0000ab30: 2020 2020 2054 6865 206c 6566 7420 656e       The left en
+0000ab40: 6420 706f 696e 7420 6f66 2027 7365 6c66  d point of 'self
+0000ab50: 272e 0a0a 2020 2020 2020 2020 5468 6973  '...        This
+0000ab60: 2070 726f 7065 7274 7920 7461 6b65 7320   property takes 
+0000ab70: 7468 6520 7361 6d65 2076 616c 7565 2061  the same value a
+0000ab80: 7320 7468 6520 2769 6e66 2720 7072 6f70  s the 'inf' prop
+0000ab90: 6572 7479 2e0a 0a20 2020 2020 2020 2045  erty...        E
+0000aba0: 7861 6d70 6c65 730a 2020 2020 2020 2020  xamples.        
+0000abb0: 3d3d 3d3d 3d3d 3d3d 0a0a 2020 2020 2020  ========..      
+0000abc0: 2020 3e3e 3e20 6672 6f6d 2073 796d 7079    >>> from sympy
+0000abd0: 2069 6d70 6f72 7420 496e 7465 7276 616c   import Interval
+0000abe0: 0a20 2020 2020 2020 203e 3e3e 2049 6e74  .        >>> Int
+0000abf0: 6572 7661 6c28 302c 2031 292e 7374 6172  erval(0, 1).star
+0000ac00: 740a 2020 2020 2020 2020 300a 0a20 2020  t.        0..   
+0000ac10: 2020 2020 2022 2222 0a20 2020 2020 2020       """.       
+0000ac20: 2072 6574 7572 6e20 7365 6c66 2e5f 6172   return self._ar
+0000ac30: 6773 5b30 5d0a 0a20 2020 205f 696e 6620  gs[0]..    _inf 
+0000ac40: 3d20 6c65 6674 203d 2073 7461 7274 0a0a  = left = start..
+0000ac50: 2020 2020 4063 6c61 7373 6d65 7468 6f64      @classmethod
+0000ac60: 0a20 2020 2064 6566 206f 7065 6e28 636c  .    def open(cl
+0000ac70: 732c 2061 2c20 6229 3a0a 2020 2020 2020  s, a, b):.      
+0000ac80: 2020 2222 2252 6574 7572 6e20 616e 2069    """Return an i
+0000ac90: 6e74 6572 7661 6c20 696e 636c 7564 696e  nterval includin
+0000aca0: 6720 6e65 6974 6865 7220 626f 756e 6461  g neither bounda
+0000acb0: 7279 2e22 2222 0a20 2020 2020 2020 2072  ry.""".        r
+0000acc0: 6574 7572 6e20 636c 7328 612c 2062 2c20  eturn cls(a, b, 
+0000acd0: 6c65 6674 5f6f 7065 6e3d 5472 7565 2c20  left_open=True, 
+0000ace0: 7269 6768 745f 6f70 656e 3d54 7275 6529  right_open=True)
+0000acf0: 0a0a 2020 2020 4063 6c61 7373 6d65 7468  ..    @classmeth
+0000ad00: 6f64 0a20 2020 2064 6566 204c 6f70 656e  od.    def Lopen
+0000ad10: 2863 6c73 2c20 612c 2062 293a 0a20 2020  (cls, a, b):.   
+0000ad20: 2020 2020 2022 2222 5265 7475 726e 2061       """Return a
+0000ad30: 6e20 696e 7465 7276 616c 206e 6f74 2069  n interval not i
+0000ad40: 6e63 6c75 6469 6e67 2074 6865 206c 6566  ncluding the lef
+0000ad50: 7420 626f 756e 6461 7279 2e22 2222 0a20  t boundary.""". 
+0000ad60: 2020 2020 2020 2072 6574 7572 6e20 636c         return cl
+0000ad70: 7328 612c 2062 2c20 6c65 6674 5f6f 7065  s(a, b, left_ope
+0000ad80: 6e3d 5472 7565 2c20 7269 6768 745f 6f70  n=True, right_op
+0000ad90: 656e 3d46 616c 7365 290a 0a20 2020 2040  en=False)..    @
+0000ada0: 636c 6173 736d 6574 686f 640a 2020 2020  classmethod.    
+0000adb0: 6465 6620 526f 7065 6e28 636c 732c 2061  def Ropen(cls, a
+0000adc0: 2c20 6229 3a0a 2020 2020 2020 2020 2222  , b):.        ""
+0000add0: 2252 6574 7572 6e20 616e 2069 6e74 6572  "Return an inter
+0000ade0: 7661 6c20 6e6f 7420 696e 636c 7564 696e  val not includin
+0000adf0: 6720 7468 6520 7269 6768 7420 626f 756e  g the right boun
+0000ae00: 6461 7279 2e22 2222 0a20 2020 2020 2020  dary.""".       
+0000ae10: 2072 6574 7572 6e20 636c 7328 612c 2062   return cls(a, b
+0000ae20: 2c20 6c65 6674 5f6f 7065 6e3d 4661 6c73  , left_open=Fals
+0000ae30: 652c 2072 6967 6874 5f6f 7065 6e3d 5472  e, right_open=Tr
+0000ae40: 7565 290a 0a20 2020 2040 7072 6f70 6572  ue)..    @proper
+0000ae50: 7479 0a20 2020 2064 6566 2073 746f 7028  ty.    def stop(
+0000ae60: 7365 6c66 293a 0a20 2020 2020 2020 2022  self):.        "
+0000ae70: 2222 0a20 2020 2020 2020 2054 6865 2072  "".        The r
+0000ae80: 6967 6874 2065 6e64 2070 6f69 6e74 206f  ight end point o
+0000ae90: 6620 2773 656c 6627 2e0a 0a20 2020 2020  f 'self'...     
+0000aea0: 2020 2054 6869 7320 7072 6f70 6572 7479     This property
+0000aeb0: 2074 616b 6573 2074 6865 2073 616d 6520   takes the same 
+0000aec0: 7661 6c75 6520 6173 2074 6865 2027 7375  value as the 'su
+0000aed0: 7027 2070 726f 7065 7274 792e 0a0a 2020  p' property...  
+0000aee0: 2020 2020 2020 4578 616d 706c 6573 0a20        Examples. 
+0000aef0: 2020 2020 2020 203d 3d3d 3d3d 3d3d 3d0a         ========.
+0000af00: 0a20 2020 2020 2020 203e 3e3e 2066 726f  .        >>> fro
+0000af10: 6d20 7379 6d70 7920 696d 706f 7274 2049  m sympy import I
+0000af20: 6e74 6572 7661 6c0a 2020 2020 2020 2020  nterval.        
+0000af30: 3e3e 3e20 496e 7465 7276 616c 2830 2c20  >>> Interval(0, 
+0000af40: 3129 2e73 746f 700a 2020 2020 2020 2020  1).stop.        
+0000af50: 310a 0a20 2020 2020 2020 2022 2222 0a20  1..        """. 
+0000af60: 2020 2020 2020 2072 6574 7572 6e20 7365         return se
+0000af70: 6c66 2e5f 6172 6773 5b31 5d0a 0a20 2020  lf._args[1]..   
+0000af80: 205f 7375 7020 3d20 7269 6768 7420 3d20   _sup = right = 
+0000af90: 7374 6f70 0a0a 2320 2020 2020 7472 7969  stop..#     tryi
+0000afa0: 6e67 2074 6f20 6576 616c 7561 7465 206f  ng to evaluate o
+0000afb0: 7468 6572 202d 2073 656c 660a 2020 2020  ther - self.    
+0000afc0: 6465 6620 5f63 6f6d 706c 656d 656e 7428  def _complement(
+0000afd0: 7365 6c66 2c20 6f74 6865 7229 3a0a 2020  self, other):.  
+0000afe0: 2020 2020 2020 6966 206f 7468 6572 2e69        if other.i
+0000aff0: 735f 496e 7465 7276 616c 2061 6e64 206f  s_Interval and o
+0000b000: 7468 6572 2e73 7461 7274 2e69 735f 696e  ther.start.is_in
+0000b010: 6669 6e69 7465 2061 6e64 206f 7468 6572  finite and other
+0000b020: 2e73 746f 702e 6973 5f69 6e66 696e 6974  .stop.is_infinit
+0000b030: 653a 0a20 2020 2020 2020 2020 2020 2061  e:.            a
+0000b040: 203d 2049 6e74 6572 7661 6c28 532e 4e65   = Interval(S.Ne
+0000b050: 6761 7469 7665 496e 6669 6e69 7479 2c20  gativeInfinity, 
+0000b060: 7365 6c66 2e73 7461 7274 2c20 6c65 6674  self.start, left
+0000b070: 5f6f 7065 6e3d 6f74 6865 722e 6c65 6674  _open=other.left
+0000b080: 5f6f 7065 6e2c 2072 6967 6874 5f6f 7065  _open, right_ope
+0000b090: 6e3d 6e6f 7420 7365 6c66 2e6c 6566 745f  n=not self.left_
+0000b0a0: 6f70 656e 290a 2020 2020 2020 2020 2020  open).          
+0000b0b0: 2020 6220 3d20 496e 7465 7276 616c 2873    b = Interval(s
+0000b0c0: 656c 662e 7374 6f70 2c20 532e 496e 6669  elf.stop, S.Infi
+0000b0d0: 6e69 7479 2c20 6c65 6674 5f6f 7065 6e3d  nity, left_open=
+0000b0e0: 6e6f 7420 7365 6c66 2e72 6967 6874 5f6f  not self.right_o
+0000b0f0: 7065 6e2c 2072 6967 6874 5f6f 7065 6e3d  pen, right_open=
+0000b100: 6f74 6865 722e 7269 6768 745f 6f70 656e  other.right_open
+0000b110: 290a 2020 2020 2020 2020 2020 2020 7265  ).            re
+0000b120: 7475 726e 2061 207c 2062 0a20 2020 2020  turn a | b.     
+0000b130: 2020 200a 2020 2020 2020 2020 6672 6f6d     .        from
+0000b140: 2073 796d 7079 2e73 6574 7320 696d 706f   sympy.sets impo
+0000b150: 7274 2049 6e74 6567 6572 730a 2020 2020  rt Integers.    
+0000b160: 2020 2020 6966 206f 7468 6572 203d 3d20      if other == 
+0000b170: 496e 7465 6765 7273 3a0a 2020 2020 2020  Integers:.      
+0000b180: 2020 2020 2020 7374 6172 742c 2073 746f        start, sto
+0000b190: 7020 3d20 532e 4e65 6761 7469 7665 496e  p = S.NegativeIn
+0000b1a0: 6669 6e69 7479 2c20 7365 6c66 2e73 7461  finity, self.sta
+0000b1b0: 7274 0a20 2020 2020 2020 2020 2020 2069  rt.            i
+0000b1c0: 6620 7365 6c66 2e6c 6566 745f 6f70 656e  f self.left_open
+0000b1d0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+0000b1e0: 2020 7374 6f70 202b 3d20 310a 2020 2020    stop += 1.    
+0000b1f0: 2020 2020 2020 2020 6672 6f6d 2073 796d          from sym
+0000b200: 7079 2069 6d70 6f72 7420 5261 6e67 650a  py import Range.
+0000b210: 2020 2020 2020 2020 2020 2020 6120 3d20              a = 
+0000b220: 5261 6e67 6528 7374 6172 742c 2073 746f  Range(start, sto
+0000b230: 7029 0a20 2020 2020 2020 2020 2020 200a  p).            .
+0000b240: 2020 2020 2020 2020 2020 2020 7374 6172              star
+0000b250: 742c 2073 746f 7020 3d20 7365 6c66 2e73  t, stop = self.s
+0000b260: 746f 702c 2053 2e49 6e66 696e 6974 790a  top, S.Infinity.
+0000b270: 2020 2020 2020 2020 2020 2020 6966 206e              if n
+0000b280: 6f74 2073 656c 662e 7269 6768 745f 6f70  ot self.right_op
+0000b290: 656e 3a0a 2020 2020 2020 2020 2020 2020  en:.            
+0000b2a0: 2020 2020 7374 6172 7420 2b3d 2031 0a20      start += 1. 
+0000b2b0: 2020 2020 2020 2020 2020 2062 203d 2052             b = R
+0000b2c0: 616e 6765 2873 7461 7274 2c20 7374 6f70  ange(start, stop
+0000b2d0: 290a 2020 2020 2020 2020 2020 2020 7265  ).            re
+0000b2e0: 7475 726e 2061 207c 2062 0a0a 2020 2020  turn a | b..    
+0000b2f0: 2020 2020 6966 206f 7468 6572 2e69 735f      if other.is_
+0000b300: 4669 6e69 7465 5365 743a 0a20 2020 2020  FiniteSet:.     
+0000b310: 2020 2020 2020 206e 756d 7320 3d20 5b6d         nums = [m
+0000b320: 2066 6f72 206d 2069 6e20 6f74 6865 722e   for m in other.
+0000b330: 6172 6773 2069 6620 6d2e 6973 5f6e 756d  args if m.is_num
+0000b340: 6265 725d 0a20 2020 2020 2020 2020 2020  ber].           
+0000b350: 2069 6620 6e75 6d73 203d 3d20 5b5d 3a0a   if nums == []:.
+0000b360: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b370: 7265 7475 726e 0a0a 2020 2020 2020 2020  return..        
+0000b380: 7265 7475 726e 2053 6574 2e5f 636f 6d70  return Set._comp
+0000b390: 6c65 6d65 6e74 2873 656c 662c 206f 7468  lement(self, oth
+0000b3a0: 6572 290a 0a20 2020 2040 7072 6f70 6572  er)..    @proper
+0000b3b0: 7479 0a20 2020 2064 6566 205f 626f 756e  ty.    def _boun
+0000b3c0: 6461 7279 2873 656c 6629 3a0a 2020 2020  dary(self):.    
+0000b3d0: 2020 2020 6672 6f6d 2073 796d 7079 2069      from sympy i
+0000b3e0: 6d70 6f72 7420 4669 6e69 7465 5365 740a  mport FiniteSet.
+0000b3f0: 2020 2020 2020 2020 6669 6e69 7465 5f70          finite_p
+0000b400: 6f69 6e74 7320 3d20 5b70 2066 6f72 2070  oints = [p for p
+0000b410: 2069 6e20 2873 656c 662e 7374 6172 742c   in (self.start,
+0000b420: 2073 656c 662e 7374 6f70 2920 6966 2061   self.stop) if a
+0000b430: 6273 2870 2920 213d 2053 2e49 6e66 696e  bs(p) != S.Infin
+0000b440: 6974 795d 0a20 2020 2020 2020 2072 6574  ity].        ret
+0000b450: 7572 6e20 4669 6e69 7465 5365 7428 2a66  urn FiniteSet(*f
+0000b460: 696e 6974 655f 706f 696e 7473 290a 0a20  inite_points).. 
+0000b470: 2020 2064 6566 205f 636f 6e74 6169 6e73     def _contains
+0000b480: 2873 656c 662c 206f 7468 6572 293a 0a20  (self, other):. 
+0000b490: 2020 2020 2020 2069 6620 6e6f 7420 6973         if not is
+0000b4a0: 696e 7374 616e 6365 286f 7468 6572 2c20  instance(other, 
+0000b4b0: 4578 7072 2920 6f72 206f 7468 6572 2069  Expr) or other i
+0000b4c0: 7320 532e 4e61 4e20 6f72 206f 7468 6572  s S.NaN or other
+0000b4d0: 2069 7320 532e 436f 6d70 6c65 7849 6e66   is S.ComplexInf
+0000b4e0: 696e 6974 7920 6f72 206f 7468 6572 2e69  inity or other.i
+0000b4f0: 735f 6578 7465 6e64 6564 5f72 6561 6c20  s_extended_real 
+0000b500: 3d3d 2046 616c 7365 3a0a 2020 2020 2020  == False:.      
+0000b510: 2020 2020 2020 7265 7475 726e 2053 2e66        return S.f
+0000b520: 616c 7365 0a0a 2020 2020 2020 2020 6966  alse..        if
+0000b530: 206f 7468 6572 2e69 735f 496e 6669 6e69   other.is_Infini
+0000b540: 7479 3a0a 2020 2020 2020 2020 2020 2020  ty:.            
+0000b550: 6966 206e 6f74 2073 656c 662e 7374 6f70  if not self.stop
+0000b560: 2e69 735f 496e 6669 6e69 7479 206f 7220  .is_Infinity or 
+0000b570: 7365 6c66 2e72 6967 6874 5f6f 7065 6e3a  self.right_open:
+0000b580: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000b590: 2072 6574 7572 6e20 532e 6661 6c73 650a   return S.false.
+0000b5a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b5b0: 0a20 2020 2020 2020 2069 6620 6f74 6865  .        if othe
+0000b5c0: 722e 6973 5f4e 6567 6174 6976 6549 6e66  r.is_NegativeInf
+0000b5d0: 696e 6974 793a 0a20 2020 2020 2020 2020  inity:.         
+0000b5e0: 2020 2069 6620 6e6f 7420 7365 6c66 2e73     if not self.s
+0000b5f0: 7461 7274 2e69 735f 4e65 6761 7469 7665  tart.is_Negative
+0000b600: 496e 6669 6e69 7479 206f 7220 7365 6c66  Infinity or self
+0000b610: 2e6c 6566 745f 6f70 656e 3a0a 2020 2020  .left_open:.    
+0000b620: 2020 2020 2020 2020 2020 2020 7265 7475              retu
+0000b630: 726e 2053 2e66 616c 7365 0a20 2020 2020  rn S.false.     
+0000b640: 2020 2020 2020 200a 2020 2020 2020 2020         .        
+0000b650: 6966 2073 656c 662e 7374 6172 7420 6973  if self.start is
+0000b660: 2053 2e4e 6567 6174 6976 6549 6e66 696e   S.NegativeInfin
+0000b670: 6974 7920 616e 6420 7365 6c66 2e73 746f  ity and self.sto
+0000b680: 7020 6973 2053 2e49 6e66 696e 6974 793a  p is S.Infinity:
+0000b690: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
+0000b6a0: 7365 6c66 2e6c 6566 745f 6f70 656e 3a0a  self.left_open:.
+0000b6b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b6c0: 6966 2073 656c 662e 7269 6768 745f 6f70  if self.right_op
+0000b6d0: 656e 3a0a 2020 2020 2020 2020 2020 2020  en:.            
+0000b6e0: 2020 2020 2020 2020 2320 7365 6c66 203d          # self =
+0000b6f0: 2028 2d6f 6f2c 206f 6f29 0a20 2020 2020   (-oo, oo).     
+0000b700: 2020 2020 2020 2020 2020 2020 2020 2069                 i
+0000b710: 6620 6f74 6865 722e 6973 5f72 6561 6c3a  f other.is_real:
+0000b720: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000b730: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
+0000b740: 532e 7472 7565 0a20 2020 2020 2020 2020  S.true.         
+0000b750: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
+0000b760: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b770: 2023 2073 656c 6620 3d20 282d 6f6f 2c20   # self = (-oo, 
+0000b780: 6f6f 5d0a 2020 2020 2020 2020 2020 2020  oo].            
+0000b790: 2020 2020 2020 2020 6966 206f 7468 6572          if other
+0000b7a0: 2e69 735f 6e6f 6e70 6f73 6974 6976 6520  .is_nonpositive 
+0000b7b0: 6f72 206f 7468 6572 2e69 735f 6578 7465  or other.is_exte
+0000b7c0: 6e64 6564 5f70 6f73 6974 6976 653a 0a20  nded_positive:. 
+0000b7d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b7e0: 2020 2020 2020 2072 6574 7572 6e20 532e         return S.
+0000b7f0: 7472 7565 0a20 2020 2020 2020 2020 2020  true.           
+0000b800: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
+0000b810: 2020 2020 2020 2069 6620 7365 6c66 2e72         if self.r
+0000b820: 6967 6874 5f6f 7065 6e3a 0a20 2020 2020  ight_open:.     
+0000b830: 2020 2020 2020 2020 2020 2020 2020 2023                 #
+0000b840: 2073 656c 6620 3d20 5b2d 6f6f 2c20 6f6f   self = [-oo, oo
+0000b850: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
+0000b860: 2020 2020 2020 6966 206f 7468 6572 2e69        if other.i
+0000b870: 735f 6e6f 6e6e 6567 6174 6976 6520 6f72  s_nonnegative or
+0000b880: 206f 7468 6572 2e69 735f 6578 7465 6e64   other.is_extend
+0000b890: 6564 5f6e 6567 6174 6976 653a 0a20 2020  ed_negative:.   
+0000b8a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b8b0: 2020 2020 2072 6574 7572 6e20 532e 7472       return S.tr
+0000b8c0: 7565 0a20 2020 2020 2020 2020 2020 2020  ue.             
+0000b8d0: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
+0000b8e0: 2020 2020 2020 2020 2020 2020 2023 2073               # s
+0000b8f0: 656c 6620 3d20 5b2d 6f6f 2c20 6f6f 5d0a  elf = [-oo, oo].
+0000b900: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b910: 2020 2020 6966 206f 7468 6572 2e69 735f      if other.is_
+0000b920: 6578 7465 6e64 6564 5f72 6561 6c3a 0a20  extended_real:. 
+0000b930: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b940: 2020 2020 2020 2072 6574 7572 6e20 532e         return S.
+0000b950: 7472 7565 0a0a 2020 2020 2020 2020 6966  true..        if
+0000b960: 206f 7468 6572 2e69 735f 6578 7465 6e64   other.is_extend
+0000b970: 6564 5f72 6561 6c20 3d3d 2046 616c 7365  ed_real == False
+0000b980: 3a0a 2020 2020 2020 2020 2020 2020 7265  :.            re
+0000b990: 7475 726e 2053 2e66 616c 7365 0a20 2020  turn S.false.   
+0000b9a0: 2020 2020 200a 2020 2020 2020 2020 6966       .        if
+0000b9b0: 206f 7468 6572 2e69 735f 6578 7465 6e64   other.is_extend
+0000b9c0: 6564 5f72 6561 6c20 6973 204e 6f6e 653a  ed_real is None:
+0000b9d0: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
+0000b9e0: 7572 6e0a 2020 2020 2020 2020 0a20 2020  urn.        .   
+0000b9f0: 2020 2020 2069 6620 7365 6c66 2e6c 6566       if self.lef
+0000ba00: 745f 6f70 656e 3a0a 2020 2020 2020 2020  t_open:.        
+0000ba10: 2020 2020 6578 7072 203d 206f 7468 6572      expr = other
+0000ba20: 203e 2073 656c 662e 7374 6172 740a 2020   > self.start.  
+0000ba30: 2020 2020 2020 656c 7365 3a0a 2020 2020        else:.    
+0000ba40: 2020 2020 2020 2020 6578 7072 203d 206f          expr = o
+0000ba50: 7468 6572 203e 3d20 7365 6c66 2e73 7461  ther >= self.sta
+0000ba60: 7274 0a0a 2020 2020 2020 2020 6966 2073  rt..        if s
+0000ba70: 656c 662e 7269 6768 745f 6f70 656e 3a0a  elf.right_open:.
+0000ba80: 2020 2020 2020 2020 2020 2020 6578 7072              expr
+0000ba90: 203d 2041 6e64 2865 7870 722c 206f 7468   = And(expr, oth
+0000baa0: 6572 203c 2073 656c 662e 7374 6f70 290a  er < self.stop).
+0000bab0: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
+0000bac0: 2020 2020 2020 2020 2020 6578 7072 203d            expr =
+0000bad0: 2041 6e64 2865 7870 722c 206f 7468 6572   And(expr, other
+0000bae0: 203c 3d20 7365 6c66 2e73 746f 7029 0a0a   <= self.stop)..
+0000baf0: 2020 2020 2020 2020 7265 7475 726e 205f          return _
+0000bb00: 7379 6d70 6966 7928 6578 7072 290a 0a20  sympify(expr).. 
+0000bb10: 2020 2040 7072 6f70 6572 7479 0a20 2020     @property.   
+0000bb20: 2064 6566 205f 6d65 6173 7572 6528 7365   def _measure(se
+0000bb30: 6c66 293a 0a20 2020 2020 2020 2072 6574  lf):.        ret
+0000bb40: 7572 6e20 7365 6c66 2e73 746f 7020 2d20  urn self.stop - 
+0000bb50: 7365 6c66 2e73 7461 7274 0a0a 2020 2020  self.start..    
+0000bb60: 6465 6620 646f 6974 2873 656c 662c 2064  def doit(self, d
+0000bb70: 6565 703d 4661 6c73 652c 202a 2a5f 293a  eep=False, **_):
+0000bb80: 0a20 2020 2020 2020 2069 6620 6465 6570  .        if deep
+0000bb90: 3a0a 2020 2020 2020 2020 2020 2020 7265  :.            re
+0000bba0: 7475 726e 2073 656c 662e 636f 7079 2873  turn self.copy(s
+0000bbb0: 7461 7274 3d73 656c 662e 7374 6172 742e  tart=self.start.
+0000bbc0: 646f 6974 2829 2c20 7374 6f70 3d73 656c  doit(), stop=sel
+0000bbd0: 662e 7374 6f70 2e64 6f69 7428 2929 0a20  f.stop.doit()). 
+0000bbe0: 2020 2020 2020 2069 6620 7365 6c66 2e69         if self.i
+0000bbf0: 735f 696e 7465 6765 723a 0a20 2020 2020  s_integer:.     
+0000bc00: 2020 2020 2020 206d 203d 2073 656c 662e         m = self.
+0000bc10: 6d69 6e28 290a 2020 2020 2020 2020 2020  min().          
+0000bc20: 2020 6966 206d 2e69 735f 496e 7465 6765    if m.is_Intege
+0000bc30: 723a 0a20 2020 2020 2020 2020 2020 2020  r:.             
+0000bc40: 2020 204d 203d 2073 656c 662e 6d61 7828     M = self.max(
+0000bc50: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
+0000bc60: 2020 6966 204d 2e69 735f 496e 7465 6765    if M.is_Intege
+0000bc70: 723a 200a 2020 2020 2020 2020 2020 2020  r: .            
+0000bc80: 2020 2020 2020 2020 6672 6f6d 2073 796d          from sym
+0000bc90: 7079 2069 6d70 6f72 7420 4669 6e69 7465  py import Finite
+0000bca0: 5365 740a 2020 2020 2020 2020 2020 2020  Set.            
+0000bcb0: 2020 2020 2020 2020 7265 7475 726e 2046          return F
+0000bcc0: 696e 6974 6553 6574 282a 7261 6e67 6528  initeSet(*range(
+0000bcd0: 6d2c 204d 202b 2031 2929 0a20 2020 2020  m, M + 1)).     
+0000bce0: 2020 2072 6574 7572 6e20 7365 6c66 0a0a     return self..
+0000bcf0: 2020 2020 6465 6620 746f 5f6d 7069 2873      def to_mpi(s
+0000bd00: 656c 662c 2070 7265 633d 3533 293a 0a20  elf, prec=53):. 
+0000bd10: 2020 2020 2020 2072 6574 7572 6e20 6d70         return mp
+0000bd20: 6928 6d70 6628 7365 6c66 2e73 7461 7274  i(mpf(self.start
+0000bd30: 2e5f 6576 616c 5f65 7661 6c66 2870 7265  ._eval_evalf(pre
+0000bd40: 6329 292c 0a20 2020 2020 2020 2020 2020  c)),.           
+0000bd50: 206d 7066 2873 656c 662e 7374 6f70 2e5f   mpf(self.stop._
+0000bd60: 6576 616c 5f65 7661 6c66 2870 7265 6329  eval_evalf(prec)
+0000bd70: 2929 0a0a 2020 2020 6465 6620 5f65 7661  ))..    def _eva
+0000bd80: 6c5f 6576 616c 6628 7365 6c66 2c20 7072  l_evalf(self, pr
+0000bd90: 6563 293a 0a20 2020 2020 2020 2072 6574  ec):.        ret
+0000bda0: 7572 6e20 496e 7465 7276 616c 2873 656c  urn Interval(sel
+0000bdb0: 662e 6c65 6674 2e5f 6576 616c 5f65 7661  f.left._eval_eva
+0000bdc0: 6c66 2870 7265 6329 2c20 7365 6c66 2e72  lf(prec), self.r
+0000bdd0: 6967 6874 2e5f 6576 616c 5f65 7661 6c66  ight._eval_evalf
+0000bde0: 2870 7265 6329 2c0a 2020 2020 2020 2020  (prec),.        
+0000bdf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000be00: 6c65 6674 5f6f 7065 6e3d 7365 6c66 2e6c  left_open=self.l
+0000be10: 6566 745f 6f70 656e 2c20 7269 6768 745f  eft_open, right_
+0000be20: 6f70 656e 3d73 656c 662e 7269 6768 745f  open=self.right_
+0000be30: 6f70 656e 290a 0a20 2020 2064 6566 205f  open)..    def _
+0000be40: 6973 5f63 6f6d 7061 7261 626c 6528 7365  is_comparable(se
+0000be50: 6c66 2c20 6f74 6865 7229 3a0a 2020 2020  lf, other):.    
+0000be60: 2020 2020 6973 5f63 6f6d 7061 7261 626c      is_comparabl
+0000be70: 6520 3d20 7365 6c66 2e73 7461 7274 2e69  e = self.start.i
+0000be80: 735f 636f 6d70 6172 6162 6c65 0a20 2020  s_comparable.   
+0000be90: 2020 2020 2069 735f 636f 6d70 6172 6162       is_comparab
+0000bea0: 6c65 2026 3d20 7365 6c66 2e73 746f 702e  le &= self.stop.
+0000beb0: 6973 5f63 6f6d 7061 7261 626c 650a 2020  is_comparable.  
+0000bec0: 2020 2020 2020 6973 5f63 6f6d 7061 7261        is_compara
+0000bed0: 626c 6520 263d 206f 7468 6572 2e73 7461  ble &= other.sta
+0000bee0: 7274 2e69 735f 636f 6d70 6172 6162 6c65  rt.is_comparable
+0000bef0: 0a20 2020 2020 2020 2069 735f 636f 6d70  .        is_comp
+0000bf00: 6172 6162 6c65 2026 3d20 6f74 6865 722e  arable &= other.
+0000bf10: 7374 6f70 2e69 735f 636f 6d70 6172 6162  stop.is_comparab
+0000bf20: 6c65 0a0a 2020 2020 2020 2020 7265 7475  le..        retu
+0000bf30: 726e 2069 735f 636f 6d70 6172 6162 6c65  rn is_comparable
+0000bf40: 0a0a 2020 2020 4070 726f 7065 7274 790a  ..    @property.
+0000bf50: 2020 2020 6465 6620 6973 5f6c 6566 745f      def is_left_
+0000bf60: 756e 626f 756e 6465 6428 7365 6c66 293a  unbounded(self):
+0000bf70: 0a20 2020 2020 2020 2022 2222 5265 7475  .        """Retu
+0000bf80: 726e 2060 6054 7275 6560 6020 6966 2074  rn ``True`` if t
+0000bf90: 6865 206c 6566 7420 656e 6470 6f69 6e74  he left endpoint
+0000bfa0: 2069 7320 6e65 6761 7469 7665 2069 6e66   is negative inf
+0000bfb0: 696e 6974 792e 2022 2222 0a20 2020 2020  inity. """.     
+0000bfc0: 2020 2066 726f 6d20 7379 6d70 792e 636f     from sympy.co
+0000bfd0: 7265 2e6e 756d 6265 7273 2069 6d70 6f72  re.numbers impor
+0000bfe0: 7420 466c 6f61 740a 2020 2020 2020 2020  t Float.        
+0000bff0: 7265 7475 726e 2073 656c 662e 6c65 6674  return self.left
+0000c000: 2069 7320 532e 4e65 6761 7469 7665 496e   is S.NegativeIn
+0000c010: 6669 6e69 7479 206f 7220 7365 6c66 2e6c  finity or self.l
+0000c020: 6566 7420 3d3d 2046 6c6f 6174 2822 2d69  eft == Float("-i
+0000c030: 6e66 2229 0a0a 2020 2020 4070 726f 7065  nf")..    @prope
+0000c040: 7274 790a 2020 2020 6465 6620 6973 5f72  rty.    def is_r
+0000c050: 6967 6874 5f75 6e62 6f75 6e64 6564 2873  ight_unbounded(s
+0000c060: 656c 6629 3a0a 2020 2020 2020 2020 2222  elf):.        ""
+0000c070: 2252 6574 7572 6e20 6060 5472 7565 6060  "Return ``True``
+0000c080: 2069 6620 7468 6520 7269 6768 7420 656e   if the right en
+0000c090: 6470 6f69 6e74 2069 7320 706f 7369 7469  dpoint is positi
+0000c0a0: 7665 2069 6e66 696e 6974 792e 2022 2222  ve infinity. """
+0000c0b0: 0a20 2020 2020 2020 2066 726f 6d20 7379  .        from sy
+0000c0c0: 6d70 792e 636f 7265 2e6e 756d 6265 7273  mpy.core.numbers
+0000c0d0: 2069 6d70 6f72 7420 466c 6f61 740a 2020   import Float.  
+0000c0e0: 2020 2020 2020 7265 7475 726e 2073 656c        return sel
+0000c0f0: 662e 7269 6768 7420 6973 2053 2e49 6e66  f.right is S.Inf
+0000c100: 696e 6974 7920 6f72 2073 656c 662e 7269  inity or self.ri
+0000c110: 6768 7420 3d3d 2046 6c6f 6174 2822 2b69  ght == Float("+i
+0000c120: 6e66 2229 0a0a 2020 2020 6465 6620 6173  nf")..    def as
+0000c130: 5f72 656c 6174 696f 6e61 6c28 7365 6c66  _relational(self
+0000c140: 2c20 7829 3a0a 2020 2020 2020 2020 2222  , x):.        ""
+0000c150: 2252 6577 7269 7465 2061 6e20 696e 7465  "Rewrite an inte
+0000c160: 7276 616c 2069 6e20 7465 726d 7320 6f66  rval in terms of
+0000c170: 2069 6e65 7175 616c 6974 6965 7320 616e   inequalities an
+0000c180: 6420 6c6f 6769 6320 6f70 6572 6174 6f72  d logic operator
+0000c190: 732e 2222 220a 2020 2020 2020 2020 7820  s.""".        x 
+0000c1a0: 3d20 7379 6d70 6966 7928 7829 0a20 2020  = sympify(x).   
+0000c1b0: 2020 2020 2069 6620 7365 6c66 2e72 6967       if self.rig
+0000c1c0: 6874 5f6f 7065 6e3a 0a20 2020 2020 2020  ht_open:.       
+0000c1d0: 2020 2020 2072 6967 6874 203d 2078 203c       right = x <
+0000c1e0: 2073 656c 662e 7374 6f70 0a20 2020 2020   self.stop.     
+0000c1f0: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
+0000c200: 2020 2020 2072 6967 6874 203d 2078 203c       right = x <
+0000c210: 3d20 7365 6c66 2e73 746f 700a 2020 2020  = self.stop.    
+0000c220: 2020 2020 6966 2073 656c 662e 6c65 6674      if self.left
+0000c230: 5f6f 7065 6e3a 0a20 2020 2020 2020 2020  _open:.         
+0000c240: 2020 206c 6566 7420 3d20 7365 6c66 2e73     left = self.s
+0000c250: 7461 7274 203c 2078 0a20 2020 2020 2020  tart < x.       
+0000c260: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
+0000c270: 2020 206c 6566 7420 3d20 7365 6c66 2e73     left = self.s
+0000c280: 7461 7274 203c 3d20 780a 2020 2020 2020  tart <= x.      
+0000c290: 2020 7265 7475 726e 2041 6e64 286c 6566    return And(lef
+0000c2a0: 742c 2072 6967 6874 290a 0a20 2020 2064  t, right)..    d
+0000c2b0: 6566 205f 6576 616c 5f45 7128 7365 6c66  ef _eval_Eq(self
+0000c2c0: 2c20 6f74 6865 7229 3a0a 2020 2020 2020  , other):.      
+0000c2d0: 2020 6966 206e 6f74 206f 7468 6572 2e69    if not other.i
+0000c2e0: 735f 496e 7465 7276 616c 3a0a 2020 2020  s_Interval:.    
+0000c2f0: 2020 2020 2020 2020 6966 206f 7468 6572          if other
+0000c300: 2e69 735f 4669 6e69 7465 5365 743a 0a20  .is_FiniteSet:. 
+0000c310: 2020 2020 2020 2020 2020 2020 2020 2069                 i
+0000c320: 6620 6f74 6865 722e 6973 5f45 6d70 7479  f other.is_Empty
+0000c330: 5365 743a 0a20 2020 2020 2020 2020 2020  Set:.           
+0000c340: 2020 2020 2020 2020 2069 6620 7365 6c66           if self
+0000c350: 2e6c 6566 745f 6f70 656e 206f 7220 7365  .left_open or se
+0000c360: 6c66 2e72 6967 6874 5f6f 7065 6e3a 0a20  lf.right_open:. 
+0000c370: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c380: 2020 2020 2020 2069 6620 7365 6c66 2e73         if self.s
+0000c390: 7461 7274 203c 2073 656c 662e 7374 6f70  tart < self.stop
+0000c3a0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+0000c3b0: 2020 2020 2020 2020 2020 2020 2020 7265                re
+0000c3c0: 7475 726e 2053 2e66 616c 7365 0a20 2020  turn S.false.   
+0000c3d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c3e0: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
+0000c3f0: 2020 2020 2020 2020 2020 2020 2020 2069                 i
+0000c400: 6620 7365 6c66 2e73 7461 7274 203c 3d20  f self.start <= 
+0000c410: 7365 6c66 2e73 746f 703a 0a20 2020 2020  self.stop:.     
+0000c420: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c430: 2020 2020 2020 2072 6574 7572 6e20 532e         return S.
+0000c440: 6661 6c73 6520 2020 2020 2020 2020 2020  false           
+0000c450: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c460: 200a 2020 2020 2020 2020 2020 2020 2020   .              
+0000c470: 2020 7265 7475 726e 0a20 2020 2020 2020    return.       
+0000c480: 2020 2020 2065 6c69 6620 6f74 6865 722e       elif other.
+0000c490: 6973 5f73 6574 3a0a 2020 2020 2020 2020  is_set:.        
+0000c4a0: 2020 2020 2020 2020 7265 7475 726e 0a20          return. 
+0000c4b0: 2020 2020 2020 2020 2020 2072 6574 7572             retur
+0000c4c0: 6e20 532e 6661 6c73 650a 0a20 2020 2020  n S.false..     
+0000c4d0: 2020 2072 6574 7572 6e20 416e 6428 4571     return And(Eq
+0000c4e0: 2873 656c 662e 6c65 6674 2c20 6f74 6865  (self.left, othe
+0000c4f0: 722e 6c65 6674 292c 2045 7128 7365 6c66  r.left), Eq(self
+0000c500: 2e72 6967 6874 2c20 6f74 6865 722e 7269  .right, other.ri
+0000c510: 6768 7429 2c0a 2020 2020 2020 2020 2020  ght),.          
+0000c520: 2020 2020 2020 2020 2073 796d 7069 6679           sympify
+0000c530: 2873 656c 662e 6c65 6674 5f6f 7065 6e20  (self.left_open 
+0000c540: 3d3d 206f 7468 6572 2e6c 6566 745f 6f70  == other.left_op
+0000c550: 656e 292c 2073 796d 7069 6679 2873 656c  en), sympify(sel
+0000c560: 662e 7269 6768 745f 6f70 656e 203d 3d20  f.right_open == 
+0000c570: 6f74 6865 722e 7269 6768 745f 6f70 656e  other.right_open
+0000c580: 2929 0a0a 2020 2020 4063 6163 6865 6974  ))..    @cacheit
+0000c590: 0a20 2020 2064 6566 205f 6576 616c 5f66  .    def _eval_f
+0000c5a0: 7265 655f 7379 6d62 6f6c 7328 7365 6c66  ree_symbols(self
+0000c5b0: 293a 0a20 2020 2020 2020 2072 6574 7572  ):.        retur
+0000c5c0: 6e20 7365 7428 292e 756e 696f 6e28 2a5b  n set().union(*[
+0000c5d0: 612e 6672 6565 5f73 796d 626f 6c73 2066  a.free_symbols f
+0000c5e0: 6f72 2061 2069 6e20 7365 6c66 2e61 7267  or a in self.arg
+0000c5f0: 735b 3a32 5d5d 290a 0a20 2020 2064 6566  s[:2]])..    def
+0000c600: 206d 6178 2873 656c 6629 3a0a 2020 2020   max(self):.    
+0000c610: 2020 2020 6966 2073 656c 662e 7269 6768      if self.righ
+0000c620: 745f 6f70 656e 3a0a 2020 2020 2020 2020  t_open:.        
+0000c630: 2020 2020 6966 2073 656c 662e 6973 5f69      if self.is_i
+0000c640: 6e74 6567 6572 3a0a 2020 2020 2020 2020  nteger:.        
+0000c650: 2020 2020 2020 2020 7265 7475 726e 2073          return s
+0000c660: 656c 662e 7374 6f70 202d 2031 0a20 2020  elf.stop - 1.   
+0000c670: 2020 2020 2020 2020 2065 6c73 653a 0a20           else:. 
+0000c680: 2020 2020 2020 2020 2020 2020 2020 2066                 f
+0000c690: 726f 6d20 7379 6d70 792e 636f 7265 2e6e  rom sympy.core.n
+0000c6a0: 756d 6265 7273 2069 6d70 6f72 7420 496e  umbers import In
+0000c6b0: 6669 6e69 7479 0a20 2020 2020 2020 2020  finity.         
+0000c6c0: 2020 2020 2020 2069 6620 6973 696e 7374         if isinst
+0000c6d0: 616e 6365 2873 656c 662e 7374 6f70 2c20  ance(self.stop, 
+0000c6e0: 496e 6669 6e69 7479 293a 0a20 2020 2020  Infinity):.     
+0000c6f0: 2020 2020 2020 2020 2020 2020 2020 2072                 r
+0000c700: 6574 7572 6e20 7365 6c66 2e73 746f 700a  eturn self.stop.
+0000c710: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c720: 2320 6e65 6761 7469 7665 2069 6e66 696e  # negative infin
+0000c730: 6974 6573 696d 616c 0a20 2020 2020 2020  itesimal.       
+0000c740: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
+0000c750: 7365 6c66 2e73 746f 7020 2b20 532e 4e65  self.stop + S.Ne
+0000c760: 6761 7469 7665 496e 6669 6e69 7465 7369  gativeInfinitesi
+0000c770: 6d61 6c0a 2020 2020 2020 2020 7265 7475  mal.        retu
+0000c780: 726e 2073 656c 662e 7374 6f70 0a0a 2020  rn self.stop..  
+0000c790: 2020 6465 6620 6d69 6e28 7365 6c66 293a    def min(self):
+0000c7a0: 0a20 2020 2020 2020 2069 6620 7365 6c66  .        if self
+0000c7b0: 2e6c 6566 745f 6f70 656e 3a0a 2020 2020  .left_open:.    
+0000c7c0: 2020 2020 2020 2020 6966 2073 656c 662e          if self.
+0000c7d0: 6973 5f69 6e74 6567 6572 3a0a 2020 2020  is_integer:.    
+0000c7e0: 2020 2020 2020 2020 2020 2020 7265 7475              retu
+0000c7f0: 726e 2073 656c 662e 7374 6172 7420 2b20  rn self.start + 
+0000c800: 310a 2020 2020 2020 2020 2020 2020 656c  1.            el
+0000c810: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
+0000c820: 2020 2020 6672 6f6d 2073 796d 7079 2e63      from sympy.c
+0000c830: 6f72 652e 6e75 6d62 6572 7320 696d 706f  ore.numbers impo
+0000c840: 7274 204e 6567 6174 6976 6549 6e66 696e  rt NegativeInfin
+0000c850: 6974 790a 2020 2020 2020 2020 2020 2020  ity.            
+0000c860: 2020 2020 6966 2069 7369 6e73 7461 6e63      if isinstanc
+0000c870: 6528 7365 6c66 2e73 7461 7274 2c20 4e65  e(self.start, Ne
+0000c880: 6761 7469 7665 496e 6669 6e69 7479 293a  gativeInfinity):
+0000c890: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000c8a0: 2020 2020 2072 6574 7572 6e20 7365 6c66       return self
+0000c8b0: 2e73 7461 7274 0a20 2020 2020 2020 2020  .start.         
+0000c8c0: 2020 2020 2020 2023 2070 6f73 6974 6976         # positiv
+0000c8d0: 6520 696e 6669 6e69 7465 7369 6d61 6c0a  e infinitesimal.
+0000c8e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c8f0: 7265 7475 726e 2073 656c 662e 7374 6172  return self.star
+0000c900: 7420 2b20 532e 496e 6669 6e69 7465 7369  t + S.Infinitesi
+0000c910: 6d61 6c0a 2020 2020 2020 2020 7265 7475  mal.        retu
+0000c920: 726e 2073 656c 662e 7374 6172 740a 0a20  rn self.start.. 
+0000c930: 2020 2064 6566 205f 5f6e 6567 5f5f 2873     def __neg__(s
+0000c940: 656c 6629 3a20 0a20 2020 2020 2020 2072  elf): .        r
+0000c950: 6574 7572 6e20 7365 6c66 2e66 756e 6328  eturn self.func(
+0000c960: 2d73 656c 662e 7374 6f70 2c20 2d73 656c  -self.stop, -sel
+0000c970: 662e 7374 6172 742c 206c 6566 745f 6f70  f.start, left_op
+0000c980: 656e 3d73 656c 662e 7269 6768 745f 6f70  en=self.right_op
+0000c990: 656e 2c20 7269 6768 745f 6f70 656e 3d73  en, right_open=s
+0000c9a0: 656c 662e 6c65 6674 5f6f 7065 6e29 0a20  elf.left_open). 
+0000c9b0: 2020 200a 2020 2020 6465 6620 5f5f 7375     .    def __su
+0000c9c0: 625f 5f28 7365 6c66 2c20 6f74 6865 7229  b__(self, other)
+0000c9d0: 3a0a 2020 2020 2020 2020 676c 6f62 616c  :.        global
+0000c9e0: 2069 735f 7365 740a 2020 2020 2020 2020   is_set.        
+0000c9f0: 6966 206e 6f74 2069 735f 7365 7428 6f74  if not is_set(ot
+0000ca00: 6865 7229 3a0a 2020 2020 2020 2020 2020  her):.          
+0000ca10: 2020 7265 7475 726e 2073 656c 6620 2b20    return self + 
+0000ca20: 282d 6f74 6865 7229 0a20 2020 2020 2020  (-other).       
+0000ca30: 2072 6574 7572 6e20 5365 742e 5f5f 7375   return Set.__su
+0000ca40: 625f 5f28 7365 6c66 2c20 6f74 6865 7229  b__(self, other)
+0000ca50: 0a20 2020 200a 2020 2020 6465 6620 5f5f  .    .    def __
+0000ca60: 6164 645f 5f28 7365 6c66 2c20 6f74 6865  add__(self, othe
+0000ca70: 7229 3a0a 2020 2020 2020 2020 6f74 6865  r):.        othe
+0000ca80: 7220 3d20 7379 6d70 6966 7928 6f74 6865  r = sympify(othe
+0000ca90: 7229 0a20 2020 2020 2020 2069 6620 6f74  r).        if ot
+0000caa0: 6865 722e 6973 5f49 6e74 6572 7661 6c3a  her.is_Interval:
+0000cab0: 0a20 2020 2020 2020 2020 2020 2069 6e74  .            int
+0000cac0: 6567 6572 203d 204e 6f6e 650a 2020 2020  eger = None.    
+0000cad0: 2020 2020 2020 2020 6966 2073 656c 662e          if self.
+0000cae0: 6973 5f69 6e74 6567 6572 3a0a 2020 2020  is_integer:.    
+0000caf0: 2020 2020 2020 2020 2020 2020 7374 6172              star
+0000cb00: 7420 3d20 7365 6c66 2e6d 696e 2829 0a20  t = self.min(). 
+0000cb10: 2020 2020 2020 2020 2020 2020 2020 2073                 s
+0000cb20: 746f 7020 3d20 7365 6c66 2e6d 6178 2829  top = self.max()
+0000cb30: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000cb40: 2069 6620 6f74 6865 722e 6973 5f69 6e74   if other.is_int
+0000cb50: 6567 6572 3a20 0a20 2020 2020 2020 2020  eger: .         
+0000cb60: 2020 2020 2020 2020 2020 2073 7461 7274             start
+0000cb70: 202b 3d20 6f74 6865 722e 6d69 6e28 290a   += other.min().
+0000cb80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000cb90: 2020 2020 7374 6f70 202b 3d20 6f74 6865      stop += othe
+0000cba0: 722e 6d61 7828 290a 2020 2020 2020 2020  r.max().        
+0000cbb0: 2020 2020 2020 2020 2020 2020 6c65 6674              left
+0000cbc0: 5f6f 7065 6e2c 2072 6967 6874 5f6f 7065  _open, right_ope
+0000cbd0: 6e20 3d20 4661 6c73 652c 2046 616c 7365  n = False, False
+0000cbe0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000cbf0: 2020 2020 2069 6e74 6567 6572 203d 2054       integer = T
+0000cc00: 7275 6520 2020 2020 2020 2020 2020 2020  rue             
+0000cc10: 2020 2020 2020 200a 2020 2020 2020 2020         .        
+0000cc20: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
+0000cc30: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000cc40: 2020 7374 6172 7420 2b3d 206f 7468 6572    start += other
+0000cc50: 2e73 7461 7274 0a20 2020 2020 2020 2020  .start.         
+0000cc60: 2020 2020 2020 2020 2020 2073 746f 7020             stop 
+0000cc70: 2b3d 206f 7468 6572 2e73 746f 700a 2020  += other.stop.  
+0000cc80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000cc90: 2020 6c65 6674 5f6f 7065 6e2c 2072 6967    left_open, rig
+0000cca0: 6874 5f6f 7065 6e20 3d20 6f74 6865 722e  ht_open = other.
+0000ccb0: 6c65 6674 5f6f 7065 6e2c 206f 7468 6572  left_open, other
+0000ccc0: 2e72 6967 6874 5f6f 7065 6e20 2020 2020  .right_open     
+0000ccd0: 2020 2020 2020 2020 2020 2020 2020 200a                 .
+0000cce0: 2020 2020 2020 2020 2020 2020 656c 7365              else
+0000ccf0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+0000cd00: 2020 7374 6172 7420 3d20 7365 6c66 2e73    start = self.s
+0000cd10: 7461 7274 0a20 2020 2020 2020 2020 2020  tart.           
+0000cd20: 2020 2020 2073 746f 7020 3d20 7365 6c66       stop = self
+0000cd30: 2e73 746f 700a 2020 2020 2020 2020 2020  .stop.          
+0000cd40: 2020 2020 2020 6966 206f 7468 6572 2e69        if other.i
+0000cd50: 735f 696e 7465 6765 723a 0a20 2020 2020  s_integer:.     
+0000cd60: 2020 2020 2020 2020 2020 2020 2020 2073                 s
+0000cd70: 7461 7274 202b 3d20 6f74 6865 722e 6d69  tart += other.mi
+0000cd80: 6e28 290a 2020 2020 2020 2020 2020 2020  n().            
+0000cd90: 2020 2020 2020 2020 7374 6f70 202b 3d20          stop += 
+0000cda0: 6f74 6865 722e 6d61 7828 290a 2020 2020  other.max().    
+0000cdb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000cdc0: 6c65 6674 5f6f 7065 6e2c 2072 6967 6874  left_open, right
+0000cdd0: 5f6f 7065 6e20 3d20 7365 6c66 2e6c 6566  _open = self.lef
+0000cde0: 745f 6f70 656e 2c20 7365 6c66 2e72 6967  t_open, self.rig
+0000cdf0: 6874 5f6f 7065 6e0a 2020 2020 2020 2020  ht_open.        
+0000ce00: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
+0000ce10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ce20: 2020 7374 6172 7420 2b3d 206f 7468 6572    start += other
+0000ce30: 2e73 7461 7274 0a20 2020 2020 2020 2020  .start.         
+0000ce40: 2020 2020 2020 2020 2020 2073 746f 7020             stop 
+0000ce50: 2b3d 206f 7468 6572 2e73 746f 700a 2020  += other.stop.  
+0000ce60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ce70: 2020 0a20 2020 2020 2020 2020 2020 2020    .             
+0000ce80: 2020 2020 2020 2069 6620 6f74 6865 722e         if other.
+0000ce90: 7374 6172 742e 6973 5f69 6e66 696e 6974  start.is_infinit
+0000cea0: 6520 616e 6420 6e6f 7420 6f74 6865 722e  e and not other.
+0000ceb0: 6c65 6674 5f6f 7065 6e3a 0a20 2020 2020  left_open:.     
+0000cec0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ced0: 2020 206c 6566 745f 6f70 656e 203d 2046     left_open = F
+0000cee0: 616c 7365 0a20 2020 2020 2020 2020 2020  alse.           
+0000cef0: 2020 2020 2020 2020 2065 6c73 653a 0a20           else:. 
+0000cf00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000cf10: 2020 2020 2020 206c 6566 745f 6f70 656e         left_open
+0000cf20: 203d 2073 656c 662e 6c65 6674 5f6f 7065   = self.left_ope
+0000cf30: 6e20 6f72 206f 7468 6572 2e6c 6566 745f  n or other.left_
+0000cf40: 6f70 656e 0a20 2020 2020 2020 2020 2020  open.           
+0000cf50: 2020 2020 2020 2020 2020 2020 200a 2020               .  
+0000cf60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000cf70: 2020 6966 206f 7468 6572 2e73 746f 702e    if other.stop.
+0000cf80: 6973 5f69 6e66 696e 6974 6520 616e 6420  is_infinite and 
+0000cf90: 6e6f 7420 6f74 6865 722e 7269 6768 745f  not other.right_
+0000cfa0: 6f70 656e 3a0a 2020 2020 2020 2020 2020  open:.          
+0000cfb0: 2020 2020 2020 2020 2020 2020 2020 7269                ri
+0000cfc0: 6768 745f 6f70 656e 203d 2046 616c 7365  ght_open = False
+0000cfd0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000cfe0: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
+0000cff0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d000: 2020 2072 6967 6874 5f6f 7065 6e20 3d20     right_open = 
+0000d010: 7365 6c66 2e72 6967 6874 5f6f 7065 6e20  self.right_open 
+0000d020: 6f72 206f 7468 6572 2e72 6967 6874 5f6f  or other.right_o
+0000d030: 7065 6e0a 2020 2020 2020 2020 2020 2020  pen.            
+0000d040: 2020 2020 2020 2020 0a20 2020 2020 2020          .       
+0000d050: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d060: 200a 2020 2020 2020 2020 2020 2020 6966   .            if
+0000d070: 2069 6e74 6567 6572 3a0a 2020 2020 2020   integer:.      
+0000d080: 2020 2020 2020 2020 2020 6672 6f6d 2073            from s
+0000d090: 796d 7079 2069 6d70 6f72 7420 5261 6e67  ympy import Rang
+0000d0a0: 650a 2020 2020 2020 2020 2020 2020 2020  e.              
+0000d0b0: 2020 7265 7475 726e 2052 616e 6765 2873    return Range(s
+0000d0c0: 7461 7274 202b 2031 2069 6620 6c65 6674  tart + 1 if left
+0000d0d0: 5f6f 7065 6e20 656c 7365 2073 7461 7274  _open else start
+0000d0e0: 2c20 7374 6f70 2069 6620 7269 6768 745f  , stop if right_
+0000d0f0: 6f70 656e 2065 6c73 6520 7374 6f70 202b  open else stop +
+0000d100: 2031 290a 2020 2020 2020 2020 2020 2020   1).            
+0000d110: 7265 7475 726e 2073 656c 662e 6675 6e63  return self.func
+0000d120: 2873 7461 7274 2c20 7374 6f70 2c20 6c65  (start, stop, le
+0000d130: 6674 5f6f 7065 6e3d 6c65 6674 5f6f 7065  ft_open=left_ope
+0000d140: 6e2c 2072 6967 6874 5f6f 7065 6e3d 7269  n, right_open=ri
+0000d150: 6768 745f 6f70 656e 290a 2020 2020 2020  ght_open).      
+0000d160: 2020 0a20 2020 2020 2020 2069 6620 6f74    .        if ot
+0000d170: 6865 722e 6973 5f43 6f6d 706c 6578 5265  her.is_ComplexRe
+0000d180: 6769 6f6e 3a0a 2020 2020 2020 2020 2020  gion:.          
+0000d190: 2020 7072 6f64 7563 7473 6574 203d 206f    productset = o
+0000d1a0: 7468 6572 2e61 7267 735b 305d 2e61 7267  ther.args[0].arg
+0000d1b0: 730a 2020 2020 2020 2020 2020 2020 7265  s.            re
+0000d1c0: 7475 726e 206f 7468 6572 2e66 756e 6328  turn other.func(
+0000d1d0: 2873 656c 6620 2b20 7072 6f64 7563 7473  (self + products
+0000d1e0: 6574 5b30 5d29 2040 2070 726f 6475 6374  et[0]) @ product
+0000d1f0: 7365 745b 315d 290a 2020 2020 2020 2020  set[1]).        
+0000d200: 0a20 2020 2020 2020 2069 6620 6f74 6865  .        if othe
+0000d210: 722e 6973 5f46 696e 6974 6553 6574 3a0a  r.is_FiniteSet:.
+0000d220: 2020 2020 2020 2020 2020 2020 6c65 6674              left
+0000d230: 5f6f 7065 6e2c 2072 6967 6874 5f6f 7065  _open, right_ope
+0000d240: 6e20 3d20 7365 6c66 2e6c 6566 745f 6f70  n = self.left_op
+0000d250: 656e 2c20 7365 6c66 2e72 6967 6874 5f6f  en, self.right_o
+0000d260: 7065 6e20 2020 2020 2020 2020 2020 200a  pen            .
+0000d270: 2020 2020 2020 2020 2020 2020 7374 6172              star
+0000d280: 742c 2073 746f 7020 3d20 7365 6c66 2e73  t, stop = self.s
+0000d290: 7461 7274 2c20 7365 6c66 2e73 746f 700a  tart, self.stop.
+0000d2a0: 2020 2020 2020 2020 2020 2020 7374 6172              star
+0000d2b0: 7420 2b3d 206f 7468 6572 2e6d 696e 2829  t += other.min()
+0000d2c0: 0a20 2020 2020 2020 2020 2020 2073 746f  .            sto
+0000d2d0: 7020 2b3d 206f 7468 6572 2e6d 6178 2829  p += other.max()
+0000d2e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d2f0: 2020 0a20 2020 2020 2020 2020 2020 2072    .            r
+0000d300: 6574 7572 6e20 7365 6c66 2e66 756e 6328  eturn self.func(
+0000d310: 7374 6172 742c 2073 746f 702c 206c 6566  start, stop, lef
+0000d320: 745f 6f70 656e 3d6c 6566 745f 6f70 656e  t_open=left_open
+0000d330: 2c20 7269 6768 745f 6f70 656e 3d72 6967  , right_open=rig
+0000d340: 6874 5f6f 7065 6e29 0a20 2020 2020 2020  ht_open).       
+0000d350: 2020 2020 200a 2020 2020 2020 2020 6966       .        if
+0000d360: 206e 6f74 206f 7468 6572 2e69 735f 7365   not other.is_se
+0000d370: 743a 0a20 2020 2020 2020 2020 2020 2073  t:.            s
+0000d380: 7461 7274 203d 2073 656c 662e 7374 6172  tart = self.star
+0000d390: 7420 2b20 6f74 6865 720a 2020 2020 2020  t + other.      
+0000d3a0: 2020 2020 2020 7374 6f70 203d 2073 656c        stop = sel
+0000d3b0: 662e 7374 6f70 202b 206f 7468 6572 0a20  f.stop + other. 
+0000d3c0: 2020 2020 2020 2020 2020 2072 6574 7572             retur
+0000d3d0: 6e20 7365 6c66 2e66 756e 6328 7374 6172  n self.func(star
+0000d3e0: 742c 2073 746f 702c 206c 6566 745f 6f70  t, stop, left_op
+0000d3f0: 656e 3d73 656c 662e 6c65 6674 5f6f 7065  en=self.left_ope
+0000d400: 6e2c 2072 6967 6874 5f6f 7065 6e3d 7365  n, right_open=se
+0000d410: 6c66 2e72 6967 6874 5f6f 7065 6e29 0a0a  lf.right_open)..
+0000d420: 2020 2020 2020 2020 6966 206f 7468 6572          if other
+0000d430: 2e69 735f 5261 6e67 653a 200a 2020 2020  .is_Range: .    
+0000d440: 2020 2020 2020 2020 7374 6172 7420 3d20          start = 
+0000d450: 7365 6c66 2e73 7461 7274 0a20 2020 2020  self.start.     
+0000d460: 2020 2020 2020 2073 746f 7020 3d20 7365         stop = se
+0000d470: 6c66 2e73 746f 700a 2020 2020 2020 2020  lf.stop.        
+0000d480: 2020 2020 0a20 2020 2020 2020 2020 2020      .           
+0000d490: 2073 7461 7274 202b 3d20 6f74 6865 722e   start += other.
+0000d4a0: 6d69 6e28 290a 2020 2020 2020 2020 2020  min().          
+0000d4b0: 2020 7374 6f70 202b 3d20 6f74 6865 722e    stop += other.
+0000d4c0: 6d61 7828 290a 2020 2020 2020 2020 2020  max().          
+0000d4d0: 2020 6c65 6674 5f6f 7065 6e2c 2072 6967    left_open, rig
+0000d4e0: 6874 5f6f 7065 6e20 3d20 7365 6c66 2e6c  ht_open = self.l
+0000d4f0: 6566 745f 6f70 656e 2c20 7365 6c66 2e72  eft_open, self.r
+0000d500: 6967 6874 5f6f 7065 6e0a 2020 2020 2020  ight_open.      
+0000d510: 2020 2020 2020 2020 2020 0a20 2020 2020            .     
+0000d520: 2020 2020 2020 2072 6574 7572 6e20 7365         return se
+0000d530: 6c66 2e66 756e 6328 7374 6172 742c 2073  lf.func(start, s
+0000d540: 746f 702c 206c 6566 745f 6f70 656e 3d6c  top, left_open=l
+0000d550: 6566 745f 6f70 656e 2c20 7269 6768 745f  eft_open, right_
+0000d560: 6f70 656e 3d72 6967 6874 5f6f 7065 6e29  open=right_open)
+0000d570: 0a20 2020 2020 2020 200a 2020 2020 2020  .        .      
+0000d580: 2020 6966 206f 7468 6572 2e69 735f 556e    if other.is_Un
+0000d590: 6976 6572 7361 6c53 6574 2061 6e64 2028  iversalSet and (
+0000d5a0: 6f74 6865 722e 6574 7970 652e 6973 5f73  other.etype.is_s
+0000d5b0: 7570 6572 5f72 6561 6c20 6f72 206f 7468  uper_real or oth
+0000d5c0: 6572 2e65 7479 7065 2e69 735f 7375 7065  er.etype.is_supe
+0000d5d0: 725f 636f 6d70 6c65 7829 3a0a 2020 2020  r_complex):.    
+0000d5e0: 2020 2020 2020 2020 7265 7475 726e 206f          return o
+0000d5f0: 7468 6572 0a0a 2020 2020 2020 2020 7265  ther..        re
+0000d600: 7475 726e 2053 6574 2e5f 5f61 6464 5f5f  turn Set.__add__
+0000d610: 2873 656c 662c 206f 7468 6572 290a 0a20  (self, other).. 
+0000d620: 2020 2064 6566 205f 5f6d 756c 5f5f 2873     def __mul__(s
+0000d630: 656c 662c 206f 7468 6572 293a 0a20 2020  elf, other):.   
+0000d640: 2020 2020 2069 6620 6973 696e 7374 616e       if isinstan
+0000d650: 6365 286f 7468 6572 2c20 4578 7072 293a  ce(other, Expr):
+0000d660: 0a20 2020 2020 2020 2020 2020 2073 7461  .            sta
+0000d670: 7274 203d 2073 656c 662e 7374 6172 7420  rt = self.start 
+0000d680: 2a20 6f74 6865 720a 2020 2020 2020 2020  * other.        
+0000d690: 2020 2020 7374 6f70 203d 2073 656c 662e      stop = self.
+0000d6a0: 7374 6f70 202a 206f 7468 6572 0a20 2020  stop * other.   
+0000d6b0: 2020 2020 2020 2020 2069 6620 6f74 6865           if othe
+0000d6c0: 7220 3e20 303a 0a20 2020 2020 2020 2020  r > 0:.         
+0000d6d0: 2020 2020 2020 2072 6574 7572 6e20 7365         return se
+0000d6e0: 6c66 2e66 756e 6328 7374 6172 742c 2073  lf.func(start, s
+0000d6f0: 746f 702c 206c 6566 745f 6f70 656e 3d73  top, left_open=s
+0000d700: 656c 662e 6c65 6674 5f6f 7065 6e2c 2072  elf.left_open, r
+0000d710: 6967 6874 5f6f 7065 6e3d 7365 6c66 2e72  ight_open=self.r
+0000d720: 6967 6874 5f6f 7065 6e29 0a20 2020 2020  ight_open).     
+0000d730: 2020 2020 2020 2069 6620 6f74 6865 7220         if other 
+0000d740: 3c20 303a 0a20 2020 2020 2020 2020 2020  < 0:.           
+0000d750: 2020 2020 2072 6574 7572 6e20 7365 6c66       return self
+0000d760: 2e66 756e 6328 7374 6f70 2c20 7374 6172  .func(stop, star
+0000d770: 742c 206c 6566 745f 6f70 656e 3d73 656c  t, left_open=sel
+0000d780: 662e 7269 6768 745f 6f70 656e 2c20 7269  f.right_open, ri
+0000d790: 6768 745f 6f70 656e 3d73 656c 662e 6c65  ght_open=self.le
+0000d7a0: 6674 5f6f 7065 6e29 0a20 2020 2020 2020  ft_open).       
+0000d7b0: 2020 2020 2069 6620 6f74 6865 7220 3d3d       if other ==
+0000d7c0: 2030 3a0a 2020 2020 2020 2020 2020 2020   0:.            
+0000d7d0: 2020 2020 6672 6f6d 2073 796d 7079 2069      from sympy i
+0000d7e0: 6d70 6f72 7420 4669 6e69 7465 5365 740a  mport FiniteSet.
+0000d7f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d800: 7265 7475 726e 2046 696e 6974 6553 6574  return FiniteSet
+0000d810: 2830 290a 2020 2020 2020 2020 2020 2020  (0).            
+0000d820: 7265 7475 726e 2073 656c 662e 6675 6e63  return self.func
+0000d830: 2853 2e4e 6567 6174 6976 6549 6e66 696e  (S.NegativeInfin
+0000d840: 6974 792c 2053 2e49 6e66 696e 6974 7929  ity, S.Infinity)
+0000d850: 0a0a 2020 2020 2020 2020 7265 7475 726e  ..        return
+0000d860: 2053 6574 2e5f 5f6d 756c 5f5f 2873 656c   Set.__mul__(sel
+0000d870: 662c 206f 7468 6572 290a 0a20 2020 2064  f, other)..    d
+0000d880: 6566 2063 6f73 2873 656c 6629 3a0a 2020  ef cos(self):.  
+0000d890: 2020 2020 2020 6672 6f6d 2073 796d 7079        from sympy
+0000d8a0: 2e63 6f72 652e 6e75 6d62 6572 7320 696d  .core.numbers im
+0000d8b0: 706f 7274 2065 7073 696c 6f6e 0a20 2020  port epsilon.   
+0000d8c0: 2020 2020 2073 7461 7274 2c20 7374 6f70       start, stop
+0000d8d0: 203d 2073 656c 662e 6172 6773 0a20 2020   = self.args.   
+0000d8e0: 2020 2020 2069 6620 7365 6c66 2e72 6967       if self.rig
+0000d8f0: 6874 5f6f 7065 6e3a 0a20 2020 2020 2020  ht_open:.       
+0000d900: 2020 2020 2073 746f 7020 2d3d 2065 7073       stop -= eps
+0000d910: 696c 6f6e 0a0a 2020 2020 2020 2020 6672  ilon..        fr
+0000d920: 6f6d 2073 796d 7079 2069 6d70 6f72 7420  om sympy import 
+0000d930: 636f 732c 2066 6c6f 6f72 0a0a 2020 2020  cos, floor..    
+0000d940: 2020 2020 6e20 3d20 666c 6f6f 7228 7374      n = floor(st
+0000d950: 6172 7420 2f20 532e 5069 290a 0a20 2020  art / S.Pi)..   
+0000d960: 2020 2020 206d 203d 2066 6c6f 6f72 2873       m = floor(s
+0000d970: 746f 7020 2f20 532e 5069 290a 0a20 2020  top / S.Pi)..   
+0000d980: 2020 2020 2069 6620 6e2e 6973 5f65 7665       if n.is_eve
+0000d990: 6e3a 0a20 2020 2020 2020 2020 2020 2069  n:.            i
+0000d9a0: 6620 6e20 3d3d 206d 3a0a 2020 2020 2020  f n == m:.      
+0000d9b0: 2020 2020 2020 2020 2020 7265 7475 726e            return
+0000d9c0: 2073 656c 662e 6675 6e63 2863 6f73 2873   self.func(cos(s
+0000d9d0: 656c 662e 7374 6f70 292c 2063 6f73 2873  elf.stop), cos(s
+0000d9e0: 7461 7274 292c 0a20 2020 2020 2020 2020  tart),.         
+0000d9f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000da00: 2020 2020 2020 2020 6c65 6674 5f6f 7065          left_ope
+0000da10: 6e3d 7365 6c66 2e72 6967 6874 5f6f 7065  n=self.right_ope
+0000da20: 6e2c 0a20 2020 2020 2020 2020 2020 2020  n,.             
+0000da30: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000da40: 2020 2020 7269 6768 745f 6f70 656e 3d73      right_open=s
+0000da50: 656c 662e 6c65 6674 5f6f 7065 6e2c 0a20  elf.left_open,. 
+0000da60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000da70: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000da80: 696e 7465 6765 723d 7365 6c66 2e69 735f  integer=self.is_
+0000da90: 696e 7465 6765 7229 0a20 2020 2020 2020  integer).       
+0000daa0: 2065 6c69 6620 6e2e 6973 5f6f 6464 3a0a   elif n.is_odd:.
+0000dab0: 2020 2020 2020 2020 2020 2020 6966 206e              if n
+0000dac0: 203d 3d20 6d3a 0a20 2020 2020 2020 2020   == m:.         
+0000dad0: 2020 2020 2020 2072 6574 7572 6e20 7365         return se
+0000dae0: 6c66 2e63 6f70 7928 7374 6172 743d 636f  lf.copy(start=co
+0000daf0: 7328 7374 6172 7429 2c20 7374 6f70 3d63  s(start), stop=c
+0000db00: 6f73 2873 656c 662e 7374 6f70 2929 0a0a  os(self.stop))..
+0000db10: 2020 2020 2020 2020 7265 7475 726e 2073          return s
+0000db20: 656c 662e 6675 6e63 282d 312c 2031 290a  elf.func(-1, 1).
+0000db30: 0a20 2020 2064 6566 2061 636f 7328 7365  .    def acos(se
+0000db40: 6c66 293a 0a20 2020 2020 2020 2066 726f  lf):.        fro
+0000db50: 6d20 7379 6d70 7920 696d 706f 7274 2061  m sympy import a
+0000db60: 636f 730a 0a20 2020 2020 2020 2073 7461  cos..        sta
+0000db70: 7274 2c20 7374 6f70 203d 2073 656c 662e  rt, stop = self.
+0000db80: 6172 6773 0a0a 2020 2020 2020 2020 7265  args..        re
+0000db90: 7475 726e 2073 656c 662e 6675 6e63 2861  turn self.func(a
+0000dba0: 636f 7328 7374 6f70 292c 2061 636f 7328  cos(stop), acos(
+0000dbb0: 7374 6172 7429 2c20 6c65 6674 5f6f 7065  start), left_ope
+0000dbc0: 6e3d 7365 6c66 2e72 6967 6874 5f6f 7065  n=self.right_ope
+0000dbd0: 6e2c 2072 6967 6874 5f6f 7065 6e3d 7365  n, right_open=se
+0000dbe0: 6c66 2e6c 6566 745f 6f70 656e 2c20 696e  lf.left_open, in
+0000dbf0: 7465 6765 723d 7365 6c66 2e69 735f 696e  teger=self.is_in
+0000dc00: 7465 6765 7229 0a0a 2020 2020 6465 6620  teger)..    def 
+0000dc10: 5f5f 7472 7565 6469 765f 5f28 7365 6c66  __truediv__(self
+0000dc20: 2c20 6f74 6865 7229 3a0a 2020 2020 2020  , other):.      
+0000dc30: 2020 6966 2073 656c 662e 6973 5f69 6e74    if self.is_int
+0000dc40: 6567 6572 3a0a 2020 2020 2020 2020 2020  eger:.          
+0000dc50: 2020 6966 206f 7468 6572 2e69 735f 4f6e    if other.is_On
+0000dc60: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
+0000dc70: 2020 2072 6574 7572 6e20 7365 6c66 0a20     return self. 
+0000dc80: 2020 2020 2020 2020 2020 2069 6620 6f74             if ot
+0000dc90: 6865 722e 6973 5f4e 6567 6174 6976 654f  her.is_NegativeO
+0000dca0: 6e65 3a20 0a20 2020 2020 2020 2020 2020  ne: .           
+0000dcb0: 2020 2020 2072 6574 7572 6e20 7365 6c66       return self
+0000dcc0: 2e66 756e 6328 7365 6c66 2e73 746f 7020  .func(self.stop 
+0000dcd0: 2f20 6f74 6865 722c 2073 656c 662e 7374  / other, self.st
+0000dce0: 6172 7420 2f20 6f74 6865 722c 0a20 2020  art / other,.   
+0000dcf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000dd00: 2020 2020 2020 2020 2020 2020 2020 6c65                le
+0000dd10: 6674 5f6f 7065 6e3d 7365 6c66 2e72 6967  ft_open=self.rig
+0000dd20: 6874 5f6f 7065 6e2c 2072 6967 6874 5f6f  ht_open, right_o
+0000dd30: 7065 6e3d 7365 6c66 2e6c 6566 745f 6f70  pen=self.left_op
+0000dd40: 656e 2c20 696e 7465 6765 723d 7365 6c66  en, integer=self
+0000dd50: 2e69 735f 696e 7465 6765 7229 0a20 2020  .is_integer).   
+0000dd60: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
+0000dd70: 2020 2020 2020 2069 6620 6f74 6865 722e         if other.
+0000dd80: 6973 5f65 7874 656e 6465 645f 706f 7369  is_extended_posi
+0000dd90: 7469 7665 3a20 0a20 2020 2020 2020 2020  tive: .         
+0000dda0: 2020 2020 2020 2072 6574 7572 6e20 7365         return se
+0000ddb0: 6c66 2e63 6f70 7928 7374 6172 743d 7365  lf.copy(start=se
+0000ddc0: 6c66 2e73 7461 7274 202f 206f 7468 6572  lf.start / other
+0000ddd0: 2c20 7374 6f70 3d73 656c 662e 7374 6f70  , stop=self.stop
+0000dde0: 202f 206f 7468 6572 290a 2020 2020 2020   / other).      
+0000ddf0: 2020 2020 2020 6966 206f 7468 6572 2e69        if other.i
+0000de00: 735f 6578 7465 6e64 6564 5f6e 6567 6174  s_extended_negat
+0000de10: 6976 653a 200a 2020 2020 2020 2020 2020  ive: .          
+0000de20: 2020 2020 2020 7265 7475 726e 2073 656c        return sel
+0000de30: 662e 6675 6e63 2873 656c 662e 7374 6f70  f.func(self.stop
+0000de40: 202f 206f 7468 6572 2c20 7365 6c66 2e73   / other, self.s
+0000de50: 7461 7274 202f 206f 7468 6572 2c0a 2020  tart / other,.  
+0000de60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000de70: 2020 2020 2020 2020 2020 2020 2020 206c                 l
+0000de80: 6566 745f 6f70 656e 3d73 656c 662e 7269  eft_open=self.ri
+0000de90: 6768 745f 6f70 656e 2c20 7269 6768 745f  ght_open, right_
+0000dea0: 6f70 656e 3d73 656c 662e 6c65 6674 5f6f  open=self.left_o
+0000deb0: 7065 6e2c 2069 6e74 6567 6572 3d73 656c  pen, integer=sel
+0000dec0: 662e 6973 5f69 6e74 6567 6572 290a 0a20  f.is_integer).. 
+0000ded0: 2020 2040 6361 6368 6569 740a 2020 2020     @cacheit.    
+0000dee0: 6465 6620 5f68 6173 2873 656c 662c 2070  def _has(self, p
+0000def0: 6174 7465 726e 293a 0a20 2020 2020 2020  attern):.       
+0000df00: 2072 6574 7572 6e20 7365 6c66 2e73 7461   return self.sta
+0000df10: 7274 2e5f 6861 7328 7061 7474 6572 6e29  rt._has(pattern)
+0000df20: 206f 7220 7365 6c66 2e73 746f 702e 5f68   or self.stop._h
+0000df30: 6173 2870 6174 7465 726e 290a 0a20 2020  as(pattern)..   
+0000df40: 2064 6566 2063 6f70 7928 7365 6c66 2c20   def copy(self, 
+0000df50: 2a2a 6b77 6172 6773 293a 0a20 2020 2020  **kwargs):.     
+0000df60: 2020 2069 6620 2773 7461 7274 2720 696e     if 'start' in
+0000df70: 206b 7761 7267 733a 0a20 2020 2020 2020   kwargs:.       
+0000df80: 2020 2020 2073 7461 7274 203d 206b 7761       start = kwa
+0000df90: 7267 735b 2773 7461 7274 275d 0a20 2020  rgs['start'].   
+0000dfa0: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
+0000dfb0: 2020 2020 2020 2073 7461 7274 203d 2073         start = s
+0000dfc0: 656c 662e 7374 6172 740a 0a20 2020 2020  elf.start..     
+0000dfd0: 2020 2069 6620 2773 746f 7027 2069 6e20     if 'stop' in 
+0000dfe0: 6b77 6172 6773 3a0a 2020 2020 2020 2020  kwargs:.        
+0000dff0: 2020 2020 7374 6f70 203d 206b 7761 7267      stop = kwarg
+0000e000: 735b 2773 746f 7027 5d0a 2020 2020 2020  s['stop'].      
+0000e010: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
+0000e020: 2020 2020 7374 6f70 203d 2073 656c 662e      stop = self.
+0000e030: 7374 6f70 0a20 2020 2020 2020 2020 2020  stop.           
+0000e040: 200a 2020 2020 2020 2020 6966 2027 6c65   .        if 'le
+0000e050: 6674 5f6f 7065 6e27 2069 6e20 6b77 6172  ft_open' in kwar
+0000e060: 6773 3a0a 2020 2020 2020 2020 2020 2020  gs:.            
+0000e070: 6c65 6674 5f6f 7065 6e20 3d20 6b77 6172  left_open = kwar
+0000e080: 6773 5b27 6c65 6674 5f6f 7065 6e27 5d0a  gs['left_open'].
+0000e090: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
+0000e0a0: 2020 2020 2020 2020 2020 6c65 6674 5f6f            left_o
+0000e0b0: 7065 6e20 3d20 7365 6c66 2e6c 6566 745f  pen = self.left_
+0000e0c0: 6f70 656e 0a0a 2020 2020 2020 2020 6966  open..        if
+0000e0d0: 2027 7269 6768 745f 6f70 656e 2720 696e   'right_open' in
+0000e0e0: 206b 7761 7267 733a 0a20 2020 2020 2020   kwargs:.       
+0000e0f0: 2020 2020 2072 6967 6874 5f6f 7065 6e20       right_open 
+0000e100: 3d20 6b77 6172 6773 5b27 7269 6768 745f  = kwargs['right_
+0000e110: 6f70 656e 275d 0a20 2020 2020 2020 2065  open'].        e
+0000e120: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
+0000e130: 2072 6967 6874 5f6f 7065 6e20 3d20 7365   right_open = se
+0000e140: 6c66 2e72 6967 6874 5f6f 7065 6e0a 2020  lf.right_open.  
+0000e150: 2020 2020 2020 2020 2020 0a20 2020 2020            .     
+0000e160: 2020 2069 6620 6b77 6172 6773 2e67 6574     if kwargs.get
+0000e170: 2827 696e 7465 6765 7227 293a 0a20 2020  ('integer'):.   
+0000e180: 2020 2020 2020 2020 2066 726f 6d20 7379           from sy
+0000e190: 6d70 7920 696d 706f 7274 2052 616e 6765  mpy import Range
+0000e1a0: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
+0000e1b0: 7572 6e20 5261 6e67 6528 7374 6172 742c  urn Range(start,
+0000e1c0: 2073 746f 702c 206c 6566 745f 6f70 656e   stop, left_open
+0000e1d0: 3d6c 6566 745f 6f70 656e 2c20 7269 6768  =left_open, righ
+0000e1e0: 745f 6f70 656e 3d72 6967 6874 5f6f 7065  t_open=right_ope
+0000e1f0: 6e29 0a20 2020 2020 2020 200a 2020 2020  n).        .    
+0000e200: 2020 2020 7265 7475 726e 2073 656c 662e      return self.
+0000e210: 6675 6e63 2873 7461 7274 2c20 7374 6f70  func(start, stop
+0000e220: 2c20 6c65 6674 5f6f 7065 6e3d 6c65 6674  , left_open=left
+0000e230: 5f6f 7065 6e2c 2072 6967 6874 5f6f 7065  _open, right_ope
+0000e240: 6e3d 7269 6768 745f 6f70 656e 290a 0a20  n=right_open).. 
+0000e250: 2020 2064 6566 2072 6574 6169 6e5f 6f64     def retain_od
+0000e260: 6428 7365 6c66 293a 0a20 2020 2020 2020  d(self):.       
+0000e270: 2069 203d 2073 656c 662e 6765 6e65 7261   i = self.genera
+0000e280: 7465 5f76 6172 2869 6e74 6567 6572 3d54  te_var(integer=T
+0000e290: 7275 6529 0a20 2020 2020 2020 2061 2c20  rue).        a, 
+0000e2a0: 6220 3d20 7365 6c66 2e6d 696e 2829 2c20  b = self.min(), 
+0000e2b0: 7365 6c66 2e6d 6178 2829 0a20 2020 2020  self.max().     
+0000e2c0: 2020 2069 6620 612e 6973 5f66 696e 6974     if a.is_finit
+0000e2d0: 653a 0a20 2020 2020 2020 2020 2020 2061  e:.            a
+0000e2e0: 203d 2028 6120 2f20 3229 2e66 6c6f 6f72   = (a / 2).floor
+0000e2f0: 2829 0a20 2020 2020 2020 2069 6620 622e  ().        if b.
+0000e300: 6973 5f66 696e 6974 653a 0a20 2020 2020  is_finite:.     
+0000e310: 2020 2020 2020 2062 203d 2028 2862 202d         b = ((b -
+0000e320: 2031 2920 2f20 3229 2e66 6c6f 6f72 2829   1) / 2).floor()
+0000e330: 0a20 2020 2020 2020 2020 2020 200a 2020  .            .  
+0000e340: 2020 2020 2020 6966 2061 2e69 735f 696e        if a.is_in
+0000e350: 6669 6e69 7465 2061 6e64 2062 2e69 735f  finite and b.is_
+0000e360: 696e 6669 6e69 7465 3a0a 2020 2020 2020  infinite:.      
+0000e370: 2020 2020 2020 646f 6d61 696e 203d 2073        domain = s
+0000e380: 656c 660a 2020 2020 2020 2020 656c 7365  elf.        else
+0000e390: 3a0a 2020 2020 2020 2020 2020 2020 646f  :.            do
+0000e3a0: 6d61 696e 203d 2073 656c 662e 6675 6e63  main = self.func
+0000e3b0: 2861 2c20 622c 2069 6e74 6567 6572 3d54  (a, b, integer=T
+0000e3c0: 7275 6529 0a20 2020 2020 2020 2066 726f  rue).        fro
+0000e3d0: 6d20 7379 6d70 7920 696d 706f 7274 2043  m sympy import C
+0000e3e0: 7570 0a20 2020 2020 2020 2072 6574 7572  up.        retur
+0000e3f0: 6e20 4375 705b 693a 646f 6d61 696e 5d28  n Cup[i:domain](
+0000e400: 2832 202a 2069 202b 2031 292e 7365 7429  (2 * i + 1).set)
+0000e410: 0a20 2020 2020 2020 200a 2020 2020 6465  .        .    de
+0000e420: 6620 7265 7461 696e 5f65 7665 6e28 7365  f retain_even(se
+0000e430: 6c66 293a 0a20 2020 2020 2020 2069 203d  lf):.        i =
+0000e440: 2073 656c 662e 6765 6e65 7261 7465 5f76   self.generate_v
+0000e450: 6172 2869 6e74 6567 6572 3d54 7275 6529  ar(integer=True)
+0000e460: 0a20 2020 2020 2020 2061 2c20 6220 3d20  .        a, b = 
+0000e470: 7365 6c66 2e6d 696e 2829 2c20 7365 6c66  self.min(), self
+0000e480: 2e6d 6178 2829 0a20 2020 2020 2020 2069  .max().        i
+0000e490: 6620 612e 6973 5f66 696e 6974 653a 0a20  f a.is_finite:. 
+0000e4a0: 2020 2020 2020 2020 2020 2061 203d 2028             a = (
+0000e4b0: 6120 2f20 3229 2e66 6c6f 6f72 2829 0a20  a / 2).floor(). 
+0000e4c0: 2020 2020 2020 2069 6620 622e 6973 5f66         if b.is_f
+0000e4d0: 696e 6974 653a 0a20 2020 2020 2020 2020  inite:.         
+0000e4e0: 2020 2062 203d 2028 6220 2f20 3229 2e66     b = (b / 2).f
+0000e4f0: 6c6f 6f72 2829 0a20 2020 2020 2020 2020  loor().         
+0000e500: 2020 200a 2020 2020 2020 2020 6966 2061     .        if a
+0000e510: 2e69 735f 696e 6669 6e69 7465 2061 6e64  .is_infinite and
+0000e520: 2062 2e69 735f 696e 6669 6e69 7465 3a0a   b.is_infinite:.
+0000e530: 2020 2020 2020 2020 2020 2020 646f 6d61              doma
+0000e540: 696e 203d 2073 656c 660a 2020 2020 2020  in = self.      
+0000e550: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
+0000e560: 2020 2020 646f 6d61 696e 203d 2073 656c      domain = sel
+0000e570: 662e 6675 6e63 2861 2c20 622c 2069 6e74  f.func(a, b, int
+0000e580: 6567 6572 3d54 7275 6529 0a20 2020 2020  eger=True).     
+0000e590: 2020 2066 726f 6d20 7379 6d70 7920 696d     from sympy im
+0000e5a0: 706f 7274 2043 7570 0a20 2020 2020 2020  port Cup.       
+0000e5b0: 2072 6574 7572 6e20 4375 705b 693a 646f   return Cup[i:do
+0000e5c0: 6d61 696e 5d28 2832 202a 2069 292e 7365  main]((2 * i).se
+0000e5d0: 7429 0a20 2020 2020 2020 200a 2020 2020  t).        .    
+0000e5e0: 6465 6620 5f73 7562 7328 7365 6c66 2c20  def _subs(self, 
+0000e5f0: 6f6c 642c 206e 6577 2c20 2a2a 6869 6e74  old, new, **hint
+0000e600: 7329 3a0a 2020 2020 2020 2020 6173 7365  s):.        asse
+0000e610: 7274 206f 6c64 2021 3d20 6e65 770a 2020  rt old != new.  
+0000e620: 2020 2020 2020 6966 2073 656c 6620 3d3d        if self ==
+0000e630: 206f 6c64 3a0a 2020 2020 2020 2020 2020   old:.          
+0000e640: 2020 7265 7475 726e 206e 6577 0a20 2020    return new.   
+0000e650: 2020 2020 200a 2020 2020 2020 2020 6869       .        hi
+0000e660: 7420 3d20 4661 6c73 650a 2020 2020 2020  t = False.      
+0000e670: 2020 6172 6773 203d 206c 6973 7428 7365    args = list(se
+0000e680: 6c66 2e61 7267 735b 3a32 5d29 0a20 2020  lf.args[:2]).   
+0000e690: 2020 2020 2066 6f72 2069 2c20 6172 6720       for i, arg 
+0000e6a0: 696e 2065 6e75 6d65 7261 7465 2861 7267  in enumerate(arg
+0000e6b0: 7329 3a0a 2020 2020 2020 2020 2020 2020  s):.            
+0000e6c0: 6966 206e 6f74 2068 6173 6174 7472 2861  if not hasattr(a
+0000e6d0: 7267 2c20 275f 6576 616c 5f73 7562 7327  rg, '_eval_subs'
+0000e6e0: 293a 0a20 2020 2020 2020 2020 2020 2020  ):.             
+0000e6f0: 2020 2063 6f6e 7469 6e75 650a 2020 2020     continue.    
+0000e700: 2020 2020 2020 2020 6172 6720 3d20 6172          arg = ar
+0000e710: 672e 5f73 7562 7328 6f6c 642c 206e 6577  g._subs(old, new
+0000e720: 2c20 2a2a 6869 6e74 7329 0a20 2020 2020  , **hints).     
+0000e730: 2020 2020 2020 2069 6620 6172 6720 213d         if arg !=
+0000e740: 2061 7267 735b 695d 3a0a 2020 2020 2020   args[i]:.      
+0000e750: 2020 2020 2020 2020 2020 6869 7420 3d20            hit = 
+0000e760: 5472 7565 0a20 2020 2020 2020 2020 2020  True.           
+0000e770: 2020 2020 2061 7267 735b 695d 203d 2061       args[i] = a
+0000e780: 7267 0a20 2020 2020 2020 2069 6620 6869  rg.        if hi
+0000e790: 743a 0a20 2020 2020 2020 2020 2020 2073  t:.            s
+0000e7a0: 7461 7274 2c20 7374 6f70 203d 2061 7267  tart, stop = arg
+0000e7b0: 730a 2020 2020 2020 2020 2020 2020 7265  s.            re
+0000e7c0: 7475 726e 2073 656c 662e 636f 7079 2873  turn self.copy(s
+0000e7d0: 7461 7274 3d73 7461 7274 2c20 7374 6f70  tart=start, stop
+0000e7e0: 3d73 746f 7029 0a20 2020 2020 2020 2072  =stop).        r
+0000e7f0: 6574 7572 6e20 7365 6c66 0a0a 2020 2020  eturn self..    
+0000e800: 4070 726f 7065 7274 790a 2020 2020 6465  @property.    de
+0000e810: 6620 6574 7970 6528 7365 6c66 293a 0a20  f etype(self):. 
+0000e820: 2020 2020 2020 2069 6620 7365 6c66 2e73         if self.s
+0000e830: 7461 7274 2e69 735f 696e 6669 6e69 7465  tart.is_infinite
+0000e840: 2061 6e64 206e 6f74 2073 656c 662e 6c65   and not self.le
+0000e850: 6674 5f6f 7065 6e20 6f72 2073 656c 662e  ft_open or self.
+0000e860: 7374 6f70 2e69 735f 696e 6669 6e69 7465  stop.is_infinite
+0000e870: 2061 6e64 206e 6f74 2073 656c 662e 7269   and not self.ri
+0000e880: 6768 745f 6f70 656e 3a0a 2020 2020 2020  ght_open:.      
+0000e890: 2020 2020 2020 7265 7475 726e 2064 7479        return dty
+0000e8a0: 7065 2e65 7874 656e 6465 645f 7265 616c  pe.extended_real
+0000e8b0: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
+0000e8c0: 6474 7970 652e 7265 616c 0a0a 2020 2020  dtype.real..    
+0000e8d0: 6465 6620 5f70 7265 7474 7928 7365 6c66  def _pretty(self
+0000e8e0: 2c20 7029 3a20 0a20 2020 2020 2020 2069  , p): .        i
+0000e8f0: 6620 7365 6c66 2e73 7461 7274 203d 3d20  f self.start == 
+0000e900: 7365 6c66 2e73 746f 703a 0a20 2020 2020  self.stop:.     
+0000e910: 2020 2020 2020 2072 6574 7572 6e20 702e         return p.
+0000e920: 5f70 7269 6e74 5f73 6571 2873 656c 662e  _print_seq(self.
+0000e930: 6172 6773 5b3a 315d 2c20 277b 272c 2027  args[:1], '{', '
+0000e940: 7d27 290a 0a20 2020 2020 2020 2065 6c73  }')..        els
+0000e950: 653a 0a20 2020 2020 2020 2020 2020 2069  e:.            i
+0000e960: 6620 7365 6c66 2e6c 6566 745f 6f70 656e  f self.left_open
+0000e970: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+0000e980: 2020 6c65 6674 203d 2027 2827 0a20 2020    left = '('.   
+0000e990: 2020 2020 2020 2020 2065 6c73 653a 0a20           else:. 
+0000e9a0: 2020 2020 2020 2020 2020 2020 2020 206c                 l
+0000e9b0: 6566 7420 3d20 275b 270a 0a20 2020 2020  eft = '['..     
+0000e9c0: 2020 2020 2020 2069 6620 7365 6c66 2e72         if self.r
+0000e9d0: 6967 6874 5f6f 7065 6e3a 0a20 2020 2020  ight_open:.     
+0000e9e0: 2020 2020 2020 2020 2020 2072 6967 6874             right
+0000e9f0: 203d 2027 2927 0a20 2020 2020 2020 2020   = ')'.         
+0000ea00: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
+0000ea10: 2020 2020 2020 2020 2072 6967 6874 203d           right =
+0000ea20: 2027 5d27 0a0a 2020 2020 2020 2020 2020   ']'..          
+0000ea30: 2020 7265 7475 726e 2070 2e5f 7072 696e    return p._prin
+0000ea40: 745f 7365 7128 7365 6c66 2e61 7267 735b  t_seq(self.args[
+0000ea50: 3a32 5d2c 206c 6566 742c 2072 6967 6874  :2], left, right
+0000ea60: 2c20 6465 6c69 6d69 7465 723d 273b 2027  , delimiter='; '
+0000ea70: 2069 6620 7365 6c66 2e69 735f 696e 7465   if self.is_inte
+0000ea80: 6765 7220 656c 7365 2027 2c20 2729 0a0a  ger else ', ')..
+0000ea90: 2020 2020 6465 6620 5f73 796d 7079 7374      def _sympyst
+0000eaa0: 7228 7365 6c66 2c20 5f29 3a20 0a20 2020  r(self, _): .   
+0000eab0: 2020 2020 2072 6574 7572 6e20 277b 6c65       return '{le
+0000eac0: 6674 5f6f 7065 6e7d 7b73 7461 7274 7d7b  ft_open}{start}{
+0000ead0: 7365 707d 207b 7374 6f70 7d7b 7269 6768  sep} {stop}{righ
+0000eae0: 745f 6f70 656e 7d27 2e66 6f72 6d61 7428  t_open}'.format(
+0000eaf0: 2a2a 7b27 7374 6172 7427 3a20 7365 6c66  **{'start': self
+0000eb00: 2e73 7461 7274 2c20 2773 746f 7027 3a20  .start, 'stop': 
+0000eb10: 7365 6c66 2e73 746f 702c 2027 7365 7027  self.stop, 'sep'
+0000eb20: 3a20 273b 2720 6966 2073 656c 662e 6973  : ';' if self.is
+0000eb30: 5f69 6e74 6567 6572 2065 6c73 6520 272c  _integer else ',
+0000eb40: 272c 0a20 2020 2020 2020 2020 2020 2020  ',.             
+0000eb50: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000eb60: 276c 6566 745f 6f70 656e 273a 2027 2827  'left_open': '('
+0000eb70: 2069 6620 7365 6c66 2e6c 6566 745f 6f70   if self.left_op
+0000eb80: 656e 2065 6c73 6520 275b 272c 0a20 2020  en else '[',.   
+0000eb90: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000eba0: 2020 2020 2020 2020 2020 2772 6967 6874            'right
+0000ebb0: 5f6f 7065 6e27 3a20 2729 2720 6966 2073  _open': ')' if s
+0000ebc0: 656c 662e 7269 6768 745f 6f70 656e 2065  elf.right_open e
+0000ebd0: 6c73 6520 275d 277d 290a 0a20 2020 2064  lse ']'})..    d
+0000ebe0: 6566 2068 616e 646c 655f 6669 6e69 7465  ef handle_finite
+0000ebf0: 5f73 6574 7328 7365 6c66 2c20 756e 6b29  _sets(self, unk)
+0000ec00: 3a0a 2020 2020 2020 2020 6966 2061 6c6c  :.        if all
+0000ec10: 2861 7267 2e64 6f6d 6169 6e20 696e 2073  (arg.domain in s
+0000ec20: 656c 6620 666f 7220 6172 6720 696e 2075  elf for arg in u
+0000ec30: 6e6b 2e61 7267 7329 3a0a 2020 2020 2020  nk.args):.      
+0000ec40: 2020 2020 2020 7265 7475 726e 2075 6e6b        return unk
+0000ec50: 0a0a 2020 2020 6465 6620 5f68 6173 6861  ..    def _hasha
+0000ec60: 626c 655f 636f 6e74 656e 7428 7365 6c66  ble_content(self
+0000ec70: 293a 0a20 2020 2020 2020 2022 2222 5265  ):.        """Re
+0000ec80: 7475 726e 2061 2074 7570 6c65 206f 6620  turn a tuple of 
+0000ec90: 696e 666f 726d 6174 696f 6e20 6162 6f75  information abou
+0000eca0: 7420 7365 6c66 2074 6861 7420 6361 6e20  t self that can 
+0000ecb0: 6265 2075 7365 6420 746f 0a20 2020 2020  be used to.     
+0000ecc0: 2020 2063 6f6d 7075 7465 2074 6865 2068     compute the h
+0000ecd0: 6173 682e 2049 6620 6120 636c 6173 7320  ash. If a class 
+0000ece0: 6465 6669 6e65 7320 6164 6469 7469 6f6e  defines addition
+0000ecf0: 616c 2061 7474 7269 6275 7465 732c 0a20  al attributes,. 
+0000ed00: 2020 2020 2020 206c 696b 6520 6060 6e61         like ``na
+0000ed10: 6d65 6060 2069 6e20 5379 6d62 6f6c 2c20  me`` in Symbol, 
+0000ed20: 7468 656e 2074 6869 7320 6d65 7468 6f64  then this method
+0000ed30: 2073 686f 756c 6420 6265 2075 7064 6174   should be updat
+0000ed40: 6564 0a20 2020 2020 2020 2061 6363 6f72  ed.        accor
+0000ed50: 6469 6e67 6c79 2074 6f20 7265 7475 726e  dingly to return
+0000ed60: 2073 7563 6820 7265 6c65 7661 6e74 2061   such relevant a
+0000ed70: 7474 7269 6275 7465 732e 0a0a 2020 2020  ttributes...    
+0000ed80: 2020 2020 4465 6669 6e69 6e67 206d 6f72      Defining mor
+0000ed90: 6520 7468 616e 205f 6861 7368 6162 6c65  e than _hashable
+0000eda0: 5f63 6f6e 7465 6e74 2069 7320 6e65 6365  _content is nece
+0000edb0: 7373 6172 7920 6966 205f 5f65 715f 5f20  ssary if __eq__ 
+0000edc0: 6861 730a 2020 2020 2020 2020 6265 656e  has.        been
+0000edd0: 2064 6566 696e 6564 2062 7920 6120 636c   defined by a cl
+0000ede0: 6173 732e 2053 6565 206e 6f74 6520 6162  ass. See note ab
+0000edf0: 6f75 7420 7468 6973 2069 6e20 4261 7369  out this in Basi
+0000ee00: 632e 5f5f 6571 5f5f 2e22 2222 0a0a 2020  c.__eq__."""..  
+0000ee10: 2020 2020 2020 7265 7475 726e 2073 656c        return sel
+0000ee20: 662e 5f61 7267 7320 2b20 2873 656c 662e  f._args + (self.
+0000ee30: 6c65 6674 5f6f 7065 6e2c 2073 656c 662e  left_open, self.
+0000ee40: 7269 6768 745f 6f70 656e 2c20 7365 6c66  right_open, self
+0000ee50: 2e69 735f 696e 7465 6765 7229 0a0a 2020  .is_integer)..  
+0000ee60: 2020 6465 6620 5f65 7661 6c5f 6973 5f65    def _eval_is_e
+0000ee70: 7874 656e 6465 645f 7261 7469 6f6e 616c  xtended_rational
+0000ee80: 2873 656c 6629 3a0a 2020 2020 2020 2020  (self):.        
+0000ee90: 2e2e 2e0a 2020 2020 0a20 2020 2064 6566  ....    .    def
+0000eea0: 205f 6576 616c 5f69 735f 6578 7465 6e64   _eval_is_extend
+0000eeb0: 6564 5f72 6561 6c28 7365 6c66 293a 0a20  ed_real(self):. 
+0000eec0: 2020 2020 2020 2072 6574 7572 6e20 5472         return Tr
+0000eed0: 7565 0a20 2020 2020 2020 200a 2020 2020  ue.        .    
+0000eee0: 6465 6620 5f65 7661 6c5f 6973 5f68 7970  def _eval_is_hyp
+0000eef0: 6572 5f72 6561 6c28 7365 6c66 293a 0a20  er_real(self):. 
+0000ef00: 2020 2020 2020 2072 6574 7572 6e20 5472         return Tr
+0000ef10: 7565 0a20 2020 200a 2020 2020 6465 6620  ue.    .    def 
+0000ef20: 5f65 7661 6c5f 6973 5f65 7874 656e 6465  _eval_is_extende
+0000ef30: 645f 6e65 6761 7469 7665 2873 656c 6629  d_negative(self)
+0000ef40: 3a0a 2020 2020 2020 2020 6966 2073 656c  :.        if sel
+0000ef50: 662e 6d69 6e28 292e 6973 5f65 7874 656e  f.min().is_exten
+0000ef60: 6465 645f 6e6f 6e6e 6567 6174 6976 653a  ded_nonnegative:
+0000ef70: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
+0000ef80: 7572 6e20 4661 6c73 650a 2020 2020 2020  urn False.      
+0000ef90: 2020 6966 2073 656c 662e 6d61 7828 292e    if self.max().
+0000efa0: 6973 5f65 7874 656e 6465 645f 6e65 6761  is_extended_nega
+0000efb0: 7469 7665 3a0a 2020 2020 2020 2020 2020  tive:.          
+0000efc0: 2020 7265 7475 726e 2054 7275 650a 0a20    return True.. 
+0000efd0: 2020 2064 6566 205f 6576 616c 5f69 735f     def _eval_is_
+0000efe0: 6578 7465 6e64 6564 5f70 6f73 6974 6976  extended_positiv
+0000eff0: 6528 7365 6c66 293a 0a20 2020 2020 2020  e(self):.       
+0000f000: 2069 6620 7365 6c66 2e6d 6178 2829 2e69   if self.max().i
+0000f010: 735f 6578 7465 6e64 6564 5f6e 6f6e 706f  s_extended_nonpo
+0000f020: 7369 7469 7665 3a0a 2020 2020 2020 2020  sitive:.        
+0000f030: 2020 2020 7265 7475 726e 2046 616c 7365      return False
+0000f040: 0a20 2020 2020 2020 2069 6620 7365 6c66  .        if self
+0000f050: 2e6d 696e 2829 2e69 735f 6578 7465 6e64  .min().is_extend
+0000f060: 6564 5f70 6f73 6974 6976 653a 0a20 2020  ed_positive:.   
+0000f070: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
+0000f080: 5472 7565 0a0a 2020 2020 6465 6620 5f65  True..    def _e
+0000f090: 7661 6c5f 6973 5f7a 6572 6f28 7365 6c66  val_is_zero(self
+0000f0a0: 293a 0a20 2020 2020 2020 2069 6620 7365  ):.        if se
+0000f0b0: 6c66 2e6d 696e 2829 2e69 735f 6578 7465  lf.min().is_exte
+0000f0c0: 6e64 6564 5f70 6f73 6974 6976 653a 0a20  nded_positive:. 
+0000f0d0: 2020 2020 2020 2020 2020 2072 6574 7572             retur
+0000f0e0: 6e20 4661 6c73 650a 2020 2020 2020 2020  n False.        
+0000f0f0: 6966 2073 656c 662e 6d61 7828 292e 6973  if self.max().is
+0000f100: 5f65 7874 656e 6465 645f 6e65 6761 7469  _extended_negati
+0000f110: 7665 3a0a 2020 2020 2020 2020 2020 2020  ve:.            
+0000f120: 7265 7475 726e 2046 616c 7365 0a0a 2020  return False..  
+0000f130: 2020 6465 6620 5f65 7661 6c5f 6973 5f61    def _eval_is_a
+0000f140: 6c67 6562 7261 6963 2873 656c 6629 3a0a  lgebraic(self):.
+0000f150: 2020 2020 2020 2020 6966 2073 656c 662e          if self.
+0000f160: 6973 5f69 6e74 6567 6572 3a0a 2020 2020  is_integer:.    
+0000f170: 2020 2020 2020 2020 7265 7475 726e 2054          return T
+0000f180: 7275 6520 2020 2020 2020 200a 0a20 2020  rue        ..   
+0000f190: 2064 6566 205f 6576 616c 5f69 735f 6669   def _eval_is_fi
+0000f1a0: 6e69 7465 2873 656c 6629 3a0a 2020 2020  nite(self):.    
+0000f1b0: 2020 2020 7265 7475 726e 2028 7365 6c66      return (self
+0000f1c0: 2e73 7461 7274 2e69 735f 6669 6e69 7465  .start.is_finite
+0000f1d0: 206f 7220 7365 6c66 2e6c 6566 745f 6f70   or self.left_op
+0000f1e0: 656e 2920 616e 6420 2873 656c 662e 7374  en) and (self.st
+0000f1f0: 6f70 2e69 735f 6669 6e69 7465 206f 7220  op.is_finite or 
+0000f200: 7365 6c66 2e72 6967 6874 5f6f 7065 6e29  self.right_open)
+0000f210: 0a20 2020 2020 2020 2020 2020 200a 2020  .            .  
+0000f220: 2020 6465 6620 5f6c 6174 6578 2873 656c    def _latex(sel
+0000f230: 662c 2070 293a 0a20 2020 2020 2020 2069  f, p):.        i
+0000f240: 6620 7365 6c66 2e73 7461 7274 203d 3d20  f self.start == 
+0000f250: 7365 6c66 2e73 746f 703a 0a20 2020 2020  self.stop:.     
+0000f260: 2020 2020 2020 2072 6574 7572 6e20 7222         return r"
+0000f270: 5c6c 6566 745c 7b25 735c 7269 6768 745c  \left\{%s\right\
+0000f280: 7d22 2025 2073 656c 662e 5f70 7269 6e74  }" % self._print
+0000f290: 2873 656c 662e 7374 6172 7429 0a20 2020  (self.start).   
+0000f2a0: 2020 2020 2065 6c69 6620 7365 6c66 2e73       elif self.s
+0000f2b0: 7461 7274 2e69 735f 4e65 6761 7469 7665  tart.is_Negative
+0000f2c0: 496e 6669 6e69 7479 3a0a 2020 2020 2020  Infinity:.      
+0000f2d0: 2020 2020 2020 6966 2073 656c 662e 7374        if self.st
+0000f2e0: 6f70 2e69 735f 496e 6669 6e69 7479 3a0a  op.is_Infinity:.
+0000f2f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000f300: 6966 2073 656c 662e 6c65 6674 5f6f 7065  if self.left_ope
+0000f310: 6e20 616e 6420 7365 6c66 2e72 6967 6874  n and self.right
+0000f320: 5f6f 7065 6e3a 200a 2020 2020 2020 2020  _open: .        
+0000f330: 2020 2020 2020 2020 2020 2020 7265 7475              retu
+0000f340: 726e 2072 225c 6d61 7468 6262 7b52 7d22  rn r"\mathbb{R}"
+0000f350: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000f360: 200a 2020 2020 2020 2020 2020 2020 656c   .            el
+0000f370: 6966 2073 656c 662e 7374 6f70 2e69 735f  if self.stop.is_
+0000f380: 5a65 726f 3a0a 2020 2020 2020 2020 2020  Zero:.          
+0000f390: 2020 2020 2020 6966 2073 656c 662e 6c65        if self.le
+0000f3a0: 6674 5f6f 7065 6e20 616e 6420 7365 6c66  ft_open and self
+0000f3b0: 2e72 6967 6874 5f6f 7065 6e3a 0a20 2020  .right_open:.   
 0000f3c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000f3d0: 7265 7475 726e 2065 203e 2073 2e73 7461  return e > s.sta
-0000f3e0: 7274 0a0a 2320 7065 7266 6f72 6d20 7365  rt..# perform se
-0000f3f0: 6c66 2069 6e20 7268 730a 2020 2020 6465  lf in rhs.    de
-0000f400: 6620 5f65 7661 6c5f 5375 6273 6574 2873  f _eval_Subset(s
-0000f410: 656c 662c 2072 6873 293a 0a20 2020 2020  elf, rhs):.     
-0000f420: 2020 2069 6620 7268 732e 6973 5f55 6e69     if rhs.is_Uni
-0000f430: 7665 7273 616c 5365 743a 0a20 2020 2020  versalSet:.     
-0000f440: 2020 2020 2020 2072 6574 7572 6e20 532e         return S.
-0000f450: 7472 7565 0a20 2020 2020 2020 2069 6620  true.        if 
-0000f460: 7268 732e 6973 5f49 6e74 6572 7661 6c3a  rhs.is_Interval:
-0000f470: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
-0000f480: 7365 6c66 2e6c 6566 745f 6f70 656e 203d  self.left_open =
-0000f490: 3d20 7268 732e 6c65 6674 5f6f 7065 6e3a  = rhs.left_open:
-0000f4a0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000f4b0: 2069 6620 7268 732e 7374 6172 7420 3d3d   if rhs.start ==
-0000f4c0: 2073 656c 662e 7374 6172 743a 0a20 2020   self.start:.   
-0000f4d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000f4e0: 2069 6620 7365 6c66 2e72 6967 6874 5f6f   if self.right_o
-0000f4f0: 7065 6e20 3d3d 2072 6873 2e72 6967 6874  pen == rhs.right
-0000f500: 5f6f 7065 6e20 6f72 2073 656c 662e 7269  _open or self.ri
-0000f510: 6768 745f 6f70 656e 2061 6e64 206e 6f74  ght_open and not
-0000f520: 2072 6873 2e72 6967 6874 5f6f 7065 6e3a   rhs.right_open:
-0000f530: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000f540: 2020 2020 2020 2020 2069 6620 7365 6c66           if self
-0000f550: 2e73 746f 7020 3c3d 2072 6873 2e73 746f  .stop <= rhs.sto
-0000f560: 703a 0a20 2020 2020 2020 2020 2020 2020  p:.             
-0000f570: 2020 2020 2020 2020 2020 2020 2020 2072                 r
-0000f580: 6574 7572 6e20 532e 7472 7565 0a20 2020  eturn S.true.   
-0000f590: 2020 2020 2020 2020 2069 6620 7365 6c66           if self
-0000f5a0: 2e72 6967 6874 5f6f 7065 6e20 3d3d 2072  .right_open == r
-0000f5b0: 6873 2e72 6967 6874 5f6f 7065 6e3a 0a20  hs.right_open:. 
-0000f5c0: 2020 2020 2020 2020 2020 2020 2020 2069                 i
-0000f5d0: 6620 7268 732e 7374 6f70 203d 3d20 7365  f rhs.stop == se
-0000f5e0: 6c66 2e73 746f 703a 0a20 2020 2020 2020  lf.stop:.       
-0000f5f0: 2020 2020 2020 2020 2020 2020 2069 6620               if 
-0000f600: 7365 6c66 2e6c 6566 745f 6f70 656e 203d  self.left_open =
-0000f610: 3d20 7268 732e 6c65 6674 5f6f 7065 6e20  = rhs.left_open 
-0000f620: 6f72 2073 656c 662e 6c65 6674 5f6f 7065  or self.left_ope
-0000f630: 6e20 616e 6420 6e6f 7420 7268 732e 6c65  n and not rhs.le
-0000f640: 6674 5f6f 7065 6e3a 0a20 2020 2020 2020  ft_open:.       
-0000f650: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000f660: 2069 6620 7365 6c66 2e73 7461 7274 203e   if self.start >
-0000f670: 3d20 7268 732e 7374 6172 743a 0a20 2020  = rhs.start:.   
-0000f680: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000f690: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
-0000f6a0: 532e 7472 7565 0a0a 2020 2020 4070 726f  S.true..    @pro
-0000f6b0: 7065 7274 790a 2020 2020 6465 6620 6b77  perty.    def kw
-0000f6c0: 6172 6773 2873 656c 6629 3a0a 2020 2020  args(self):.    
-0000f6d0: 2020 2020 7265 7475 726e 207b 276c 6566      return {'lef
-0000f6e0: 745f 6f70 656e 273a 2073 656c 662e 6c65  t_open': self.le
-0000f6f0: 6674 5f6f 7065 6e2c 2027 7269 6768 745f  ft_open, 'right_
-0000f700: 6f70 656e 273a 2073 656c 662e 7269 6768  open': self.righ
-0000f710: 745f 6f70 656e 7d20 2020 2020 2020 2020  t_open}         
-0000f720: 2020 2020 0a20 2020 2020 200a 2020 2020      .      .    
-0000f730: 4063 6c61 7373 6d65 7468 6f64 0a20 2020  @classmethod.   
-0000f740: 2064 6566 2061 7373 756d 6528 636c 732c   def assume(cls,
-0000f750: 202a 2a6b 7761 7267 7329 3a0a 2020 2020   **kwargs):.    
-0000f760: 2020 2020 6c65 6674 5f6f 7065 6e20 3d20      left_open = 
-0000f770: 4661 6c73 650a 2020 2020 2020 2020 7269  False.        ri
-0000f780: 6768 745f 6f70 656e 203d 2046 616c 7365  ght_open = False
-0000f790: 0a20 2020 2020 2020 2069 6620 6b77 6172  .        if kwar
-0000f7a0: 6773 2e67 6574 2827 706f 7369 7469 7665  gs.get('positive
-0000f7b0: 2729 3a0a 2020 2020 2020 2020 2020 2020  '):.            
-0000f7c0: 7374 6f70 203d 2053 2e49 6e66 696e 6974  stop = S.Infinit
-0000f7d0: 790a 2020 2020 2020 2020 2020 2020 7374  y.            st
-0000f7e0: 6172 7420 3d20 532e 5a65 726f 0a20 2020  art = S.Zero.   
-0000f7f0: 2020 2020 2020 2020 206c 6566 745f 6f70           left_op
-0000f800: 656e 203d 2054 7275 650a 2020 2020 2020  en = True.      
-0000f810: 2020 656c 6966 206b 7761 7267 732e 6765    elif kwargs.ge
-0000f820: 7428 276e 6f6e 6e65 6761 7469 7665 2729  t('nonnegative')
-0000f830: 3a0a 2020 2020 2020 2020 2020 2020 7374  :.            st
-0000f840: 6172 7420 3d20 532e 5a65 726f 0a20 2020  art = S.Zero.   
-0000f850: 2020 2020 2020 2020 2073 746f 7020 3d20           stop = 
-0000f860: 532e 496e 6669 6e69 7479 0a20 2020 2020  S.Infinity.     
-0000f870: 2020 2065 6c69 6620 6b77 6172 6773 2e67     elif kwargs.g
-0000f880: 6574 2827 6e65 6761 7469 7665 2729 3a0a  et('negative'):.
-0000f890: 2020 2020 2020 2020 2020 2020 7374 6172              star
-0000f8a0: 7420 3d20 532e 4e65 6761 7469 7665 496e  t = S.NegativeIn
-0000f8b0: 6669 6e69 7479 0a20 2020 2020 2020 2020  finity.         
-0000f8c0: 2020 2073 746f 7020 3d20 532e 5a65 726f     stop = S.Zero
-0000f8d0: 0a20 2020 2020 2020 2020 2020 2072 6967  .            rig
-0000f8e0: 6874 5f6f 7065 6e20 3d20 5472 7565 0a20  ht_open = True. 
-0000f8f0: 2020 2020 2020 2065 6c69 6620 6b77 6172         elif kwar
-0000f900: 6773 2e67 6574 2827 6e6f 6e70 6f73 6974  gs.get('nonposit
-0000f910: 6976 6527 293a 0a20 2020 2020 2020 2020  ive'):.         
-0000f920: 2020 2073 7461 7274 203d 2053 2e4e 6567     start = S.Neg
-0000f930: 6174 6976 6549 6e66 696e 6974 790a 2020  ativeInfinity.  
-0000f940: 2020 2020 2020 2020 2020 7374 6f70 203d            stop =
-0000f950: 2053 2e5a 6572 6f0a 2020 2020 2020 2020   S.Zero.        
-0000f960: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
-0000f970: 2020 7374 6172 7420 3d20 532e 4e65 6761    start = S.Nega
-0000f980: 7469 7665 496e 6669 6e69 7479 0a20 2020  tiveInfinity.   
-0000f990: 2020 2020 2020 2020 2073 746f 7020 3d20           stop = 
-0000f9a0: 532e 496e 6669 6e69 7479 0a20 2020 2020  S.Infinity.     
-0000f9b0: 2020 2072 6574 7572 6e20 636c 7328 7374     return cls(st
-0000f9c0: 6172 742c 2073 746f 702c 206c 6566 745f  art, stop, left_
-0000f9d0: 6f70 656e 3d6c 6566 745f 6f70 656e 2c20  open=left_open, 
-0000f9e0: 7269 6768 745f 6f70 656e 3d72 6967 6874  right_open=right
-0000f9f0: 5f6f 7065 6e29 0a20 2020 2020 2020 200a  _open).        .
-0000fa00: 2020 2020 6465 6620 6164 6a75 7374 5f64      def adjust_d
-0000fa10: 6f6d 6169 6e28 7365 6c66 2c20 782c 202a  omain(self, x, *
-0000fa20: 636f 6e64 293a 0a20 2020 2020 2020 2069  cond):.        i
-0000fa30: 6620 7365 6c66 2e73 7461 7274 2e5f 6861  f self.start._ha
-0000fa40: 7328 7829 3a0a 2020 2020 2020 2020 2020  s(x):.          
-0000fa50: 2020 7365 6c66 203d 2073 656c 662e 636f    self = self.co
-0000fa60: 7079 2873 7461 7274 3d53 2e4e 6567 6174  py(start=S.Negat
-0000fa70: 6976 6549 6e66 696e 6974 7929 0a20 2020  iveInfinity).   
-0000fa80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000fa90: 200a 2020 2020 2020 2020 6966 2073 656c   .        if sel
-0000faa0: 662e 7374 6f70 2e5f 6861 7328 7829 3a0a  f.stop._has(x):.
-0000fab0: 2020 2020 2020 2020 2020 2020 7365 6c66              self
-0000fac0: 203d 2073 656c 662e 636f 7079 2873 746f   = self.copy(sto
-0000fad0: 703d 532e 496e 6669 6e69 7479 290a 2020  p=S.Infinity).  
-0000fae0: 2020 2020 2020 2020 2020 0a20 2020 2020            .     
-0000faf0: 2020 2072 6574 7572 6e20 7365 6c66 0a0a     return self..
-0000fb00: 2020 2020 6465 6620 636f 6e64 6974 696f      def conditio
-0000fb10: 6e61 6c6c 795f 636f 6e74 6169 6e73 2873  nally_contains(s
-0000fb20: 656c 662c 2066 7429 3a0a 2020 2020 2020  elf, ft):.      
-0000fb30: 2020 612c 2062 203d 2073 656c 662e 6172    a, b = self.ar
-0000fb40: 6773 0a20 2020 2020 2020 2069 6620 7365  gs.        if se
-0000fb50: 6c66 2e6c 6566 745f 6f70 656e 3a0a 2020  lf.left_open:.  
-0000fb60: 2020 2020 2020 2020 2020 6966 2073 656c            if sel
-0000fb70: 662e 7269 6768 745f 6f70 656e 3a0a 2020  f.right_open:.  
-0000fb80: 2020 2020 2020 2020 2020 2020 2020 6966                if
-0000fb90: 2061 203c 2066 7420 3c20 623a 0a20 2020   a < ft < b:.   
-0000fba0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000fbb0: 2072 6574 7572 6e20 5472 7565 0a20 2020   return True.   
-0000fbc0: 2020 2020 2020 2020 2065 6c73 653a 0a20           else:. 
-0000fbd0: 2020 2020 2020 2020 2020 2020 2020 2069                 i
-0000fbe0: 6620 6120 3c20 6674 203c 3d20 623a 0a20  f a < ft <= b:. 
+0000f3d0: 2072 6574 7572 6e20 7222 5c6d 6174 6862   return r"\mathb
+0000f3e0: 627b 527d 5e2d 220a 2020 2020 2020 2020  b{R}^-".        
+0000f3f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000f400: 2020 2020 2020 2020 2020 2020 0a20 2020              .   
+0000f410: 2020 2020 2065 6c69 6620 7365 6c66 2e73       elif self.s
+0000f420: 746f 702e 6973 5f49 6e66 696e 6974 793a  top.is_Infinity:
+0000f430: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
+0000f440: 7365 6c66 2e73 7461 7274 2e69 735f 5a65  self.start.is_Ze
+0000f450: 726f 3a0a 2020 2020 2020 2020 2020 2020  ro:.            
+0000f460: 2020 2020 6966 2073 656c 662e 6c65 6674      if self.left
+0000f470: 5f6f 7065 6e20 616e 6420 7365 6c66 2e72  _open and self.r
+0000f480: 6967 6874 5f6f 7065 6e3a 0a20 2020 2020  ight_open:.     
+0000f490: 2020 2020 2020 2020 2020 2020 2020 2072                 r
+0000f4a0: 6574 7572 6e20 7222 5c6d 6174 6862 627b  eturn r"\mathbb{
+0000f4b0: 527d 5e2b 220a 2020 2020 2020 2020 0a20  R}^+".        . 
+0000f4c0: 2020 2020 2020 2069 6620 7365 6c66 2e6c         if self.l
+0000f4d0: 6566 745f 6f70 656e 3a0a 2020 2020 2020  eft_open:.      
+0000f4e0: 2020 2020 2020 6c65 6674 203d 2027 2827        left = '('
+0000f4f0: 0a20 2020 2020 2020 2065 6c73 653a 0a20  .        else:. 
+0000f500: 2020 2020 2020 2020 2020 206c 6566 7420             left 
+0000f510: 3d20 275b 270a 0a20 2020 2020 2020 2069  = '['..        i
+0000f520: 6620 7365 6c66 2e72 6967 6874 5f6f 7065  f self.right_ope
+0000f530: 6e3a 0a20 2020 2020 2020 2020 2020 2072  n:.            r
+0000f540: 6967 6874 203d 2027 2927 0a20 2020 2020  ight = ')'.     
+0000f550: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
+0000f560: 2020 2020 2072 6967 6874 203d 2027 5d27       right = ']'
+0000f570: 0a0a 2020 2020 2020 2020 7265 7475 726e  ..        return
+0000f580: 2072 225c 6c65 6674 2573 2573 2c20 2573   r"\left%s%s, %s
+0000f590: 5c72 6967 6874 2573 2220 2520 286c 6566  \right%s" % (lef
+0000f5a0: 742c 2070 2e5f 7072 696e 7428 7365 6c66  t, p._print(self
+0000f5b0: 2e73 7461 7274 292c 2070 2e5f 7072 696e  .start), p._prin
+0000f5c0: 7428 7365 6c66 2e73 746f 7029 2c20 7269  t(self.stop), ri
+0000f5d0: 6768 7429 0a0a 2020 2020 4063 6c61 7373  ght)..    @class
+0000f5e0: 6d65 7468 6f64 0a20 2020 2064 6566 2073  method.    def s
+0000f5f0: 696d 706c 6966 795f 456c 656d 656e 7428  implify_Element(
+0000f600: 636c 732c 2073 656c 662c 2065 2c20 7329  cls, self, e, s)
+0000f610: 3a20 0a20 2020 2020 2020 2069 6620 732e  : .        if s.
+0000f620: 7374 6172 742e 6973 5f4e 6567 6174 6976  start.is_Negativ
+0000f630: 6549 6e66 696e 6974 793a 0a20 2020 2020  eInfinity:.     
+0000f640: 2020 2020 2020 2066 726f 6d20 7379 6d70         from symp
+0000f650: 7920 696d 706f 7274 204c 6573 732c 204c  y import Less, L
+0000f660: 6573 7345 7175 616c 0a20 2020 2020 2020  essEqual.       
+0000f670: 2020 2020 2066 756e 6320 3d20 4c65 7373       func = Less
+0000f680: 2069 6620 732e 7269 6768 745f 6f70 656e   if s.right_open
+0000f690: 2065 6c73 6520 4c65 7373 4571 7561 6c0a   else LessEqual.
+0000f6a0: 2020 2020 2020 2020 2020 2020 6966 206e              if n
+0000f6b0: 6f74 2062 6f6f 6c28 732e 6c65 6674 5f6f  ot bool(s.left_o
+0000f6c0: 7065 6e29 205e 2062 6f6f 6c28 652e 6973  pen) ^ bool(e.is
+0000f6d0: 5f66 696e 6974 6529 3a0a 2020 2020 2020  _finite):.      
+0000f6e0: 2020 2020 2020 2020 2020 7265 7475 726e            return
+0000f6f0: 2066 756e 6328 652c 2073 2e73 746f 7029   func(e, s.stop)
+0000f700: 2e73 696d 706c 6966 7928 290a 2020 2020  .simplify().    
+0000f710: 2020 2020 2020 2020 0a20 2020 2020 2020          .       
+0000f720: 2069 6620 732e 7374 6f70 2e69 735f 496e   if s.stop.is_In
+0000f730: 6669 6e69 7479 3a0a 2020 2020 2020 2020  finity:.        
+0000f740: 2020 2020 6672 6f6d 2073 796d 7079 2069      from sympy i
+0000f750: 6d70 6f72 7420 4772 6561 7465 722c 2047  mport Greater, G
+0000f760: 7265 6174 6572 4571 7561 6c0a 2020 2020  reaterEqual.    
+0000f770: 2020 2020 2020 2020 6675 6e63 203d 2047          func = G
+0000f780: 7265 6174 6572 2069 6620 732e 6c65 6674  reater if s.left
+0000f790: 5f6f 7065 6e20 656c 7365 2047 7265 6174  _open else Great
+0000f7a0: 6572 4571 7561 6c0a 2020 2020 2020 2020  erEqual.        
+0000f7b0: 2020 2020 6966 206e 6f74 2062 6f6f 6c28      if not bool(
+0000f7c0: 732e 7269 6768 745f 6f70 656e 2920 5e20  s.right_open) ^ 
+0000f7d0: 626f 6f6c 2865 2e69 735f 6669 6e69 7465  bool(e.is_finite
+0000f7e0: 293a 0a20 2020 2020 2020 2020 2020 2020  ):.             
+0000f7f0: 2020 2072 6574 7572 6e20 6675 6e63 2865     return func(e
+0000f800: 2c20 732e 7374 6172 7429 2e73 696d 706c  , s.start).simpl
+0000f810: 6966 7928 290a 2020 2020 2020 2020 0a20  ify().        . 
+0000f820: 2020 2020 2020 2063 6f6d 706c 656d 656e         complemen
+0000f830: 7420 3d20 652e 646f 6d61 696e 202d 2073  t = e.domain - s
+0000f840: 0a20 2020 2020 2020 2069 6620 636f 6d70  .        if comp
+0000f850: 6c65 6d65 6e74 2e69 735f 4669 6e69 7465  lement.is_Finite
+0000f860: 5365 743a 0a20 2020 2020 2020 2020 2020  Set:.           
+0000f870: 2072 6574 7572 6e20 7365 6c66 2e69 6e76   return self.inv
+0000f880: 6572 745f 7479 7065 2865 2c20 636f 6d70  ert_type(e, comp
+0000f890: 6c65 6d65 6e74 292e 7369 6d70 6c69 6679  lement).simplify
+0000f8a0: 2829 2020 2020 2020 2020 2020 2020 2020  ()              
+0000f8b0: 2020 0a20 2020 2020 2020 2020 2020 200a    .            .
+0000f8c0: 2020 2020 4063 6c61 7373 6d65 7468 6f64      @classmethod
+0000f8d0: 0a20 2020 2064 6566 2073 696d 706c 6966  .    def simplif
+0000f8e0: 795f 4e6f 7445 6c65 6d65 6e74 2863 6c73  y_NotElement(cls
+0000f8f0: 2c20 7365 6c66 2c20 652c 2073 293a 0a20  , self, e, s):. 
+0000f900: 2020 2020 2020 2069 6620 652e 6973 5f72         if e.is_r
+0000f910: 6561 6c3a 0a20 2020 2020 2020 2020 2020  eal:.           
+0000f920: 2069 6620 732e 7374 6f70 2e69 735f 696e   if s.stop.is_in
+0000f930: 6669 6e69 7465 3a0a 2020 2020 2020 2020  finite:.        
+0000f940: 2020 2020 2020 2020 6966 2073 2e6c 6566          if s.lef
+0000f950: 745f 6f70 656e 3a0a 2020 2020 2020 2020  t_open:.        
+0000f960: 2020 2020 2020 2020 2020 2020 7265 7475              retu
+0000f970: 726e 2065 203c 3d20 732e 7374 6172 7420  rn e <= s.start 
+0000f980: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000f990: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
+0000f9a0: 2020 2020 2020 2020 2020 2072 6574 7572             retur
+0000f9b0: 6e20 6520 3c20 732e 7374 6172 740a 2020  n e < s.start.  
+0000f9c0: 2020 2020 2020 2020 2020 656c 6966 2073            elif s
+0000f9d0: 2e73 7461 7274 2e69 735f 696e 6669 6e69  .start.is_infini
+0000f9e0: 7465 3a0a 2020 2020 2020 2020 2020 2020  te:.            
+0000f9f0: 2020 2020 6966 2073 2e72 6967 6874 5f6f      if s.right_o
+0000fa00: 7065 6e3a 0a20 2020 2020 2020 2020 2020  pen:.           
+0000fa10: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
+0000fa20: 6520 3e3d 2073 2e73 7461 7274 200a 2020  e >= s.start .  
+0000fa30: 2020 2020 2020 2020 2020 2020 2020 656c                el
+0000fa40: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
+0000fa50: 2020 2020 2020 2020 7265 7475 726e 2065          return e
+0000fa60: 203e 2073 2e73 7461 7274 0a0a 2320 7065   > s.start..# pe
+0000fa70: 7266 6f72 6d20 7365 6c66 2069 6e20 7268  rform self in rh
+0000fa80: 730a 2020 2020 6465 6620 5f65 7661 6c5f  s.    def _eval_
+0000fa90: 5375 6273 6574 2873 656c 662c 2072 6873  Subset(self, rhs
+0000faa0: 293a 0a20 2020 2020 2020 2069 6620 7268  ):.        if rh
+0000fab0: 732e 6973 5f55 6e69 7665 7273 616c 5365  s.is_UniversalSe
+0000fac0: 743a 0a20 2020 2020 2020 2020 2020 2072  t:.            r
+0000fad0: 6574 7572 6e20 532e 7472 7565 0a20 2020  eturn S.true.   
+0000fae0: 2020 2020 2069 6620 7268 732e 6973 5f49       if rhs.is_I
+0000faf0: 6e74 6572 7661 6c3a 0a20 2020 2020 2020  nterval:.       
+0000fb00: 2020 2020 2069 6620 7365 6c66 2e6c 6566       if self.lef
+0000fb10: 745f 6f70 656e 203d 3d20 7268 732e 6c65  t_open == rhs.le
+0000fb20: 6674 5f6f 7065 6e3a 0a20 2020 2020 2020  ft_open:.       
+0000fb30: 2020 2020 2020 2020 2069 6620 7268 732e           if rhs.
+0000fb40: 7374 6172 7420 3d3d 2073 656c 662e 7374  start == self.st
+0000fb50: 6172 743a 0a20 2020 2020 2020 2020 2020  art:.           
+0000fb60: 2020 2020 2020 2020 2069 6620 7365 6c66           if self
+0000fb70: 2e72 6967 6874 5f6f 7065 6e20 3d3d 2072  .right_open == r
+0000fb80: 6873 2e72 6967 6874 5f6f 7065 6e20 6f72  hs.right_open or
+0000fb90: 2073 656c 662e 7269 6768 745f 6f70 656e   self.right_open
+0000fba0: 2061 6e64 206e 6f74 2072 6873 2e72 6967   and not rhs.rig
+0000fbb0: 6874 5f6f 7065 6e3a 0a20 2020 2020 2020  ht_open:.       
+0000fbc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000fbd0: 2069 6620 7365 6c66 2e73 746f 7020 3c3d   if self.stop <=
+0000fbe0: 2072 6873 2e73 746f 703a 0a20 2020 2020   rhs.stop:.     
 0000fbf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000fc00: 2020 2072 6574 7572 6e20 5472 7565 0a20     return True. 
-0000fc10: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
-0000fc20: 2020 2020 2020 2020 2069 6620 7365 6c66           if self
-0000fc30: 2e72 6967 6874 5f6f 7065 6e3a 0a20 2020  .right_open:.   
-0000fc40: 2020 2020 2020 2020 2020 2020 2069 6620               if 
-0000fc50: 6120 3c3d 2066 7420 3c20 623a 0a20 2020  a <= ft < b:.   
-0000fc60: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000fc70: 2072 6574 7572 6e20 5472 7565 0a20 2020   return True.   
-0000fc80: 2020 2020 2020 2020 2065 6c73 653a 0a20           else:. 
-0000fc90: 2020 2020 2020 2020 2020 2020 2020 2069                 i
-0000fca0: 6620 6120 3c3d 2066 7420 3c3d 2062 3a0a  f a <= ft <= b:.
-0000fcb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000fcc0: 2020 2020 7265 7475 726e 2054 7275 650a      return True.
-0000fcd0: 0a20 2020 2020 2020 2066 7265 655f 7379  .        free_sy
-0000fce0: 6d62 6f6c 7320 3d20 6674 2e66 7265 655f  mbols = ft.free_
-0000fcf0: 7379 6d62 6f6c 730a 2020 2020 2020 2020  symbols.        
-0000fd00: 6966 206c 656e 2866 7265 655f 7379 6d62  if len(free_symb
-0000fd10: 6f6c 7329 203d 3d20 313a 0a20 2020 2020  ols) == 1:.     
-0000fd20: 2020 2020 2020 2074 2c20 3d20 6672 6565         t, = free
-0000fd30: 5f73 796d 626f 6c73 0a20 2020 2020 2020  _symbols.       
-0000fd40: 2020 2020 2069 6620 6e6f 7420 742e 7368       if not t.sh
-0000fd50: 6170 653a 0a20 2020 2020 2020 2020 2020  ape:.           
-0000fd60: 2020 2020 2063 6f6e 6420 3d20 6220 2d20       cond = b - 
-0000fd70: 6120 3e20 300a 2020 2020 2020 2020 2020  a > 0.          
-0000fd80: 2020 2020 2020 6966 2063 6f6e 642e 5f68        if cond._h
-0000fd90: 6173 2874 293a 0a20 2020 2020 2020 2020  as(t):.         
-0000fda0: 2020 2020 2020 2020 2020 205f 7420 3d20             _t = 
-0000fdb0: 742e 636f 7079 2864 6f6d 6169 6e3d 636f  t.copy(domain=co
-0000fdc0: 6e64 2e64 6f6d 6169 6e5f 636f 6e64 6974  nd.domain_condit
-0000fdd0: 696f 6e65 6428 7429 290a 2020 2020 2020  ioned(t)).      
-0000fde0: 2020 2020 2020 2020 2020 2020 2020 0a20                . 
-0000fdf0: 2020 2020 2020 2020 2020 2020 2020 2061                 a
-0000fe00: 5f20 3d20 612e 5f73 7562 7328 742c 205f  _ = a._subs(t, _
-0000fe10: 7429 0a20 2020 2020 2020 2020 2020 2020  t).             
-0000fe20: 2020 2066 745f 203d 2066 742e 5f73 7562     ft_ = ft._sub
-0000fe30: 7328 742c 205f 7429 0a20 2020 2020 2020  s(t, _t).       
-0000fe40: 2020 2020 2020 2020 2062 5f20 3d20 622e           b_ = b.
-0000fe50: 5f73 7562 7328 742c 205f 7429 0a20 2020  _subs(t, _t).   
-0000fe60: 2020 2020 2020 2020 2020 2020 200a 2020               .  
-0000fe70: 2020 2020 2020 2020 2020 2020 2020 6966                if
-0000fe80: 2073 656c 662e 6c65 6674 5f6f 7065 6e3a   self.left_open:
-0000fe90: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000fea0: 2020 2020 2069 6620 7365 6c66 2e72 6967       if self.rig
-0000feb0: 6874 5f6f 7065 6e3a 0a20 2020 2020 2020  ht_open:.       
-0000fec0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000fed0: 2069 6620 615f 203c 2066 745f 203c 2062   if a_ < ft_ < b
-0000fee0: 5f3a 0a20 2020 2020 2020 2020 2020 2020  _:.             
-0000fef0: 2020 2020 2020 2020 2020 2020 2020 2072                 r
-0000ff00: 6574 7572 6e20 5472 7565 0a20 2020 2020  eturn True.     
-0000ff10: 2020 2020 2020 2020 2020 2020 2020 2065                 e
-0000ff20: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
-0000ff30: 2020 2020 2020 2020 2020 2020 2069 6620               if 
-0000ff40: 615f 203c 2066 745f 203c 3d20 625f 3a0a  a_ < ft_ <= b_:.
-0000ff50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ff60: 2020 2020 2020 2020 2020 2020 7265 7475              retu
-0000ff70: 726e 2054 7275 650a 2020 2020 2020 2020  rn True.        
-0000ff80: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
-0000ff90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ffa0: 2020 6966 2073 656c 662e 7269 6768 745f    if self.right_
-0000ffb0: 6f70 656e 3a0a 2020 2020 2020 2020 2020  open:.          
-0000ffc0: 2020 2020 2020 2020 2020 2020 2020 6966                if
-0000ffd0: 2061 5f20 3c3d 2066 745f 203c 2062 5f3a   a_ <= ft_ < b_:
-0000ffe0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000fff0: 2020 2020 2020 2020 2020 2020 2072 6574               ret
-00010000: 7572 6e20 5472 7565 0a20 2020 2020 2020  urn True.       
-00010010: 2020 2020 2020 2020 2020 2020 2065 6c73               els
-00010020: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
-00010030: 2020 2020 2020 2020 2020 2069 6620 615f             if a_
-00010040: 203c 3d20 6674 5f20 3c3d 2062 5f3a 0a20   <= ft_ <= b_:. 
-00010050: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00010060: 2020 2020 2020 2020 2020 2072 6574 7572             retur
-00010070: 6e20 5472 7565 0a20 2020 2020 2020 2020  n True.         
-00010080: 2020 2020 2020 2020 2020 200a 2020 2020             .    
-00010090: 2020 2020 2320 6769 7665 6e3a 2061 203c      # given: a <
-000100a0: 2062 0a20 2020 2020 2020 2023 2069 6d70   b.        # imp
-000100b0: 6c79 3a20 6120 3c20 7420 3c20 620a 2020  ly: a < t < b.  
-000100c0: 2020 2020 2020 6661 203d 2028 6674 202d        fa = (ft -
-000100d0: 2061 2920 2f20 2862 202d 2061 290a 2020   a) / (b - a).  
-000100e0: 2020 2020 2020 6661 203d 2066 612e 7261        fa = fa.ra
-000100f0: 7473 696d 7028 290a 2020 2020 2020 2020  tsimp().        
-00010100: 6966 2073 656c 662e 6c65 6674 5f6f 7065  if self.left_ope
-00010110: 6e20 616e 6420 6661 203e 2030 206f 7220  n and fa > 0 or 
-00010120: 6e6f 7420 7365 6c66 2e6c 6566 745f 6f70  not self.left_op
-00010130: 656e 2061 6e64 2066 6120 3e3d 2030 3a20  en and fa >= 0: 
-00010140: 0a20 2020 2020 2020 2020 2020 2066 6220  .            fb 
-00010150: 3d20 2866 7420 2d20 6229 202f 2028 6220  = (ft - b) / (b 
-00010160: 2d20 6129 0a20 2020 2020 2020 2020 2020  - a).           
-00010170: 2066 6220 3d20 6662 2e72 6174 7369 6d70   fb = fb.ratsimp
-00010180: 2829 0a20 2020 2020 2020 2020 2020 2069  ().            i
-00010190: 6620 7365 6c66 2e72 6967 6874 5f6f 7065  f self.right_ope
-000101a0: 6e20 616e 6420 6662 203c 2030 206f 7220  n and fb < 0 or 
-000101b0: 6e6f 7420 7365 6c66 2e72 6967 6874 5f6f  not self.right_o
-000101c0: 7065 6e20 616e 6420 6662 203c 3d20 303a  pen and fb <= 0:
-000101d0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000101e0: 2072 6574 7572 6e20 5472 7565 0a0a 2020   return True..  
-000101f0: 2020 6465 6620 5f65 7661 6c5f 6973 5f66    def _eval_is_f
-00010200: 696e 6974 6573 6574 2873 656c 6629 3a0a  initeset(self):.
-00010210: 2020 2020 2020 2020 612c 2062 203d 2073          a, b = s
-00010220: 656c 662e 6172 6773 0a20 2020 2020 2020  elf.args.       
-00010230: 2069 6620 6120 3c20 623a 0a20 2020 2020   if a < b:.     
-00010240: 2020 2020 2020 2072 6574 7572 6e20 4661         return Fa
-00010250: 6c73 650a 0a20 2020 2040 7072 6f70 6572  lse..    @proper
-00010260: 7479 0a20 2020 2064 6566 2069 735f 636c  ty.    def is_cl
-00010270: 6f73 6564 2873 656c 6629 3a0a 2020 2020  osed(self):.    
-00010280: 2020 2020 7265 7475 726e 206e 6f74 2073      return not s
-00010290: 656c 662e 6c65 6674 5f6f 7065 6e20 616e  elf.left_open an
-000102a0: 6420 6e6f 7420 7365 6c66 2e72 6967 6874  d not self.right
-000102b0: 5f6f 7065 6e0a 2020 2020 0a20 2020 2040  _open.    .    @
-000102c0: 7072 6f70 6572 7479 0a20 2020 2064 6566  property.    def
-000102d0: 2069 735f 6f70 656e 2873 656c 6629 3a0a   is_open(self):.
-000102e0: 2020 2020 2020 2020 7265 7475 726e 2073          return s
-000102f0: 656c 662e 6c65 6674 5f6f 7065 6e20 616e  elf.left_open an
-00010300: 6420 7365 6c66 2e72 6967 6874 5f6f 7065  d self.right_ope
-00010310: 6e0a 0a20 2020 2040 6361 6368 6569 740a  n..    @cacheit.
-00010320: 2020 2020 6465 6620 736f 7274 5f6b 6579      def sort_key
-00010330: 2873 656c 662c 206f 7264 6572 3d4e 6f6e  (self, order=Non
-00010340: 6529 3a0a 2020 2020 2020 2020 6172 6773  e):.        args
-00010350: 203d 2073 656c 662e 5f73 6f72 7465 645f   = self._sorted_
-00010360: 6172 6773 0a20 2020 2020 2020 2061 7267  args.        arg
-00010370: 7320 3d20 6c65 6e28 6172 6773 292c 2074  s = len(args), t
-00010380: 7570 6c65 2861 7267 2e63 6c61 7373 5f6b  uple(arg.class_k
-00010390: 6579 2829 2066 6f72 2061 7267 2069 6e20  ey() for arg in 
-000103a0: 6172 6773 292c 2074 7570 6c65 2861 7267  args), tuple(arg
-000103b0: 2e73 6f72 745f 6b65 7928 6f72 6465 723d  .sort_key(order=
-000103c0: 6f72 6465 7229 2066 6f72 2061 7267 2069  order) for arg i
-000103d0: 6e20 6172 6773 290a 2020 2020 2020 2020  n args).        
-000103e0: 6c65 6674 5f63 6c6f 7365 6420 3d20 696e  left_closed = in
-000103f0: 7428 6e6f 7420 7365 6c66 2e6c 6566 745f  t(not self.left_
-00010400: 6f70 656e 290a 2020 2020 2020 2020 7269  open).        ri
-00010410: 6768 745f 636c 6f73 6564 203d 2069 6e74  ght_closed = int
-00010420: 286e 6f74 2073 656c 662e 7269 6768 745f  (not self.right_
-00010430: 6f70 656e 290a 2020 2020 2020 2020 7265  open).        re
-00010440: 7475 726e 2028 2a73 656c 662e 636c 6173  turn (*self.clas
-00010450: 735f 6b65 7928 292c 206c 6566 745f 636c  s_key(), left_cl
-00010460: 6f73 6564 2c20 7269 6768 745f 636c 6f73  osed, right_clos
-00010470: 6564 292c 2061 7267 732c 2053 2e4f 6e65  ed), args, S.One
-00010480: 2e73 6f72 745f 6b65 7928 292c 2053 2e4f  .sort_key(), S.O
-00010490: 6e65 0a0a 0a63 6c61 7373 2055 6e69 6f6e  ne...class Union
-000104a0: 2853 6574 2c20 4c61 7474 6963 654f 702c  (Set, LatticeOp,
-000104b0: 2045 7661 6c66 4d69 7869 6e29 3a0a 2020   EvalfMixin):.  
-000104c0: 2020 2222 220a 2020 2020 5265 7072 6573    """.    Repres
-000104d0: 656e 7473 2061 2075 6e69 6f6e 206f 6620  ents a union of 
-000104e0: 7365 7473 2061 7320 6120 3a63 6c61 7373  sets as a :class
-000104f0: 3a60 5365 7460 2e0a 0a20 2020 2045 7861  :`Set`...    Exa
-00010500: 6d70 6c65 730a 2020 2020 3d3d 3d3d 3d3d  mples.    ======
-00010510: 3d3d 0a0a 2020 2020 3e3e 3e20 6672 6f6d  ==..    >>> from
-00010520: 2073 796d 7079 2069 6d70 6f72 7420 556e   sympy import Un
-00010530: 696f 6e2c 2049 6e74 6572 7661 6c0a 2020  ion, Interval.  
-00010540: 2020 3e3e 3e20 556e 696f 6e28 496e 7465    >>> Union(Inte
-00010550: 7276 616c 2831 2c20 3229 2c20 496e 7465  rval(1, 2), Inte
-00010560: 7276 616c 2833 2c20 3429 290a 2020 2020  rval(3, 4)).    
-00010570: 556e 696f 6e28 496e 7465 7276 616c 2831  Union(Interval(1
-00010580: 2c20 3229 2c20 496e 7465 7276 616c 2833  , 2), Interval(3
-00010590: 2c20 3429 290a 0a20 2020 2054 6865 2055  , 4))..    The U
-000105a0: 6e69 6f6e 2063 6f6e 7374 7275 6374 6f72  nion constructor
-000105b0: 2077 696c 6c20 616c 7761 7973 2074 7279   will always try
-000105c0: 2074 6f20 6d65 7267 6520 6f76 6572 6c61   to merge overla
-000105d0: 7070 696e 6720 696e 7465 7276 616c 732c  pping intervals,
-000105e0: 0a20 2020 2069 6620 706f 7373 6962 6c65  .    if possible
-000105f0: 2e20 466f 7220 6578 616d 706c 653a 0a0a  . For example:..
-00010600: 2020 2020 3e3e 3e20 556e 696f 6e28 496e      >>> Union(In
-00010610: 7465 7276 616c 2831 2c20 3229 2c20 496e  terval(1, 2), In
-00010620: 7465 7276 616c 2832 2c20 3329 290a 2020  terval(2, 3)).  
-00010630: 2020 496e 7465 7276 616c 2831 2c20 3329    Interval(1, 3)
-00010640: 0a0a 2020 2020 5365 6520 416c 736f 0a20  ..    See Also. 
-00010650: 2020 203d 3d3d 3d3d 3d3d 3d0a 0a20 2020     ========..   
-00010660: 2049 6e74 6572 7365 6374 696f 6e0a 0a20   Intersection.. 
-00010670: 2020 2052 6566 6572 656e 6365 730a 2020     References.  
-00010680: 2020 3d3d 3d3d 3d3d 3d3d 3d3d 0a0a 2020    ==========..  
-00010690: 2020 2e2e 205b 315d 2068 7474 7073 3a2f    .. [1] https:/
-000106a0: 2f65 6e2e 7769 6b69 7065 6469 612e 6f72  /en.wikipedia.or
-000106b0: 672f 7769 6b69 2f55 6e69 6f6e 5f25 3238  g/wiki/Union_%28
-000106c0: 7365 745f 7468 656f 7279 2532 390a 2020  set_theory%29.  
-000106d0: 2020 2222 220a 0a20 2020 2064 6566 205f    """..    def _
-000106e0: 5f6e 6577 5f5f 2863 6c73 2c20 2a61 7267  _new__(cls, *arg
-000106f0: 732c 202a 2a6b 7761 7267 7329 3a0a 2020  s, **kwargs):.  
-00010700: 2020 2020 2020 6576 616c 7561 7465 203d        evaluate =
-00010710: 206b 7761 7267 732e 6765 7428 2765 7661   kwargs.get('eva
-00010720: 6c75 6174 6527 2c20 676c 6f62 616c 5f70  luate', global_p
-00010730: 6172 616d 6574 6572 732e 6576 616c 7561  arameters.evalua
-00010740: 7465 290a 0a20 2020 2020 2020 2023 2066  te)..        # f
-00010750: 6c61 7474 656e 2069 6e70 7574 7320 746f  latten inputs to
-00010760: 206d 6572 6765 2069 6e74 6572 7365 6374   merge intersect
-00010770: 696f 6e73 2061 6e64 2069 7465 7261 626c  ions and iterabl
-00010780: 6573 0a20 2020 2020 2020 205b 2a61 7267  es.        [*arg
-00010790: 735d 203d 206d 6170 285f 7379 6d70 6966  s] = map(_sympif
-000107a0: 792c 2061 7267 7329 0a20 2020 2020 2020  y, args).       
-000107b0: 2069 6620 6c65 6e28 6172 6773 2920 3d3d   if len(args) ==
-000107c0: 2031 3a0a 2020 2020 2020 2020 2020 2020   1:.            
-000107d0: 7265 7475 726e 2061 7267 735b 305d 0a20  return args[0]. 
-000107e0: 2020 2020 2020 2023 2052 6564 7563 6520         # Reduce 
-000107f0: 7365 7473 2075 7369 6e67 206b 6e6f 776e  sets using known
-00010800: 2072 756c 6573 0a20 2020 2020 2020 2069   rules.        i
-00010810: 6620 6576 616c 7561 7465 3a0a 2020 2020  f evaluate:.    
-00010820: 2020 2020 2020 2020 6172 6773 203d 206c          args = l
-00010830: 6973 7428 636c 732e 5f6e 6577 5f61 7267  ist(cls._new_arg
-00010840: 735f 6669 6c74 6572 2861 7267 7329 290a  s_filter(args)).
-00010850: 2020 2020 2020 2020 2020 2020 7265 7475              retu
-00010860: 726e 2073 696d 706c 6966 795f 756e 696f  rn simplify_unio
-00010870: 6e28 6172 6773 290a 0a20 2020 2020 2020  n(args)..       
-00010880: 2061 7267 732e 736f 7274 286b 6579 3d6c   args.sort(key=l
-00010890: 616d 6264 6120 6172 673a 2061 7267 2e73  ambda arg: arg.s
-000108a0: 6f72 745f 6b65 7928 2929 0a0a 2020 2020  ort_key())..    
-000108b0: 2020 2020 6f62 6a20 3d20 4261 7369 632e      obj = Basic.
-000108c0: 5f5f 6e65 775f 5f28 636c 732c 202a 6172  __new__(cls, *ar
-000108d0: 6773 290a 2020 2020 2020 2020 6f62 6a2e  gs).        obj.
-000108e0: 5f61 7267 7365 7420 3d20 6672 6f7a 656e  _argset = frozen
-000108f0: 7365 7428 6172 6773 290a 2020 2020 2020  set(args).      
-00010900: 2020 7265 7475 726e 206f 626a 0a0a 2020    return obj..  
-00010910: 2020 4063 6c61 7373 6d65 7468 6f64 0a20    @classmethod. 
-00010920: 2020 2064 6566 205f 6e65 775f 6172 6773     def _new_args
-00010930: 5f66 696c 7465 7228 636c 732c 2061 7267  _filter(cls, arg
-00010940: 5f73 6571 7565 6e63 652c 2063 616c 6c5f  _sequence, call_
-00010950: 636c 733d 4e6f 6e65 293a 0a20 2020 2020  cls=None):.     
-00010960: 2020 2022 2222 4765 6e65 7261 746f 7220     """Generator 
-00010970: 6669 6c74 6572 696e 6720 6172 6773 2222  filtering args""
-00010980: 220a 2020 2020 2020 2020 6e63 6c73 203d  ".        ncls =
-00010990: 2063 616c 6c5f 636c 7320 6f72 2063 6c73   call_cls or cls
-000109a0: 0a20 2020 2020 2020 2066 6f72 2061 7267  .        for arg
-000109b0: 2069 6e20 6172 675f 7365 7175 656e 6365   in arg_sequence
-000109c0: 3a20 0a20 2020 2020 2020 2020 2020 2069  : .            i
-000109d0: 6620 6172 672e 6675 6e63 203d 3d20 6e63  f arg.func == nc
-000109e0: 6c73 3a0a 2020 2020 2020 2020 2020 2020  ls:.            
-000109f0: 2020 2020 7969 656c 6420 6672 6f6d 2061      yield from a
-00010a00: 7267 2e61 7267 730a 2020 2020 2020 2020  rg.args.        
-00010a10: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
-00010a20: 2020 2020 2020 2020 2020 7969 656c 6420            yield 
-00010a30: 6172 670a 0a20 2020 2064 6566 205f 636f  arg..    def _co
-00010a40: 6d70 6c65 6d65 6e74 2873 656c 662c 2075  mplement(self, u
-00010a50: 6e69 7665 7273 6529 3a0a 2020 2020 2020  niverse):.      
-00010a60: 2020 2320 4465 4d6f 7267 616e 2773 204c    # DeMorgan's L
-00010a70: 6177 0a20 2020 2020 2020 2072 6574 7572  aw.        retur
-00010a80: 6e20 496e 7465 7273 6563 7469 6f6e 2873  n Intersection(s
-00010a90: 2e63 6f6d 706c 656d 656e 7428 756e 6976  .complement(univ
-00010aa0: 6572 7365 2920 666f 7220 7320 696e 2073  erse) for s in s
-00010ab0: 656c 662e 6172 6773 290a 0a20 2020 2040  elf.args)..    @
-00010ac0: 7072 6f70 6572 7479 0a20 2020 2064 6566  property.    def
-00010ad0: 205f 696e 6628 7365 6c66 293a 0a20 2020   _inf(self):.   
-00010ae0: 2020 2020 2023 2057 6520 7573 6520 4d69       # We use Mi
-00010af0: 6e20 736f 2074 6861 7420 7375 7020 6973  n so that sup is
-00010b00: 206d 6561 6e69 6e67 6675 6c20 696e 2063   meaningful in c
-00010b10: 6f6d 6269 6e61 7469 6f6e 2077 6974 6820  ombination with 
-00010b20: 7379 6d62 6f6c 6963 0a20 2020 2020 2020  symbolic.       
-00010b30: 2023 2069 6e74 6572 7661 6c20 656e 6420   # interval end 
-00010b40: 706f 696e 7473 2e0a 2020 2020 2020 2020  points..        
-00010b50: 6672 6f6d 2073 796d 7079 2e66 756e 6374  from sympy.funct
-00010b60: 696f 6e73 2e65 6c65 6d65 6e74 6172 792e  ions.elementary.
-00010b70: 6d69 7363 656c 6c61 6e65 6f75 7320 696d  miscellaneous im
-00010b80: 706f 7274 204d 696e 0a20 2020 2020 2020  port Min.       
-00010b90: 2072 6574 7572 6e20 4d69 6e28 2a5b 732e   return Min(*[s.
-00010ba0: 696e 6620 666f 7220 7320 696e 2073 656c  inf for s in sel
-00010bb0: 662e 6172 6773 5d29 0a0a 2020 2020 4070  f.args])..    @p
-00010bc0: 726f 7065 7274 790a 2020 2020 6465 6620  roperty.    def 
-00010bd0: 5f73 7570 2873 656c 6629 3a0a 2020 2020  _sup(self):.    
-00010be0: 2020 2020 2320 5765 2075 7365 204d 6178      # We use Max
-00010bf0: 2073 6f20 7468 6174 2073 7570 2069 7320   so that sup is 
-00010c00: 6d65 616e 696e 6766 756c 2069 6e20 636f  meaningful in co
-00010c10: 6d62 696e 6174 696f 6e20 7769 7468 2073  mbination with s
-00010c20: 796d 626f 6c69 630a 2020 2020 2020 2020  ymbolic.        
-00010c30: 2320 656e 6420 706f 696e 7473 2e0a 2020  # end points..  
-00010c40: 2020 2020 2020 6672 6f6d 2073 796d 7079        from sympy
-00010c50: 2e66 756e 6374 696f 6e73 2e65 6c65 6d65  .functions.eleme
-00010c60: 6e74 6172 792e 6d69 7363 656c 6c61 6e65  ntary.miscellane
-00010c70: 6f75 7320 696d 706f 7274 204d 6178 0a20  ous import Max. 
-00010c80: 2020 2020 2020 2072 6574 7572 6e20 4d61         return Ma
-00010c90: 7828 2a5b 732e 7375 7020 666f 7220 7320  x(*[s.sup for s 
-00010ca0: 696e 2073 656c 662e 6172 6773 5d29 0a0a  in self.args])..
-00010cb0: 2020 2020 6465 6620 5f63 6f6e 7461 696e      def _contain
-00010cc0: 7328 7365 6c66 2c20 6f74 6865 7229 3a0a  s(self, other):.
-00010cd0: 2020 2020 2020 2020 7265 7475 726e 204f          return O
-00010ce0: 7228 2a5b 456c 656d 656e 7428 6f74 6865  r(*[Element(othe
-00010cf0: 722c 2073 2920 666f 7220 7320 696e 2073  r, s) for s in s
-00010d00: 656c 662e 6172 6773 5d29 0a0a 2020 2020  elf.args])..    
-00010d10: 4070 726f 7065 7274 790a 2020 2020 6465  @property.    de
-00010d20: 6620 5f6d 6561 7375 7265 2873 656c 6629  f _measure(self)
-00010d30: 3a0a 2020 2020 2020 2020 2320 4d65 6173  :.        # Meas
-00010d40: 7572 6520 6f66 2061 2075 6e69 6f6e 2069  ure of a union i
-00010d50: 7320 7468 6520 7375 6d20 6f66 2074 6865  s the sum of the
-00010d60: 206d 6561 7375 7265 7320 6f66 2074 6865   measures of the
-00010d70: 2073 6574 7320 6d69 6e75 730a 2020 2020   sets minus.    
-00010d80: 2020 2020 2320 7468 6520 7375 6d20 6f66      # the sum of
-00010d90: 2074 6865 6972 2070 6169 7277 6973 6520   their pairwise 
-00010da0: 696e 7465 7273 6563 7469 6f6e 7320 706c  intersections pl
-00010db0: 7573 2074 6865 2073 756d 206f 6620 7468  us the sum of th
-00010dc0: 6569 720a 2020 2020 2020 2020 2320 7472  eir.        # tr
-00010dd0: 6970 6c65 2d77 6973 6520 696e 7465 7273  iple-wise inters
-00010de0: 6563 7469 6f6e 7320 6d69 6e75 7320 2e2e  ections minus ..
-00010df0: 2e20 6574 632e 2e2e 0a0a 2020 2020 2020  . etc.....      
-00010e00: 2020 2320 5365 7473 2069 7320 6120 636f    # Sets is a co
-00010e10: 6c6c 6563 7469 6f6e 206f 6620 696e 7465  llection of inte
-00010e20: 7273 6563 7469 6f6e 7320 616e 6420 6120  rsections and a 
-00010e30: 7365 7420 6f66 2065 6c65 6d65 6e74 6172  set of elementar
-00010e40: 790a 2020 2020 2020 2020 2320 7365 7473  y.        # sets
-00010e50: 2077 6869 6368 206d 6164 6520 7570 2074   which made up t
-00010e60: 686f 7365 2069 6e74 6572 7365 6374 696f  hose intersectio
-00010e70: 6e73 2028 6361 6c6c 6564 2022 736f 7322  ns (called "sos"
-00010e80: 2066 6f72 2073 6574 206f 6620 7365 7473   for set of sets
-00010e90: 290a 2020 2020 2020 2020 2320 416e 2065  ).        # An e
-00010ea0: 7861 6d70 6c65 2065 6c65 6d65 6e74 206d  xample element m
-00010eb0: 6967 6874 206f 6620 7468 6973 206c 6973  ight of this lis
-00010ec0: 7420 6d69 6768 7420 6265 3a0a 2020 2020  t might be:.    
-00010ed0: 2020 2020 2320 2020 2028 207b 412c 422c      #    ( {A,B,
-00010ee0: 437d 2c20 412e 696e 7465 7273 6563 7428  C}, A.intersect(
-00010ef0: 4229 2e69 6e74 6572 7365 6374 2843 2920  B).intersect(C) 
-00010f00: 290a 0a20 2020 2020 2020 2023 2053 7461  )..        # Sta
-00010f10: 7274 2077 6974 6820 6a75 7374 2065 6c65  rt with just ele
-00010f20: 6d65 6e74 6172 7920 7365 7473 2028 2020  mentary sets (  
-00010f30: 287b 417d 2c20 4129 2c20 287b 427d 2c20  ({A}, A), ({B}, 
-00010f40: 4229 2c20 2e2e 2e20 290a 2020 2020 2020  B), ... ).      
-00010f50: 2020 2320 5468 656e 2067 6574 2061 6e64    # Then get and
-00010f60: 2073 7562 7472 6163 7420 2820 2028 7b41   subtract (  ({A
-00010f70: 2c42 7d2c 2028 4120 696e 7420 4229 2c20  ,B}, (A int B), 
-00010f80: 2e2e 2e20 2920 7768 696c 6520 6e6f 6e2d  ... ) while non-
-00010f90: 7a65 726f 0a20 2020 2020 2020 2066 726f  zero.        fro
-00010fa0: 6d20 7379 6d70 7920 696d 706f 7274 2046  m sympy import F
-00010fb0: 696e 6974 6553 6574 0a20 2020 2020 2020  initeSet.       
-00010fc0: 2073 6574 7320 3d20 5b28 4669 6e69 7465   sets = [(Finite
-00010fd0: 5365 7428 7329 2c20 7329 2066 6f72 2073  Set(s), s) for s
-00010fe0: 2069 6e20 7365 6c66 2e61 7267 735d 0a20   in self.args]. 
-00010ff0: 2020 2020 2020 206d 6561 7375 7265 203d         measure =
-00011000: 2030 0a20 2020 2020 2020 2070 6172 6974   0.        parit
-00011010: 7920 3d20 310a 2020 2020 2020 2020 7768  y = 1.        wh
-00011020: 696c 6520 7365 7473 3a0a 2020 2020 2020  ile sets:.      
-00011030: 2020 2020 2020 2320 4164 6420 7570 2074        # Add up t
-00011040: 6865 206d 6561 7375 7265 206f 6620 7468  he measure of th
-00011050: 6573 6520 7365 7473 2061 6e64 2061 6464  ese sets and add
-00011060: 206f 7220 7375 6274 7261 6374 2069 7420   or subtract it 
-00011070: 746f 2074 6f74 616c 0a20 2020 2020 2020  to total.       
-00011080: 2020 2020 206d 6561 7375 7265 202b 3d20       measure += 
-00011090: 7061 7269 7479 202a 2073 756d 2869 6e74  parity * sum(int
-000110a0: 6572 2e6d 6561 7375 7265 2066 6f72 2073  er.measure for s
-000110b0: 6f73 2c20 696e 7465 7220 696e 2073 6574  os, inter in set
-000110c0: 7329 0a0a 2020 2020 2020 2020 2020 2020  s)..            
-000110d0: 2320 466f 7220 6561 6368 2069 6e74 6572  # For each inter
-000110e0: 7365 6374 696f 6e20 696e 2073 6574 732c  section in sets,
-000110f0: 2063 6f6d 7075 7465 2074 6865 2069 6e74   compute the int
-00011100: 6572 7365 6374 696f 6e20 7769 7468 2065  ersection with e
-00011110: 7665 7279 0a20 2020 2020 2020 2020 2020  very.           
-00011120: 2023 206f 7468 6572 2073 6574 206e 6f74   # other set not
-00011130: 2061 6c72 6561 6479 2070 6172 7420 6f66   already part of
-00011140: 2074 6865 2069 6e74 6572 7365 6374 696f   the intersectio
-00011150: 6e2e 0a20 2020 2020 2020 2020 2020 2073  n..            s
-00011160: 6574 7320 3d20 2828 736f 7320 2b20 4669  ets = ((sos + Fi
-00011170: 6e69 7465 5365 7428 6e65 7773 6574 292c  niteSet(newset),
-00011180: 206e 6577 7365 742e 696e 7465 7273 6563   newset.intersec
-00011190: 7428 696e 7465 7273 6563 7469 6f6e 2929  t(intersection))
-000111a0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000111b0: 2020 2020 2066 6f72 2073 6f73 2c20 696e       for sos, in
-000111c0: 7465 7273 6563 7469 6f6e 2069 6e20 7365  tersection in se
-000111d0: 7473 2066 6f72 206e 6577 7365 7420 696e  ts for newset in
-000111e0: 2073 656c 662e 6172 6773 0a20 2020 2020   self.args.     
-000111f0: 2020 2020 2020 2020 2020 2020 2020 2069                 i
-00011200: 6620 6e65 7773 6574 206e 6f74 2069 6e20  f newset not in 
-00011210: 736f 7329 0a0a 2020 2020 2020 2020 2020  sos)..          
-00011220: 2020 2320 436c 6561 7220 6f75 7420 7365    # Clear out se
-00011230: 7473 2077 6974 6820 6e6f 206d 6561 7375  ts with no measu
-00011240: 7265 0a20 2020 2020 2020 2020 2020 2073  re.            s
-00011250: 6574 7320 3d20 5b28 736f 732c 2069 6e74  ets = [(sos, int
-00011260: 6572 2920 666f 7220 736f 732c 2069 6e74  er) for sos, int
-00011270: 6572 2069 6e20 7365 7473 2069 6620 696e  er in sets if in
-00011280: 7465 722e 6d65 6173 7572 6520 213d 2030  ter.measure != 0
-00011290: 5d0a 0a20 2020 2020 2020 2020 2020 2023  ]..            #
-000112a0: 2043 6c65 6172 206f 7574 2064 7570 6c69   Clear out dupli
-000112b0: 6361 7465 730a 2020 2020 2020 2020 2020  cates.          
-000112c0: 2020 736f 735f 6c69 7374 203d 205b 5d0a    sos_list = [].
-000112d0: 2020 2020 2020 2020 2020 2020 7365 7473              sets
-000112e0: 5f6c 6973 7420 3d20 5b5d 0a20 2020 2020  _list = [].     
-000112f0: 2020 2020 2020 2066 6f72 2073 2069 6e20         for s in 
-00011300: 7365 7473 3a0a 2020 2020 2020 2020 2020  sets:.          
-00011310: 2020 2020 2020 6966 2073 5b30 5d20 696e        if s[0] in
-00011320: 2073 6f73 5f6c 6973 743a 0a20 2020 2020   sos_list:.     
-00011330: 2020 2020 2020 2020 2020 2020 2020 2063                 c
-00011340: 6f6e 7469 6e75 650a 2020 2020 2020 2020  ontinue.        
-00011350: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
-00011360: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011370: 2020 736f 735f 6c69 7374 2e61 7070 656e    sos_list.appen
-00011380: 6428 735b 305d 290a 2020 2020 2020 2020  d(s[0]).        
-00011390: 2020 2020 2020 2020 2020 2020 7365 7473              sets
-000113a0: 5f6c 6973 742e 6170 7065 6e64 2873 290a  _list.append(s).
-000113b0: 2020 2020 2020 2020 2020 2020 7365 7473              sets
-000113c0: 203d 2073 6574 735f 6c69 7374 0a0a 2020   = sets_list..  
-000113d0: 2020 2020 2020 2020 2020 2320 466c 6970            # Flip
-000113e0: 2050 6172 6974 7920 2d20 6e65 7874 2074   Parity - next t
-000113f0: 696d 6520 7375 6274 7261 6374 2f61 6464  ime subtract/add
-00011400: 2069 6620 7765 2061 6464 6564 2f73 7562   if we added/sub
-00011410: 7472 6163 7465 6420 6865 7265 0a20 2020  tracted here.   
-00011420: 2020 2020 2020 2020 2070 6172 6974 7920           parity 
-00011430: 2a3d 202d 310a 2020 2020 2020 2020 7265  *= -1.        re
-00011440: 7475 726e 206d 6561 7375 7265 0a0a 2020  turn measure..  
-00011450: 2020 4070 726f 7065 7274 790a 2020 2020    @property.    
-00011460: 6465 6620 5f62 6f75 6e64 6172 7928 7365  def _boundary(se
-00011470: 6c66 293a 0a0a 2020 2020 2020 2020 6465  lf):..        de
-00011480: 6620 626f 756e 6461 7279 5f6f 665f 7365  f boundary_of_se
-00011490: 7428 6929 3a0a 2020 2020 2020 2020 2020  t(i):.          
-000114a0: 2020 2222 2220 5468 6520 626f 756e 6461    """ The bounda
-000114b0: 7279 206f 6620 7365 7420 6920 6d69 6e75  ry of set i minu
-000114c0: 7320 696e 7465 7269 6f72 206f 6620 616c  s interior of al
-000114d0: 6c20 6f74 6865 7220 7365 7473 2022 2222  l other sets """
-000114e0: 0a20 2020 2020 2020 2020 2020 2062 203d  .            b =
-000114f0: 2073 656c 662e 6172 6773 5b69 5d2e 626f   self.args[i].bo
-00011500: 756e 6461 7279 0a20 2020 2020 2020 2020  undary.         
-00011510: 2020 2066 6f72 206a 2c20 6120 696e 2065     for j, a in e
-00011520: 6e75 6d65 7261 7465 2873 656c 662e 6172  numerate(self.ar
-00011530: 6773 293a 0a20 2020 2020 2020 2020 2020  gs):.           
-00011540: 2020 2020 2069 6620 6a20 213d 2069 3a0a       if j != i:.
-00011550: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011560: 2020 2020 6220 3d20 6220 2d20 612e 696e      b = b - a.in
-00011570: 7465 7269 6f72 0a20 2020 2020 2020 2020  terior.         
-00011580: 2020 2072 6574 7572 6e20 620a 0a20 2020     return b..   
-00011590: 2020 2020 2072 6574 7572 6e20 556e 696f       return Unio
-000115a0: 6e28 2a6d 6170 2862 6f75 6e64 6172 795f  n(*map(boundary_
-000115b0: 6f66 5f73 6574 2c20 7261 6e67 6528 6c65  of_set, range(le
-000115c0: 6e28 7365 6c66 2e61 7267 7329 2929 290a  n(self.args)))).
-000115d0: 0a20 2020 2064 6566 2061 735f 7265 6c61  .    def as_rela
-000115e0: 7469 6f6e 616c 2873 656c 662c 2073 796d  tional(self, sym
-000115f0: 626f 6c29 3a0a 2020 2020 2020 2020 2222  bol):.        ""
-00011600: 2252 6577 7269 7465 2061 2055 6e69 6f6e  "Rewrite a Union
-00011610: 2069 6e20 7465 726d 7320 6f66 2065 7175   in terms of equ
-00011620: 616c 6974 6965 7320 616e 6420 6c6f 6769  alities and logi
-00011630: 6320 6f70 6572 6174 6f72 732e 2022 2222  c operators. """
-00011640: 0a20 2020 2020 2020 2069 6620 6c65 6e28  .        if len(
-00011650: 7365 6c66 2e61 7267 7329 203d 3d20 323a  self.args) == 2:
-00011660: 0a20 2020 2020 2020 2020 2020 2061 2c20  .            a, 
-00011670: 6220 3d20 7365 6c66 2e61 7267 730a 2020  b = self.args.  
-00011680: 2020 2020 2020 2020 2020 6966 2028 612e            if (a.
-00011690: 7375 7020 3d3d 2062 2e69 6e66 2061 6e64  sup == b.inf and
-000116a0: 2061 2e69 6e66 2069 7320 532e 4e65 6761   a.inf is S.Nega
-000116b0: 7469 7665 496e 6669 6e69 7479 0a20 2020  tiveInfinity.   
-000116c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000116d0: 2061 6e64 2062 2e73 7570 2069 7320 532e   and b.sup is S.
-000116e0: 496e 6669 6e69 7479 293a 0a20 2020 2020  Infinity):.     
-000116f0: 2020 2020 2020 2020 2020 2072 6574 7572             retur
-00011700: 6e20 416e 6428 4e65 2873 796d 626f 6c2c  n And(Ne(symbol,
-00011710: 2061 2e73 7570 292c 2073 796d 626f 6c20   a.sup), symbol 
-00011720: 3c20 622e 7375 702c 2073 796d 626f 6c20  < b.sup, symbol 
-00011730: 3e20 612e 696e 6629 0a20 2020 2020 2020  > a.inf).       
-00011740: 2072 6574 7572 6e20 4f72 282a 5b73 2e61   return Or(*[s.a
-00011750: 735f 7265 6c61 7469 6f6e 616c 2873 796d  s_relational(sym
-00011760: 626f 6c29 2066 6f72 2073 2069 6e20 7365  bol) for s in se
-00011770: 6c66 2e61 7267 735d 290a 0a20 2020 2040  lf.args])..    @
-00011780: 7072 6f70 6572 7479 0a20 2020 2064 6566  property.    def
-00011790: 2069 735f 6974 6572 6162 6c65 2873 656c   is_iterable(sel
-000117a0: 6629 3a0a 2020 2020 2020 2020 7265 7475  f):.        retu
-000117b0: 726e 2061 6c6c 2861 7267 2e69 735f 6974  rn all(arg.is_it
-000117c0: 6572 6162 6c65 2066 6f72 2061 7267 2069  erable for arg i
-000117d0: 6e20 7365 6c66 2e61 7267 7329 0a0a 2020  n self.args)..  
-000117e0: 2020 6465 6620 5f65 7661 6c5f 6576 616c    def _eval_eval
-000117f0: 6628 7365 6c66 2c20 7072 6563 293a 0a20  f(self, prec):. 
-00011800: 2020 2020 2020 2074 7279 3a0a 2020 2020         try:.    
-00011810: 2020 2020 2020 2020 7265 7475 726e 2055          return U
-00011820: 6e69 6f6e 282a 2873 2e5f 6576 616c 5f65  nion(*(s._eval_e
-00011830: 7661 6c66 2870 7265 6329 2066 6f72 2073  valf(prec) for s
-00011840: 2069 6e20 7365 6c66 2e61 7267 7329 290a   in self.args)).
-00011850: 2020 2020 2020 2020 6578 6365 7074 2028          except (
-00011860: 5479 7065 4572 726f 722c 2056 616c 7565  TypeError, Value
-00011870: 4572 726f 722c 204e 6f74 496d 706c 656d  Error, NotImplem
-00011880: 656e 7465 6445 7272 6f72 293a 0a20 2020  entedError):.   
-00011890: 2020 2020 2020 2020 2069 6d70 6f72 7420           import 
-000118a0: 7379 730a 2020 2020 2020 2020 2020 2020  sys.            
-000118b0: 7261 6973 6520 2854 7970 6545 7272 6f72  raise (TypeError
-000118c0: 2822 4e6f 7420 616c 6c20 7365 7473 2061  ("Not all sets a
-000118d0: 7265 2065 7661 6c66 2d61 626c 6522 292c  re evalf-able"),
-000118e0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000118f0: 2020 2020 4e6f 6e65 2c0a 2020 2020 2020      None,.      
-00011900: 2020 2020 2020 2020 2020 2020 2073 7973               sys
-00011910: 2e65 7863 5f69 6e66 6f28 295b 325d 290a  .exc_info()[2]).
-00011920: 0a20 2020 2064 6566 205f 5f69 7465 725f  .    def __iter_
-00011930: 5f28 7365 6c66 293a 0a20 2020 2020 2020  _(self):.       
-00011940: 2069 6d70 6f72 7420 6974 6572 746f 6f6c   import itertool
-00011950: 730a 0a20 2020 2020 2020 2023 2072 6f75  s..        # rou
-00011960: 6e64 726f 6269 6e20 7265 6369 7065 2074  ndrobin recipe t
-00011970: 616b 656e 2066 726f 6d20 6974 6572 746f  aken from iterto
-00011980: 6f6c 7320 646f 6375 6d65 6e74 6174 696f  ols documentatio
-00011990: 6e3a 0a20 2020 2020 2020 2023 2068 7474  n:.        # htt
-000119a0: 7073 3a2f 2f64 6f63 732e 7079 7468 6f6e  ps://docs.python
-000119b0: 2e6f 7267 2f32 2f6c 6962 7261 7279 2f69  .org/2/library/i
-000119c0: 7465 7274 6f6f 6c73 2e68 746d 6c23 7265  tertools.html#re
-000119d0: 6369 7065 730a 2020 2020 2020 2020 6465  cipes.        de
-000119e0: 6620 726f 756e 6472 6f62 696e 282a 6974  f roundrobin(*it
-000119f0: 6572 6162 6c65 7329 3a0a 2020 2020 2020  erables):.      
-00011a00: 2020 2020 2020 2272 6f75 6e64 726f 6269        "roundrobi
-00011a10: 6e28 2741 4243 272c 2027 4427 2c20 2745  n('ABC', 'D', 'E
-00011a20: 4627 2920 2d2d 3e20 4120 4420 4520 4220  F') --> A D E B 
-00011a30: 4620 4322 0a20 2020 2020 2020 2020 2020  F C".           
-00011a40: 2023 2052 6563 6970 6520 6372 6564 6974   # Recipe credit
-00011a50: 6564 2074 6f20 4765 6f72 6765 2053 616b  ed to George Sak
-00011a60: 6b69 730a 2020 2020 2020 2020 2020 2020  kis.            
-00011a70: 7065 6e64 696e 6720 3d20 6c65 6e28 6974  pending = len(it
-00011a80: 6572 6162 6c65 7329 0a20 2020 2020 2020  erables).       
-00011a90: 2020 2020 2069 6620 5059 333a 0a20 2020       if PY3:.   
-00011aa0: 2020 2020 2020 2020 2020 2020 206e 6578               nex
-00011ab0: 7473 203d 2069 7465 7274 6f6f 6c73 2e63  ts = itertools.c
-00011ac0: 7963 6c65 2869 7465 7228 6974 292e 5f5f  ycle(iter(it).__
-00011ad0: 6e65 7874 5f5f 2066 6f72 2069 7420 696e  next__ for it in
-00011ae0: 2069 7465 7261 626c 6573 290a 2020 2020   iterables).    
-00011af0: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
-00011b00: 2020 2020 2020 2020 2020 2020 2020 6e65                ne
-00011b10: 7874 7320 3d20 6974 6572 746f 6f6c 732e  xts = itertools.
-00011b20: 6379 636c 6528 6974 6572 2869 7429 2e6e  cycle(iter(it).n
-00011b30: 6578 7420 666f 7220 6974 2069 6e20 6974  ext for it in it
-00011b40: 6572 6162 6c65 7329 0a20 2020 2020 2020  erables).       
-00011b50: 2020 2020 2077 6869 6c65 2070 656e 6469       while pendi
-00011b60: 6e67 3a0a 2020 2020 2020 2020 2020 2020  ng:.            
-00011b70: 2020 2020 7472 793a 0a20 2020 2020 2020      try:.       
-00011b80: 2020 2020 2020 2020 2020 2020 2066 6f72               for
-00011b90: 206e 6578 7420 696e 206e 6578 7473 3a0a   next in nexts:.
-00011ba0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011bb0: 2020 2020 2020 2020 7969 656c 6420 6e65          yield ne
-00011bc0: 7874 2829 0a20 2020 2020 2020 2020 2020  xt().           
-00011bd0: 2020 2020 2065 7863 6570 7420 5374 6f70       except Stop
-00011be0: 4974 6572 6174 696f 6e3a 0a20 2020 2020  Iteration:.     
-00011bf0: 2020 2020 2020 2020 2020 2020 2020 2070                 p
-00011c00: 656e 6469 6e67 202d 3d20 310a 2020 2020  ending -= 1.    
-00011c10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011c20: 6e65 7874 7320 3d20 6974 6572 746f 6f6c  nexts = itertool
-00011c30: 732e 6379 636c 6528 6974 6572 746f 6f6c  s.cycle(itertool
-00011c40: 732e 6973 6c69 6365 286e 6578 7473 2c20  s.islice(nexts, 
-00011c50: 7065 6e64 696e 6729 290a 0a20 2020 2020  pending))..     
-00011c60: 2020 2069 6620 616c 6c28 732e 6973 5f69     if all(s.is_i
-00011c70: 7465 7261 626c 6520 666f 7220 7320 696e  terable for s in
-00011c80: 2073 656c 662e 6172 6773 293a 0a20 2020   self.args):.   
-00011c90: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
-00011ca0: 726f 756e 6472 6f62 696e 282a 2869 7465  roundrobin(*(ite
-00011cb0: 7228 6172 6729 2066 6f72 2061 7267 2069  r(arg) for arg i
-00011cc0: 6e20 7365 6c66 2e61 7267 7329 290a 2020  n self.args)).  
-00011cd0: 2020 2020 2020 656c 7365 3a0a 2020 2020        else:.    
-00011ce0: 2020 2020 2020 2020 7261 6973 6520 5479          raise Ty
-00011cf0: 7065 4572 726f 7228 224e 6f74 2061 6c6c  peError("Not all
-00011d00: 2063 6f6e 7374 6974 7565 6e74 2073 6574   constituent set
-00011d10: 7320 6172 6520 6974 6572 6162 6c65 2229  s are iterable")
-00011d20: 0a0a 2020 2020 6465 6620 5f65 7661 6c5f  ..    def _eval_
-00011d30: 6973 5f66 696e 6974 6573 6574 2873 656c  is_finiteset(sel
-00011d40: 6629 3a0a 2020 2020 2020 2020 6966 2066  f):.        if f
-00011d50: 757a 7a79 5f65 7428 612e 6973 5f66 696e  uzzy_et(a.is_fin
-00011d60: 6974 6573 6574 2066 6f72 2061 2069 6e20  iteset for a in 
-00011d70: 7365 6c66 2e61 7267 7329 3a0a 2020 2020  self.args):.    
-00011d80: 2020 2020 2020 2020 7265 7475 726e 2054          return T
-00011d90: 7275 650a 0a20 2020 2064 6566 205f 6576  rue..    def _ev
-00011da0: 616c 5f69 735f 6578 7465 6e64 6564 5f69  al_is_extended_i
-00011db0: 6e74 6567 6572 2873 656c 6629 3a0a 2020  nteger(self):.  
-00011dc0: 2020 2020 2020 7265 7475 726e 2066 757a        return fuz
-00011dd0: 7a79 5f65 7428 6172 672e 6973 5f65 7874  zy_et(arg.is_ext
-00011de0: 656e 6465 645f 696e 7465 6765 7220 666f  ended_integer fo
-00011df0: 7220 6172 6720 696e 2073 656c 662e 6172  r arg in self.ar
-00011e00: 6773 290a 0a20 2020 2064 6566 205f 6576  gs)..    def _ev
-00011e10: 616c 5f69 735f 7375 7065 725f 696e 7465  al_is_super_inte
-00011e20: 6765 7228 7365 6c66 293a 0a20 2020 2020  ger(self):.     
-00011e30: 2020 2072 6574 7572 6e20 6675 7a7a 795f     return fuzzy_
-00011e40: 6574 2865 2e69 735f 7375 7065 725f 696e  et(e.is_super_in
-00011e50: 7465 6765 7220 666f 7220 6520 696e 2073  teger for e in s
-00011e60: 656c 662e 6172 6773 290a 2020 2020 0a20  elf.args).    . 
-00011e70: 2020 2064 6566 205f 6576 616c 5f69 735f     def _eval_is_
-00011e80: 6578 7465 6e64 6564 5f72 6174 696f 6e61  extended_rationa
-00011e90: 6c28 7365 6c66 293a 0a20 2020 2020 2020  l(self):.       
-00011ea0: 2072 6574 7572 6e20 6675 7a7a 795f 6574   return fuzzy_et
-00011eb0: 2865 2e69 735f 6578 7465 6e64 6564 5f72  (e.is_extended_r
-00011ec0: 6174 696f 6e61 6c20 666f 7220 6520 696e  ational for e in
-00011ed0: 2073 656c 662e 6172 6773 290a 2020 2020   self.args).    
-00011ee0: 0a20 2020 2064 6566 205f 6576 616c 5f69  .    def _eval_i
-00011ef0: 735f 7375 7065 725f 7261 7469 6f6e 616c  s_super_rational
-00011f00: 2873 656c 6629 3a0a 2020 2020 2020 2020  (self):.        
-00011f10: 7265 7475 726e 2066 757a 7a79 5f65 7428  return fuzzy_et(
-00011f20: 652e 6973 5f73 7570 6572 5f72 6174 696f  e.is_super_ratio
-00011f30: 6e61 6c20 666f 7220 6520 696e 2073 656c  nal for e in sel
-00011f40: 662e 6172 6773 290a 0a20 2020 2064 6566  f.args)..    def
-00011f50: 205f 6576 616c 5f69 735f 6879 7065 725f   _eval_is_hyper_
-00011f60: 7261 7469 6f6e 616c 2873 656c 6629 3a0a  rational(self):.
-00011f70: 2020 2020 2020 2020 7265 7475 726e 2066          return f
-00011f80: 757a 7a79 5f65 7428 652e 6973 5f68 7970  uzzy_et(e.is_hyp
-00011f90: 6572 5f72 6174 696f 6e61 6c20 666f 7220  er_rational for 
-00011fa0: 6520 696e 2073 656c 662e 6172 6773 290a  e in self.args).
-00011fb0: 2020 2020 0a20 2020 2064 6566 205f 6576      .    def _ev
-00011fc0: 616c 5f69 735f 6578 7465 6e64 6564 5f72  al_is_extended_r
-00011fd0: 6561 6c28 7365 6c66 293a 0a20 2020 2020  eal(self):.     
-00011fe0: 2020 2072 6574 7572 6e20 6675 7a7a 795f     return fuzzy_
-00011ff0: 6574 2865 2e69 735f 6578 7465 6e64 6564  et(e.is_extended
-00012000: 5f72 6561 6c20 666f 7220 6520 696e 2073  _real for e in s
-00012010: 656c 662e 6172 6773 2920 0a0a 2020 2020  elf.args) ..    
-00012020: 6465 6620 5f65 7661 6c5f 6973 5f68 7970  def _eval_is_hyp
-00012030: 6572 5f72 6561 6c28 7365 6c66 293a 0a20  er_real(self):. 
-00012040: 2020 2020 2020 2072 6574 7572 6e20 6675         return fu
-00012050: 7a7a 795f 6574 2865 2e69 735f 6879 7065  zzy_et(e.is_hype
-00012060: 725f 7265 616c 2066 6f72 2065 2069 6e20  r_real for e in 
-00012070: 7365 6c66 2e61 7267 7329 0a20 2020 200a  self.args).    .
-00012080: 2020 2020 6465 6620 5f65 7661 6c5f 6973      def _eval_is
-00012090: 5f73 7570 6572 5f72 6561 6c28 7365 6c66  _super_real(self
-000120a0: 293a 0a20 2020 2020 2020 2072 6574 7572  ):.        retur
-000120b0: 6e20 6675 7a7a 795f 6574 2865 2e69 735f  n fuzzy_et(e.is_
-000120c0: 7375 7065 725f 7265 616c 2066 6f72 2065  super_real for e
-000120d0: 2069 6e20 7365 6c66 2e61 7267 7329 0a20   in self.args). 
-000120e0: 2020 200a 2020 2020 6465 6620 5f65 7661     .    def _eva
-000120f0: 6c5f 6973 5f65 7874 656e 6465 645f 636f  l_is_extended_co
-00012100: 6d70 6c65 7828 7365 6c66 293a 0a20 2020  mplex(self):.   
-00012110: 2020 2020 2072 6574 7572 6e20 6675 7a7a       return fuzz
-00012120: 795f 6574 2865 2e69 735f 6578 7465 6e64  y_et(e.is_extend
-00012130: 6564 5f63 6f6d 706c 6578 2066 6f72 2065  ed_complex for e
-00012140: 2069 6e20 7365 6c66 2e61 7267 7329 0a20   in self.args). 
-00012150: 2020 2020 0a20 2020 2064 6566 205f 6576      .    def _ev
-00012160: 616c 5f69 735f 6879 7065 725f 636f 6d70  al_is_hyper_comp
-00012170: 6c65 7828 7365 6c66 293a 0a20 2020 2020  lex(self):.     
-00012180: 2020 2072 6574 7572 6e20 6675 7a7a 795f     return fuzzy_
-00012190: 6574 2865 2e69 735f 6879 7065 725f 636f  et(e.is_hyper_co
-000121a0: 6d70 6c65 7820 666f 7220 6520 696e 2073  mplex for e in s
-000121b0: 656c 662e 6172 6773 290a 0a20 2020 2040  elf.args)..    @
-000121c0: 7072 6f70 6572 7479 0a20 2020 2064 6566  property.    def
-000121d0: 2065 7479 7065 2873 656c 6629 3a0a 2020   etype(self):.  
-000121e0: 2020 2020 2020 6474 7970 6520 3d20 4e6f        dtype = No
-000121f0: 6e65 0a20 2020 2020 2020 2066 6f72 2065  ne.        for e
-00012200: 2069 6e20 7365 6c66 2e61 7267 733a 0a20   in self.args:. 
-00012210: 2020 2020 2020 2020 2020 205f 6474 7970             _dtyp
-00012220: 6520 3d20 652e 6574 7970 650a 2020 2020  e = e.etype.    
-00012230: 2020 2020 2020 2020 6966 2064 7479 7065          if dtype
-00012240: 2069 7320 4e6f 6e65 3a0a 2020 2020 2020   is None:.      
-00012250: 2020 2020 2020 2020 2020 6474 7970 6520            dtype 
-00012260: 3d20 5f64 7479 7065 0a20 2020 2020 2020  = _dtype.       
-00012270: 2020 2020 2020 2020 2063 6f6e 7469 6e75           continu
-00012280: 650a 2020 2020 2020 2020 2020 2020 6966  e.            if
-00012290: 2064 7479 7065 2021 3d20 5f64 7479 7065   dtype != _dtype
-000122a0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-000122b0: 2020 6966 205f 6474 7970 6520 696e 2064    if _dtype in d
-000122c0: 7479 7065 3a0a 2020 2020 2020 2020 2020  type:.          
-000122d0: 2020 2020 2020 2020 2020 636f 6e74 696e            contin
-000122e0: 7565 0a20 2020 2020 2020 2020 2020 2020  ue.             
-000122f0: 2020 2069 6620 6474 7970 6520 696e 205f     if dtype in _
-00012300: 6474 7970 653a 0a20 2020 2020 2020 2020  dtype:.         
-00012310: 2020 2020 2020 2020 2020 2064 7479 7065             dtype
-00012320: 203d 205f 6474 7970 650a 2020 2020 2020   = _dtype.      
-00012330: 2020 2020 2020 2020 2020 2020 2020 636f                co
-00012340: 6e74 696e 7565 0a20 2020 2020 2020 2020  ntinue.         
-00012350: 2020 2020 2020 2072 6169 7365 2045 7863         raise Exc
-00012360: 6570 7469 6f6e 2827 696e 636f 6e73 6973  eption('inconsis
-00012370: 7465 6e74 2064 7479 7065 3a20 2573 2061  tent dtype: %s a
-00012380: 6e64 2025 7327 2025 2028 6474 7970 652c  nd %s' % (dtype,
-00012390: 205f 6474 7970 6529 290a 0a20 2020 2020   _dtype))..     
-000123a0: 2020 2072 6574 7572 6e20 6474 7970 650a     return dtype.
-000123b0: 0a20 2020 2064 6566 205f 6576 616c 5f43  .    def _eval_C
-000123c0: 6172 6428 7365 6c66 293a 0a20 2020 2020  ard(self):.     
-000123d0: 2020 206e 6f6e 5f69 6e74 6572 7365 6374     non_intersect
-000123e0: 203d 205b 5d0a 2020 2020 2020 2020 6172   = [].        ar
-000123f0: 6773 203d 205b 2a73 656c 662e 6172 6773  gs = [*self.args
-00012400: 5d0a 2020 2020 2020 2020 666f 7220 4120  ].        for A 
-00012410: 696e 2073 656c 662e 6172 6773 3a0a 2020  in self.args:.  
-00012420: 2020 2020 2020 2020 2020 696e 7465 7273            inters
-00012430: 6563 7420 3d20 4661 6c73 650a 2020 2020  ect = False.    
-00012440: 2020 2020 2020 2020 666f 7220 4220 696e          for B in
-00012450: 2061 7267 733a 0a20 2020 2020 2020 2020   args:.         
-00012460: 2020 2020 2020 2069 6620 4120 3d3d 2042         if A == B
-00012470: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-00012480: 2020 2020 2020 636f 6e74 696e 7565 0a0a        continue..
-00012490: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000124a0: 6966 2041 2026 2042 3a0a 2020 2020 2020  if A & B:.      
-000124b0: 2020 2020 2020 2020 2020 2020 2020 696e                in
-000124c0: 7465 7273 6563 7420 3d20 5472 7565 0a20  tersect = True. 
-000124d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000124e0: 2020 2062 7265 616b 0a20 2020 2020 2020     break.       
-000124f0: 2020 2020 2069 6620 696e 7465 7273 6563       if intersec
-00012500: 743a 0a20 2020 2020 2020 2020 2020 2020  t:.             
-00012510: 2020 2063 6f6e 7469 6e75 650a 2020 2020     continue.    
-00012520: 2020 2020 2020 2020 6e6f 6e5f 696e 7465          non_inte
-00012530: 7273 6563 742e 6170 7065 6e64 2841 290a  rsect.append(A).
-00012540: 2020 2020 2020 2020 2020 2020 6172 6773              args
-00012550: 2e72 656d 6f76 6528 4129 0a0a 2020 2020  .remove(A)..    
-00012560: 2020 2020 6966 206e 6f6e 5f69 6e74 6572      if non_inter
-00012570: 7365 6374 3a0a 2020 2020 2020 2020 2020  sect:.          
-00012580: 2020 6672 6f6d 2073 796d 7079 2069 6d70    from sympy imp
-00012590: 6f72 7420 4164 642c 2043 6172 640a 2020  ort Add, Card.  
-000125a0: 2020 2020 2020 2020 2020 6966 2061 7267            if arg
-000125b0: 733a 0a20 2020 2020 2020 2020 2020 2020  s:.             
-000125c0: 2020 2073 203d 2043 6172 6428 556e 696f     s = Card(Unio
-000125d0: 6e28 2a61 7267 7329 290a 2020 2020 2020  n(*args)).      
-000125e0: 2020 2020 2020 656c 7365 3a0a 2020 2020        else:.    
-000125f0: 2020 2020 2020 2020 2020 2020 7320 3d20              s = 
-00012600: 300a 2020 2020 2020 2020 2020 2020 7265  0.            re
-00012610: 7475 726e 2041 6464 282a 5b43 6172 6428  turn Add(*[Card(
-00012620: 4129 2066 6f72 2041 2069 6e20 6e6f 6e5f  A) for A in non_
-00012630: 696e 7465 7273 6563 745d 2920 2b20 730a  intersect]) + s.
-00012640: 0a20 2020 2064 6566 206d 696e 2873 656c  .    def min(sel
-00012650: 6629 3a0a 2020 2020 2020 2020 6672 6f6d  f):.        from
-00012660: 2073 796d 7079 2e66 756e 6374 696f 6e73   sympy.functions
-00012670: 2e65 6c65 6d65 6e74 6172 792e 6d69 7363  .elementary.misc
-00012680: 656c 6c61 6e65 6f75 7320 696d 706f 7274  ellaneous import
-00012690: 204d 696e 0a20 2020 2020 2020 2072 6574   Min.        ret
-000126a0: 7572 6e20 4d69 6e28 2a28 6172 672e 6d69  urn Min(*(arg.mi
-000126b0: 6e28 2920 666f 7220 6172 6720 696e 2073  n() for arg in s
-000126c0: 656c 662e 6172 6773 2929 2020 2020 2020  elf.args))      
-000126d0: 2020 0a0a 2020 2020 6465 6620 6d61 7828    ..    def max(
-000126e0: 7365 6c66 293a 0a20 2020 2020 2020 2066  self):.        f
-000126f0: 726f 6d20 7379 6d70 792e 6675 6e63 7469  rom sympy.functi
-00012700: 6f6e 732e 656c 656d 656e 7461 7279 2e6d  ons.elementary.m
-00012710: 6973 6365 6c6c 616e 656f 7573 2069 6d70  iscellaneous imp
-00012720: 6f72 7420 4d61 780a 2020 2020 2020 2020  ort Max.        
-00012730: 7265 7475 726e 204d 6178 282a 2861 7267  return Max(*(arg
-00012740: 2e6d 6178 2829 2066 6f72 2061 7267 2069  .max() for arg i
-00012750: 6e20 7365 6c66 2e61 7267 7329 2920 2020  n self.args))   
-00012760: 2020 2020 200a 0a20 2020 2064 6566 205f       ..    def _
-00012770: 7379 6d70 7973 7472 2873 656c 662c 2070  sympystr(self, p
-00012780: 293a 0a20 2020 2020 2020 2023 205c 4e7b  ):.        # \N{
-00012790: 554e 494f 4e7d 0a20 2020 2020 2020 2072  UNION}.        r
-000127a0: 6574 7572 6e20 2720 7c20 272e 6a6f 696e  eturn ' | '.join
-000127b0: 285b 2228 2573 2922 2025 2070 2e5f 7072  (["(%s)" % p._pr
-000127c0: 696e 7428 6129 2069 6620 612e 6973 5f43  int(a) if a.is_C
-000127d0: 6f6d 706c 656d 656e 7420 656c 7365 2070  omplement else p
-000127e0: 2e5f 7072 696e 7428 6129 2066 6f72 2061  ._print(a) for a
-000127f0: 2069 6e20 7365 6c66 2e61 7267 735d 290a   in self.args]).
-00012800: 0a20 2020 2064 6566 205f 6c61 7465 7828  .    def _latex(
-00012810: 7365 6c66 2c20 7029 3a0a 2020 2020 2020  self, p):.      
-00012820: 2020 6172 6773 203d 205b 5d0a 2020 2020    args = [].    
-00012830: 2020 2020 666f 7220 6920 696e 2073 656c      for i in sel
-00012840: 662e 6172 6773 3a0a 2020 2020 2020 2020  f.args:.        
-00012850: 2020 2020 6c61 7465 7820 3d20 702e 5f70      latex = p._p
-00012860: 7269 6e74 2869 290a 2020 2020 2020 2020  rint(i).        
-00012870: 2020 2020 6966 2069 2e69 735f 436f 6d70      if i.is_Comp
-00012880: 6c65 6d65 6e74 206f 7220 692e 6973 5f55  lement or i.is_U
-00012890: 6e69 6f6e 3a0a 2020 2020 2020 2020 2020  nion:.          
-000128a0: 2020 2020 2020 6c61 7465 7820 3d20 7227        latex = r'
-000128b0: 5c6c 6566 7428 2573 5c72 6967 6874 2927  \left(%s\right)'
-000128c0: 2025 206c 6174 6578 0a20 2020 2020 2020   % latex.       
-000128d0: 2020 2020 2061 7267 732e 6170 7065 6e64       args.append
-000128e0: 286c 6174 6578 290a 0a20 2020 2020 2020  (latex)..       
-000128f0: 2072 6574 7572 6e20 7222 205c 6375 7020   return r" \cup 
-00012900: 222e 6a6f 696e 2861 7267 7329 0a0a 2020  ".join(args)..  
-00012910: 2020 6465 6620 5f5f 6164 645f 5f28 7365    def __add__(se
-00012920: 6c66 2c20 6f74 6865 7229 3a0a 2020 2020  lf, other):.    
-00012930: 2020 2020 6966 206f 7468 6572 2e69 735f      if other.is_
-00012940: 7365 743a 0a20 2020 2020 2020 2020 2020  set:.           
-00012950: 2072 6169 7365 2045 7863 6570 7469 6f6e   raise Exception
-00012960: 2822 636f 756c 6420 6e6f 7420 6164 6420  ("could not add 
-00012970: 2573 2c20 2573 2220 2520 2873 656c 662c  %s, %s" % (self,
-00012980: 206f 7468 6572 2929 0a20 2020 2020 2020   other)).       
-00012990: 2072 6574 7572 6e20 7365 6c66 2e66 756e   return self.fun
-000129a0: 6328 2a28 6172 6720 2b20 6f74 6865 7220  c(*(arg + other 
-000129b0: 666f 7220 6172 6720 696e 2073 656c 662e  for arg in self.
-000129c0: 6172 6773 2929 0a0a 2020 2020 2320 7065  args))..    # pe
-000129d0: 7266 6f72 6d20 6c68 7320 696e 2073 656c  rform lhs in sel
-000129e0: 660a 2020 2020 6465 6620 5f65 7661 6c5f  f.    def _eval_
-000129f0: 5375 6273 6574 5f72 6576 6572 7365 6428  Subset_reversed(
-00012a00: 7365 6c66 2c20 6c68 7329 3a0a 2020 2020  self, lhs):.    
-00012a10: 2020 2020 6966 206c 6873 2069 6e20 7365      if lhs in se
-00012a20: 6c66 2e5f 6172 6773 6574 3a0a 2020 2020  lf._argset:.    
-00012a30: 2020 2020 2020 2020 7265 7475 726e 2053          return S
-00012a40: 2e74 7275 650a 0a20 2020 2023 2070 6572  .true..    # per
-00012a50: 666f 726d 2073 656c 6620 696e 2072 6873  form self in rhs
-00012a60: 0a20 2020 2064 6566 205f 6576 616c 5f53  .    def _eval_S
-00012a70: 7562 7365 7428 7365 6c66 2c20 7268 7329  ubset(self, rhs)
-00012a80: 3a0a 2020 2020 2020 2020 6672 6f6d 2073  :.        from s
-00012a90: 796d 7079 2069 6d70 6f72 7420 5375 6273  ympy import Subs
-00012aa0: 6574 0a20 2020 2020 2020 2066 6f72 2073  et.        for s
-00012ab0: 2069 6e20 7365 6c66 2e5f 6172 6773 6574   in self._argset
-00012ac0: 3a20 0a20 2020 2020 2020 2020 2020 2063  : .            c
-00012ad0: 6f6e 6420 3d20 5375 6273 6574 2873 2c20  ond = Subset(s, 
-00012ae0: 7268 7329 0a20 2020 2020 2020 2020 2020  rhs).           
-00012af0: 2069 6620 636f 6e64 3a0a 2020 2020 2020   if cond:.      
-00012b00: 2020 2020 2020 2020 2020 636f 6e74 696e            contin
-00012b10: 7565 0a20 2020 2020 2020 2020 2020 2065  ue.            e
-00012b20: 6c69 6620 636f 6e64 203d 3d20 4661 6c73  lif cond == Fals
-00012b30: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
-00012b40: 2020 2072 6574 7572 6e20 532e 6661 6c73     return S.fals
-00012b50: 650a 2020 2020 2020 2020 2020 2020 656c  e.            el
-00012b60: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
-00012b70: 2020 2020 7265 7475 726e 0a20 2020 2020      return.     
-00012b80: 2020 2072 6574 7572 6e20 532e 7472 7565     return S.true
-00012b90: 0a0a 2020 2020 6465 6620 7369 6d70 6c69  ..    def simpli
-00012ba0: 6679 2873 656c 662c 2064 6565 703d 4661  fy(self, deep=Fa
-00012bb0: 6c73 652c 202a 2a6b 7761 7267 7329 3a0a  lse, **kwargs):.
-00012bc0: 2020 2020 2020 2020 6966 2064 6565 703a          if deep:
-00012bd0: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
-00012be0: 7572 6e20 5365 742e 7369 6d70 6c69 6679  urn Set.simplify
-00012bf0: 2873 656c 662c 2064 6565 703d 6465 6570  (self, deep=deep
-00012c00: 2c20 2a2a 6b77 6172 6773 290a 2020 2020  , **kwargs).    
-00012c10: 2020 2020 7265 7475 726e 2073 656c 660a      return self.
-00012c20: 0a20 2020 2064 6566 205f 7375 6273 2873  .    def _subs(s
-00012c30: 656c 662c 206f 6c64 2c20 6e65 772c 202a  elf, old, new, *
-00012c40: 2a68 696e 7473 293a 0a20 2020 2020 2020  *hints):.       
-00012c50: 2069 6620 6f6c 642e 6973 5f55 6e69 6f6e   if old.is_Union
-00012c60: 3a0a 2020 2020 2020 2020 2020 2020 6966  :.            if
-00012c70: 206e 6f74 206f 6c64 2e5f 6172 6773 6574   not old._argset
-00012c80: 202d 2073 656c 662e 5f61 7267 7365 743a   - self._argset:
-00012c90: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00012ca0: 2064 6966 6620 3d20 7365 6c66 2e5f 6172   diff = self._ar
-00012cb0: 6773 6574 202d 206f 6c64 2e5f 6172 6773  gset - old._args
-00012cc0: 6574 0a20 2020 2020 2020 2020 2020 2020  et.             
-00012cd0: 2020 2069 6620 6469 6666 3a0a 2020 2020     if diff:.    
-00012ce0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00012cf0: 7265 7475 726e 2055 6e69 6f6e 282a 6469  return Union(*di
-00012d00: 6666 2920 7c20 6e65 770a 2020 2020 2020  ff) | new.      
-00012d10: 2020 2020 2020 2020 2020 7265 7475 726e            return
-00012d20: 206e 6577 0a20 2020 2020 2020 2072 6574   new.        ret
-00012d30: 7572 6e20 5365 742e 5f73 7562 7328 7365  urn Set._subs(se
-00012d40: 6c66 2c20 6f6c 642c 206e 6577 2c20 2a2a  lf, old, new, **
-00012d50: 6869 6e74 7329 0a0a 2020 2020 4063 6c61  hints)..    @cla
-00012d60: 7373 6d65 7468 6f64 0a20 2020 2064 6566  ssmethod.    def
-00012d70: 2063 6c61 7373 5f6b 6579 2863 6c73 293a   class_key(cls):
-00012d80: 0a20 2020 2020 2020 2022 2222 4e69 6365  .        """Nice
-00012d90: 206f 7264 6572 206f 6620 636c 6173 7365   order of classe
-00012da0: 732e 2022 2222 0a20 2020 2020 2020 2072  s. """.        r
-00012db0: 6574 7572 6e20 352c 2038 2c20 636c 732e  eturn 5, 8, cls.
-00012dc0: 5f5f 6e61 6d65 5f5f 0a0a 2020 2020 6465  __name__..    de
-00012dd0: 6620 746f 7365 7428 7365 6c66 293a 0a20  f toset(self):. 
-00012de0: 2020 2020 2020 2073 203d 2073 6574 2829         s = set()
-00012df0: 0a20 2020 2020 2020 2066 6f72 2061 7267  .        for arg
-00012e00: 2069 6e20 7365 6c66 2e61 7267 733a 0a20   in self.args:. 
-00012e10: 2020 2020 2020 2020 2020 2069 6620 6172             if ar
-00012e20: 672e 6973 5f46 696e 6974 6553 6574 3a0a  g.is_FiniteSet:.
-00012e30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00012e40: 7320 7c3d 207b 2a61 7267 2e61 7267 737d  s |= {*arg.args}
-00012e50: 0a20 2020 2020 2020 2020 2020 2065 6c73  .            els
-00012e60: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
-00012e70: 2020 2073 207c 3d20 6172 672e 746f 7365     s |= arg.tose
-00012e80: 7428 290a 2020 2020 2020 2020 2020 2020  t().            
-00012e90: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
-00012ea0: 730a 0a0a 636c 6173 7320 496e 7465 7273  s...class Inters
-00012eb0: 6563 7469 6f6e 2853 6574 2c20 4c61 7474  ection(Set, Latt
-00012ec0: 6963 654f 7029 3a0a 2020 2020 2222 220a  iceOp):.    """.
-00012ed0: 2020 2020 5265 7072 6573 656e 7473 2061      Represents a
-00012ee0: 6e20 696e 7465 7273 6563 7469 6f6e 206f  n intersection o
-00012ef0: 6620 7365 7473 2061 7320 6120 3a63 6c61  f sets as a :cla
-00012f00: 7373 3a60 5365 7460 2e0a 0a20 2020 2045  ss:`Set`...    E
-00012f10: 7861 6d70 6c65 730a 2020 2020 3d3d 3d3d  xamples.    ====
-00012f20: 3d3d 3d3d 0a0a 2020 2020 3e3e 3e20 6672  ====..    >>> fr
-00012f30: 6f6d 2073 796d 7079 2069 6d70 6f72 7420  om sympy import 
-00012f40: 496e 7465 7273 6563 7469 6f6e 2c20 496e  Intersection, In
-00012f50: 7465 7276 616c 0a20 2020 203e 3e3e 2049  terval.    >>> I
-00012f60: 6e74 6572 7365 6374 696f 6e28 496e 7465  ntersection(Inte
-00012f70: 7276 616c 2831 2c20 3329 2c20 496e 7465  rval(1, 3), Inte
-00012f80: 7276 616c 2832 2c20 3429 290a 2020 2020  rval(2, 4)).    
-00012f90: 496e 7465 7276 616c 2832 2c20 3329 0a0a  Interval(2, 3)..
-00012fa0: 2020 2020 5765 206f 6674 656e 2075 7365      We often use
-00012fb0: 2074 6865 202e 696e 7465 7273 6563 7420   the .intersect 
-00012fc0: 6d65 7468 6f64 0a0a 2020 2020 3e3e 3e20  method..    >>> 
-00012fd0: 496e 7465 7276 616c 2831 2c33 292e 696e  Interval(1,3).in
-00012fe0: 7465 7273 6563 7428 496e 7465 7276 616c  tersect(Interval
-00012ff0: 2832 2c34 2929 0a20 2020 2049 6e74 6572  (2,4)).    Inter
-00013000: 7661 6c28 322c 2033 290a 0a20 2020 2053  val(2, 3)..    S
-00013010: 6565 2041 6c73 6f0a 2020 2020 3d3d 3d3d  ee Also.    ====
-00013020: 3d3d 3d3d 0a0a 2020 2020 556e 696f 6e0a  ====..    Union.
-00013030: 0a20 2020 2052 6566 6572 656e 6365 730a  .    References.
-00013040: 2020 2020 3d3d 3d3d 3d3d 3d3d 3d3d 0a0a      ==========..
-00013050: 2020 2020 2e2e 205b 315d 2068 7474 7073      .. [1] https
-00013060: 3a2f 2f65 6e2e 7769 6b69 7065 6469 612e  ://en.wikipedia.
-00013070: 6f72 672f 7769 6b69 2f49 6e74 6572 7365  org/wiki/Interse
-00013080: 6374 696f 6e5f 2532 3873 6574 5f74 6865  ction_%28set_the
-00013090: 6f72 7925 3239 0a20 2020 2022 2222 0a0a  ory%29.    """..
-000130a0: 2020 2020 4070 726f 7065 7274 790a 2020      @property.  
-000130b0: 2020 6465 6620 6574 7970 6528 7365 6c66    def etype(self
-000130c0: 293a 0a20 2020 2020 2020 2064 7479 7065  ):.        dtype
-000130d0: 203d 204e 6f6e 650a 2020 2020 2020 2020   = None.        
-000130e0: 666f 7220 6520 696e 2073 656c 662e 6172  for e in self.ar
-000130f0: 6773 3a0a 2020 2020 2020 2020 2020 2020  gs:.            
-00013100: 5f64 7479 7065 203d 2065 2e65 7479 7065  _dtype = e.etype
-00013110: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
-00013120: 6474 7970 6520 6973 204e 6f6e 653a 0a20  dtype is None:. 
-00013130: 2020 2020 2020 2020 2020 2020 2020 2064                 d
-00013140: 7479 7065 203d 205f 6474 7970 650a 2020  type = _dtype.  
-00013150: 2020 2020 2020 2020 2020 2020 2020 636f                co
-00013160: 6e74 696e 7565 0a20 2020 2020 2020 2020  ntinue.         
-00013170: 2020 2069 6620 6474 7970 6520 213d 205f     if dtype != _
-00013180: 6474 7970 653a 0a20 2020 2020 2020 2020  dtype:.         
-00013190: 2020 2020 2020 2069 6620 5f64 7479 7065         if _dtype
-000131a0: 2069 6e20 6474 7970 653a 0a20 2020 2020   in dtype:.     
-000131b0: 2020 2020 2020 2020 2020 2020 2020 2063                 c
-000131c0: 6f6e 7469 6e75 650a 2020 2020 2020 2020  ontinue.        
-000131d0: 2020 2020 2020 2020 6966 2064 7479 7065          if dtype
-000131e0: 2069 6e20 5f64 7479 7065 3a0a 2020 2020   in _dtype:.    
-000131f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00013200: 6474 7970 6520 3d20 5f64 7479 7065 0a20  dtype = _dtype. 
-00013210: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00013220: 2020 2063 6f6e 7469 6e75 650a 2020 2020     continue.    
-00013230: 2020 2020 2020 2020 2020 2020 7261 6973              rais
-00013240: 6520 4578 6365 7074 696f 6e28 2769 6e63  e Exception('inc
-00013250: 6f6e 7369 7374 656e 7420 6474 7970 653a  onsistent dtype:
-00013260: 2025 7320 616e 6420 2573 2720 2520 2864   %s and %s' % (d
-00013270: 7479 7065 2c20 5f64 7479 7065 2929 0a0a  type, _dtype))..
-00013280: 2020 2020 2020 2020 7265 7475 726e 2064          return d
-00013290: 7479 7065 0a0a 2020 2020 6465 6620 756e  type..    def un
-000132a0: 696f 6e5f 7365 7473 2873 656c 662c 2062  ion_sets(self, b
-000132b0: 293a 0a23 2028 4120 2d20 4229 207c 2028  ):.# (A - B) | (
-000132c0: 4320 2620 4429 203d 2028 2841 202d 2042  C & D) = ((A - B
-000132d0: 2920 7c20 4329 2026 2028 2841 202d 2042  ) | C) & ((A - B
-000132e0: 2920 7c20 4429 203d 2028 4120 7c20 4329  ) | D) = (A | C)
-000132f0: 2026 2028 2841 202d 2042 2920 7c20 4429   & ((A - B) | D)
-00013300: 0a20 2020 2020 2020 2066 6f72 2069 2c20  .        for i, 
-00013310: 6320 696e 2065 6e75 6d65 7261 7465 2873  c in enumerate(s
-00013320: 656c 662e 6172 6773 293a 0a20 2020 2020  elf.args):.     
-00013330: 2020 2020 2020 2069 6620 632e 6973 5f73         if c.is_s
-00013340: 7562 7365 7428 6229 3a0a 2020 2020 2020  ubset(b):.      
-00013350: 2020 2020 2020 2020 2020 7265 7475 726e            return
-00013360: 2062 0a20 2020 2020 2020 2020 2020 2069   b.            i
-00013370: 6620 632e 6973 5f43 6f6d 706c 656d 656e  f c.is_Complemen
-00013380: 743a 0a20 2020 2020 2020 2020 2020 2020  t:.             
-00013390: 2020 2041 2c20 4220 3d20 632e 6172 6773     A, B = c.args
-000133a0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000133b0: 2069 6620 4220 696e 2062 3a0a 2320 2020   if B in b:.#   
-000133c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000133d0: 2020 287b 6b7d 2026 2028 5b30 3b20 6e29    ({k} & ([0; n)
-000133e0: 202f 207b 697d 2929 207c 207b 697d 0a20   / {i})) | {i}. 
-000133f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00013400: 2020 2061 7267 7320 3d20 5b2a 7365 6c66     args = [*self
-00013410: 2e61 7267 735d 0a20 2020 2020 2020 2020  .args].         
-00013420: 2020 2020 2020 2020 2020 2064 656c 2061             del a
-00013430: 7267 735b 695d 0a20 2020 2020 2020 2020  rgs[i].         
-00013440: 2020 2020 2020 2020 2020 2072 6574 7572             retur
-00013450: 6e20 2873 656c 662e 6675 6e63 282a 6172  n (self.func(*ar
-00013460: 6773 2c20 6576 616c 7561 7465 3d46 616c  gs, evaluate=Fal
-00013470: 7365 2920 7c20 6229 2026 2041 0a20 2020  se) | b) & A.   
-00013480: 2020 2020 2020 2020 200a 2320 2841 2026           .# (A &
-00013490: 2043 2920 7c20 2842 2026 2043 2920 3d20   C) | (B & C) = 
-000134a0: 2841 207c 2042 2920 2620 430a 2020 2020  (A | B) & C.    
-000134b0: 2020 2020 6966 2062 2e69 735f 496e 7465      if b.is_Inte
-000134c0: 7273 6563 7469 6f6e 3a0a 2020 2020 2020  rsection:.      
-000134d0: 2020 2020 2020 4320 3d20 7365 6c66 2e5f        C = self._
-000134e0: 6172 6773 6574 2026 2062 2e5f 6172 6773  argset & b._args
-000134f0: 6574 0a20 2020 2020 2020 2020 2020 2069  et.            i
-00013500: 6620 433a 200a 2020 2020 2020 2020 2020  f C: .          
-00013510: 2020 2020 2020 615f 7365 7420 3d20 7365        a_set = se
-00013520: 6c66 2e5f 6172 6773 6574 202d 2043 0a20  lf._argset - C. 
-00013530: 2020 2020 2020 2020 2020 2020 2020 2062                 b
-00013540: 5f73 6574 203d 2062 2e5f 6172 6773 6574  _set = b._argset
-00013550: 202d 2043 0a20 2020 2020 2020 2020 2020   - C.           
-00013560: 2020 2020 2069 6620 6e6f 7420 615f 7365       if not a_se
-00013570: 7420 6f72 206e 6f74 2062 5f73 6574 3a0a  t or not b_set:.
-00013580: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00013590: 2020 2020 7265 7475 726e 2073 656c 662e      return self.
-000135a0: 6675 6e63 282a 4329 0a20 2020 2020 2020  func(*C).       
-000135b0: 2020 2020 2020 2020 200a 2020 2020 2020           .      
-000135c0: 2020 2020 2020 2020 2020 615f 7365 7420            a_set 
-000135d0: 3d20 7365 6c66 2e66 756e 6328 2a61 5f73  = self.func(*a_s
-000135e0: 6574 2c20 6576 616c 7561 7465 3d46 616c  et, evaluate=Fal
-000135f0: 7365 290a 2020 2020 2020 2020 2020 2020  se).            
-00013600: 2020 2020 625f 7365 7420 3d20 7365 6c66      b_set = self
-00013610: 2e66 756e 6328 2a62 5f73 6574 2c20 6576  .func(*b_set, ev
-00013620: 616c 7561 7465 3d46 616c 7365 290a 2020  aluate=False).  
-00013630: 2020 2020 2020 2020 2020 2020 2020 7265                re
-00013640: 7475 726e 2049 6e74 6572 7365 6374 696f  turn Intersectio
-00013650: 6e28 615f 7365 7420 7c20 625f 7365 742c  n(a_set | b_set,
-00013660: 2073 656c 662e 6675 6e63 282a 4329 2c20   self.func(*C), 
-00013670: 6576 616c 7561 7465 3d46 616c 7365 290a  evaluate=False).
-00013680: 2020 2020 2020 2020 0a20 2020 2064 6566          .    def
-00013690: 205f 5f6e 6577 5f5f 2863 6c73 2c20 2a61   __new__(cls, *a
-000136a0: 7267 732c 202a 2a6b 7761 7267 7329 3a0a  rgs, **kwargs):.
-000136b0: 2020 2020 2020 2020 6576 616c 7561 7465          evaluate
-000136c0: 203d 206b 7761 7267 732e 6765 7428 2765   = kwargs.get('e
-000136d0: 7661 6c75 6174 6527 2c20 676c 6f62 616c  valuate', global
-000136e0: 5f70 6172 616d 6574 6572 732e 6576 616c  _parameters.eval
-000136f0: 7561 7465 290a 0a20 2020 2020 2020 2023  uate)..        #
-00013700: 2066 6c61 7474 656e 2069 6e70 7574 7320   flatten inputs 
-00013710: 746f 206d 6572 6765 2069 6e74 6572 7365  to merge interse
-00013720: 6374 696f 6e73 2061 6e64 2069 7465 7261  ctions and itera
-00013730: 626c 6573 0a20 2020 2020 2020 205b 2a61  bles.        [*a
-00013740: 7267 735d 203d 206d 6170 285f 7379 6d70  rgs] = map(_symp
-00013750: 6966 792c 2061 7267 7329 0a20 2020 2020  ify, args).     
-00013760: 2020 2069 6620 6c65 6e28 6172 6773 2920     if len(args) 
-00013770: 3d3d 2031 3a0a 2020 2020 2020 2020 2020  == 1:.          
-00013780: 2020 7265 7475 726e 2061 7267 735b 305d    return args[0]
-00013790: 0a20 2020 2020 2020 2023 2052 6564 7563  .        # Reduc
-000137a0: 6520 7365 7473 2075 7369 6e67 206b 6e6f  e sets using kno
-000137b0: 776e 2072 756c 6573 0a20 2020 2020 2020  wn rules.       
-000137c0: 2069 6620 6576 616c 7561 7465 3a0a 2020   if evaluate:.  
-000137d0: 2020 2020 2020 2020 2020 6172 6773 203d            args =
-000137e0: 206c 6973 7428 636c 732e 5f6e 6577 5f61   list(cls._new_a
-000137f0: 7267 735f 6669 6c74 6572 2861 7267 7329  rgs_filter(args)
-00013800: 290a 2020 2020 2020 2020 2020 2020 7265  ).            re
-00013810: 7475 726e 2073 696d 706c 6966 795f 696e  turn simplify_in
-00013820: 7465 7273 6563 7469 6f6e 2861 7267 7329  tersection(args)
-00013830: 0a0a 2020 2020 2020 2020 6172 6773 2e73  ..        args.s
-00013840: 6f72 7428 6b65 793d 6c61 6d62 6461 2061  ort(key=lambda a
-00013850: 7267 3a20 6172 672e 736f 7274 5f6b 6579  rg: arg.sort_key
-00013860: 2829 290a 0a20 2020 2020 2020 206f 626a  ())..        obj
-00013870: 203d 2042 6173 6963 2e5f 5f6e 6577 5f5f   = Basic.__new__
-00013880: 2863 6c73 2c20 2a61 7267 7329 0a20 2020  (cls, *args).   
-00013890: 2020 2020 206f 626a 2e5f 6172 6773 6574       obj._argset
-000138a0: 203d 2066 726f 7a65 6e73 6574 2861 7267   = frozenset(arg
-000138b0: 7329 0a20 2020 2020 2020 2072 6574 7572  s).        retur
-000138c0: 6e20 6f62 6a0a 0a20 2020 2040 636c 6173  n obj..    @clas
-000138d0: 736d 6574 686f 640a 2020 2020 6465 6620  smethod.    def 
-000138e0: 5f6e 6577 5f61 7267 735f 6669 6c74 6572  _new_args_filter
-000138f0: 2863 6c73 2c20 6172 675f 7365 7175 656e  (cls, arg_sequen
-00013900: 6365 2c20 6361 6c6c 5f63 6c73 3d4e 6f6e  ce, call_cls=Non
-00013910: 6529 3a0a 2020 2020 2020 2020 2222 2247  e):.        """G
-00013920: 656e 6572 6174 6f72 2066 696c 7465 7269  enerator filteri
-00013930: 6e67 2061 7267 7322 2222 0a20 2020 2020  ng args""".     
-00013940: 2020 206e 636c 7320 3d20 6361 6c6c 5f63     ncls = call_c
-00013950: 6c73 206f 7220 636c 730a 2020 2020 2020  ls or cls.      
-00013960: 2020 666f 7220 6172 6720 696e 2061 7267    for arg in arg
-00013970: 5f73 6571 7565 6e63 653a 200a 2020 2020  _sequence: .    
-00013980: 2020 2020 2020 2020 6966 2061 7267 2e66          if arg.f
-00013990: 756e 6320 3d3d 206e 636c 733a 0a20 2020  unc == ncls:.   
-000139a0: 2020 2020 2020 2020 2020 2020 2079 6965               yie
-000139b0: 6c64 2066 726f 6d20 6172 672e 6172 6773  ld from arg.args
-000139c0: 0a20 2020 2020 2020 2020 2020 2065 6c73  .            els
-000139d0: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
-000139e0: 2020 2079 6965 6c64 2061 7267 0a0a 2020     yield arg..  
-000139f0: 2020 4070 726f 7065 7274 790a 2020 2020    @property.    
-00013a00: 6465 6620 6973 5f69 7465 7261 626c 6528  def is_iterable(
-00013a10: 7365 6c66 293a 0a20 2020 2020 2020 2072  self):.        r
-00013a20: 6574 7572 6e20 616e 7928 6172 672e 6973  eturn any(arg.is
-00013a30: 5f69 7465 7261 626c 6520 666f 7220 6172  _iterable for ar
-00013a40: 6720 696e 2073 656c 662e 6172 6773 290a  g in self.args).
-00013a50: 0a20 2020 2040 7072 6f70 6572 7479 0a20  .    @property. 
-00013a60: 2020 2064 6566 205f 696e 6628 7365 6c66     def _inf(self
-00013a70: 293a 0a20 2020 2020 2020 2072 6169 7365  ):.        raise
-00013a80: 204e 6f74 496d 706c 656d 656e 7465 6445   NotImplementedE
-00013a90: 7272 6f72 2829 0a0a 2020 2020 4070 726f  rror()..    @pro
-00013aa0: 7065 7274 790a 2020 2020 6465 6620 5f73  perty.    def _s
-00013ab0: 7570 2873 656c 6629 3a0a 2020 2020 2020  up(self):.      
-00013ac0: 2020 7261 6973 6520 4e6f 7449 6d70 6c65    raise NotImple
-00013ad0: 6d65 6e74 6564 4572 726f 7228 290a 0a20  mentedError().. 
-00013ae0: 2020 2064 6566 205f 636f 6e74 6169 6e73     def _contains
-00013af0: 2873 656c 662c 206f 7468 6572 293a 0a20  (self, other):. 
-00013b00: 2020 2020 2020 2072 6574 7572 6e20 416e         return An
-00013b10: 6428 2a5b 456c 656d 656e 7428 6f74 6865  d(*[Element(othe
-00013b20: 722c 2073 2920 666f 7220 7320 696e 2073  r, s) for s in s
-00013b30: 656c 662e 6172 6773 5d29 0a0a 2020 2020  elf.args])..    
-00013b40: 6465 6620 5f5f 6974 6572 5f5f 2873 656c  def __iter__(sel
-00013b50: 6629 3a0a 2020 2020 2020 2020 6e6f 5f69  f):.        no_i
-00013b60: 7465 7220 3d20 5472 7565 0a20 2020 2020  ter = True.     
-00013b70: 2020 2066 6f72 2073 2069 6e20 7365 6c66     for s in self
-00013b80: 2e61 7267 733a 0a20 2020 2020 2020 2020  .args:.         
-00013b90: 2020 2069 6620 732e 6973 5f69 7465 7261     if s.is_itera
-00013ba0: 626c 653a 0a20 2020 2020 2020 2020 2020  ble:.           
-00013bb0: 2020 2020 206e 6f5f 6974 6572 203d 2046       no_iter = F
-00013bc0: 616c 7365 0a20 2020 2020 2020 2020 2020  alse.           
-00013bd0: 2020 2020 206f 7468 6572 5f73 6574 7320       other_sets 
-00013be0: 3d20 7365 7428 7365 6c66 2e61 7267 7329  = set(self.args)
-00013bf0: 202d 2073 6574 2828 732c 2929 0a20 2020   - set((s,)).   
-00013c00: 2020 2020 2020 2020 2020 2020 206f 7468               oth
-00013c10: 6572 203d 2049 6e74 6572 7365 6374 696f  er = Intersectio
-00013c20: 6e28 2a6f 7468 6572 5f73 6574 732c 2065  n(*other_sets, e
-00013c30: 7661 6c75 6174 653d 4661 6c73 6529 0a20  valuate=False). 
-00013c40: 2020 2020 2020 2020 2020 2020 2020 2066                 f
-00013c50: 6f72 2078 2069 6e20 733a 0a20 2020 2020  or x in s:.     
-00013c60: 2020 2020 2020 2020 2020 2020 2020 2063                 c
-00013c70: 203d 2073 796d 7069 6679 286f 7468 6572   = sympify(other
-00013c80: 2e63 6f6e 7461 696e 7328 7829 290a 2020  .contains(x)).  
-00013c90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00013ca0: 2020 6966 2063 2069 7320 532e 7472 7565    if c is S.true
-00013cb0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-00013cc0: 2020 2020 2020 2020 2020 7969 656c 6420            yield 
-00013cd0: 780a 2020 2020 2020 2020 2020 2020 2020  x.              
-00013ce0: 2020 2020 2020 656c 6966 2063 2069 7320        elif c is 
-00013cf0: 532e 6661 6c73 653a 0a20 2020 2020 2020  S.false:.       
-00013d00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00013d10: 2070 6173 730a 2020 2020 2020 2020 2020   pass.          
-00013d20: 2020 2020 2020 2020 2020 656c 7365 3a0a            else:.
-00013d30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00013d40: 2020 2020 2020 2020 7969 656c 6420 630a          yield c.
-00013d50: 0a20 2020 2020 2020 2069 6620 6e6f 5f69  .        if no_i
-00013d60: 7465 723a 0a20 2020 2020 2020 2020 2020  ter:.           
-00013d70: 2072 6169 7365 2056 616c 7565 4572 726f   raise ValueErro
-00013d80: 7228 224e 6f6e 6520 6f66 2074 6865 2063  r("None of the c
-00013d90: 6f6e 7374 6974 7565 6e74 2073 6574 7320  onstituent sets 
-00013da0: 6172 6520 6974 6572 6162 6c65 2229 0a0a  are iterable")..
-00013db0: 2020 2020 4073 7461 7469 636d 6574 686f      @staticmetho
-00013dc0: 640a 2020 2020 6465 6620 5f68 616e 646c  d.    def _handl
-00013dd0: 655f 6669 6e69 7465 5f73 6574 7328 6172  e_finite_sets(ar
-00013de0: 6773 293a 0a20 2020 2020 2020 2066 726f  gs):.        fro
-00013df0: 6d20 6974 6572 746f 6f6c 7320 696d 706f  m itertools impo
-00013e00: 7274 207a 6970 5f6c 6f6e 6765 7374 0a0a  rt zip_longest..
-00013e10: 2020 2020 2020 2020 6673 5f61 7267 732c          fs_args,
-00013e20: 206f 7468 6572 203d 2073 6966 7428 6172   other = sift(ar
-00013e30: 6773 2c20 6c61 6d62 6461 2078 3a20 782e  gs, lambda x: x.
-00013e40: 6973 5f46 696e 6974 6553 6574 2c20 6269  is_FiniteSet, bi
-00013e50: 6e61 7279 3d54 7275 6529 0a20 2020 2020  nary=True).     
-00013e60: 2020 2069 6620 6e6f 7420 6673 5f61 7267     if not fs_arg
-00013e70: 733a 0a20 2020 2020 2020 2020 2020 2072  s:.            r
-00013e80: 6574 7572 6e0a 2020 2020 2020 2020 6673  eturn.        fs
-00013e90: 5f61 7267 732e 736f 7274 286b 6579 3d6c  _args.sort(key=l
-00013ea0: 656e 290a 2020 2020 2020 2020 7320 3d20  en).        s = 
-00013eb0: 6673 5f61 7267 735b 305d 0a20 2020 2020  fs_args[0].     
-00013ec0: 2020 2066 735f 6172 6773 203d 2066 735f     fs_args = fs_
-00013ed0: 6172 6773 5b31 3a5d 0a0a 2020 2020 2020  args[1:]..      
-00013ee0: 2020 7265 7320 3d20 5b5d 0a20 2020 2020    res = [].     
-00013ef0: 2020 2075 6e6b 203d 205b 5d0a 2020 2020     unk = [].    
-00013f00: 2020 2020 666f 7220 7820 696e 2073 3a0a      for x in s:.
-00013f10: 2020 2020 2020 2020 2020 2020 6320 3d20              c = 
-00013f20: 6675 7a7a 795f 616e 6428 6675 7a7a 795f  fuzzy_and(fuzzy_
-00013f30: 626f 6f6c 286f 2e63 6f6e 7461 696e 7328  bool(o.contains(
-00013f40: 7829 2920 666f 7220 6f20 696e 2066 735f  x)) for o in fs_
-00013f50: 6172 6773 202b 206f 7468 6572 290a 2020  args + other).  
-00013f60: 2020 2020 2020 2020 2020 6966 2063 3a0a            if c:.
-00013f70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00013f80: 7265 732e 6170 7065 6e64 2878 290a 2020  res.append(x).  
-00013f90: 2020 2020 2020 2020 2020 656c 6966 2063            elif c
-00013fa0: 2069 7320 4e6f 6e65 3a0a 2020 2020 2020   is None:.      
-00013fb0: 2020 2020 2020 2020 2020 756e 6b2e 6170            unk.ap
-00013fc0: 7065 6e64 2878 290a 2020 2020 2020 2020  pend(x).        
-00013fd0: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
-00013fe0: 2020 2020 2020 2020 2020 7061 7373 2020            pass  
-00013ff0: 2320 6472 6f70 2061 7267 0a20 2020 2020  # drop arg.     
-00014000: 2020 2020 2020 200a 2020 2020 2020 2020         .        
-00014010: 6672 6f6d 2073 796d 7079 2069 6d70 6f72  from sympy impor
-00014020: 7420 4669 6e69 7465 5365 740a 2020 2020  t FiniteSet.    
-00014030: 2020 2020 7265 7320 3d20 4669 6e69 7465      res = Finite
-00014040: 5365 7428 2a72 6573 2920 6966 2072 6573  Set(*res) if res
-00014050: 2065 6c73 6520 732e 656d 7074 7953 6574   else s.emptySet
-00014060: 0a20 2020 2020 2020 2069 6620 756e 6b3a  .        if unk:
-00014070: 0a20 2020 2020 2020 2020 2020 2073 796d  .            sym
-00014080: 626f 6c69 635f 735f 6c69 7374 203d 205b  bolic_s_list = [
-00014090: 7820 666f 7220 7820 696e 2073 2069 6620  x for x in s if 
-000140a0: 782e 6861 7328 5379 6d62 6f6c 295d 0a20  x.has(Symbol)]. 
-000140b0: 2020 2020 2020 2020 2020 2077 6869 6c65             while
-000140c0: 2066 735f 6172 6773 3a0a 2020 2020 2020   fs_args:.      
-000140d0: 2020 2020 2020 2020 2020 7620 3d20 6673            v = fs
-000140e0: 5f61 7267 732e 706f 7028 290a 2020 2020  _args.pop().    
-000140f0: 2020 2020 2020 2020 2020 2020 6966 206e              if n
-00014100: 6f74 2061 6c6c 2869 203d 3d20 6a20 666f  ot all(i == j fo
-00014110: 7220 692c 206a 2069 6e20 7a69 705f 6c6f  r i, j in zip_lo
-00014120: 6e67 6573 7428 7379 6d62 6f6c 6963 5f73  ngest(symbolic_s
-00014130: 5f6c 6973 742c 2028 7820 666f 7220 7820  _list, (x for x 
-00014140: 696e 2076 2069 6620 782e 6861 7328 5379  in v if x.has(Sy
-00014150: 6d62 6f6c 2929 2929 3a0a 2020 2020 2020  mbol)))):.      
-00014160: 2020 2020 2020 2020 2020 2020 2020 2320                # 
-00014170: 6966 206f 6e6c 7920 6120 7375 6273 6574  if only a subset
-00014180: 206f 6620 656c 656d 656e 7473 2069 6e20   of elements in 
-00014190: 6073 6020 6172 650a 2020 2020 2020 2020  `s` are.        
-000141a0: 2020 2020 2020 2020 2020 2020 2320 636f              # co
-000141b0: 6e74 6169 6e65 6420 696e 2060 7660 2074  ntained in `v` t
-000141c0: 6865 6e20 7265 6d6f 7665 2074 6865 6d20  hen remove them 
-000141d0: 6672 6f6d 2060 7660 0a20 2020 2020 2020  from `v`.       
-000141e0: 2020 2020 2020 2020 2020 2020 2023 2061               # a
-000141f0: 6e64 2061 6464 2074 6869 7320 6173 2061  nd add this as a
-00014200: 206e 6577 2061 7267 0a20 2020 2020 2020   new arg.       
-00014210: 2020 2020 2020 2020 2020 2020 2063 6f6e               con
-00014220: 7461 696e 6564 203d 205b 7820 666f 7220  tained = [x for 
-00014230: 7820 696e 2073 796d 626f 6c69 635f 735f  x in symbolic_s_
-00014240: 6c69 7374 2069 6620 7379 6d70 6966 7928  list if sympify(
-00014250: 762e 636f 6e74 6169 6e73 2878 2929 2069  v.contains(x)) i
-00014260: 7320 532e 7472 7565 5d0a 2020 2020 2020  s S.true].      
-00014270: 2020 2020 2020 2020 2020 2020 2020 6966                if
-00014280: 2063 6f6e 7461 696e 6564 2021 3d20 7379   contained != sy
-00014290: 6d62 6f6c 6963 5f73 5f6c 6973 743a 0a20  mbolic_s_list:. 
-000142a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000142b0: 2020 2020 2020 206f 7468 6572 2e61 7070         other.app
-000142c0: 656e 6428 436f 6d70 6c65 6d65 6e74 2876  end(Complement(v
-000142d0: 2c20 4669 6e69 7465 5365 7428 2a63 6f6e  , FiniteSet(*con
-000142e0: 7461 696e 6564 2929 290a 2020 2020 2020  tained))).      
-000142f0: 2020 2020 2020 2020 2020 2020 2020 656c                el
-00014300: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
-00014310: 2020 2020 2020 2020 2020 2020 6f74 6865              othe
-00014320: 722e 6170 7065 6e64 2876 290a 0a20 2020  r.append(v)..   
-00014330: 2020 2020 2020 2020 206f 7468 6572 5f73           other_s
-00014340: 6574 7320 3d20 496e 7465 7273 6563 7469  ets = Intersecti
-00014350: 6f6e 282a 6f74 6865 7229 0a20 2020 2020  on(*other).     
-00014360: 2020 2020 2020 2069 6620 6e6f 7420 6f74         if not ot
-00014370: 6865 725f 7365 7473 3a0a 2020 2020 2020  her_sets:.      
-00014380: 2020 2020 2020 2020 2020 7265 7475 726e            return
-00014390: 2073 2e65 6d70 7479 5365 7420 2023 2062   s.emptySet  # b
-000143a0: 2f63 2077 6520 7573 6520 6576 616c 7561  /c we use evalua
-000143b0: 7465 3d46 616c 7365 2062 656c 6f77 0a20  te=False below. 
-000143c0: 2020 2020 2020 2020 2020 2065 6c69 6620             elif 
-000143d0: 6f74 6865 725f 7365 7473 2e69 735f 556e  other_sets.is_Un
-000143e0: 6976 6572 7361 6c53 6574 3a0a 2020 2020  iversalSet:.    
-000143f0: 2020 2020 2020 2020 2020 2020 7265 7320              res 
-00014400: 7c3d 2046 696e 6974 6553 6574 282a 756e  |= FiniteSet(*un
-00014410: 6b29 0a20 2020 2020 2020 2020 2020 2065  k).            e
-00014420: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
-00014430: 2020 2020 2075 6e6b 203d 2046 696e 6974       unk = Finit
-00014440: 6553 6574 282a 756e 6b29 0a20 2020 2020  eSet(*unk).     
-00014450: 2020 2020 2020 2020 2020 2072 6573 756c             resul
-00014460: 7420 3d20 6f74 6865 725f 7365 7473 2e68  t = other_sets.h
-00014470: 616e 646c 655f 6669 6e69 7465 5f73 6574  andle_finite_set
-00014480: 7328 756e 6b29 0a20 2020 2020 2020 2020  s(unk).         
-00014490: 2020 2020 2020 2069 6620 7265 7375 6c74         if result
-000144a0: 2069 7320 6e6f 7420 4e6f 6e65 3a0a 2020   is not None:.  
-000144b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000144c0: 2020 7265 7475 726e 2072 6573 207c 2072    return res | r
-000144d0: 6573 756c 740a 2020 2020 2020 2020 2020  esult.          
-000144e0: 2020 2020 2020 7265 7475 726e 2072 6573        return res
-000144f0: 207c 2049 6e74 6572 7365 6374 696f 6e28   | Intersection(
-00014500: 756e 6b2c 206f 7468 6572 5f73 6574 732c  unk, other_sets,
-00014510: 2065 7661 6c75 6174 653d 4661 6c73 6529   evaluate=False)
-00014520: 200a 2020 2020 2020 2020 7265 7475 726e   .        return
-00014530: 2072 6573 0a0a 2020 2020 6465 6620 6173   res..    def as
-00014540: 5f72 656c 6174 696f 6e61 6c28 7365 6c66  _relational(self
-00014550: 2c20 7379 6d62 6f6c 293a 0a20 2020 2020  , symbol):.     
-00014560: 2020 2022 2222 5265 7772 6974 6520 616e     """Rewrite an
-00014570: 2049 6e74 6572 7365 6374 696f 6e20 696e   Intersection in
-00014580: 2074 6572 6d73 206f 6620 6571 7561 6c69   terms of equali
-00014590: 7469 6573 2061 6e64 206c 6f67 6963 206f  ties and logic o
-000145a0: 7065 7261 746f 7273 2222 220a 2020 2020  perators""".    
-000145b0: 2020 2020 7265 7475 726e 2041 6e64 282a      return And(*
-000145c0: 5b73 2e61 735f 7265 6c61 7469 6f6e 616c  [s.as_relational
-000145d0: 2873 796d 626f 6c29 2066 6f72 2073 2069  (symbol) for s i
-000145e0: 6e20 7365 6c66 2e61 7267 735d 290a 0a20  n self.args]).. 
-000145f0: 2020 2022 2222 0a20 2020 2070 7265 636f     """.    preco
-00014600: 6e64 6974 696f 6e3a 2074 6869 7320 7365  ndition: this se
-00014610: 7420 7368 6f75 6c64 206e 6f74 2062 6520  t should not be 
-00014620: 656d 7074 7921 0a20 2020 2022 2222 0a0a  empty!.    """..
-00014630: 2020 2020 6465 6620 6d69 6e28 7365 6c66      def min(self
-00014640: 293a 0a20 2020 2020 2020 2066 726f 6d20  ):.        from 
-00014650: 7379 6d70 792e 6675 6e63 7469 6f6e 732e  sympy.functions.
-00014660: 656c 656d 656e 7461 7279 2e6d 6973 6365  elementary.misce
-00014670: 6c6c 616e 656f 7573 2069 6d70 6f72 7420  llaneous import 
-00014680: 4d61 780a 2020 2020 2020 2020 7265 7475  Max.        retu
-00014690: 726e 204d 6178 282a 2861 7267 2e6d 696e  rn Max(*(arg.min
-000146a0: 2829 2066 6f72 2061 7267 2069 6e20 7365  () for arg in se
-000146b0: 6c66 2e61 7267 7329 2920 2020 2020 2020  lf.args))       
-000146c0: 200a 0a20 2020 2022 2222 0a20 2020 2070   ..    """.    p
-000146d0: 7265 636f 6e64 6974 696f 6e3a 2074 6869  recondition: thi
-000146e0: 7320 7365 7420 7368 6f75 6c64 206e 6f74  s set should not
-000146f0: 2062 6520 656d 7074 7921 0a20 2020 2022   be empty!.    "
-00014700: 2222 0a0a 2020 2020 6465 6620 6d61 7828  ""..    def max(
-00014710: 7365 6c66 293a 0a20 2020 2020 2020 2066  self):.        f
-00014720: 726f 6d20 7379 6d70 792e 6675 6e63 7469  rom sympy.functi
-00014730: 6f6e 732e 656c 656d 656e 7461 7279 2e6d  ons.elementary.m
-00014740: 6973 6365 6c6c 616e 656f 7573 2069 6d70  iscellaneous imp
-00014750: 6f72 7420 4d69 6e0a 2020 2020 2020 2020  ort Min.        
-00014760: 7265 7475 726e 204d 696e 282a 2861 7267  return Min(*(arg
-00014770: 2e6d 6178 2829 2066 6f72 2061 7267 2069  .max() for arg i
-00014780: 6e20 7365 6c66 2e61 7267 7329 290a 0a20  n self.args)).. 
-00014790: 2020 2064 6566 205f 7379 6d70 7973 7472     def _sympystr
-000147a0: 2873 656c 662c 2070 293a 0a20 2020 2020  (self, p):.     
-000147b0: 2020 2023 205c 4e7b 494e 5445 5253 4543     # \N{INTERSEC
-000147c0: 5449 4f4e 7d0a 2020 2020 2020 2020 7265  TION}.        re
-000147d0: 7475 726e 2027 2026 2027 2e6a 6f69 6e28  turn ' & '.join(
-000147e0: 5b22 2825 7329 2220 2520 702e 5f70 7269  ["(%s)" % p._pri
-000147f0: 6e74 2861 2920 6966 2061 2e69 735f 436f  nt(a) if a.is_Co
-00014800: 6d70 6c65 6d65 6e74 206f 7220 612e 6973  mplement or a.is
-00014810: 5f55 6e69 6f6e 2065 6c73 6520 702e 5f70  _Union else p._p
-00014820: 7269 6e74 2861 2920 666f 7220 6120 696e  rint(a) for a in
-00014830: 2073 656c 662e 6172 6773 5d29 0a0a 2020   self.args])..  
-00014840: 2020 6465 6620 5f6c 6174 6578 2873 656c    def _latex(sel
-00014850: 662c 2070 293a 0a20 2020 2020 2020 2061  f, p):.        a
-00014860: 7267 7320 3d20 5b5d 0a20 2020 2020 2020  rgs = [].       
-00014870: 2066 6f72 2069 2069 6e20 7365 6c66 2e61   for i in self.a
-00014880: 7267 733a 0a20 2020 2020 2020 2020 2020  rgs:.           
-00014890: 206c 6174 6578 203d 2070 2e5f 7072 696e   latex = p._prin
-000148a0: 7428 6929 0a20 2020 2020 2020 2020 2020  t(i).           
-000148b0: 2069 6620 692e 6973 5f43 6f6d 706c 656d   if i.is_Complem
-000148c0: 656e 7420 6f72 2069 2e69 735f 556e 696f  ent or i.is_Unio
-000148d0: 6e3a 0a20 2020 2020 2020 2020 2020 2020  n:.             
-000148e0: 2020 206c 6174 6578 203d 2072 275c 6c65     latex = r'\le
-000148f0: 6674 2825 735c 7269 6768 7429 2720 2520  ft(%s\right)' % 
-00014900: 6c61 7465 780a 2020 2020 2020 2020 2020  latex.          
-00014910: 2020 6172 6773 2e61 7070 656e 6428 6c61    args.append(la
-00014920: 7465 7829 0a0a 2020 2020 2020 2020 7265  tex)..        re
-00014930: 7475 726e 2072 2220 5c63 6170 2022 2e6a  turn r" \cap ".j
-00014940: 6f69 6e28 6172 6773 290a 0a20 2020 2064  oin(args)..    d
-00014950: 6566 2068 616e 646c 655f 6669 6e69 7465  ef handle_finite
-00014960: 5f73 6574 7328 7365 6c66 2c20 756e 6b29  _sets(self, unk)
-00014970: 3a0a 2020 2020 2020 2020 666f 7220 692c  :.        for i,
-00014980: 2073 2069 6e20 656e 756d 6572 6174 6528   s in enumerate(
-00014990: 7365 6c66 2e61 7267 7329 3a0a 2020 2020  self.args):.    
-000149a0: 2020 2020 2020 2020 6966 2075 6e6b 2069          if unk i
-000149b0: 6e20 733a 0a20 2020 2020 2020 2020 2020  n s:.           
-000149c0: 2020 2020 2061 7267 7320 3d20 5b2a 7365       args = [*se
-000149d0: 6c66 2e61 7267 735d 0a20 2020 2020 2020  lf.args].       
-000149e0: 2020 2020 2020 2020 2061 7267 735b 695d           args[i]
-000149f0: 203d 2075 6e6b 0a20 2020 2020 2020 2020   = unk.         
-00014a00: 2020 2020 2020 2072 6574 7572 6e20 7365         return se
-00014a10: 6c66 2e66 756e 6328 2a61 7267 732c 2065  lf.func(*args, e
-00014a20: 7661 6c75 6174 653d 4661 6c73 6529 0a20  valuate=False). 
-00014a30: 2020 2020 2020 2020 2020 2069 6620 7320             if s 
-00014a40: 696e 2075 6e6b 3a0a 2020 2020 2020 2020  in unk:.        
-00014a50: 2020 2020 2020 2020 7265 7475 726e 2073          return s
-00014a60: 656c 660a 2020 2020 2020 2020 7265 7475  elf.        retu
-00014a70: 726e 2073 656c 662e 6675 6e63 282a 7365  rn self.func(*se
-00014a80: 6c66 2e61 7267 732c 2075 6e6b 2c20 6576  lf.args, unk, ev
-00014a90: 616c 7561 7465 3d46 616c 7365 290a 0a20  aluate=False).. 
-00014aa0: 2020 2064 6566 205f 6576 616c 5f69 735f     def _eval_is_
-00014ab0: 6669 6e69 7465 7365 7428 7365 6c66 293a  finiteset(self):
-00014ac0: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
-00014ad0: 6675 7a7a 795f 6f75 2861 2e69 735f 6669  fuzzy_ou(a.is_fi
-00014ae0: 6e69 7465 7365 7420 666f 7220 6120 696e  niteset for a in
-00014af0: 2073 656c 662e 6172 6773 290a 2020 2020   self.args).    
-00014b00: 2020 2020 0a20 2020 2064 6566 205f 6576      .    def _ev
-00014b10: 616c 5f69 735f 6578 7465 6e64 6564 5f69  al_is_extended_i
-00014b20: 6e74 6567 6572 2873 656c 6629 3a0a 2020  nteger(self):.  
-00014b30: 2020 2020 2020 7265 7475 726e 2066 757a        return fuz
-00014b40: 7a79 5f6f 7528 6172 672e 6973 5f65 7874  zy_ou(arg.is_ext
-00014b50: 656e 6465 645f 696e 7465 6765 7220 666f  ended_integer fo
-00014b60: 7220 6172 6720 696e 2073 656c 662e 6172  r arg in self.ar
-00014b70: 6773 290a 0a20 2020 2064 6566 205f 6576  gs)..    def _ev
-00014b80: 616c 5f69 735f 7375 7065 725f 696e 7465  al_is_super_inte
-00014b90: 6765 7228 7365 6c66 293a 0a20 2020 2020  ger(self):.     
-00014ba0: 2020 2072 6574 7572 6e20 6675 7a7a 795f     return fuzzy_
-00014bb0: 6f75 2865 2e69 735f 7375 7065 725f 696e  ou(e.is_super_in
-00014bc0: 7465 6765 7220 666f 7220 6520 696e 2073  teger for e in s
-00014bd0: 656c 662e 6172 6773 290a 2020 2020 0a20  elf.args).    . 
-00014be0: 2020 2064 6566 205f 6576 616c 5f69 735f     def _eval_is_
-00014bf0: 6578 7465 6e64 6564 5f72 6174 696f 6e61  extended_rationa
-00014c00: 6c28 7365 6c66 293a 0a20 2020 2020 2020  l(self):.       
-00014c10: 2072 6574 7572 6e20 6675 7a7a 795f 6f75   return fuzzy_ou
-00014c20: 2865 2e69 735f 6578 7465 6e64 6564 5f72  (e.is_extended_r
-00014c30: 6174 696f 6e61 6c20 666f 7220 6520 696e  ational for e in
-00014c40: 2073 656c 662e 6172 6773 290a 2020 2020   self.args).    
-00014c50: 0a20 2020 2064 6566 205f 6576 616c 5f69  .    def _eval_i
-00014c60: 735f 7375 7065 725f 7261 7469 6f6e 616c  s_super_rational
-00014c70: 2873 656c 6629 3a0a 2020 2020 2020 2020  (self):.        
-00014c80: 7265 7475 726e 2066 757a 7a79 5f6f 7528  return fuzzy_ou(
-00014c90: 652e 6973 5f73 7570 6572 5f72 6174 696f  e.is_super_ratio
-00014ca0: 6e61 6c20 666f 7220 6520 696e 2073 656c  nal for e in sel
-00014cb0: 662e 6172 6773 290a 0a20 2020 2064 6566  f.args)..    def
-00014cc0: 205f 6576 616c 5f69 735f 6879 7065 725f   _eval_is_hyper_
-00014cd0: 7261 7469 6f6e 616c 2873 656c 6629 3a0a  rational(self):.
-00014ce0: 2020 2020 2020 2020 7265 7475 726e 2066          return f
-00014cf0: 757a 7a79 5f6f 7528 652e 6973 5f68 7970  uzzy_ou(e.is_hyp
-00014d00: 6572 5f72 6174 696f 6e61 6c20 666f 7220  er_rational for 
-00014d10: 6520 696e 2073 656c 662e 6172 6773 290a  e in self.args).
-00014d20: 2020 2020 0a20 2020 2064 6566 205f 6576      .    def _ev
-00014d30: 616c 5f69 735f 6578 7465 6e64 6564 5f72  al_is_extended_r
-00014d40: 6561 6c28 7365 6c66 293a 0a20 2020 2020  eal(self):.     
-00014d50: 2020 2072 6574 7572 6e20 6675 7a7a 795f     return fuzzy_
-00014d60: 6f75 2865 2e69 735f 6578 7465 6e64 6564  ou(e.is_extended
-00014d70: 5f72 6561 6c20 666f 7220 6520 696e 2073  _real for e in s
-00014d80: 656c 662e 6172 6773 2920 0a0a 2020 2020  elf.args) ..    
-00014d90: 6465 6620 5f65 7661 6c5f 6973 5f68 7970  def _eval_is_hyp
-00014da0: 6572 5f72 6561 6c28 7365 6c66 293a 0a20  er_real(self):. 
-00014db0: 2020 2020 2020 2072 6574 7572 6e20 6675         return fu
-00014dc0: 7a7a 795f 6f75 2865 2e69 735f 6879 7065  zzy_ou(e.is_hype
-00014dd0: 725f 7265 616c 2066 6f72 2065 2069 6e20  r_real for e in 
-00014de0: 7365 6c66 2e61 7267 7329 0a20 2020 200a  self.args).    .
-00014df0: 2020 2020 6465 6620 5f65 7661 6c5f 6973      def _eval_is
-00014e00: 5f73 7570 6572 5f72 6561 6c28 7365 6c66  _super_real(self
-00014e10: 293a 0a20 2020 2020 2020 2072 6574 7572  ):.        retur
-00014e20: 6e20 6675 7a7a 795f 6f75 2865 2e69 735f  n fuzzy_ou(e.is_
-00014e30: 7375 7065 725f 7265 616c 2066 6f72 2065  super_real for e
-00014e40: 2069 6e20 7365 6c66 2e61 7267 7329 0a20   in self.args). 
-00014e50: 2020 200a 2020 2020 6465 6620 5f65 7661     .    def _eva
-00014e60: 6c5f 6973 5f65 7874 656e 6465 645f 636f  l_is_extended_co
-00014e70: 6d70 6c65 7828 7365 6c66 293a 0a20 2020  mplex(self):.   
-00014e80: 2020 2020 2072 6574 7572 6e20 6675 7a7a       return fuzz
-00014e90: 795f 6f75 2865 2e69 735f 6578 7465 6e64  y_ou(e.is_extend
-00014ea0: 6564 5f63 6f6d 706c 6578 2066 6f72 2065  ed_complex for e
-00014eb0: 2069 6e20 7365 6c66 2e61 7267 7329 0a20   in self.args). 
-00014ec0: 2020 2020 0a20 2020 2064 6566 205f 6576      .    def _ev
-00014ed0: 616c 5f69 735f 6879 7065 725f 636f 6d70  al_is_hyper_comp
-00014ee0: 6c65 7828 7365 6c66 293a 0a20 2020 2020  lex(self):.     
-00014ef0: 2020 2072 6574 7572 6e20 6675 7a7a 795f     return fuzzy_
-00014f00: 6f75 2865 2e69 735f 6879 7065 725f 636f  ou(e.is_hyper_co
-00014f10: 6d70 6c65 7820 666f 7220 6520 696e 2073  mplex for e in s
-00014f20: 656c 662e 6172 6773 290a 2020 2020 2020  elf.args).      
-00014f30: 2020 2020 2020 0a20 2020 2040 636c 6173        .    @clas
-00014f40: 736d 6574 686f 640a 2020 2020 6465 6620  smethod.    def 
-00014f50: 7369 6d70 6c69 6679 5f45 7175 616c 2863  simplify_Equal(c
-00014f60: 6c73 2c20 7365 6c66 2c20 6c68 732c 2072  ls, self, lhs, r
-00014f70: 6873 293a 0a20 2020 2020 2020 2022 2222  hs):.        """
-00014f80: 0a20 2020 2020 2020 2070 7265 636f 6e64  .        precond
-00014f90: 6974 696f 6e3a 2073 656c 662e 6c68 7320  ition: self.lhs 
-00014fa0: 6973 2061 2049 6e74 6572 7365 6374 696f  is a Intersectio
-00014fb0: 6e20 6f62 6a65 6374 210a 2020 2020 2020  n object!.      
-00014fc0: 2020 2222 220a 2020 2020 2020 2020 6966    """.        if
-00014fd0: 2072 6873 2e69 735f 456d 7074 7953 6574   rhs.is_EmptySet
-00014fe0: 3a0a 2020 2020 2020 2020 2020 2020 7468  :.            th
-00014ff0: 6973 203d 2073 656c 662e 7369 6d70 6c69  is = self.simpli
-00015000: 6679 5f49 6e74 6572 7365 6374 696f 6e28  fy_Intersection(
-00015010: 6c68 7329 0a20 2020 2020 2020 2020 2020  lhs).           
-00015020: 2069 6620 7468 6973 2069 7320 6e6f 7420   if this is not 
-00015030: 4e6f 6e65 3a0a 2020 2020 2020 2020 2020  None:.          
-00015040: 2020 2020 2020 7265 7475 726e 2074 6869        return thi
-00015050: 730a 0a20 2020 2064 6566 205f 5f61 6464  s..    def __add
-00015060: 5f5f 2873 656c 662c 206f 7468 6572 293a  __(self, other):
-00015070: 0a20 2020 2020 2020 2069 6620 6f74 6865  .        if othe
-00015080: 722e 6973 5f73 6574 3a0a 2020 2020 2020  r.is_set:.      
-00015090: 2020 2020 2020 7261 6973 6520 4578 6365        raise Exce
-000150a0: 7074 696f 6e28 2263 6f75 6c64 206e 6f74  ption("could not
-000150b0: 2061 6464 2025 732c 2025 7322 2025 2028   add %s, %s" % (
-000150c0: 7365 6c66 2c20 6f74 6865 7229 290a 2020  self, other)).  
-000150d0: 2020 2020 2020 7265 7475 726e 2073 656c        return sel
-000150e0: 662e 6675 6e63 282a 2861 7267 202b 206f  f.func(*(arg + o
-000150f0: 7468 6572 2066 6f72 2061 7267 2069 6e20  ther for arg in 
-00015100: 7365 6c66 2e61 7267 7329 290a 0a20 2020  self.args))..   
-00015110: 2023 2070 6572 666f 726d 2073 656c 6620   # perform self 
-00015120: 696e 2072 6873 0a20 2020 2064 6566 205f  in rhs.    def _
-00015130: 6576 616c 5f53 7562 7365 7428 7365 6c66  eval_Subset(self
-00015140: 2c20 7268 7329 3a0a 2020 2020 2020 2020  , rhs):.        
-00015150: 666f 7220 6520 696e 2073 656c 662e 5f61  for e in self._a
-00015160: 7267 7365 743a 0a20 2020 2020 2020 2020  rgset:.         
-00015170: 2020 2069 6620 6520 696e 2072 6873 3a0a     if e in rhs:.
-00015180: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015190: 7265 7475 726e 2053 2e74 7275 650a 0a20  return S.true.. 
-000151a0: 2020 2023 2070 6572 666f 726d 206c 6873     # perform lhs
-000151b0: 2069 6e20 7365 6c66 0a20 2020 2064 6566   in self.    def
-000151c0: 205f 6576 616c 5f53 7562 7365 745f 7265   _eval_Subset_re
-000151d0: 7665 7273 6564 2873 656c 662c 206c 6873  versed(self, lhs
-000151e0: 293a 0a20 2020 2020 2020 2066 726f 6d20  ):.        from 
-000151f0: 7379 6d70 7920 696d 706f 7274 2053 7562  sympy import Sub
-00015200: 7365 740a 2020 2020 2020 2020 666f 7220  set.        for 
-00015210: 6520 696e 2073 656c 662e 5f61 7267 7365  e in self._argse
-00015220: 743a 0a20 2020 2020 2020 2020 2020 2063  t:.            c
-00015230: 6f6e 6420 3d20 5375 6273 6574 286c 6873  ond = Subset(lhs
-00015240: 2c20 6529 0a20 2020 2020 2020 2020 2020  , e).           
-00015250: 2069 6620 636f 6e64 3a0a 2020 2020 2020   if cond:.      
-00015260: 2020 2020 2020 2020 2020 636f 6e74 696e            contin
-00015270: 7565 0a20 2020 2020 2020 2020 2020 2069  ue.            i
-00015280: 6620 636f 6e64 203d 3d20 4661 6c73 653a  f cond == False:
-00015290: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000152a0: 2072 6574 7572 6e20 532e 6661 6c73 650a   return S.false.
-000152b0: 2020 2020 2020 2020 2020 2020 656c 7365              else
-000152c0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-000152d0: 2020 7265 7475 726e 0a20 2020 2020 2020    return.       
-000152e0: 2072 6574 7572 6e20 532e 7472 7565 0a0a   return S.true..
-000152f0: 2020 2020 6465 6620 5f73 7562 7328 7365      def _subs(se
-00015300: 6c66 2c20 6f6c 642c 206e 6577 2c20 2a2a  lf, old, new, **
-00015310: 6869 6e74 7329 3a0a 2020 2020 2020 2020  hints):.        
-00015320: 6966 206f 6c64 2e69 735f 496e 7465 7273  if old.is_Inters
-00015330: 6563 7469 6f6e 3a0a 2020 2020 2020 2020  ection:.        
-00015340: 2020 2020 6966 206e 6f74 206f 6c64 2e5f      if not old._
-00015350: 6172 6773 6574 202d 2073 656c 662e 5f61  argset - self._a
-00015360: 7267 7365 743a 0a20 2020 2020 2020 2020  rgset:.         
-00015370: 2020 2020 2020 2064 6966 6620 3d20 7365         diff = se
-00015380: 6c66 2e5f 6172 6773 6574 202d 206f 6c64  lf._argset - old
-00015390: 2e5f 6172 6773 6574 0a20 2020 2020 2020  ._argset.       
-000153a0: 2020 2020 2020 2020 2069 6620 6469 6666           if diff
-000153b0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-000153c0: 2020 2020 2020 7265 7475 726e 2049 6e74        return Int
-000153d0: 6572 7365 6374 696f 6e28 2a64 6966 6629  ersection(*diff)
-000153e0: 2026 206e 6577 0a20 2020 2020 2020 2020   & new.         
-000153f0: 2020 2020 2020 2072 6574 7572 6e20 6e65         return ne
-00015400: 770a 2020 2020 2020 2020 7265 7475 726e  w.        return
-00015410: 2053 6574 2e5f 7375 6273 2873 656c 662c   Set._subs(self,
-00015420: 206f 6c64 2c20 6e65 772c 202a 2a68 696e   old, new, **hin
-00015430: 7473 290a 0a20 2020 2040 636c 6173 736d  ts)..    @classm
-00015440: 6574 686f 640a 2020 2020 6465 6620 636c  ethod.    def cl
-00015450: 6173 735f 6b65 7928 636c 7329 3a0a 2020  ass_key(cls):.  
-00015460: 2020 2020 2020 2222 224e 6963 6520 6f72        """Nice or
-00015470: 6465 7220 6f66 2063 6c61 7373 6573 2e20  der of classes. 
-00015480: 2222 220a 2020 2020 2020 2020 7265 7475  """.        retu
-00015490: 726e 2035 2c20 372c 2063 6c73 2e5f 5f6e  rn 5, 7, cls.__n
-000154a0: 616d 655f 5f0a 0a0a 636c 6173 7320 436f  ame__...class Co
-000154b0: 6d70 6c65 6d65 6e74 2853 6574 2c20 4576  mplement(Set, Ev
-000154c0: 616c 664d 6978 696e 293a 0a20 2020 2072  alfMixin):.    r
-000154d0: 2222 2252 6570 7265 7365 6e74 7320 7468  """Represents th
-000154e0: 6520 7365 7420 6469 6666 6572 656e 6365  e set difference
-000154f0: 206f 7220 7265 6c61 7469 7665 2063 6f6d   or relative com
-00015500: 706c 656d 656e 7420 6f66 2061 2073 6574  plement of a set
-00015510: 2077 6974 680a 2020 2020 616e 6f74 6865   with.    anothe
-00015520: 7220 7365 742e 0a0a 2020 2020 6041 202d  r set...    `A -
-00015530: 2042 203d 205c 7b78 205c 696e 2041 7c20   B = \{x \in A| 
-00015540: 7820 5c5c 6e6f 7469 6e20 425c 7d60 0a0a  x \\notin B\}`..
-00015550: 0a20 2020 2045 7861 6d70 6c65 730a 2020  .    Examples.  
-00015560: 2020 3d3d 3d3d 3d3d 3d3d 0a0a 2020 2020    ========..    
-00015570: 3e3e 3e20 6672 6f6d 2073 796d 7079 2069  >>> from sympy i
-00015580: 6d70 6f72 7420 436f 6d70 6c65 6d65 6e74  mport Complement
-00015590: 2c20 4669 6e69 7465 5365 740a 2020 2020  , FiniteSet.    
-000155a0: 3e3e 3e20 436f 6d70 6c65 6d65 6e74 2846  >>> Complement(F
-000155b0: 696e 6974 6553 6574 2830 2c20 312c 2032  initeSet(0, 1, 2
-000155c0: 292c 2046 696e 6974 6553 6574 2831 2929  ), FiniteSet(1))
-000155d0: 0a20 2020 207b 302c 2032 7d0a 0a20 2020  .    {0, 2}..   
-000155e0: 2053 6565 2041 6c73 6f0a 2020 2020 3d3d   See Also.    ==
-000155f0: 3d3d 3d3d 3d3d 3d0a 0a20 2020 2049 6e74  =======..    Int
-00015600: 6572 7365 6374 696f 6e2c 2055 6e69 6f6e  ersection, Union
-00015610: 0a0a 2020 2020 5265 6665 7265 6e63 6573  ..    References
-00015620: 0a20 2020 203d 3d3d 3d3d 3d3d 3d3d 3d0a  .    ==========.
-00015630: 0a20 2020 202e 2e20 5b31 5d20 6874 7470  .    .. [1] http
-00015640: 3a2f 2f6d 6174 6877 6f72 6c64 2e77 6f6c  ://mathworld.wol
-00015650: 6672 616d 2e63 6f6d 2f43 6f6d 706c 656d  fram.com/Complem
-00015660: 656e 7453 6574 2e68 746d 6c0a 2020 2020  entSet.html.    
-00015670: 2222 220a 0a20 2020 2069 735f 436f 6d70  """..    is_Comp
-00015680: 6c65 6d65 6e74 203d 2054 7275 650a 0a20  lement = True.. 
-00015690: 2020 2064 6566 205f 6c61 7465 7828 7365     def _latex(se
-000156a0: 6c66 2c20 7029 3a0a 2020 2020 2020 2020  lf, p):.        
+0000fc00: 2020 2020 2020 2072 6574 7572 6e20 532e         return S.
+0000fc10: 7472 7565 0a20 2020 2020 2020 2020 2020  true.           
+0000fc20: 2069 6620 7365 6c66 2e72 6967 6874 5f6f   if self.right_o
+0000fc30: 7065 6e20 3d3d 2072 6873 2e72 6967 6874  pen == rhs.right
+0000fc40: 5f6f 7065 6e3a 0a20 2020 2020 2020 2020  _open:.         
+0000fc50: 2020 2020 2020 2069 6620 7268 732e 7374         if rhs.st
+0000fc60: 6f70 203d 3d20 7365 6c66 2e73 746f 703a  op == self.stop:
+0000fc70: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000fc80: 2020 2020 2069 6620 7365 6c66 2e6c 6566       if self.lef
+0000fc90: 745f 6f70 656e 203d 3d20 7268 732e 6c65  t_open == rhs.le
+0000fca0: 6674 5f6f 7065 6e20 6f72 2073 656c 662e  ft_open or self.
+0000fcb0: 6c65 6674 5f6f 7065 6e20 616e 6420 6e6f  left_open and no
+0000fcc0: 7420 7268 732e 6c65 6674 5f6f 7065 6e3a  t rhs.left_open:
+0000fcd0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000fce0: 2020 2020 2020 2020 2069 6620 7365 6c66           if self
+0000fcf0: 2e73 7461 7274 203e 3d20 7268 732e 7374  .start >= rhs.st
+0000fd00: 6172 743a 0a20 2020 2020 2020 2020 2020  art:.           
+0000fd10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000fd20: 2072 6574 7572 6e20 532e 7472 7565 2020   return S.true  
+0000fd30: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000fd40: 2020 2020 2020 0a0a 2020 2020 4070 726f        ..    @pro
+0000fd50: 7065 7274 790a 2020 2020 6465 6620 6b77  perty.    def kw
+0000fd60: 6172 6773 2873 656c 6629 3a0a 2020 2020  args(self):.    
+0000fd70: 2020 2020 7265 7475 726e 207b 276c 6566      return {'lef
+0000fd80: 745f 6f70 656e 273a 2073 656c 662e 6c65  t_open': self.le
+0000fd90: 6674 5f6f 7065 6e2c 2027 7269 6768 745f  ft_open, 'right_
+0000fda0: 6f70 656e 273a 2073 656c 662e 7269 6768  open': self.righ
+0000fdb0: 745f 6f70 656e 7d20 2020 2020 2020 2020  t_open}         
+0000fdc0: 2020 2020 0a20 2020 2020 200a 2020 2020      .      .    
+0000fdd0: 4063 6c61 7373 6d65 7468 6f64 0a20 2020  @classmethod.   
+0000fde0: 2064 6566 2061 7373 756d 6528 636c 732c   def assume(cls,
+0000fdf0: 202a 2a6b 7761 7267 7329 3a0a 2020 2020   **kwargs):.    
+0000fe00: 2020 2020 6c65 6674 5f6f 7065 6e20 3d20      left_open = 
+0000fe10: 4661 6c73 650a 2020 2020 2020 2020 7269  False.        ri
+0000fe20: 6768 745f 6f70 656e 203d 2046 616c 7365  ght_open = False
+0000fe30: 0a20 2020 2020 2020 2069 6620 6b77 6172  .        if kwar
+0000fe40: 6773 2e67 6574 2827 706f 7369 7469 7665  gs.get('positive
+0000fe50: 2729 3a0a 2020 2020 2020 2020 2020 2020  '):.            
+0000fe60: 7374 6f70 203d 2053 2e49 6e66 696e 6974  stop = S.Infinit
+0000fe70: 790a 2020 2020 2020 2020 2020 2020 7374  y.            st
+0000fe80: 6172 7420 3d20 532e 5a65 726f 0a20 2020  art = S.Zero.   
+0000fe90: 2020 2020 2020 2020 206c 6566 745f 6f70           left_op
+0000fea0: 656e 203d 2054 7275 6520 2020 2020 2020  en = True       
+0000feb0: 2020 2020 200a 2020 2020 2020 2020 656c       .        el
+0000fec0: 6966 206b 7761 7267 732e 6765 7428 276e  if kwargs.get('n
+0000fed0: 6f6e 6e65 6761 7469 7665 2729 3a0a 2020  onnegative'):.  
+0000fee0: 2020 2020 2020 2020 2020 7374 6172 7420            start 
+0000fef0: 3d20 532e 5a65 726f 0a20 2020 2020 2020  = S.Zero.       
+0000ff00: 2020 2020 2073 746f 7020 3d20 532e 496e       stop = S.In
+0000ff10: 6669 6e69 7479 0a20 2020 2020 2020 2065  finity.        e
+0000ff20: 6c69 6620 6b77 6172 6773 2e67 6574 2827  lif kwargs.get('
+0000ff30: 6e65 6761 7469 7665 2729 3a0a 2020 2020  negative'):.    
+0000ff40: 2020 2020 2020 2020 7374 6172 7420 3d20          start = 
+0000ff50: 532e 4e65 6761 7469 7665 496e 6669 6e69  S.NegativeInfini
+0000ff60: 7479 0a20 2020 2020 2020 2020 2020 2073  ty.            s
+0000ff70: 746f 7020 3d20 532e 5a65 726f 0a20 2020  top = S.Zero.   
+0000ff80: 2020 2020 2020 2020 2072 6967 6874 5f6f           right_o
+0000ff90: 7065 6e20 3d20 5472 7565 2020 2020 2020  pen = True      
+0000ffa0: 0a20 2020 2020 2020 2065 6c69 6620 6b77  .        elif kw
+0000ffb0: 6172 6773 2e67 6574 2827 6e6f 6e70 6f73  args.get('nonpos
+0000ffc0: 6974 6976 6527 293a 0a20 2020 2020 2020  itive'):.       
+0000ffd0: 2020 2020 2073 7461 7274 203d 2053 2e4e       start = S.N
+0000ffe0: 6567 6174 6976 6549 6e66 696e 6974 790a  egativeInfinity.
+0000fff0: 2020 2020 2020 2020 2020 2020 7374 6f70              stop
+00010000: 203d 2053 2e5a 6572 6f0a 2020 2020 2020   = S.Zero.      
+00010010: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
+00010020: 2020 2020 7374 6172 7420 3d20 532e 4e65      start = S.Ne
+00010030: 6761 7469 7665 496e 6669 6e69 7479 0a20  gativeInfinity. 
+00010040: 2020 2020 2020 2020 2020 2073 746f 7020             stop 
+00010050: 3d20 532e 496e 6669 6e69 7479 0a20 2020  = S.Infinity.   
+00010060: 2020 2020 2072 6574 7572 6e20 636c 7328       return cls(
+00010070: 7374 6172 742c 2073 746f 702c 206c 6566  start, stop, lef
+00010080: 745f 6f70 656e 3d6c 6566 745f 6f70 656e  t_open=left_open
+00010090: 2c20 7269 6768 745f 6f70 656e 3d72 6967  , right_open=rig
+000100a0: 6874 5f6f 7065 6e29 0a20 2020 2020 2020  ht_open).       
+000100b0: 200a 2020 2020 2020 2020 0a63 6c61 7373   .        .class
+000100c0: 2055 6e69 6f6e 2853 6574 2c20 4c61 7474   Union(Set, Latt
+000100d0: 6963 654f 702c 2045 7661 6c66 4d69 7869  iceOp, EvalfMixi
+000100e0: 6e29 3a0a 2020 2020 2222 220a 2020 2020  n):.    """.    
+000100f0: 5265 7072 6573 656e 7473 2061 2075 6e69  Represents a uni
+00010100: 6f6e 206f 6620 7365 7473 2061 7320 6120  on of sets as a 
+00010110: 3a63 6c61 7373 3a60 5365 7460 2e0a 0a20  :class:`Set`... 
+00010120: 2020 2045 7861 6d70 6c65 730a 2020 2020     Examples.    
+00010130: 3d3d 3d3d 3d3d 3d3d 0a0a 2020 2020 3e3e  ========..    >>
+00010140: 3e20 6672 6f6d 2073 796d 7079 2069 6d70  > from sympy imp
+00010150: 6f72 7420 556e 696f 6e2c 2049 6e74 6572  ort Union, Inter
+00010160: 7661 6c0a 2020 2020 3e3e 3e20 556e 696f  val.    >>> Unio
+00010170: 6e28 496e 7465 7276 616c 2831 2c20 3229  n(Interval(1, 2)
+00010180: 2c20 496e 7465 7276 616c 2833 2c20 3429  , Interval(3, 4)
+00010190: 290a 2020 2020 556e 696f 6e28 496e 7465  ).    Union(Inte
+000101a0: 7276 616c 2831 2c20 3229 2c20 496e 7465  rval(1, 2), Inte
+000101b0: 7276 616c 2833 2c20 3429 290a 0a20 2020  rval(3, 4))..   
+000101c0: 2054 6865 2055 6e69 6f6e 2063 6f6e 7374   The Union const
+000101d0: 7275 6374 6f72 2077 696c 6c20 616c 7761  ructor will alwa
+000101e0: 7973 2074 7279 2074 6f20 6d65 7267 6520  ys try to merge 
+000101f0: 6f76 6572 6c61 7070 696e 6720 696e 7465  overlapping inte
+00010200: 7276 616c 732c 0a20 2020 2069 6620 706f  rvals,.    if po
+00010210: 7373 6962 6c65 2e20 466f 7220 6578 616d  ssible. For exam
+00010220: 706c 653a 0a0a 2020 2020 3e3e 3e20 556e  ple:..    >>> Un
+00010230: 696f 6e28 496e 7465 7276 616c 2831 2c20  ion(Interval(1, 
+00010240: 3229 2c20 496e 7465 7276 616c 2832 2c20  2), Interval(2, 
+00010250: 3329 290a 2020 2020 496e 7465 7276 616c  3)).    Interval
+00010260: 2831 2c20 3329 0a0a 2020 2020 5365 6520  (1, 3)..    See 
+00010270: 416c 736f 0a20 2020 203d 3d3d 3d3d 3d3d  Also.    =======
+00010280: 3d0a 0a20 2020 2049 6e74 6572 7365 6374  =..    Intersect
+00010290: 696f 6e0a 0a20 2020 2052 6566 6572 656e  ion..    Referen
+000102a0: 6365 730a 2020 2020 3d3d 3d3d 3d3d 3d3d  ces.    ========
+000102b0: 3d3d 0a0a 2020 2020 2e2e 205b 315d 2068  ==..    .. [1] h
+000102c0: 7474 7073 3a2f 2f65 6e2e 7769 6b69 7065  ttps://en.wikipe
+000102d0: 6469 612e 6f72 672f 7769 6b69 2f55 6e69  dia.org/wiki/Uni
+000102e0: 6f6e 5f25 3238 7365 745f 7468 656f 7279  on_%28set_theory
+000102f0: 2532 390a 2020 2020 2222 220a 0a20 2020  %29.    """..   
+00010300: 2040 7072 6f70 6572 7479 0a20 2020 2064   @property.    d
+00010310: 6566 2069 6465 6e74 6974 7928 7365 6c66  ef identity(self
+00010320: 293a 0a20 2020 2020 2020 2072 6574 7572  ):.        retur
+00010330: 6e20 7365 6c66 2e65 7479 7065 2e65 6d70  n self.etype.emp
+00010340: 7479 5365 740a 2020 2020 0a20 2020 2040  tySet.    .    @
+00010350: 7072 6f70 6572 7479 0a20 2020 2064 6566  property.    def
+00010360: 207a 6572 6f28 7365 6c66 293a 0a20 2020   zero(self):.   
+00010370: 2020 2020 2072 6574 7572 6e20 7365 6c66       return self
+00010380: 2e65 7479 7065 2e75 6e69 7665 7273 616c  .etype.universal
+00010390: 5365 740a 0a20 2020 2064 6566 205f 5f6e  Set..    def __n
+000103a0: 6577 5f5f 2863 6c73 2c20 2a61 7267 732c  ew__(cls, *args,
+000103b0: 202a 2a6b 7761 7267 7329 3a0a 2020 2020   **kwargs):.    
+000103c0: 2020 2020 6576 616c 7561 7465 203d 206b      evaluate = k
+000103d0: 7761 7267 732e 6765 7428 2765 7661 6c75  wargs.get('evalu
+000103e0: 6174 6527 2c20 676c 6f62 616c 5f70 6172  ate', global_par
+000103f0: 616d 6574 6572 732e 6576 616c 7561 7465  ameters.evaluate
+00010400: 290a 0a20 2020 2020 2020 2023 2066 6c61  )..        # fla
+00010410: 7474 656e 2069 6e70 7574 7320 746f 206d  tten inputs to m
+00010420: 6572 6765 2069 6e74 6572 7365 6374 696f  erge intersectio
+00010430: 6e73 2061 6e64 2069 7465 7261 626c 6573  ns and iterables
+00010440: 0a20 2020 2020 2020 2061 7267 7320 3d20  .        args = 
+00010450: 5f73 796d 7069 6679 2861 7267 7329 0a20  _sympify(args). 
+00010460: 2020 2020 2020 2069 6620 6c65 6e28 6172         if len(ar
+00010470: 6773 2920 3d3d 2031 3a0a 2020 2020 2020  gs) == 1:.      
+00010480: 2020 2020 2020 7265 7475 726e 2061 7267        return arg
+00010490: 735b 305d 0a20 2020 2020 2020 2023 2052  s[0].        # R
+000104a0: 6564 7563 6520 7365 7473 2075 7369 6e67  educe sets using
+000104b0: 206b 6e6f 776e 2072 756c 6573 0a20 2020   known rules.   
+000104c0: 2020 2020 2069 6620 6576 616c 7561 7465       if evaluate
+000104d0: 3a0a 2020 2020 2020 2020 2020 2020 6172  :.            ar
+000104e0: 6773 203d 206c 6973 7428 636c 732e 5f6e  gs = list(cls._n
+000104f0: 6577 5f61 7267 735f 6669 6c74 6572 2861  ew_args_filter(a
+00010500: 7267 7329 290a 2020 2020 2020 2020 2020  rgs)).          
+00010510: 2020 7265 7475 726e 2073 696d 706c 6966    return simplif
+00010520: 795f 756e 696f 6e28 6172 6773 290a 0a20  y_union(args).. 
+00010530: 2020 2020 2020 2061 7267 7320 3d20 6c69         args = li
+00010540: 7374 286f 7264 6572 6564 2861 7267 732c  st(ordered(args,
+00010550: 2053 6574 2e5f 696e 6669 6d75 6d5f 6b65   Set._infimum_ke
+00010560: 7929 290a 0a20 2020 2020 2020 206f 626a  y))..        obj
+00010570: 203d 2042 6173 6963 2e5f 5f6e 6577 5f5f   = Basic.__new__
+00010580: 2863 6c73 2c20 2a61 7267 7329 0a20 2020  (cls, *args).   
+00010590: 2020 2020 206f 626a 2e5f 6172 6773 6574       obj._argset
+000105a0: 203d 2066 726f 7a65 6e73 6574 2861 7267   = frozenset(arg
+000105b0: 7329 0a20 2020 2020 2020 2072 6574 7572  s).        retur
+000105c0: 6e20 6f62 6a0a 0a20 2020 2040 636c 6173  n obj..    @clas
+000105d0: 736d 6574 686f 640a 2020 2020 6465 6620  smethod.    def 
+000105e0: 5f6e 6577 5f61 7267 735f 6669 6c74 6572  _new_args_filter
+000105f0: 2863 6c73 2c20 6172 675f 7365 7175 656e  (cls, arg_sequen
+00010600: 6365 2c20 6361 6c6c 5f63 6c73 3d4e 6f6e  ce, call_cls=Non
+00010610: 6529 3a0a 2020 2020 2020 2020 2222 2247  e):.        """G
+00010620: 656e 6572 6174 6f72 2066 696c 7465 7269  enerator filteri
+00010630: 6e67 2061 7267 7322 2222 0a20 2020 2020  ng args""".     
+00010640: 2020 206e 636c 7320 3d20 6361 6c6c 5f63     ncls = call_c
+00010650: 6c73 206f 7220 636c 730a 2020 2020 2020  ls or cls.      
+00010660: 2020 666f 7220 6172 6720 696e 2061 7267    for arg in arg
+00010670: 5f73 6571 7565 6e63 653a 200a 2020 2020  _sequence: .    
+00010680: 2020 2020 2020 2020 6966 2061 7267 2e66          if arg.f
+00010690: 756e 6320 3d3d 206e 636c 733a 0a20 2020  unc == ncls:.   
+000106a0: 2020 2020 2020 2020 2020 2020 2079 6965               yie
+000106b0: 6c64 2066 726f 6d20 6172 672e 6172 6773  ld from arg.args
+000106c0: 0a20 2020 2020 2020 2020 2020 2065 6c73  .            els
+000106d0: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
+000106e0: 2020 2079 6965 6c64 2061 7267 0a0a 2020     yield arg..  
+000106f0: 2020 4070 726f 7065 7274 790a 2020 2020    @property.    
+00010700: 4063 6163 6865 6974 0a20 2020 2064 6566  @cacheit.    def
+00010710: 2061 7267 7328 7365 6c66 293a 0a20 2020   args(self):.   
+00010720: 2020 2020 2072 6574 7572 6e20 7365 6c66       return self
+00010730: 2e5f 6172 6773 0a0a 2020 2020 6465 6620  ._args..    def 
+00010740: 5f63 6f6d 706c 656d 656e 7428 7365 6c66  _complement(self
+00010750: 2c20 756e 6976 6572 7365 293a 0a20 2020  , universe):.   
+00010760: 2020 2020 2023 2044 654d 6f72 6761 6e27       # DeMorgan'
+00010770: 7320 4c61 770a 2020 2020 2020 2020 7265  s Law.        re
+00010780: 7475 726e 2049 6e74 6572 7365 6374 696f  turn Intersectio
+00010790: 6e28 732e 636f 6d70 6c65 6d65 6e74 2875  n(s.complement(u
+000107a0: 6e69 7665 7273 6529 2066 6f72 2073 2069  niverse) for s i
+000107b0: 6e20 7365 6c66 2e61 7267 7329 0a0a 2020  n self.args)..  
+000107c0: 2020 4070 726f 7065 7274 790a 2020 2020    @property.    
+000107d0: 6465 6620 5f69 6e66 2873 656c 6629 3a0a  def _inf(self):.
+000107e0: 2020 2020 2020 2020 2320 5765 2075 7365          # We use
+000107f0: 204d 696e 2073 6f20 7468 6174 2073 7570   Min so that sup
+00010800: 2069 7320 6d65 616e 696e 6766 756c 2069   is meaningful i
+00010810: 6e20 636f 6d62 696e 6174 696f 6e20 7769  n combination wi
+00010820: 7468 2073 796d 626f 6c69 630a 2020 2020  th symbolic.    
+00010830: 2020 2020 2320 696e 7465 7276 616c 2065      # interval e
+00010840: 6e64 2070 6f69 6e74 732e 0a20 2020 2020  nd points..     
+00010850: 2020 2066 726f 6d20 7379 6d70 792e 6675     from sympy.fu
+00010860: 6e63 7469 6f6e 732e 656c 656d 656e 7461  nctions.elementa
+00010870: 7279 2e6d 6973 6365 6c6c 616e 656f 7573  ry.miscellaneous
+00010880: 2069 6d70 6f72 7420 4d69 6e0a 2020 2020   import Min.    
+00010890: 2020 2020 7265 7475 726e 204d 696e 282a      return Min(*
+000108a0: 5b73 2e69 6e66 2066 6f72 2073 2069 6e20  [s.inf for s in 
+000108b0: 7365 6c66 2e61 7267 735d 290a 0a20 2020  self.args])..   
+000108c0: 2040 7072 6f70 6572 7479 0a20 2020 2064   @property.    d
+000108d0: 6566 205f 7375 7028 7365 6c66 293a 0a20  ef _sup(self):. 
+000108e0: 2020 2020 2020 2023 2057 6520 7573 6520         # We use 
+000108f0: 4d61 7820 736f 2074 6861 7420 7375 7020  Max so that sup 
+00010900: 6973 206d 6561 6e69 6e67 6675 6c20 696e  is meaningful in
+00010910: 2063 6f6d 6269 6e61 7469 6f6e 2077 6974   combination wit
+00010920: 6820 7379 6d62 6f6c 6963 0a20 2020 2020  h symbolic.     
+00010930: 2020 2023 2065 6e64 2070 6f69 6e74 732e     # end points.
+00010940: 0a20 2020 2020 2020 2066 726f 6d20 7379  .        from sy
+00010950: 6d70 792e 6675 6e63 7469 6f6e 732e 656c  mpy.functions.el
+00010960: 656d 656e 7461 7279 2e6d 6973 6365 6c6c  ementary.miscell
+00010970: 616e 656f 7573 2069 6d70 6f72 7420 4d61  aneous import Ma
+00010980: 780a 2020 2020 2020 2020 7265 7475 726e  x.        return
+00010990: 204d 6178 282a 5b73 2e73 7570 2066 6f72   Max(*[s.sup for
+000109a0: 2073 2069 6e20 7365 6c66 2e61 7267 735d   s in self.args]
+000109b0: 290a 0a20 2020 2064 6566 205f 636f 6e74  )..    def _cont
+000109c0: 6169 6e73 2873 656c 662c 206f 7468 6572  ains(self, other
+000109d0: 293a 0a20 2020 2020 2020 2072 6574 7572  ):.        retur
+000109e0: 6e20 4f72 282a 5b45 6c65 6d65 6e74 286f  n Or(*[Element(o
+000109f0: 7468 6572 2c20 7329 2066 6f72 2073 2069  ther, s) for s i
+00010a00: 6e20 7365 6c66 2e61 7267 735d 290a 0a20  n self.args]).. 
+00010a10: 2020 2040 7072 6f70 6572 7479 0a20 2020     @property.   
+00010a20: 2064 6566 205f 6d65 6173 7572 6528 7365   def _measure(se
+00010a30: 6c66 293a 0a20 2020 2020 2020 2023 204d  lf):.        # M
+00010a40: 6561 7375 7265 206f 6620 6120 756e 696f  easure of a unio
+00010a50: 6e20 6973 2074 6865 2073 756d 206f 6620  n is the sum of 
+00010a60: 7468 6520 6d65 6173 7572 6573 206f 6620  the measures of 
+00010a70: 7468 6520 7365 7473 206d 696e 7573 0a20  the sets minus. 
+00010a80: 2020 2020 2020 2023 2074 6865 2073 756d         # the sum
+00010a90: 206f 6620 7468 6569 7220 7061 6972 7769   of their pairwi
+00010aa0: 7365 2069 6e74 6572 7365 6374 696f 6e73  se intersections
+00010ab0: 2070 6c75 7320 7468 6520 7375 6d20 6f66   plus the sum of
+00010ac0: 2074 6865 6972 0a20 2020 2020 2020 2023   their.        #
+00010ad0: 2074 7269 706c 652d 7769 7365 2069 6e74   triple-wise int
+00010ae0: 6572 7365 6374 696f 6e73 206d 696e 7573  ersections minus
+00010af0: 202e 2e2e 2065 7463 2e2e 2e0a 0a20 2020   ... etc.....   
+00010b00: 2020 2020 2023 2053 6574 7320 6973 2061       # Sets is a
+00010b10: 2063 6f6c 6c65 6374 696f 6e20 6f66 2069   collection of i
+00010b20: 6e74 6572 7365 6374 696f 6e73 2061 6e64  ntersections and
+00010b30: 2061 2073 6574 206f 6620 656c 656d 656e   a set of elemen
+00010b40: 7461 7279 0a20 2020 2020 2020 2023 2073  tary.        # s
+00010b50: 6574 7320 7768 6963 6820 6d61 6465 2075  ets which made u
+00010b60: 7020 7468 6f73 6520 696e 7465 7273 6563  p those intersec
+00010b70: 7469 6f6e 7320 2863 616c 6c65 6420 2273  tions (called "s
+00010b80: 6f73 2220 666f 7220 7365 7420 6f66 2073  os" for set of s
+00010b90: 6574 7329 0a20 2020 2020 2020 2023 2041  ets).        # A
+00010ba0: 6e20 6578 616d 706c 6520 656c 656d 656e  n example elemen
+00010bb0: 7420 6d69 6768 7420 6f66 2074 6869 7320  t might of this 
+00010bc0: 6c69 7374 206d 6967 6874 2062 653a 0a20  list might be:. 
+00010bd0: 2020 2020 2020 2023 2020 2020 2820 7b41         #    ( {A
+00010be0: 2c42 2c43 7d2c 2041 2e69 6e74 6572 7365  ,B,C}, A.interse
+00010bf0: 6374 2842 292e 696e 7465 7273 6563 7428  ct(B).intersect(
+00010c00: 4329 2029 0a0a 2020 2020 2020 2020 2320  C) )..        # 
+00010c10: 5374 6172 7420 7769 7468 206a 7573 7420  Start with just 
+00010c20: 656c 656d 656e 7461 7279 2073 6574 7320  elementary sets 
+00010c30: 2820 2028 7b41 7d2c 2041 292c 2028 7b42  (  ({A}, A), ({B
+00010c40: 7d2c 2042 292c 202e 2e2e 2029 0a20 2020  }, B), ... ).   
+00010c50: 2020 2020 2023 2054 6865 6e20 6765 7420       # Then get 
+00010c60: 616e 6420 7375 6274 7261 6374 2028 2020  and subtract (  
+00010c70: 287b 412c 427d 2c20 2841 2069 6e74 2042  ({A,B}, (A int B
+00010c80: 292c 202e 2e2e 2029 2077 6869 6c65 206e  ), ... ) while n
+00010c90: 6f6e 2d7a 6572 6f0a 2020 2020 2020 2020  on-zero.        
+00010ca0: 6672 6f6d 2073 796d 7079 2069 6d70 6f72  from sympy impor
+00010cb0: 7420 4669 6e69 7465 5365 740a 2020 2020  t FiniteSet.    
+00010cc0: 2020 2020 7365 7473 203d 205b 2846 696e      sets = [(Fin
+00010cd0: 6974 6553 6574 2873 292c 2073 2920 666f  iteSet(s), s) fo
+00010ce0: 7220 7320 696e 2073 656c 662e 6172 6773  r s in self.args
+00010cf0: 5d0a 2020 2020 2020 2020 6d65 6173 7572  ].        measur
+00010d00: 6520 3d20 300a 2020 2020 2020 2020 7061  e = 0.        pa
+00010d10: 7269 7479 203d 2031 0a20 2020 2020 2020  rity = 1.       
+00010d20: 2077 6869 6c65 2073 6574 733a 0a20 2020   while sets:.   
+00010d30: 2020 2020 2020 2020 2023 2041 6464 2075           # Add u
+00010d40: 7020 7468 6520 6d65 6173 7572 6520 6f66  p the measure of
+00010d50: 2074 6865 7365 2073 6574 7320 616e 6420   these sets and 
+00010d60: 6164 6420 6f72 2073 7562 7472 6163 7420  add or subtract 
+00010d70: 6974 2074 6f20 746f 7461 6c0a 2020 2020  it to total.    
+00010d80: 2020 2020 2020 2020 6d65 6173 7572 6520          measure 
+00010d90: 2b3d 2070 6172 6974 7920 2a20 7375 6d28  += parity * sum(
+00010da0: 696e 7465 722e 6d65 6173 7572 6520 666f  inter.measure fo
+00010db0: 7220 736f 732c 2069 6e74 6572 2069 6e20  r sos, inter in 
+00010dc0: 7365 7473 290a 0a20 2020 2020 2020 2020  sets)..         
+00010dd0: 2020 2023 2046 6f72 2065 6163 6820 696e     # For each in
+00010de0: 7465 7273 6563 7469 6f6e 2069 6e20 7365  tersection in se
+00010df0: 7473 2c20 636f 6d70 7574 6520 7468 6520  ts, compute the 
+00010e00: 696e 7465 7273 6563 7469 6f6e 2077 6974  intersection wit
+00010e10: 6820 6576 6572 790a 2020 2020 2020 2020  h every.        
+00010e20: 2020 2020 2320 6f74 6865 7220 7365 7420      # other set 
+00010e30: 6e6f 7420 616c 7265 6164 7920 7061 7274  not already part
+00010e40: 206f 6620 7468 6520 696e 7465 7273 6563   of the intersec
+00010e50: 7469 6f6e 2e0a 2020 2020 2020 2020 2020  tion..          
+00010e60: 2020 7365 7473 203d 2028 2873 6f73 202b    sets = ((sos +
+00010e70: 2046 696e 6974 6553 6574 286e 6577 7365   FiniteSet(newse
+00010e80: 7429 2c20 6e65 7773 6574 2e69 6e74 6572  t), newset.inter
+00010e90: 7365 6374 2869 6e74 6572 7365 6374 696f  sect(intersectio
+00010ea0: 6e29 290a 2020 2020 2020 2020 2020 2020  n)).            
+00010eb0: 2020 2020 2020 2020 666f 7220 736f 732c          for sos,
+00010ec0: 2069 6e74 6572 7365 6374 696f 6e20 696e   intersection in
+00010ed0: 2073 6574 7320 666f 7220 6e65 7773 6574   sets for newset
+00010ee0: 2069 6e20 7365 6c66 2e61 7267 730a 2020   in self.args.  
+00010ef0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00010f00: 2020 6966 206e 6577 7365 7420 6e6f 7420    if newset not 
+00010f10: 696e 2073 6f73 290a 0a20 2020 2020 2020  in sos)..       
+00010f20: 2020 2020 2023 2043 6c65 6172 206f 7574       # Clear out
+00010f30: 2073 6574 7320 7769 7468 206e 6f20 6d65   sets with no me
+00010f40: 6173 7572 650a 2020 2020 2020 2020 2020  asure.          
+00010f50: 2020 7365 7473 203d 205b 2873 6f73 2c20    sets = [(sos, 
+00010f60: 696e 7465 7229 2066 6f72 2073 6f73 2c20  inter) for sos, 
+00010f70: 696e 7465 7220 696e 2073 6574 7320 6966  inter in sets if
+00010f80: 2069 6e74 6572 2e6d 6561 7375 7265 2021   inter.measure !
+00010f90: 3d20 305d 0a0a 2020 2020 2020 2020 2020  = 0]..          
+00010fa0: 2020 2320 436c 6561 7220 6f75 7420 6475    # Clear out du
+00010fb0: 706c 6963 6174 6573 0a20 2020 2020 2020  plicates.       
+00010fc0: 2020 2020 2073 6f73 5f6c 6973 7420 3d20       sos_list = 
+00010fd0: 5b5d 0a20 2020 2020 2020 2020 2020 2073  [].            s
+00010fe0: 6574 735f 6c69 7374 203d 205b 5d0a 2020  ets_list = [].  
+00010ff0: 2020 2020 2020 2020 2020 666f 7220 7320            for s 
+00011000: 696e 2073 6574 733a 0a20 2020 2020 2020  in sets:.       
+00011010: 2020 2020 2020 2020 2069 6620 735b 305d           if s[0]
+00011020: 2069 6e20 736f 735f 6c69 7374 3a0a 2020   in sos_list:.  
+00011030: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00011040: 2020 636f 6e74 696e 7565 0a20 2020 2020    continue.     
+00011050: 2020 2020 2020 2020 2020 2065 6c73 653a             else:
+00011060: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00011070: 2020 2020 2073 6f73 5f6c 6973 742e 6170       sos_list.ap
+00011080: 7065 6e64 2873 5b30 5d29 0a20 2020 2020  pend(s[0]).     
+00011090: 2020 2020 2020 2020 2020 2020 2020 2073                 s
+000110a0: 6574 735f 6c69 7374 2e61 7070 656e 6428  ets_list.append(
+000110b0: 7329 0a20 2020 2020 2020 2020 2020 2073  s).            s
+000110c0: 6574 7320 3d20 7365 7473 5f6c 6973 740a  ets = sets_list.
+000110d0: 0a20 2020 2020 2020 2020 2020 2023 2046  .            # F
+000110e0: 6c69 7020 5061 7269 7479 202d 206e 6578  lip Parity - nex
+000110f0: 7420 7469 6d65 2073 7562 7472 6163 742f  t time subtract/
+00011100: 6164 6420 6966 2077 6520 6164 6465 642f  add if we added/
+00011110: 7375 6274 7261 6374 6564 2068 6572 650a  subtracted here.
+00011120: 2020 2020 2020 2020 2020 2020 7061 7269              pari
+00011130: 7479 202a 3d20 2d31 0a20 2020 2020 2020  ty *= -1.       
+00011140: 2072 6574 7572 6e20 6d65 6173 7572 650a   return measure.
+00011150: 0a20 2020 2040 7072 6f70 6572 7479 0a20  .    @property. 
+00011160: 2020 2064 6566 205f 626f 756e 6461 7279     def _boundary
+00011170: 2873 656c 6629 3a0a 0a20 2020 2020 2020  (self):..       
+00011180: 2064 6566 2062 6f75 6e64 6172 795f 6f66   def boundary_of
+00011190: 5f73 6574 2869 293a 0a20 2020 2020 2020  _set(i):.       
+000111a0: 2020 2020 2022 2222 2054 6865 2062 6f75       """ The bou
+000111b0: 6e64 6172 7920 6f66 2073 6574 2069 206d  ndary of set i m
+000111c0: 696e 7573 2069 6e74 6572 696f 7220 6f66  inus interior of
+000111d0: 2061 6c6c 206f 7468 6572 2073 6574 7320   all other sets 
+000111e0: 2222 220a 2020 2020 2020 2020 2020 2020  """.            
+000111f0: 6220 3d20 7365 6c66 2e61 7267 735b 695d  b = self.args[i]
+00011200: 2e62 6f75 6e64 6172 790a 2020 2020 2020  .boundary.      
+00011210: 2020 2020 2020 666f 7220 6a2c 2061 2069        for j, a i
+00011220: 6e20 656e 756d 6572 6174 6528 7365 6c66  n enumerate(self
+00011230: 2e61 7267 7329 3a0a 2020 2020 2020 2020  .args):.        
+00011240: 2020 2020 2020 2020 6966 206a 2021 3d20          if j != 
+00011250: 693a 0a20 2020 2020 2020 2020 2020 2020  i:.             
+00011260: 2020 2020 2020 2062 203d 2062 202d 2061         b = b - a
+00011270: 2e69 6e74 6572 696f 720a 2020 2020 2020  .interior.      
+00011280: 2020 2020 2020 7265 7475 726e 2062 0a0a        return b..
+00011290: 2020 2020 2020 2020 7265 7475 726e 2055          return U
+000112a0: 6e69 6f6e 282a 6d61 7028 626f 756e 6461  nion(*map(bounda
+000112b0: 7279 5f6f 665f 7365 742c 2072 616e 6765  ry_of_set, range
+000112c0: 286c 656e 2873 656c 662e 6172 6773 2929  (len(self.args))
+000112d0: 2929 0a0a 2020 2020 6465 6620 6173 5f72  ))..    def as_r
+000112e0: 656c 6174 696f 6e61 6c28 7365 6c66 2c20  elational(self, 
+000112f0: 7379 6d62 6f6c 293a 0a20 2020 2020 2020  symbol):.       
+00011300: 2022 2222 5265 7772 6974 6520 6120 556e   """Rewrite a Un
+00011310: 696f 6e20 696e 2074 6572 6d73 206f 6620  ion in terms of 
+00011320: 6571 7561 6c69 7469 6573 2061 6e64 206c  equalities and l
+00011330: 6f67 6963 206f 7065 7261 746f 7273 2e20  ogic operators. 
+00011340: 2222 220a 2020 2020 2020 2020 6966 206c  """.        if l
+00011350: 656e 2873 656c 662e 6172 6773 2920 3d3d  en(self.args) ==
+00011360: 2032 3a0a 2020 2020 2020 2020 2020 2020   2:.            
+00011370: 612c 2062 203d 2073 656c 662e 6172 6773  a, b = self.args
+00011380: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
+00011390: 2861 2e73 7570 203d 3d20 622e 696e 6620  (a.sup == b.inf 
+000113a0: 616e 6420 612e 696e 6620 6973 2053 2e4e  and a.inf is S.N
+000113b0: 6567 6174 6976 6549 6e66 696e 6974 790a  egativeInfinity.
+000113c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000113d0: 2020 2020 616e 6420 622e 7375 7020 6973      and b.sup is
+000113e0: 2053 2e49 6e66 696e 6974 7929 3a0a 2020   S.Infinity):.  
+000113f0: 2020 2020 2020 2020 2020 2020 2020 7265                re
+00011400: 7475 726e 2041 6e64 284e 6528 7379 6d62  turn And(Ne(symb
+00011410: 6f6c 2c20 612e 7375 7029 2c20 7379 6d62  ol, a.sup), symb
+00011420: 6f6c 203c 2062 2e73 7570 2c20 7379 6d62  ol < b.sup, symb
+00011430: 6f6c 203e 2061 2e69 6e66 290a 2020 2020  ol > a.inf).    
+00011440: 2020 2020 7265 7475 726e 204f 7228 2a5b      return Or(*[
+00011450: 732e 6173 5f72 656c 6174 696f 6e61 6c28  s.as_relational(
+00011460: 7379 6d62 6f6c 2920 666f 7220 7320 696e  symbol) for s in
+00011470: 2073 656c 662e 6172 6773 5d29 0a0a 2020   self.args])..  
+00011480: 2020 4070 726f 7065 7274 790a 2020 2020    @property.    
+00011490: 6465 6620 6973 5f69 7465 7261 626c 6528  def is_iterable(
+000114a0: 7365 6c66 293a 0a20 2020 2020 2020 2072  self):.        r
+000114b0: 6574 7572 6e20 616c 6c28 6172 672e 6973  eturn all(arg.is
+000114c0: 5f69 7465 7261 626c 6520 666f 7220 6172  _iterable for ar
+000114d0: 6720 696e 2073 656c 662e 6172 6773 290a  g in self.args).
+000114e0: 0a20 2020 2064 6566 205f 6576 616c 5f65  .    def _eval_e
+000114f0: 7661 6c66 2873 656c 662c 2070 7265 6329  valf(self, prec)
+00011500: 3a0a 2020 2020 2020 2020 7472 793a 0a20  :.        try:. 
+00011510: 2020 2020 2020 2020 2020 2072 6574 7572             retur
+00011520: 6e20 556e 696f 6e28 2a28 732e 5f65 7661  n Union(*(s._eva
+00011530: 6c5f 6576 616c 6628 7072 6563 2920 666f  l_evalf(prec) fo
+00011540: 7220 7320 696e 2073 656c 662e 6172 6773  r s in self.args
+00011550: 2929 0a20 2020 2020 2020 2065 7863 6570  )).        excep
+00011560: 7420 2854 7970 6545 7272 6f72 2c20 5661  t (TypeError, Va
+00011570: 6c75 6545 7272 6f72 2c20 4e6f 7449 6d70  lueError, NotImp
+00011580: 6c65 6d65 6e74 6564 4572 726f 7229 3a0a  lementedError):.
+00011590: 2020 2020 2020 2020 2020 2020 696d 706f              impo
+000115a0: 7274 2073 7973 0a20 2020 2020 2020 2020  rt sys.         
+000115b0: 2020 2072 6169 7365 2028 5479 7065 4572     raise (TypeEr
+000115c0: 726f 7228 224e 6f74 2061 6c6c 2073 6574  ror("Not all set
+000115d0: 7320 6172 6520 6576 616c 662d 6162 6c65  s are evalf-able
+000115e0: 2229 2c0a 2020 2020 2020 2020 2020 2020  "),.            
+000115f0: 2020 2020 2020 204e 6f6e 652c 0a20 2020         None,.   
+00011600: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00011610: 7379 732e 6578 635f 696e 666f 2829 5b32  sys.exc_info()[2
+00011620: 5d29 0a0a 2020 2020 6465 6620 5f5f 6974  ])..    def __it
+00011630: 6572 5f5f 2873 656c 6629 3a0a 2020 2020  er__(self):.    
+00011640: 2020 2020 696d 706f 7274 2069 7465 7274      import itert
+00011650: 6f6f 6c73 0a0a 2020 2020 2020 2020 2320  ools..        # 
+00011660: 726f 756e 6472 6f62 696e 2072 6563 6970  roundrobin recip
+00011670: 6520 7461 6b65 6e20 6672 6f6d 2069 7465  e taken from ite
+00011680: 7274 6f6f 6c73 2064 6f63 756d 656e 7461  rtools documenta
+00011690: 7469 6f6e 3a0a 2020 2020 2020 2020 2320  tion:.        # 
+000116a0: 6874 7470 733a 2f2f 646f 6373 2e70 7974  https://docs.pyt
+000116b0: 686f 6e2e 6f72 672f 322f 6c69 6272 6172  hon.org/2/librar
+000116c0: 792f 6974 6572 746f 6f6c 732e 6874 6d6c  y/itertools.html
+000116d0: 2372 6563 6970 6573 0a20 2020 2020 2020  #recipes.       
+000116e0: 2064 6566 2072 6f75 6e64 726f 6269 6e28   def roundrobin(
+000116f0: 2a69 7465 7261 626c 6573 293a 0a20 2020  *iterables):.   
+00011700: 2020 2020 2020 2020 2022 726f 756e 6472           "roundr
+00011710: 6f62 696e 2827 4142 4327 2c20 2744 272c  obin('ABC', 'D',
+00011720: 2027 4546 2729 202d 2d3e 2041 2044 2045   'EF') --> A D E
+00011730: 2042 2046 2043 220a 2020 2020 2020 2020   B F C".        
+00011740: 2020 2020 2320 5265 6369 7065 2063 7265      # Recipe cre
+00011750: 6469 7465 6420 746f 2047 656f 7267 6520  dited to George 
+00011760: 5361 6b6b 6973 0a20 2020 2020 2020 2020  Sakkis.         
+00011770: 2020 2070 656e 6469 6e67 203d 206c 656e     pending = len
+00011780: 2869 7465 7261 626c 6573 290a 2020 2020  (iterables).    
+00011790: 2020 2020 2020 2020 6966 2050 5933 3a0a          if PY3:.
+000117a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000117b0: 6e65 7874 7320 3d20 6974 6572 746f 6f6c  nexts = itertool
+000117c0: 732e 6379 636c 6528 6974 6572 2869 7429  s.cycle(iter(it)
+000117d0: 2e5f 5f6e 6578 745f 5f20 666f 7220 6974  .__next__ for it
+000117e0: 2069 6e20 6974 6572 6162 6c65 7329 0a20   in iterables). 
+000117f0: 2020 2020 2020 2020 2020 2065 6c73 653a             else:
+00011800: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00011810: 206e 6578 7473 203d 2069 7465 7274 6f6f   nexts = itertoo
+00011820: 6c73 2e63 7963 6c65 2869 7465 7228 6974  ls.cycle(iter(it
+00011830: 292e 6e65 7874 2066 6f72 2069 7420 696e  ).next for it in
+00011840: 2069 7465 7261 626c 6573 290a 2020 2020   iterables).    
+00011850: 2020 2020 2020 2020 7768 696c 6520 7065          while pe
+00011860: 6e64 696e 673a 0a20 2020 2020 2020 2020  nding:.         
+00011870: 2020 2020 2020 2074 7279 3a0a 2020 2020         try:.    
+00011880: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00011890: 666f 7220 6e65 7874 2069 6e20 6e65 7874  for next in next
+000118a0: 733a 0a20 2020 2020 2020 2020 2020 2020  s:.             
+000118b0: 2020 2020 2020 2020 2020 2079 6965 6c64             yield
+000118c0: 206e 6578 7428 290a 2020 2020 2020 2020   next().        
+000118d0: 2020 2020 2020 2020 6578 6365 7074 2053          except S
+000118e0: 746f 7049 7465 7261 7469 6f6e 3a0a 2020  topIteration:.  
+000118f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00011900: 2020 7065 6e64 696e 6720 2d3d 2031 0a20    pending -= 1. 
+00011910: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00011920: 2020 206e 6578 7473 203d 2069 7465 7274     nexts = itert
+00011930: 6f6f 6c73 2e63 7963 6c65 2869 7465 7274  ools.cycle(itert
+00011940: 6f6f 6c73 2e69 736c 6963 6528 6e65 7874  ools.islice(next
+00011950: 732c 2070 656e 6469 6e67 2929 0a0a 2020  s, pending))..  
+00011960: 2020 2020 2020 6966 2061 6c6c 2873 2e69        if all(s.i
+00011970: 735f 6974 6572 6162 6c65 2066 6f72 2073  s_iterable for s
+00011980: 2069 6e20 7365 6c66 2e61 7267 7329 3a0a   in self.args):.
+00011990: 2020 2020 2020 2020 2020 2020 7265 7475              retu
+000119a0: 726e 2072 6f75 6e64 726f 6269 6e28 2a28  rn roundrobin(*(
+000119b0: 6974 6572 2861 7267 2920 666f 7220 6172  iter(arg) for ar
+000119c0: 6720 696e 2073 656c 662e 6172 6773 2929  g in self.args))
+000119d0: 0a20 2020 2020 2020 2065 6c73 653a 0a20  .        else:. 
+000119e0: 2020 2020 2020 2020 2020 2072 6169 7365             raise
+000119f0: 2054 7970 6545 7272 6f72 2822 4e6f 7420   TypeError("Not 
+00011a00: 616c 6c20 636f 6e73 7469 7475 656e 7420  all constituent 
+00011a10: 7365 7473 2061 7265 2069 7465 7261 626c  sets are iterabl
+00011a20: 6522 290a 0a20 2020 2064 6566 205f 6576  e")..    def _ev
+00011a30: 616c 5f69 735f 6669 6e69 7465 2873 656c  al_is_finite(sel
+00011a40: 6629 3a0a 2020 2020 2020 2020 6966 2066  f):.        if f
+00011a50: 757a 7a79 5f65 7428 612e 6973 5f66 696e  uzzy_et(a.is_fin
+00011a60: 6974 6520 666f 7220 6120 696e 2073 656c  ite for a in sel
+00011a70: 662e 6172 6773 293a 0a20 2020 2020 2020  f.args):.       
+00011a80: 2020 2020 2072 6574 7572 6e20 5472 7565       return True
+00011a90: 0a0a 2020 2020 6465 6620 5f65 7661 6c5f  ..    def _eval_
+00011aa0: 6973 5f65 7874 656e 6465 645f 696e 7465  is_extended_inte
+00011ab0: 6765 7228 7365 6c66 293a 0a20 2020 2020  ger(self):.     
+00011ac0: 2020 2072 6574 7572 6e20 6675 7a7a 795f     return fuzzy_
+00011ad0: 6574 2861 7267 2e69 735f 6578 7465 6e64  et(arg.is_extend
+00011ae0: 6564 5f69 6e74 6567 6572 2066 6f72 2061  ed_integer for a
+00011af0: 7267 2069 6e20 7365 6c66 2e61 7267 7329  rg in self.args)
+00011b00: 0a0a 2020 2020 6465 6620 5f65 7661 6c5f  ..    def _eval_
+00011b10: 6973 5f73 7570 6572 5f69 6e74 6567 6572  is_super_integer
+00011b20: 2873 656c 6629 3a0a 2020 2020 2020 2020  (self):.        
+00011b30: 7265 7475 726e 2066 757a 7a79 5f65 7428  return fuzzy_et(
+00011b40: 652e 6973 5f73 7570 6572 5f69 6e74 6567  e.is_super_integ
+00011b50: 6572 2066 6f72 2065 2069 6e20 7365 6c66  er for e in self
+00011b60: 2e61 7267 7329 0a20 2020 200a 2020 2020  .args).    .    
+00011b70: 6465 6620 5f65 7661 6c5f 6973 5f65 7874  def _eval_is_ext
+00011b80: 656e 6465 645f 7261 7469 6f6e 616c 2873  ended_rational(s
+00011b90: 656c 6629 3a0a 2020 2020 2020 2020 7265  elf):.        re
+00011ba0: 7475 726e 2066 757a 7a79 5f65 7428 652e  turn fuzzy_et(e.
+00011bb0: 6973 5f65 7874 656e 6465 645f 7261 7469  is_extended_rati
+00011bc0: 6f6e 616c 2066 6f72 2065 2069 6e20 7365  onal for e in se
+00011bd0: 6c66 2e61 7267 7329 0a20 2020 200a 2020  lf.args).    .  
+00011be0: 2020 6465 6620 5f65 7661 6c5f 6973 5f73    def _eval_is_s
+00011bf0: 7570 6572 5f72 6174 696f 6e61 6c28 7365  uper_rational(se
+00011c00: 6c66 293a 0a20 2020 2020 2020 2072 6574  lf):.        ret
+00011c10: 7572 6e20 6675 7a7a 795f 6574 2865 2e69  urn fuzzy_et(e.i
+00011c20: 735f 7375 7065 725f 7261 7469 6f6e 616c  s_super_rational
+00011c30: 2066 6f72 2065 2069 6e20 7365 6c66 2e61   for e in self.a
+00011c40: 7267 7329 0a0a 2020 2020 6465 6620 5f65  rgs)..    def _e
+00011c50: 7661 6c5f 6973 5f68 7970 6572 5f72 6174  val_is_hyper_rat
+00011c60: 696f 6e61 6c28 7365 6c66 293a 0a20 2020  ional(self):.   
+00011c70: 2020 2020 2072 6574 7572 6e20 6675 7a7a       return fuzz
+00011c80: 795f 6574 2865 2e69 735f 6879 7065 725f  y_et(e.is_hyper_
+00011c90: 7261 7469 6f6e 616c 2066 6f72 2065 2069  rational for e i
+00011ca0: 6e20 7365 6c66 2e61 7267 7329 0a20 2020  n self.args).   
+00011cb0: 200a 2020 2020 6465 6620 5f65 7661 6c5f   .    def _eval_
+00011cc0: 6973 5f65 7874 656e 6465 645f 7265 616c  is_extended_real
+00011cd0: 2873 656c 6629 3a0a 2020 2020 2020 2020  (self):.        
+00011ce0: 7265 7475 726e 2066 757a 7a79 5f65 7428  return fuzzy_et(
+00011cf0: 652e 6973 5f65 7874 656e 6465 645f 7265  e.is_extended_re
+00011d00: 616c 2066 6f72 2065 2069 6e20 7365 6c66  al for e in self
+00011d10: 2e61 7267 7329 200a 0a20 2020 2064 6566  .args) ..    def
+00011d20: 205f 6576 616c 5f69 735f 6879 7065 725f   _eval_is_hyper_
+00011d30: 7265 616c 2873 656c 6629 3a0a 2020 2020  real(self):.    
+00011d40: 2020 2020 7265 7475 726e 2066 757a 7a79      return fuzzy
+00011d50: 5f65 7428 652e 6973 5f68 7970 6572 5f72  _et(e.is_hyper_r
+00011d60: 6561 6c20 666f 7220 6520 696e 2073 656c  eal for e in sel
+00011d70: 662e 6172 6773 290a 2020 2020 0a20 2020  f.args).    .   
+00011d80: 2064 6566 205f 6576 616c 5f69 735f 7375   def _eval_is_su
+00011d90: 7065 725f 7265 616c 2873 656c 6629 3a0a  per_real(self):.
+00011da0: 2020 2020 2020 2020 7265 7475 726e 2066          return f
+00011db0: 757a 7a79 5f65 7428 652e 6973 5f73 7570  uzzy_et(e.is_sup
+00011dc0: 6572 5f72 6561 6c20 666f 7220 6520 696e  er_real for e in
+00011dd0: 2073 656c 662e 6172 6773 290a 2020 2020   self.args).    
+00011de0: 0a20 2020 2064 6566 205f 6576 616c 5f69  .    def _eval_i
+00011df0: 735f 6578 7465 6e64 6564 5f63 6f6d 706c  s_extended_compl
+00011e00: 6578 2873 656c 6629 3a0a 2020 2020 2020  ex(self):.      
+00011e10: 2020 7265 7475 726e 2066 757a 7a79 5f65    return fuzzy_e
+00011e20: 7428 652e 6973 5f65 7874 656e 6465 645f  t(e.is_extended_
+00011e30: 636f 6d70 6c65 7820 666f 7220 6520 696e  complex for e in
+00011e40: 2073 656c 662e 6172 6773 290a 2020 2020   self.args).    
+00011e50: 200a 2020 2020 6465 6620 5f65 7661 6c5f   .    def _eval_
+00011e60: 6973 5f68 7970 6572 5f63 6f6d 706c 6578  is_hyper_complex
+00011e70: 2873 656c 6629 3a0a 2020 2020 2020 2020  (self):.        
+00011e80: 7265 7475 726e 2066 757a 7a79 5f65 7428  return fuzzy_et(
+00011e90: 652e 6973 5f68 7970 6572 5f63 6f6d 706c  e.is_hyper_compl
+00011ea0: 6578 2066 6f72 2065 2069 6e20 7365 6c66  ex for e in self
+00011eb0: 2e61 7267 7329 0a0a 2020 2020 4070 726f  .args)..    @pro
+00011ec0: 7065 7274 790a 2020 2020 6465 6620 6574  perty.    def et
+00011ed0: 7970 6528 7365 6c66 293a 0a20 2020 2020  ype(self):.     
+00011ee0: 2020 2064 7479 7065 203d 204e 6f6e 650a     dtype = None.
+00011ef0: 2020 2020 2020 2020 666f 7220 6520 696e          for e in
+00011f00: 2073 656c 662e 6172 6773 3a0a 2020 2020   self.args:.    
+00011f10: 2020 2020 2020 2020 5f64 7479 7065 203d          _dtype =
+00011f20: 2065 2e65 7479 7065 0a20 2020 2020 2020   e.etype.       
+00011f30: 2020 2020 2069 6620 6474 7970 6520 6973       if dtype is
+00011f40: 204e 6f6e 653a 0a20 2020 2020 2020 2020   None:.         
+00011f50: 2020 2020 2020 2064 7479 7065 203d 205f         dtype = _
+00011f60: 6474 7970 650a 2020 2020 2020 2020 2020  dtype.          
+00011f70: 2020 2020 2020 636f 6e74 696e 7565 0a20        continue. 
+00011f80: 2020 2020 2020 2020 2020 2069 6620 6474             if dt
+00011f90: 7970 6520 213d 205f 6474 7970 653a 0a20  ype != _dtype:. 
+00011fa0: 2020 2020 2020 2020 2020 2020 2020 2069                 i
+00011fb0: 6620 5f64 7479 7065 2069 6e20 6474 7970  f _dtype in dtyp
+00011fc0: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
+00011fd0: 2020 2020 2020 2063 6f6e 7469 6e75 650a         continue.
+00011fe0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00011ff0: 6966 2064 7479 7065 2069 6e20 5f64 7479  if dtype in _dty
+00012000: 7065 3a0a 2020 2020 2020 2020 2020 2020  pe:.            
+00012010: 2020 2020 2020 2020 6474 7970 6520 3d20          dtype = 
+00012020: 5f64 7479 7065 0a20 2020 2020 2020 2020  _dtype.         
+00012030: 2020 2020 2020 2020 2020 2063 6f6e 7469             conti
+00012040: 6e75 650a 2020 2020 2020 2020 2020 2020  nue.            
+00012050: 2020 2020 7261 6973 6520 4578 6365 7074      raise Except
+00012060: 696f 6e28 2769 6e63 6f6e 7369 7374 656e  ion('inconsisten
+00012070: 7420 6474 7970 653a 2025 7320 616e 6420  t dtype: %s and 
+00012080: 2573 2720 2520 2864 7479 7065 2c20 5f64  %s' % (dtype, _d
+00012090: 7479 7065 2929 0a0a 2020 2020 2020 2020  type))..        
+000120a0: 7265 7475 726e 2064 7479 7065 0a0a 2020  return dtype..  
+000120b0: 2020 6465 6620 5f65 7661 6c5f 4361 7264    def _eval_Card
+000120c0: 2873 656c 6629 3a0a 2020 2020 2020 2020  (self):.        
+000120d0: 6e6f 6e5f 696e 7465 7273 6563 7420 3d20  non_intersect = 
+000120e0: 5b5d 0a20 2020 2020 2020 2061 7267 7320  [].        args 
+000120f0: 3d20 5b2a 7365 6c66 2e61 7267 735d 0a20  = [*self.args]. 
+00012100: 2020 2020 2020 2066 6f72 2041 2069 6e20         for A in 
+00012110: 7365 6c66 2e61 7267 733a 0a20 2020 2020  self.args:.     
+00012120: 2020 2020 2020 2069 6e74 6572 7365 6374         intersect
+00012130: 203d 2046 616c 7365 0a20 2020 2020 2020   = False.       
+00012140: 2020 2020 2066 6f72 2042 2069 6e20 6172       for B in ar
+00012150: 6773 3a0a 2020 2020 2020 2020 2020 2020  gs:.            
+00012160: 2020 2020 6966 2041 203d 3d20 423a 0a20      if A == B:. 
+00012170: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00012180: 2020 2063 6f6e 7469 6e75 650a 0a20 2020     continue..   
+00012190: 2020 2020 2020 2020 2020 2020 2069 6620               if 
+000121a0: 4120 2620 423a 0a20 2020 2020 2020 2020  A & B:.         
+000121b0: 2020 2020 2020 2020 2020 2069 6e74 6572             inter
+000121c0: 7365 6374 203d 2054 7275 650a 2020 2020  sect = True.    
+000121d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000121e0: 6272 6561 6b0a 2020 2020 2020 2020 2020  break.          
+000121f0: 2020 6966 2069 6e74 6572 7365 6374 3a0a    if intersect:.
+00012200: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00012210: 636f 6e74 696e 7565 0a20 2020 2020 2020  continue.       
+00012220: 2020 2020 206e 6f6e 5f69 6e74 6572 7365       non_interse
+00012230: 6374 2e61 7070 656e 6428 4129 0a20 2020  ct.append(A).   
+00012240: 2020 2020 2020 2020 2061 7267 732e 7265           args.re
+00012250: 6d6f 7665 2841 290a 0a20 2020 2020 2020  move(A)..       
+00012260: 2066 726f 6d20 7379 6d70 792e 636f 7265   from sympy.core
+00012270: 2e61 6464 2069 6d70 6f72 7420 4164 640a  .add import Add.
+00012280: 2020 2020 2020 2020 6966 206e 6f6e 5f69          if non_i
+00012290: 6e74 6572 7365 6374 3a0a 2020 2020 2020  ntersect:.      
+000122a0: 2020 2020 2020 6966 2061 7267 733a 0a20        if args:. 
+000122b0: 2020 2020 2020 2020 2020 2020 2020 2073                 s
+000122c0: 203d 2043 6172 6428 556e 696f 6e28 2a61   = Card(Union(*a
+000122d0: 7267 7329 290a 2020 2020 2020 2020 2020  rgs)).          
+000122e0: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
+000122f0: 2020 2020 2020 2020 7320 3d20 300a 2020          s = 0.  
+00012300: 2020 2020 2020 2020 2020 6672 6f6d 2073            from s
+00012310: 796d 7079 2069 6d70 6f72 7420 4361 7264  ympy import Card
+00012320: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
+00012330: 7572 6e20 4164 6428 2a5b 4361 7264 2841  urn Add(*[Card(A
+00012340: 2920 666f 7220 4120 696e 206e 6f6e 5f69  ) for A in non_i
+00012350: 6e74 6572 7365 6374 5d29 202b 2073 0a0a  ntersect]) + s..
+00012360: 2020 2020 6465 6620 6d69 6e28 7365 6c66      def min(self
+00012370: 293a 0a20 2020 2020 2020 2066 726f 6d20  ):.        from 
+00012380: 7379 6d70 792e 6675 6e63 7469 6f6e 732e  sympy.functions.
+00012390: 656c 656d 656e 7461 7279 2e6d 6973 6365  elementary.misce
+000123a0: 6c6c 616e 656f 7573 2069 6d70 6f72 7420  llaneous import 
+000123b0: 4d69 6e20 2020 2020 2020 200a 2020 2020  Min        .    
+000123c0: 2020 2020 7265 7475 726e 204d 696e 282a      return Min(*
+000123d0: 2861 7267 2e6d 696e 2829 2066 6f72 2061  (arg.min() for a
+000123e0: 7267 2069 6e20 7365 6c66 2e61 7267 7329  rg in self.args)
+000123f0: 2920 2020 2020 2020 200a 0a20 2020 2064  )        ..    d
+00012400: 6566 206d 6178 2873 656c 6629 3a0a 2020  ef max(self):.  
+00012410: 2020 2020 2020 6672 6f6d 2073 796d 7079        from sympy
+00012420: 2e66 756e 6374 696f 6e73 2e65 6c65 6d65  .functions.eleme
+00012430: 6e74 6172 792e 6d69 7363 656c 6c61 6e65  ntary.miscellane
+00012440: 6f75 7320 696d 706f 7274 204d 6178 2020  ous import Max  
+00012450: 2020 2020 2020 0a20 2020 2020 2020 2072        .        r
+00012460: 6574 7572 6e20 4d61 7828 2a28 6172 672e  eturn Max(*(arg.
+00012470: 6d61 7828 2920 666f 7220 6172 6720 696e  max() for arg in
+00012480: 2073 656c 662e 6172 6773 2929 2020 2020   self.args))    
+00012490: 2020 2020 0a0a 2020 2020 6465 6620 5f73      ..    def _s
+000124a0: 796d 7079 7374 7228 7365 6c66 2c20 7029  ympystr(self, p)
+000124b0: 3a0a 2020 2020 2020 2020 7265 7475 726e  :.        return
+000124c0: 2027 20e2 88aa 2027 2e6a 6f69 6e28 5b22   ' ... '.join(["
+000124d0: 2825 7329 2220 2520 702e 5f70 7269 6e74  (%s)" % p._print
+000124e0: 2861 2920 6966 2061 2e69 735f 436f 6d70  (a) if a.is_Comp
+000124f0: 6c65 6d65 6e74 2065 6c73 6520 702e 5f70  lement else p._p
+00012500: 7269 6e74 2861 2920 666f 7220 6120 696e  rint(a) for a in
+00012510: 2073 656c 662e 6172 6773 5d29 0a0a 2020   self.args])..  
+00012520: 2020 6465 6620 5f6c 6174 6578 2873 656c    def _latex(sel
+00012530: 662c 2070 293a 0a20 2020 2020 2020 2061  f, p):.        a
+00012540: 7267 7320 3d20 5b5d 0a20 2020 2020 2020  rgs = [].       
+00012550: 2066 6f72 2069 2069 6e20 7365 6c66 2e61   for i in self.a
+00012560: 7267 733a 0a20 2020 2020 2020 2020 2020  rgs:.           
+00012570: 206c 6174 6578 203d 2070 2e5f 7072 696e   latex = p._prin
+00012580: 7428 6929 0a20 2020 2020 2020 2020 2020  t(i).           
+00012590: 2069 6620 692e 6973 5f43 6f6d 706c 656d   if i.is_Complem
+000125a0: 656e 7420 6f72 2069 2e69 735f 556e 696f  ent or i.is_Unio
+000125b0: 6e3a 0a20 2020 2020 2020 2020 2020 2020  n:.             
+000125c0: 2020 206c 6174 6578 203d 2072 275c 6c65     latex = r'\le
+000125d0: 6674 2825 735c 7269 6768 7429 2720 2520  ft(%s\right)' % 
+000125e0: 6c61 7465 780a 2020 2020 2020 2020 2020  latex.          
+000125f0: 2020 6172 6773 2e61 7070 656e 6428 6c61    args.append(la
+00012600: 7465 7829 0a0a 2020 2020 2020 2020 7265  tex)..        re
+00012610: 7475 726e 2072 2220 5c63 7570 2022 2e6a  turn r" \cup ".j
+00012620: 6f69 6e28 6172 6773 290a 0a20 2020 2064  oin(args)..    d
+00012630: 6566 205f 5f61 6464 5f5f 2873 656c 662c  ef __add__(self,
+00012640: 206f 7468 6572 293a 0a20 2020 2020 2020   other):.       
+00012650: 2069 6620 6f74 6865 722e 6973 5f73 6574   if other.is_set
+00012660: 3a0a 2020 2020 2020 2020 2020 2020 7261  :.            ra
+00012670: 6973 6520 4578 6365 7074 696f 6e28 2263  ise Exception("c
+00012680: 6f75 6c64 206e 6f74 2061 6464 2025 732c  ould not add %s,
+00012690: 2025 7322 2025 2028 7365 6c66 2c20 6f74   %s" % (self, ot
+000126a0: 6865 7229 290a 2020 2020 2020 2020 7265  her)).        re
+000126b0: 7475 726e 2073 656c 662e 6675 6e63 282a  turn self.func(*
+000126c0: 2861 7267 202b 206f 7468 6572 2066 6f72  (arg + other for
+000126d0: 2061 7267 2069 6e20 7365 6c66 2e61 7267   arg in self.arg
+000126e0: 7329 290a 0a20 2020 2023 2070 6572 666f  s))..    # perfo
+000126f0: 726d 206c 6873 2069 6e20 7365 6c66 0a20  rm lhs in self. 
+00012700: 2020 2064 6566 205f 6576 616c 5f53 7562     def _eval_Sub
+00012710: 7365 745f 7265 7665 7273 6564 2873 656c  set_reversed(sel
+00012720: 662c 206c 6873 293a 0a20 2020 2020 2020  f, lhs):.       
+00012730: 2069 6620 6c68 7320 696e 2073 656c 662e   if lhs in self.
+00012740: 5f61 7267 7365 743a 0a20 2020 2020 2020  _argset:.       
+00012750: 2020 2020 2072 6574 7572 6e20 532e 7472       return S.tr
+00012760: 7565 0a0a 2020 2020 2320 7065 7266 6f72  ue..    # perfor
+00012770: 6d20 7365 6c66 2069 6e20 7268 730a 2020  m self in rhs.  
+00012780: 2020 6465 6620 5f65 7661 6c5f 5375 6273    def _eval_Subs
+00012790: 6574 2873 656c 662c 2072 6873 293a 0a20  et(self, rhs):. 
+000127a0: 2020 2020 2020 2066 726f 6d20 7379 6d70         from symp
+000127b0: 7920 696d 706f 7274 2053 7562 7365 740a  y import Subset.
+000127c0: 2020 2020 2020 2020 666f 7220 7320 696e          for s in
+000127d0: 2073 656c 662e 5f61 7267 7365 743a 200a   self._argset: .
+000127e0: 2020 2020 2020 2020 2020 2020 636f 6e64              cond
+000127f0: 203d 2053 7562 7365 7428 732c 2072 6873   = Subset(s, rhs
+00012800: 290a 2020 2020 2020 2020 2020 2020 6966  ).            if
+00012810: 2063 6f6e 643a 0a20 2020 2020 2020 2020   cond:.         
+00012820: 2020 2020 2020 2063 6f6e 7469 6e75 650a         continue.
+00012830: 2020 2020 2020 2020 2020 2020 656c 6966              elif
+00012840: 2063 6f6e 6420 3d3d 2046 616c 7365 3a0a   cond == False:.
+00012850: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00012860: 7265 7475 726e 2053 2e66 616c 7365 0a20  return S.false. 
+00012870: 2020 2020 2020 2020 2020 2065 6c73 653a             else:
+00012880: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00012890: 2072 6574 7572 6e0a 2020 2020 2020 2020   return.        
+000128a0: 7265 7475 726e 2053 2e74 7275 650a 0a20  return S.true.. 
+000128b0: 2020 2064 6566 2073 696d 706c 6966 7928     def simplify(
+000128c0: 7365 6c66 2c20 6465 6570 3d46 616c 7365  self, deep=False
+000128d0: 2c20 2a2a 6b77 6172 6773 293a 0a20 2020  , **kwargs):.   
+000128e0: 2020 2020 2069 6620 6465 6570 3a0a 2020       if deep:.  
+000128f0: 2020 2020 2020 2020 2020 7265 7475 726e            return
+00012900: 2053 6574 2e73 696d 706c 6966 7928 7365   Set.simplify(se
+00012910: 6c66 2c20 6465 6570 3d64 6565 702c 202a  lf, deep=deep, *
+00012920: 2a6b 7761 7267 7329 0a20 2020 2020 2020  *kwargs).       
+00012930: 2072 6574 7572 6e20 7365 6c66 0a0a 2020   return self..  
+00012940: 2020 6465 6620 5f73 7562 7328 7365 6c66    def _subs(self
+00012950: 2c20 6f6c 642c 206e 6577 2c20 2a2a 6869  , old, new, **hi
+00012960: 6e74 7329 3a0a 2020 2020 2020 2020 6966  nts):.        if
+00012970: 206f 6c64 2e69 735f 556e 696f 6e3a 0a20   old.is_Union:. 
+00012980: 2020 2020 2020 2020 2020 2069 6620 6e6f             if no
+00012990: 7420 6f6c 642e 5f61 7267 7365 7420 2d20  t old._argset - 
+000129a0: 7365 6c66 2e5f 6172 6773 6574 3a0a 2020  self._argset:.  
+000129b0: 2020 2020 2020 2020 2020 2020 2020 6469                di
+000129c0: 6666 203d 2073 656c 662e 5f61 7267 7365  ff = self._argse
+000129d0: 7420 2d20 6f6c 642e 5f61 7267 7365 740a  t - old._argset.
+000129e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000129f0: 6966 2064 6966 663a 0a20 2020 2020 2020  if diff:.       
+00012a00: 2020 2020 2020 2020 2020 2020 2072 6574               ret
+00012a10: 7572 6e20 556e 696f 6e28 2a64 6966 6629  urn Union(*diff)
+00012a20: 207c 206e 6577 0a20 2020 2020 2020 2020   | new.         
+00012a30: 2020 2020 2020 2072 6574 7572 6e20 6e65         return ne
+00012a40: 770a 2020 2020 2020 2020 7265 7475 726e  w.        return
+00012a50: 2053 6574 2e5f 7375 6273 2873 656c 662c   Set._subs(self,
+00012a60: 206f 6c64 2c20 6e65 772c 202a 2a68 696e   old, new, **hin
+00012a70: 7473 290a 0a0a 636c 6173 7320 496e 7465  ts)...class Inte
+00012a80: 7273 6563 7469 6f6e 2853 6574 2c20 4c61  rsection(Set, La
+00012a90: 7474 6963 654f 7029 3a0a 2020 2020 2222  tticeOp):.    ""
+00012aa0: 220a 2020 2020 5265 7072 6573 656e 7473  ".    Represents
+00012ab0: 2061 6e20 696e 7465 7273 6563 7469 6f6e   an intersection
+00012ac0: 206f 6620 7365 7473 2061 7320 6120 3a63   of sets as a :c
+00012ad0: 6c61 7373 3a60 5365 7460 2e0a 0a20 2020  lass:`Set`...   
+00012ae0: 2045 7861 6d70 6c65 730a 2020 2020 3d3d   Examples.    ==
+00012af0: 3d3d 3d3d 3d3d 0a0a 2020 2020 3e3e 3e20  ======..    >>> 
+00012b00: 6672 6f6d 2073 796d 7079 2069 6d70 6f72  from sympy impor
+00012b10: 7420 496e 7465 7273 6563 7469 6f6e 2c20  t Intersection, 
+00012b20: 496e 7465 7276 616c 0a20 2020 203e 3e3e  Interval.    >>>
+00012b30: 2049 6e74 6572 7365 6374 696f 6e28 496e   Intersection(In
+00012b40: 7465 7276 616c 2831 2c20 3329 2c20 496e  terval(1, 3), In
+00012b50: 7465 7276 616c 2832 2c20 3429 290a 2020  terval(2, 4)).  
+00012b60: 2020 496e 7465 7276 616c 2832 2c20 3329    Interval(2, 3)
+00012b70: 0a0a 2020 2020 5765 206f 6674 656e 2075  ..    We often u
+00012b80: 7365 2074 6865 202e 696e 7465 7273 6563  se the .intersec
+00012b90: 7420 6d65 7468 6f64 0a0a 2020 2020 3e3e  t method..    >>
+00012ba0: 3e20 496e 7465 7276 616c 2831 2c33 292e  > Interval(1,3).
+00012bb0: 696e 7465 7273 6563 7428 496e 7465 7276  intersect(Interv
+00012bc0: 616c 2832 2c34 2929 0a20 2020 2049 6e74  al(2,4)).    Int
+00012bd0: 6572 7661 6c28 322c 2033 290a 0a20 2020  erval(2, 3)..   
+00012be0: 2053 6565 2041 6c73 6f0a 2020 2020 3d3d   See Also.    ==
+00012bf0: 3d3d 3d3d 3d3d 0a0a 2020 2020 556e 696f  ======..    Unio
+00012c00: 6e0a 0a20 2020 2052 6566 6572 656e 6365  n..    Reference
+00012c10: 730a 2020 2020 3d3d 3d3d 3d3d 3d3d 3d3d  s.    ==========
+00012c20: 0a0a 2020 2020 2e2e 205b 315d 2068 7474  ..    .. [1] htt
+00012c30: 7073 3a2f 2f65 6e2e 7769 6b69 7065 6469  ps://en.wikipedi
+00012c40: 612e 6f72 672f 7769 6b69 2f49 6e74 6572  a.org/wiki/Inter
+00012c50: 7365 6374 696f 6e5f 2532 3873 6574 5f74  section_%28set_t
+00012c60: 6865 6f72 7925 3239 0a20 2020 2022 2222  heory%29.    """
+00012c70: 0a0a 2020 2020 4070 726f 7065 7274 790a  ..    @property.
+00012c80: 2020 2020 6465 6620 6964 656e 7469 7479      def identity
+00012c90: 2873 656c 6629 3a0a 2020 2020 2020 2020  (self):.        
+00012ca0: 7265 7475 726e 2073 656c 662e 6574 7970  return self.etyp
+00012cb0: 652e 756e 6976 6572 7361 6c53 6574 0a20  e.universalSet. 
+00012cc0: 2020 200a 2020 2020 4070 726f 7065 7274     .    @propert
+00012cd0: 790a 2020 2020 6465 6620 6574 7970 6528  y.    def etype(
+00012ce0: 7365 6c66 293a 0a20 2020 2020 2020 2064  self):.        d
+00012cf0: 7479 7065 203d 204e 6f6e 650a 2020 2020  type = None.    
+00012d00: 2020 2020 666f 7220 6520 696e 2073 656c      for e in sel
+00012d10: 662e 6172 6773 3a0a 2020 2020 2020 2020  f.args:.        
+00012d20: 2020 2020 5f64 7479 7065 203d 2065 2e65      _dtype = e.e
+00012d30: 7479 7065 0a20 2020 2020 2020 2020 2020  type.           
+00012d40: 2069 6620 6474 7970 6520 6973 204e 6f6e   if dtype is Non
+00012d50: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
+00012d60: 2020 2064 7479 7065 203d 205f 6474 7970     dtype = _dtyp
+00012d70: 650a 2020 2020 2020 2020 2020 2020 2020  e.              
+00012d80: 2020 636f 6e74 696e 7565 0a20 2020 2020    continue.     
+00012d90: 2020 2020 2020 2069 6620 6474 7970 6520         if dtype 
+00012da0: 213d 205f 6474 7970 653a 0a20 2020 2020  != _dtype:.     
+00012db0: 2020 2020 2020 2020 2020 2069 6620 5f64             if _d
+00012dc0: 7479 7065 2069 6e20 6474 7970 653a 0a20  type in dtype:. 
+00012dd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00012de0: 2020 2063 6f6e 7469 6e75 650a 2020 2020     continue.    
+00012df0: 2020 2020 2020 2020 2020 2020 6966 2064              if d
+00012e00: 7479 7065 2069 6e20 5f64 7479 7065 3a0a  type in _dtype:.
+00012e10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00012e20: 2020 2020 6474 7970 6520 3d20 5f64 7479      dtype = _dty
+00012e30: 7065 0a20 2020 2020 2020 2020 2020 2020  pe.             
+00012e40: 2020 2020 2020 2063 6f6e 7469 6e75 650a         continue.
+00012e50: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00012e60: 7261 6973 6520 4578 6365 7074 696f 6e28  raise Exception(
+00012e70: 2769 6e63 6f6e 7369 7374 656e 7420 6474  'inconsistent dt
+00012e80: 7970 653a 2025 7320 616e 6420 2573 2720  ype: %s and %s' 
+00012e90: 2520 2864 7479 7065 2c20 5f64 7479 7065  % (dtype, _dtype
+00012ea0: 2929 0a0a 2020 2020 2020 2020 7265 7475  ))..        retu
+00012eb0: 726e 2064 7479 7065 0a0a 2020 2020 6465  rn dtype..    de
+00012ec0: 6620 756e 696f 6e5f 7365 7473 2873 656c  f union_sets(sel
+00012ed0: 662c 2062 293a 0a23 2028 4120 2d20 4229  f, b):.# (A - B)
+00012ee0: 207c 2028 4320 2620 4429 203d 2028 2841   | (C & D) = ((A
+00012ef0: 202d 2042 2920 7c20 4329 2026 2028 2841   - B) | C) & ((A
+00012f00: 202d 2042 2920 7c20 4429 203d 2028 4120   - B) | D) = (A 
+00012f10: 7c20 4329 2026 2028 2841 202d 2042 2920  | C) & ((A - B) 
+00012f20: 7c20 4429 0a20 2020 2020 2020 2066 6f72  | D).        for
+00012f30: 2069 2c20 6320 696e 2065 6e75 6d65 7261   i, c in enumera
+00012f40: 7465 2873 656c 662e 6172 6773 293a 0a20  te(self.args):. 
+00012f50: 2020 2020 2020 2020 2020 2069 6620 632e             if c.
+00012f60: 6973 5f73 7562 7365 7428 6229 3a0a 2020  is_subset(b):.  
+00012f70: 2020 2020 2020 2020 2020 2020 2020 7265                re
+00012f80: 7475 726e 2062 0a20 2020 2020 2020 2020  turn b.         
+00012f90: 2020 2069 6620 632e 6973 5f43 6f6d 706c     if c.is_Compl
+00012fa0: 656d 656e 743a 0a20 2020 2020 2020 2020  ement:.         
+00012fb0: 2020 2020 2020 2041 2c20 4220 3d20 632e         A, B = c.
+00012fc0: 6172 6773 0a20 2020 2020 2020 2020 2020  args.           
+00012fd0: 2020 2020 2069 6620 4220 696e 2062 3a0a       if B in b:.
+00012fe0: 2320 2020 2020 2020 2020 2020 2020 2020  #               
+00012ff0: 2020 2020 2020 287b 6b7d 20e2 88a9 2028        ({k} ... (
+00013000: 5b30 3b20 6e29 202f 207b 697d 2929 20e2  [0; n) / {i})) .
+00013010: 88aa 207b 697d 0a20 2020 2020 2020 2020  .. {i}.         
+00013020: 2020 2020 2020 2020 2020 2061 7267 7320             args 
+00013030: 3d20 5b2a 7365 6c66 2e61 7267 735d 0a20  = [*self.args]. 
+00013040: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00013050: 2020 2064 656c 2061 7267 735b 695d 0a20     del args[i]. 
+00013060: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00013070: 2020 2072 6574 7572 6e20 2873 656c 662e     return (self.
+00013080: 6675 6e63 282a 6172 6773 2c20 6576 616c  func(*args, eval
+00013090: 7561 7465 3d46 616c 7365 2920 7c20 6229  uate=False) | b)
+000130a0: 2026 2041 0a20 2020 2020 2020 2020 2020   & A.           
+000130b0: 200a 2320 2841 2026 2043 2920 7c20 2842   .# (A & C) | (B
+000130c0: 2026 2043 2920 3d20 2841 207c 2042 2920   & C) = (A | B) 
+000130d0: 2620 4320 2020 2020 2020 2020 2020 0a20  & C           . 
+000130e0: 2020 2020 2020 2069 6620 622e 6973 5f49         if b.is_I
+000130f0: 6e74 6572 7365 6374 696f 6e3a 0a20 2020  ntersection:.   
+00013100: 2020 2020 2020 2020 2043 203d 2073 656c           C = sel
+00013110: 662e 5f61 7267 7365 7420 2620 622e 5f61  f._argset & b._a
+00013120: 7267 7365 740a 2020 2020 2020 2020 2020  rgset.          
+00013130: 2020 6966 2043 3a20 0a20 2020 2020 2020    if C: .       
+00013140: 2020 2020 2020 2020 2061 5f73 6574 203d           a_set =
+00013150: 2073 656c 662e 5f61 7267 7365 7420 2d20   self._argset - 
+00013160: 430a 2020 2020 2020 2020 2020 2020 2020  C.              
+00013170: 2020 625f 7365 7420 3d20 622e 5f61 7267    b_set = b._arg
+00013180: 7365 7420 2d20 430a 2020 2020 2020 2020  set - C.        
+00013190: 2020 2020 2020 2020 6966 206e 6f74 2061          if not a
+000131a0: 5f73 6574 206f 7220 6e6f 7420 625f 7365  _set or not b_se
+000131b0: 743a 0a20 2020 2020 2020 2020 2020 2020  t:.             
+000131c0: 2020 2020 2020 2072 6574 7572 6e20 7365         return se
+000131d0: 6c66 2e66 756e 6328 2a43 290a 2020 2020  lf.func(*C).    
+000131e0: 2020 2020 2020 2020 2020 2020 0a20 2020              .   
+000131f0: 2020 2020 2020 2020 2020 2020 2061 5f73               a_s
+00013200: 6574 203d 2073 656c 662e 6675 6e63 282a  et = self.func(*
+00013210: 615f 7365 742c 2065 7661 6c75 6174 653d  a_set, evaluate=
+00013220: 4661 6c73 6529 0a20 2020 2020 2020 2020  False).         
+00013230: 2020 2020 2020 2062 5f73 6574 203d 2073         b_set = s
+00013240: 656c 662e 6675 6e63 282a 625f 7365 742c  elf.func(*b_set,
+00013250: 2065 7661 6c75 6174 653d 4661 6c73 6529   evaluate=False)
+00013260: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00013270: 2072 6574 7572 6e20 496e 7465 7273 6563   return Intersec
+00013280: 7469 6f6e 2861 5f73 6574 207c 2062 5f73  tion(a_set | b_s
+00013290: 6574 2c20 7365 6c66 2e66 756e 6328 2a43  et, self.func(*C
+000132a0: 292c 2065 7661 6c75 6174 653d 4661 6c73  ), evaluate=Fals
+000132b0: 6529 0a20 2020 2020 2020 200a 2020 2020  e).        .    
+000132c0: 4070 726f 7065 7274 790a 2020 2020 6465  @property.    de
+000132d0: 6620 7a65 726f 2873 656c 6629 3a0a 2020  f zero(self):.  
+000132e0: 2020 2020 2020 7265 7475 726e 2073 656c        return sel
+000132f0: 662e 6574 7970 652e 656d 7074 7953 6574  f.etype.emptySet
+00013300: 0a0a 2020 2020 6465 6620 5f5f 6e65 775f  ..    def __new_
+00013310: 5f28 636c 732c 202a 6172 6773 2c20 2a2a  _(cls, *args, **
+00013320: 6b77 6172 6773 293a 0a20 2020 2020 2020  kwargs):.       
+00013330: 2065 7661 6c75 6174 6520 3d20 6b77 6172   evaluate = kwar
+00013340: 6773 2e67 6574 2827 6576 616c 7561 7465  gs.get('evaluate
+00013350: 272c 2067 6c6f 6261 6c5f 7061 7261 6d65  ', global_parame
+00013360: 7465 7273 2e65 7661 6c75 6174 6529 0a0a  ters.evaluate)..
+00013370: 2020 2020 2020 2020 2320 666c 6174 7465          # flatte
+00013380: 6e20 696e 7075 7473 2074 6f20 6d65 7267  n inputs to merg
+00013390: 6520 696e 7465 7273 6563 7469 6f6e 7320  e intersections 
+000133a0: 616e 6420 6974 6572 6162 6c65 730a 2020  and iterables.  
+000133b0: 2020 2020 2020 6172 6773 203d 205f 7379        args = _sy
+000133c0: 6d70 6966 7928 6172 6773 290a 2020 2020  mpify(args).    
+000133d0: 2020 2020 6966 206c 656e 2861 7267 7329      if len(args)
+000133e0: 203d 3d20 313a 0a20 2020 2020 2020 2020   == 1:.         
+000133f0: 2020 2072 6574 7572 6e20 6172 6773 5b30     return args[0
+00013400: 5d0a 2020 2020 2020 2020 2320 5265 6475  ].        # Redu
+00013410: 6365 2073 6574 7320 7573 696e 6720 6b6e  ce sets using kn
+00013420: 6f77 6e20 7275 6c65 730a 2020 2020 2020  own rules.      
+00013430: 2020 6966 2065 7661 6c75 6174 653a 0a20    if evaluate:. 
+00013440: 2020 2020 2020 2020 2020 2061 7267 7320             args 
+00013450: 3d20 6c69 7374 2863 6c73 2e5f 6e65 775f  = list(cls._new_
+00013460: 6172 6773 5f66 696c 7465 7228 6172 6773  args_filter(args
+00013470: 2929 0a20 2020 2020 2020 2020 2020 2072  )).            r
+00013480: 6574 7572 6e20 7369 6d70 6c69 6679 5f69  eturn simplify_i
+00013490: 6e74 6572 7365 6374 696f 6e28 6172 6773  ntersection(args
+000134a0: 290a 0a20 2020 2020 2020 2061 7267 7320  )..        args 
+000134b0: 3d20 6c69 7374 286f 7264 6572 6564 2861  = list(ordered(a
+000134c0: 7267 732c 2053 6574 2e5f 696e 6669 6d75  rgs, Set._infimu
+000134d0: 6d5f 6b65 7929 290a 0a20 2020 2020 2020  m_key))..       
+000134e0: 206f 626a 203d 2042 6173 6963 2e5f 5f6e   obj = Basic.__n
+000134f0: 6577 5f5f 2863 6c73 2c20 2a61 7267 7329  ew__(cls, *args)
+00013500: 0a20 2020 2020 2020 206f 626a 2e5f 6172  .        obj._ar
+00013510: 6773 6574 203d 2066 726f 7a65 6e73 6574  gset = frozenset
+00013520: 2861 7267 7329 0a20 2020 2020 2020 2072  (args).        r
+00013530: 6574 7572 6e20 6f62 6a0a 0a20 2020 2040  eturn obj..    @
+00013540: 636c 6173 736d 6574 686f 640a 2020 2020  classmethod.    
+00013550: 6465 6620 5f6e 6577 5f61 7267 735f 6669  def _new_args_fi
+00013560: 6c74 6572 2863 6c73 2c20 6172 675f 7365  lter(cls, arg_se
+00013570: 7175 656e 6365 2c20 6361 6c6c 5f63 6c73  quence, call_cls
+00013580: 3d4e 6f6e 6529 3a0a 2020 2020 2020 2020  =None):.        
+00013590: 2222 2247 656e 6572 6174 6f72 2066 696c  """Generator fil
+000135a0: 7465 7269 6e67 2061 7267 7322 2222 0a20  tering args""". 
+000135b0: 2020 2020 2020 206e 636c 7320 3d20 6361         ncls = ca
+000135c0: 6c6c 5f63 6c73 206f 7220 636c 7320 2020  ll_cls or cls   
+000135d0: 2020 2020 200a 2020 2020 2020 2020 666f       .        fo
+000135e0: 7220 6172 6720 696e 2061 7267 5f73 6571  r arg in arg_seq
+000135f0: 7565 6e63 653a 200a 2020 2020 2020 2020  uence: .        
+00013600: 2020 2020 6966 2061 7267 2e66 756e 6320      if arg.func 
+00013610: 3d3d 206e 636c 733a 0a20 2020 2020 2020  == ncls:.       
+00013620: 2020 2020 2020 2020 2079 6965 6c64 2066           yield f
+00013630: 726f 6d20 6172 672e 6172 6773 0a20 2020  rom arg.args.   
+00013640: 2020 2020 2020 2020 2065 6c73 653a 0a20           else:. 
+00013650: 2020 2020 2020 2020 2020 2020 2020 2079                 y
+00013660: 6965 6c64 2061 7267 0a0a 2020 2020 4070  ield arg..    @p
+00013670: 726f 7065 7274 790a 2020 2020 4063 6163  roperty.    @cac
+00013680: 6865 6974 0a20 2020 2064 6566 2061 7267  heit.    def arg
+00013690: 7328 7365 6c66 293a 0a20 2020 2020 2020  s(self):.       
+000136a0: 2072 6574 7572 6e20 7365 6c66 2e5f 6172   return self._ar
+000136b0: 6773 0a0a 2020 2020 4070 726f 7065 7274  gs..    @propert
+000136c0: 790a 2020 2020 6465 6620 6973 5f69 7465  y.    def is_ite
+000136d0: 7261 626c 6528 7365 6c66 293a 0a20 2020  rable(self):.   
+000136e0: 2020 2020 2072 6574 7572 6e20 616e 7928       return any(
+000136f0: 6172 672e 6973 5f69 7465 7261 626c 6520  arg.is_iterable 
+00013700: 666f 7220 6172 6720 696e 2073 656c 662e  for arg in self.
+00013710: 6172 6773 290a 0a20 2020 2040 7072 6f70  args)..    @prop
+00013720: 6572 7479 0a20 2020 2064 6566 205f 696e  erty.    def _in
+00013730: 6628 7365 6c66 293a 0a20 2020 2020 2020  f(self):.       
+00013740: 2072 6169 7365 204e 6f74 496d 706c 656d   raise NotImplem
+00013750: 656e 7465 6445 7272 6f72 2829 0a0a 2020  entedError()..  
+00013760: 2020 4070 726f 7065 7274 790a 2020 2020    @property.    
+00013770: 6465 6620 5f73 7570 2873 656c 6629 3a0a  def _sup(self):.
+00013780: 2020 2020 2020 2020 7261 6973 6520 4e6f          raise No
+00013790: 7449 6d70 6c65 6d65 6e74 6564 4572 726f  tImplementedErro
+000137a0: 7228 290a 0a20 2020 2064 6566 205f 636f  r()..    def _co
+000137b0: 6e74 6169 6e73 2873 656c 662c 206f 7468  ntains(self, oth
+000137c0: 6572 293a 0a20 2020 2020 2020 2072 6574  er):.        ret
+000137d0: 7572 6e20 416e 6428 2a5b 456c 656d 656e  urn And(*[Elemen
+000137e0: 7428 6f74 6865 722c 2073 2920 666f 7220  t(other, s) for 
+000137f0: 7320 696e 2073 656c 662e 6172 6773 5d29  s in self.args])
+00013800: 0a0a 2020 2020 6465 6620 5f5f 6974 6572  ..    def __iter
+00013810: 5f5f 2873 656c 6629 3a0a 2020 2020 2020  __(self):.      
+00013820: 2020 6e6f 5f69 7465 7220 3d20 5472 7565    no_iter = True
+00013830: 0a20 2020 2020 2020 2066 6f72 2073 2069  .        for s i
+00013840: 6e20 7365 6c66 2e61 7267 733a 0a20 2020  n self.args:.   
+00013850: 2020 2020 2020 2020 2069 6620 732e 6973           if s.is
+00013860: 5f69 7465 7261 626c 653a 0a20 2020 2020  _iterable:.     
+00013870: 2020 2020 2020 2020 2020 206e 6f5f 6974             no_it
+00013880: 6572 203d 2046 616c 7365 0a20 2020 2020  er = False.     
+00013890: 2020 2020 2020 2020 2020 206f 7468 6572             other
+000138a0: 5f73 6574 7320 3d20 7365 7428 7365 6c66  _sets = set(self
+000138b0: 2e61 7267 7329 202d 2073 6574 2828 732c  .args) - set((s,
+000138c0: 2929 0a20 2020 2020 2020 2020 2020 2020  )).             
+000138d0: 2020 206f 7468 6572 203d 2049 6e74 6572     other = Inter
+000138e0: 7365 6374 696f 6e28 2a6f 7468 6572 5f73  section(*other_s
+000138f0: 6574 732c 2065 7661 6c75 6174 653d 4661  ets, evaluate=Fa
+00013900: 6c73 6529 0a20 2020 2020 2020 2020 2020  lse).           
+00013910: 2020 2020 2066 6f72 2078 2069 6e20 733a       for x in s:
+00013920: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00013930: 2020 2020 2063 203d 2073 796d 7069 6679       c = sympify
+00013940: 286f 7468 6572 2e63 6f6e 7461 696e 7328  (other.contains(
+00013950: 7829 290a 2020 2020 2020 2020 2020 2020  x)).            
+00013960: 2020 2020 2020 2020 6966 2063 2069 7320          if c is 
+00013970: 532e 7472 7565 3a0a 2020 2020 2020 2020  S.true:.        
+00013980: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00013990: 7969 656c 6420 780a 2020 2020 2020 2020  yield x.        
+000139a0: 2020 2020 2020 2020 2020 2020 656c 6966              elif
+000139b0: 2063 2069 7320 532e 6661 6c73 653a 0a20   c is S.false:. 
+000139c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000139d0: 2020 2020 2020 2070 6173 730a 2020 2020         pass.    
+000139e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000139f0: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
+00013a00: 2020 2020 2020 2020 2020 2020 2020 7969                yi
+00013a10: 656c 6420 630a 0a20 2020 2020 2020 2069  eld c..        i
+00013a20: 6620 6e6f 5f69 7465 723a 0a20 2020 2020  f no_iter:.     
+00013a30: 2020 2020 2020 2072 6169 7365 2056 616c         raise Val
+00013a40: 7565 4572 726f 7228 224e 6f6e 6520 6f66  ueError("None of
+00013a50: 2074 6865 2063 6f6e 7374 6974 7565 6e74   the constituent
+00013a60: 2073 6574 7320 6172 6520 6974 6572 6162   sets are iterab
+00013a70: 6c65 2229 0a0a 2020 2020 4073 7461 7469  le")..    @stati
+00013a80: 636d 6574 686f 640a 2020 2020 6465 6620  cmethod.    def 
+00013a90: 5f68 616e 646c 655f 6669 6e69 7465 5f73  _handle_finite_s
+00013aa0: 6574 7328 6172 6773 293a 0a20 2020 2020  ets(args):.     
+00013ab0: 2020 2066 726f 6d20 6974 6572 746f 6f6c     from itertool
+00013ac0: 7320 696d 706f 7274 207a 6970 5f6c 6f6e  s import zip_lon
+00013ad0: 6765 7374 0a0a 2020 2020 2020 2020 6673  gest..        fs
+00013ae0: 5f61 7267 732c 206f 7468 6572 203d 2073  _args, other = s
+00013af0: 6966 7428 6172 6773 2c20 6c61 6d62 6461  ift(args, lambda
+00013b00: 2078 3a20 782e 6973 5f46 696e 6974 6553   x: x.is_FiniteS
+00013b10: 6574 2c20 6269 6e61 7279 3d54 7275 6529  et, binary=True)
+00013b20: 0a20 2020 2020 2020 2069 6620 6e6f 7420  .        if not 
+00013b30: 6673 5f61 7267 733a 0a20 2020 2020 2020  fs_args:.       
+00013b40: 2020 2020 2072 6574 7572 6e0a 2020 2020       return.    
+00013b50: 2020 2020 6673 5f61 7267 732e 736f 7274      fs_args.sort
+00013b60: 286b 6579 3d6c 656e 290a 2020 2020 2020  (key=len).      
+00013b70: 2020 7320 3d20 6673 5f61 7267 735b 305d    s = fs_args[0]
+00013b80: 0a20 2020 2020 2020 2066 735f 6172 6773  .        fs_args
+00013b90: 203d 2066 735f 6172 6773 5b31 3a5d 0a0a   = fs_args[1:]..
+00013ba0: 2020 2020 2020 2020 7265 7320 3d20 5b5d          res = []
+00013bb0: 0a20 2020 2020 2020 2075 6e6b 203d 205b  .        unk = [
+00013bc0: 5d0a 2020 2020 2020 2020 666f 7220 7820  ].        for x 
+00013bd0: 696e 2073 3a0a 2020 2020 2020 2020 2020  in s:.          
+00013be0: 2020 6320 3d20 6675 7a7a 795f 616e 6428    c = fuzzy_and(
+00013bf0: 6675 7a7a 795f 626f 6f6c 286f 2e63 6f6e  fuzzy_bool(o.con
+00013c00: 7461 696e 7328 7829 2920 666f 7220 6f20  tains(x)) for o 
+00013c10: 696e 2066 735f 6172 6773 202b 206f 7468  in fs_args + oth
+00013c20: 6572 290a 2020 2020 2020 2020 2020 2020  er).            
+00013c30: 6966 2063 3a0a 2020 2020 2020 2020 2020  if c:.          
+00013c40: 2020 2020 2020 7265 732e 6170 7065 6e64        res.append
+00013c50: 2878 290a 2020 2020 2020 2020 2020 2020  (x).            
+00013c60: 656c 6966 2063 2069 7320 4e6f 6e65 3a0a  elif c is None:.
+00013c70: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00013c80: 756e 6b2e 6170 7065 6e64 2878 290a 2020  unk.append(x).  
+00013c90: 2020 2020 2020 2020 2020 656c 7365 3a0a            else:.
+00013ca0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00013cb0: 7061 7373 2020 2320 6472 6f70 2061 7267  pass  # drop arg
+00013cc0: 0a20 2020 2020 2020 2020 2020 200a 2020  .            .  
+00013cd0: 2020 2020 2020 6672 6f6d 2073 796d 7079        from sympy
+00013ce0: 2069 6d70 6f72 7420 4669 6e69 7465 5365   import FiniteSe
+00013cf0: 740a 2020 2020 2020 2020 7265 7320 3d20  t.        res = 
+00013d00: 4669 6e69 7465 5365 7428 2a72 6573 2920  FiniteSet(*res) 
+00013d10: 6966 2072 6573 2065 6c73 6520 732e 656d  if res else s.em
+00013d20: 7074 7953 6574 0a20 2020 2020 2020 2069  ptySet.        i
+00013d30: 6620 756e 6b3a 0a20 2020 2020 2020 2020  f unk:.         
+00013d40: 2020 2073 796d 626f 6c69 635f 735f 6c69     symbolic_s_li
+00013d50: 7374 203d 205b 7820 666f 7220 7820 696e  st = [x for x in
+00013d60: 2073 2069 6620 782e 6861 7328 5379 6d62   s if x.has(Symb
+00013d70: 6f6c 295d 0a20 2020 2020 2020 2020 2020  ol)].           
+00013d80: 2077 6869 6c65 2066 735f 6172 6773 3a0a   while fs_args:.
+00013d90: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00013da0: 7620 3d20 6673 5f61 7267 732e 706f 7028  v = fs_args.pop(
+00013db0: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
+00013dc0: 2020 6966 206e 6f74 2061 6c6c 2869 203d    if not all(i =
+00013dd0: 3d20 6a20 666f 7220 692c 206a 2069 6e20  = j for i, j in 
+00013de0: 7a69 705f 6c6f 6e67 6573 7428 7379 6d62  zip_longest(symb
+00013df0: 6f6c 6963 5f73 5f6c 6973 742c 2028 7820  olic_s_list, (x 
+00013e00: 666f 7220 7820 696e 2076 2069 6620 782e  for x in v if x.
+00013e10: 6861 7328 5379 6d62 6f6c 2929 2929 3a0a  has(Symbol)))):.
+00013e20: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00013e30: 2020 2020 2320 6966 206f 6e6c 7920 6120      # if only a 
+00013e40: 7375 6273 6574 206f 6620 656c 656d 656e  subset of elemen
+00013e50: 7473 2069 6e20 6073 6020 6172 650a 2020  ts in `s` are.  
+00013e60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00013e70: 2020 2320 636f 6e74 6169 6e65 6420 696e    # contained in
+00013e80: 2060 7660 2074 6865 6e20 7265 6d6f 7665   `v` then remove
+00013e90: 2074 6865 6d20 6672 6f6d 2060 7660 0a20   them from `v`. 
+00013ea0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00013eb0: 2020 2023 2061 6e64 2061 6464 2074 6869     # and add thi
+00013ec0: 7320 6173 2061 206e 6577 2061 7267 0a20  s as a new arg. 
+00013ed0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00013ee0: 2020 2063 6f6e 7461 696e 6564 203d 205b     contained = [
+00013ef0: 7820 666f 7220 7820 696e 2073 796d 626f  x for x in symbo
+00013f00: 6c69 635f 735f 6c69 7374 2069 6620 7379  lic_s_list if sy
+00013f10: 6d70 6966 7928 762e 636f 6e74 6169 6e73  mpify(v.contains
+00013f20: 2878 2929 2069 7320 532e 7472 7565 5d0a  (x)) is S.true].
+00013f30: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00013f40: 2020 2020 6966 2063 6f6e 7461 696e 6564      if contained
+00013f50: 2021 3d20 7379 6d62 6f6c 6963 5f73 5f6c   != symbolic_s_l
+00013f60: 6973 743a 0a20 2020 2020 2020 2020 2020  ist:.           
+00013f70: 2020 2020 2020 2020 2020 2020 206f 7468               oth
+00013f80: 6572 2e61 7070 656e 6428 436f 6d70 6c65  er.append(Comple
+00013f90: 6d65 6e74 2876 2c20 4669 6e69 7465 5365  ment(v, FiniteSe
+00013fa0: 7428 2a63 6f6e 7461 696e 6564 2929 290a  t(*contained))).
+00013fb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00013fc0: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
+00013fd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00013fe0: 2020 6f74 6865 722e 6170 7065 6e64 2876    other.append(v
+00013ff0: 290a 0a20 2020 2020 2020 2020 2020 206f  )..            o
+00014000: 7468 6572 5f73 6574 7320 3d20 496e 7465  ther_sets = Inte
+00014010: 7273 6563 7469 6f6e 282a 6f74 6865 7229  rsection(*other)
+00014020: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
+00014030: 6e6f 7420 6f74 6865 725f 7365 7473 3a0a  not other_sets:.
+00014040: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00014050: 7265 7475 726e 2073 2e65 6d70 7479 5365  return s.emptySe
+00014060: 7420 2023 2062 2f63 2077 6520 7573 6520  t  # b/c we use 
+00014070: 6576 616c 7561 7465 3d46 616c 7365 2062  evaluate=False b
+00014080: 656c 6f77 0a20 2020 2020 2020 2020 2020  elow.           
+00014090: 2065 6c69 6620 6f74 6865 725f 7365 7473   elif other_sets
+000140a0: 2e69 735f 556e 6976 6572 7361 6c53 6574  .is_UniversalSet
+000140b0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+000140c0: 2020 7265 7320 7c3d 2046 696e 6974 6553    res |= FiniteS
+000140d0: 6574 282a 756e 6b29 0a20 2020 2020 2020  et(*unk).       
+000140e0: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
+000140f0: 2020 2020 2020 2020 2020 2075 6e6b 203d             unk =
+00014100: 2046 696e 6974 6553 6574 282a 756e 6b29   FiniteSet(*unk)
+00014110: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00014120: 2072 6573 756c 7420 3d20 6f74 6865 725f   result = other_
+00014130: 7365 7473 2e68 616e 646c 655f 6669 6e69  sets.handle_fini
+00014140: 7465 5f73 6574 7328 756e 6b29 0a20 2020  te_sets(unk).   
+00014150: 2020 2020 2020 2020 2020 2020 2069 6620               if 
+00014160: 7265 7375 6c74 2069 7320 6e6f 7420 4e6f  result is not No
+00014170: 6e65 3a0a 2020 2020 2020 2020 2020 2020  ne:.            
+00014180: 2020 2020 2020 2020 7265 7475 726e 2072          return r
+00014190: 6573 207c 2072 6573 756c 740a 2020 2020  es | result.    
+000141a0: 2020 2020 2020 2020 2020 2020 7265 7475              retu
+000141b0: 726e 2072 6573 207c 2049 6e74 6572 7365  rn res | Interse
+000141c0: 6374 696f 6e28 756e 6b2c 206f 7468 6572  ction(unk, other
+000141d0: 5f73 6574 732c 2065 7661 6c75 6174 653d  _sets, evaluate=
+000141e0: 4661 6c73 6529 200a 2020 2020 2020 2020  False) .        
+000141f0: 7265 7475 726e 2072 6573 0a0a 2020 2020  return res..    
+00014200: 6465 6620 6173 5f72 656c 6174 696f 6e61  def as_relationa
+00014210: 6c28 7365 6c66 2c20 7379 6d62 6f6c 293a  l(self, symbol):
+00014220: 0a20 2020 2020 2020 2022 2222 5265 7772  .        """Rewr
+00014230: 6974 6520 616e 2049 6e74 6572 7365 6374  ite an Intersect
+00014240: 696f 6e20 696e 2074 6572 6d73 206f 6620  ion in terms of 
+00014250: 6571 7561 6c69 7469 6573 2061 6e64 206c  equalities and l
+00014260: 6f67 6963 206f 7065 7261 746f 7273 2222  ogic operators""
+00014270: 220a 2020 2020 2020 2020 7265 7475 726e  ".        return
+00014280: 2041 6e64 282a 5b73 2e61 735f 7265 6c61   And(*[s.as_rela
+00014290: 7469 6f6e 616c 2873 796d 626f 6c29 2066  tional(symbol) f
+000142a0: 6f72 2073 2069 6e20 7365 6c66 2e61 7267  or s in self.arg
+000142b0: 735d 290a 0a20 2020 2022 2222 0a20 2020  s])..    """.   
+000142c0: 2070 7265 636f 6e64 6974 696f 6e3a 2074   precondition: t
+000142d0: 6869 7320 7365 7420 7368 6f75 6c64 206e  his set should n
+000142e0: 6f74 2062 6520 656d 7074 7921 0a20 2020  ot be empty!.   
+000142f0: 2022 2222 0a0a 2020 2020 6465 6620 6d69   """..    def mi
+00014300: 6e28 7365 6c66 293a 0a20 2020 2020 2020  n(self):.       
+00014310: 2066 726f 6d20 7379 6d70 792e 6675 6e63   from sympy.func
+00014320: 7469 6f6e 732e 656c 656d 656e 7461 7279  tions.elementary
+00014330: 2e6d 6973 6365 6c6c 616e 656f 7573 2069  .miscellaneous i
+00014340: 6d70 6f72 7420 4d61 7820 2020 2020 2020  mport Max       
+00014350: 200a 2020 2020 2020 2020 7265 7475 726e   .        return
+00014360: 204d 6178 282a 2861 7267 2e6d 696e 2829   Max(*(arg.min()
+00014370: 2066 6f72 2061 7267 2069 6e20 7365 6c66   for arg in self
+00014380: 2e61 7267 7329 2920 2020 2020 2020 200a  .args))        .
+00014390: 0a20 2020 2022 2222 0a20 2020 2070 7265  .    """.    pre
+000143a0: 636f 6e64 6974 696f 6e3a 2074 6869 7320  condition: this 
+000143b0: 7365 7420 7368 6f75 6c64 206e 6f74 2062  set should not b
+000143c0: 6520 656d 7074 7921 0a20 2020 2022 2222  e empty!.    """
+000143d0: 0a0a 2020 2020 6465 6620 6d61 7828 7365  ..    def max(se
+000143e0: 6c66 293a 0a20 2020 2020 2020 2066 726f  lf):.        fro
+000143f0: 6d20 7379 6d70 792e 6675 6e63 7469 6f6e  m sympy.function
+00014400: 732e 656c 656d 656e 7461 7279 2e6d 6973  s.elementary.mis
+00014410: 6365 6c6c 616e 656f 7573 2069 6d70 6f72  cellaneous impor
+00014420: 7420 4d69 6e20 2020 2020 2020 200a 2020  t Min        .  
+00014430: 2020 2020 2020 7265 7475 726e 204d 696e        return Min
+00014440: 282a 2861 7267 2e6d 6178 2829 2066 6f72  (*(arg.max() for
+00014450: 2061 7267 2069 6e20 7365 6c66 2e61 7267   arg in self.arg
+00014460: 7329 290a 0a20 2020 2064 6566 205f 7379  s))..    def _sy
+00014470: 6d70 7973 7472 2873 656c 662c 2070 293a  mpystr(self, p):
+00014480: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
+00014490: 2720 e288 a920 272e 6a6f 696e 285b 2228  ' ... '.join(["(
+000144a0: 2573 2922 2025 2070 2e5f 7072 696e 7428  %s)" % p._print(
+000144b0: 6129 2069 6620 612e 6973 5f43 6f6d 706c  a) if a.is_Compl
+000144c0: 656d 656e 7420 6f72 2061 2e69 735f 556e  ement or a.is_Un
+000144d0: 696f 6e20 656c 7365 2070 2e5f 7072 696e  ion else p._prin
+000144e0: 7428 6129 2066 6f72 2061 2069 6e20 7365  t(a) for a in se
+000144f0: 6c66 2e61 7267 735d 290a 0a20 2020 2064  lf.args])..    d
+00014500: 6566 205f 6c61 7465 7828 7365 6c66 2c20  ef _latex(self, 
+00014510: 7029 3a0a 2020 2020 2020 2020 6172 6773  p):.        args
+00014520: 203d 205b 5d0a 2020 2020 2020 2020 666f   = [].        fo
+00014530: 7220 6920 696e 2073 656c 662e 6172 6773  r i in self.args
+00014540: 3a0a 2020 2020 2020 2020 2020 2020 6c61  :.            la
+00014550: 7465 7820 3d20 702e 5f70 7269 6e74 2869  tex = p._print(i
+00014560: 290a 2020 2020 2020 2020 2020 2020 6966  ).            if
+00014570: 2069 2e69 735f 436f 6d70 6c65 6d65 6e74   i.is_Complement
+00014580: 206f 7220 692e 6973 5f55 6e69 6f6e 3a0a   or i.is_Union:.
+00014590: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000145a0: 6c61 7465 7820 3d20 7227 5c6c 6566 7428  latex = r'\left(
+000145b0: 2573 5c72 6967 6874 2927 2025 206c 6174  %s\right)' % lat
+000145c0: 6578 0a20 2020 2020 2020 2020 2020 2061  ex.            a
+000145d0: 7267 732e 6170 7065 6e64 286c 6174 6578  rgs.append(latex
+000145e0: 290a 0a20 2020 2020 2020 2072 6574 7572  )..        retur
+000145f0: 6e20 7222 205c 6361 7020 222e 6a6f 696e  n r" \cap ".join
+00014600: 2861 7267 7329 0a0a 2020 2020 6465 6620  (args)..    def 
+00014610: 6861 6e64 6c65 5f66 696e 6974 655f 7365  handle_finite_se
+00014620: 7473 2873 656c 662c 2075 6e6b 293a 0a20  ts(self, unk):. 
+00014630: 2020 2020 2020 2066 6f72 2069 2c20 7320         for i, s 
+00014640: 696e 2065 6e75 6d65 7261 7465 2873 656c  in enumerate(sel
+00014650: 662e 6172 6773 293a 0a20 2020 2020 2020  f.args):.       
+00014660: 2020 2020 2069 6620 756e 6b20 696e 2073       if unk in s
+00014670: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+00014680: 2020 6172 6773 203d 205b 2a73 656c 662e    args = [*self.
+00014690: 6172 6773 5d0a 2020 2020 2020 2020 2020  args].          
+000146a0: 2020 2020 2020 6172 6773 5b69 5d20 3d20        args[i] = 
+000146b0: 756e 6b0a 2020 2020 2020 2020 2020 2020  unk.            
+000146c0: 2020 2020 7265 7475 726e 2073 656c 662e      return self.
+000146d0: 6675 6e63 282a 6172 6773 2c20 6576 616c  func(*args, eval
+000146e0: 7561 7465 3d46 616c 7365 290a 2020 2020  uate=False).    
+000146f0: 2020 2020 2020 2020 6966 2073 2069 6e20          if s in 
+00014700: 756e 6b3a 0a20 2020 2020 2020 2020 2020  unk:.           
+00014710: 2020 2020 2072 6574 7572 6e20 7365 6c66       return self
+00014720: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
+00014730: 7365 6c66 2e66 756e 6328 2a73 656c 662e  self.func(*self.
+00014740: 6172 6773 2c20 756e 6b2c 2065 7661 6c75  args, unk, evalu
+00014750: 6174 653d 4661 6c73 6529 0a20 2020 2020  ate=False).     
+00014760: 2020 2020 2020 2020 2020 200a 2020 2020             .    
+00014770: 6465 6620 5f65 7661 6c5f 6973 5f66 696e  def _eval_is_fin
+00014780: 6974 6528 7365 6c66 293a 0a20 2020 2020  ite(self):.     
+00014790: 2020 2072 6574 7572 6e20 6675 7a7a 795f     return fuzzy_
+000147a0: 6f75 2861 2e69 735f 6669 6e69 7465 2066  ou(a.is_finite f
+000147b0: 6f72 2061 2069 6e20 7365 6c66 2e61 7267  or a in self.arg
+000147c0: 7329 0a20 2020 2020 2020 200a 2020 2020  s).        .    
+000147d0: 6465 6620 5f65 7661 6c5f 6973 5f65 7874  def _eval_is_ext
+000147e0: 656e 6465 645f 696e 7465 6765 7228 7365  ended_integer(se
+000147f0: 6c66 293a 0a20 2020 2020 2020 2072 6574  lf):.        ret
+00014800: 7572 6e20 6675 7a7a 795f 6f75 2861 7267  urn fuzzy_ou(arg
+00014810: 2e69 735f 6578 7465 6e64 6564 5f69 6e74  .is_extended_int
+00014820: 6567 6572 2066 6f72 2061 7267 2069 6e20  eger for arg in 
+00014830: 7365 6c66 2e61 7267 7329 0a0a 2020 2020  self.args)..    
+00014840: 6465 6620 5f65 7661 6c5f 6973 5f73 7570  def _eval_is_sup
+00014850: 6572 5f69 6e74 6567 6572 2873 656c 6629  er_integer(self)
+00014860: 3a0a 2020 2020 2020 2020 7265 7475 726e  :.        return
+00014870: 2066 757a 7a79 5f6f 7528 652e 6973 5f73   fuzzy_ou(e.is_s
+00014880: 7570 6572 5f69 6e74 6567 6572 2066 6f72  uper_integer for
+00014890: 2065 2069 6e20 7365 6c66 2e61 7267 7329   e in self.args)
+000148a0: 0a20 2020 200a 2020 2020 6465 6620 5f65  .    .    def _e
+000148b0: 7661 6c5f 6973 5f65 7874 656e 6465 645f  val_is_extended_
+000148c0: 7261 7469 6f6e 616c 2873 656c 6629 3a0a  rational(self):.
+000148d0: 2020 2020 2020 2020 7265 7475 726e 2066          return f
+000148e0: 757a 7a79 5f6f 7528 652e 6973 5f65 7874  uzzy_ou(e.is_ext
+000148f0: 656e 6465 645f 7261 7469 6f6e 616c 2066  ended_rational f
+00014900: 6f72 2065 2069 6e20 7365 6c66 2e61 7267  or e in self.arg
+00014910: 7329 0a20 2020 200a 2020 2020 6465 6620  s).    .    def 
+00014920: 5f65 7661 6c5f 6973 5f73 7570 6572 5f72  _eval_is_super_r
+00014930: 6174 696f 6e61 6c28 7365 6c66 293a 0a20  ational(self):. 
+00014940: 2020 2020 2020 2072 6574 7572 6e20 6675         return fu
+00014950: 7a7a 795f 6f75 2865 2e69 735f 7375 7065  zzy_ou(e.is_supe
+00014960: 725f 7261 7469 6f6e 616c 2066 6f72 2065  r_rational for e
+00014970: 2069 6e20 7365 6c66 2e61 7267 7329 0a0a   in self.args)..
+00014980: 2020 2020 6465 6620 5f65 7661 6c5f 6973      def _eval_is
+00014990: 5f68 7970 6572 5f72 6174 696f 6e61 6c28  _hyper_rational(
+000149a0: 7365 6c66 293a 0a20 2020 2020 2020 2072  self):.        r
+000149b0: 6574 7572 6e20 6675 7a7a 795f 6f75 2865  eturn fuzzy_ou(e
+000149c0: 2e69 735f 6879 7065 725f 7261 7469 6f6e  .is_hyper_ration
+000149d0: 616c 2066 6f72 2065 2069 6e20 7365 6c66  al for e in self
+000149e0: 2e61 7267 7329 0a20 2020 200a 2020 2020  .args).    .    
+000149f0: 6465 6620 5f65 7661 6c5f 6973 5f65 7874  def _eval_is_ext
+00014a00: 656e 6465 645f 7265 616c 2873 656c 6629  ended_real(self)
+00014a10: 3a0a 2020 2020 2020 2020 7265 7475 726e  :.        return
+00014a20: 2066 757a 7a79 5f6f 7528 652e 6973 5f65   fuzzy_ou(e.is_e
+00014a30: 7874 656e 6465 645f 7265 616c 2066 6f72  xtended_real for
+00014a40: 2065 2069 6e20 7365 6c66 2e61 7267 7329   e in self.args)
+00014a50: 200a 0a20 2020 2064 6566 205f 6576 616c   ..    def _eval
+00014a60: 5f69 735f 6879 7065 725f 7265 616c 2873  _is_hyper_real(s
+00014a70: 656c 6629 3a0a 2020 2020 2020 2020 7265  elf):.        re
+00014a80: 7475 726e 2066 757a 7a79 5f6f 7528 652e  turn fuzzy_ou(e.
+00014a90: 6973 5f68 7970 6572 5f72 6561 6c20 666f  is_hyper_real fo
+00014aa0: 7220 6520 696e 2073 656c 662e 6172 6773  r e in self.args
+00014ab0: 290a 2020 2020 0a20 2020 2064 6566 205f  ).    .    def _
+00014ac0: 6576 616c 5f69 735f 7375 7065 725f 7265  eval_is_super_re
+00014ad0: 616c 2873 656c 6629 3a0a 2020 2020 2020  al(self):.      
+00014ae0: 2020 7265 7475 726e 2066 757a 7a79 5f6f    return fuzzy_o
+00014af0: 7528 652e 6973 5f73 7570 6572 5f72 6561  u(e.is_super_rea
+00014b00: 6c20 666f 7220 6520 696e 2073 656c 662e  l for e in self.
+00014b10: 6172 6773 290a 2020 2020 0a20 2020 2064  args).    .    d
+00014b20: 6566 205f 6576 616c 5f69 735f 6578 7465  ef _eval_is_exte
+00014b30: 6e64 6564 5f63 6f6d 706c 6578 2873 656c  nded_complex(sel
+00014b40: 6629 3a0a 2020 2020 2020 2020 7265 7475  f):.        retu
+00014b50: 726e 2066 757a 7a79 5f6f 7528 652e 6973  rn fuzzy_ou(e.is
+00014b60: 5f65 7874 656e 6465 645f 636f 6d70 6c65  _extended_comple
+00014b70: 7820 666f 7220 6520 696e 2073 656c 662e  x for e in self.
+00014b80: 6172 6773 290a 2020 2020 200a 2020 2020  args).     .    
+00014b90: 6465 6620 5f65 7661 6c5f 6973 5f68 7970  def _eval_is_hyp
+00014ba0: 6572 5f63 6f6d 706c 6578 2873 656c 6629  er_complex(self)
+00014bb0: 3a0a 2020 2020 2020 2020 7265 7475 726e  :.        return
+00014bc0: 2066 757a 7a79 5f6f 7528 652e 6973 5f68   fuzzy_ou(e.is_h
+00014bd0: 7970 6572 5f63 6f6d 706c 6578 2066 6f72  yper_complex for
+00014be0: 2065 2069 6e20 7365 6c66 2e61 7267 7329   e in self.args)
+00014bf0: 0a20 2020 2020 2020 2020 2020 200a 2020  .            .  
+00014c00: 2020 4063 6c61 7373 6d65 7468 6f64 0a20    @classmethod. 
+00014c10: 2020 2064 6566 2073 696d 706c 6966 795f     def simplify_
+00014c20: 4571 7561 6c28 636c 732c 2073 656c 662c  Equal(cls, self,
+00014c30: 206c 6873 2c20 7268 7329 3a0a 2020 2020   lhs, rhs):.    
+00014c40: 2020 2020 2222 220a 2020 2020 2020 2020      """.        
+00014c50: 7072 6563 6f6e 6469 7469 6f6e 3a20 7365  precondition: se
+00014c60: 6c66 2e6c 6873 2069 7320 6120 496e 7465  lf.lhs is a Inte
+00014c70: 7273 6563 7469 6f6e 206f 626a 6563 7421  rsection object!
+00014c80: 0a20 2020 2020 2020 2022 2222 0a20 2020  .        """.   
+00014c90: 2020 2020 2069 6620 7268 732e 6973 5f45       if rhs.is_E
+00014ca0: 6d70 7479 5365 743a 0a20 2020 2020 2020  mptySet:.       
+00014cb0: 2020 2020 2074 6869 7320 3d20 7365 6c66       this = self
+00014cc0: 2e73 696d 706c 6966 795f 496e 7465 7273  .simplify_Inters
+00014cd0: 6563 7469 6f6e 286c 6873 290a 2020 2020  ection(lhs).    
+00014ce0: 2020 2020 2020 2020 6966 2074 6869 7320          if this 
+00014cf0: 6973 206e 6f74 204e 6f6e 653a 0a20 2020  is not None:.   
+00014d00: 2020 2020 2020 2020 2020 2020 2072 6574               ret
+00014d10: 7572 6e20 7468 6973 0a0a 2020 2020 6465  urn this..    de
+00014d20: 6620 5f5f 6164 645f 5f28 7365 6c66 2c20  f __add__(self, 
+00014d30: 6f74 6865 7229 3a0a 2020 2020 2020 2020  other):.        
+00014d40: 6966 206f 7468 6572 2e69 735f 7365 743a  if other.is_set:
+00014d50: 0a20 2020 2020 2020 2020 2020 2072 6169  .            rai
+00014d60: 7365 2045 7863 6570 7469 6f6e 2822 636f  se Exception("co
+00014d70: 756c 6420 6e6f 7420 6164 6420 2573 2c20  uld not add %s, 
+00014d80: 2573 2220 2520 2873 656c 662c 206f 7468  %s" % (self, oth
+00014d90: 6572 2929 0a20 2020 2020 2020 2072 6574  er)).        ret
+00014da0: 7572 6e20 7365 6c66 2e66 756e 6328 2a28  urn self.func(*(
+00014db0: 6172 6720 2b20 6f74 6865 7220 666f 7220  arg + other for 
+00014dc0: 6172 6720 696e 2073 656c 662e 6172 6773  arg in self.args
+00014dd0: 2929 0a0a 2020 2020 2320 7065 7266 6f72  ))..    # perfor
+00014de0: 6d20 7365 6c66 2069 6e20 7268 730a 2020  m self in rhs.  
+00014df0: 2020 6465 6620 5f65 7661 6c5f 5375 6273    def _eval_Subs
+00014e00: 6574 2873 656c 662c 2072 6873 293a 0a20  et(self, rhs):. 
+00014e10: 2020 2020 2020 2066 6f72 2065 2069 6e20         for e in 
+00014e20: 7365 6c66 2e5f 6172 6773 6574 3a0a 2020  self._argset:.  
+00014e30: 2020 2020 2020 2020 2020 6966 2065 2069            if e i
+00014e40: 6e20 7268 733a 0a20 2020 2020 2020 2020  n rhs:.         
+00014e50: 2020 2020 2020 2072 6574 7572 6e20 532e         return S.
+00014e60: 7472 7565 0a0a 2020 2020 2320 7065 7266  true..    # perf
+00014e70: 6f72 6d20 6c68 7320 696e 2073 656c 660a  orm lhs in self.
+00014e80: 2020 2020 6465 6620 5f65 7661 6c5f 5375      def _eval_Su
+00014e90: 6273 6574 5f72 6576 6572 7365 6428 7365  bset_reversed(se
+00014ea0: 6c66 2c20 6c68 7329 3a0a 2020 2020 2020  lf, lhs):.      
+00014eb0: 2020 6672 6f6d 2073 796d 7079 2069 6d70    from sympy imp
+00014ec0: 6f72 7420 5375 6273 6574 0a20 2020 2020  ort Subset.     
+00014ed0: 2020 2066 6f72 2065 2069 6e20 7365 6c66     for e in self
+00014ee0: 2e5f 6172 6773 6574 3a0a 2020 2020 2020  ._argset:.      
+00014ef0: 2020 2020 2020 636f 6e64 203d 2053 7562        cond = Sub
+00014f00: 7365 7428 6c68 732c 2065 290a 2020 2020  set(lhs, e).    
+00014f10: 2020 2020 2020 2020 6966 2063 6f6e 643a          if cond:
+00014f20: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00014f30: 2063 6f6e 7469 6e75 650a 2020 2020 2020   continue.      
+00014f40: 2020 2020 2020 6966 2063 6f6e 6420 3d3d        if cond ==
+00014f50: 2046 616c 7365 3a0a 2020 2020 2020 2020   False:.        
+00014f60: 2020 2020 2020 2020 7265 7475 726e 2053          return S
+00014f70: 2e66 616c 7365 0a20 2020 2020 2020 2020  .false.         
+00014f80: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
+00014f90: 2020 2020 2020 2020 2072 6574 7572 6e0a           return.
+00014fa0: 2020 2020 2020 2020 7265 7475 726e 2053          return S
+00014fb0: 2e74 7275 650a 0a20 2020 2064 6566 205f  .true..    def _
+00014fc0: 7375 6273 2873 656c 662c 206f 6c64 2c20  subs(self, old, 
+00014fd0: 6e65 772c 202a 2a68 696e 7473 293a 0a20  new, **hints):. 
+00014fe0: 2020 2020 2020 2069 6620 6f6c 642e 6973         if old.is
+00014ff0: 5f49 6e74 6572 7365 6374 696f 6e3a 0a20  _Intersection:. 
+00015000: 2020 2020 2020 2020 2020 2069 6620 6e6f             if no
+00015010: 7420 6f6c 642e 5f61 7267 7365 7420 2d20  t old._argset - 
+00015020: 7365 6c66 2e5f 6172 6773 6574 3a0a 2020  self._argset:.  
+00015030: 2020 2020 2020 2020 2020 2020 2020 6469                di
+00015040: 6666 203d 2073 656c 662e 5f61 7267 7365  ff = self._argse
+00015050: 7420 2d20 6f6c 642e 5f61 7267 7365 740a  t - old._argset.
+00015060: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00015070: 6966 2064 6966 663a 0a20 2020 2020 2020  if diff:.       
+00015080: 2020 2020 2020 2020 2020 2020 2072 6574               ret
+00015090: 7572 6e20 496e 7465 7273 6563 7469 6f6e  urn Intersection
+000150a0: 282a 6469 6666 2920 2620 6e65 770a 2020  (*diff) & new.  
+000150b0: 2020 2020 2020 2020 2020 2020 2020 7265                re
+000150c0: 7475 726e 206e 6577 0a20 2020 2020 2020  turn new.       
+000150d0: 2072 6574 7572 6e20 5365 742e 5f73 7562   return Set._sub
+000150e0: 7328 7365 6c66 2c20 6f6c 642c 206e 6577  s(self, old, new
+000150f0: 2c20 2a2a 6869 6e74 7329 0a0a 0a63 6c61  , **hints)...cla
+00015100: 7373 2043 6f6d 706c 656d 656e 7428 5365  ss Complement(Se
+00015110: 742c 2045 7661 6c66 4d69 7869 6e29 3a0a  t, EvalfMixin):.
+00015120: 2020 2020 7222 2222 5265 7072 6573 656e      r"""Represen
+00015130: 7473 2074 6865 2073 6574 2064 6966 6665  ts the set diffe
+00015140: 7265 6e63 6520 6f72 2072 656c 6174 6976  rence or relativ
+00015150: 6520 636f 6d70 6c65 6d65 6e74 206f 6620  e complement of 
+00015160: 6120 7365 7420 7769 7468 0a20 2020 2061  a set with.    a
+00015170: 6e6f 7468 6572 2073 6574 2e0a 0a20 2020  nother set...   
+00015180: 2060 4120 2d20 4220 3d20 5c7b 7820 5c69   `A - B = \{x \i
+00015190: 6e20 417c 2078 205c 5c6e 6f74 696e 2042  n A| x \\notin B
+000151a0: 5c7d 600a 0a0a 2020 2020 4578 616d 706c  \}`...    Exampl
+000151b0: 6573 0a20 2020 203d 3d3d 3d3d 3d3d 3d0a  es.    ========.
+000151c0: 0a20 2020 203e 3e3e 2066 726f 6d20 7379  .    >>> from sy
+000151d0: 6d70 7920 696d 706f 7274 2043 6f6d 706c  mpy import Compl
+000151e0: 656d 656e 742c 2046 696e 6974 6553 6574  ement, FiniteSet
+000151f0: 0a20 2020 203e 3e3e 2043 6f6d 706c 656d  .    >>> Complem
+00015200: 656e 7428 4669 6e69 7465 5365 7428 302c  ent(FiniteSet(0,
+00015210: 2031 2c20 3229 2c20 4669 6e69 7465 5365   1, 2), FiniteSe
+00015220: 7428 3129 290a 2020 2020 7b30 2c20 327d  t(1)).    {0, 2}
+00015230: 0a0a 2020 2020 5365 6520 416c 736f 0a20  ..    See Also. 
+00015240: 2020 203d 3d3d 3d3d 3d3d 3d3d 0a0a 2020     =========..  
+00015250: 2020 496e 7465 7273 6563 7469 6f6e 2c20    Intersection, 
+00015260: 556e 696f 6e0a 0a20 2020 2052 6566 6572  Union..    Refer
+00015270: 656e 6365 730a 2020 2020 3d3d 3d3d 3d3d  ences.    ======
+00015280: 3d3d 3d3d 0a0a 2020 2020 2e2e 205b 315d  ====..    .. [1]
+00015290: 2068 7474 703a 2f2f 6d61 7468 776f 726c   http://mathworl
+000152a0: 642e 776f 6c66 7261 6d2e 636f 6d2f 436f  d.wolfram.com/Co
+000152b0: 6d70 6c65 6d65 6e74 5365 742e 6874 6d6c  mplementSet.html
+000152c0: 0a20 2020 2022 2222 0a0a 2020 2020 6973  .    """..    is
+000152d0: 5f43 6f6d 706c 656d 656e 7420 3d20 5472  _Complement = Tr
+000152e0: 7565 0a0a 2020 2020 6465 6620 5f6c 6174  ue..    def _lat
+000152f0: 6578 2873 656c 662c 2070 293a 0a20 2020  ex(self, p):.   
+00015300: 2020 2020 2041 2c20 4220 3d20 7365 6c66       A, B = self
+00015310: 2e61 7267 730a 2020 2020 2020 2020 6966  .args.        if
+00015320: 2042 2e69 735f 436f 6d70 6c65 6d65 6e74   B.is_Complement
+00015330: 3a0a 2020 2020 2020 2020 2020 2020 4220  :.            B 
+00015340: 3d20 7222 5c6c 6566 7428 2573 5c72 6967  = r"\left(%s\rig
+00015350: 6874 2922 2025 2070 2e5f 7072 696e 7428  ht)" % p._print(
+00015360: 4229 0a20 2020 2020 2020 2065 6c73 653a  B).        else:
+00015370: 0a20 2020 2020 2020 2020 2020 2042 203d  .            B =
+00015380: 2070 2e5f 7072 696e 7428 4229 0a20 2020   p._print(B).   
+00015390: 2020 2020 2020 2020 200a 2020 2020 2020           .      
+000153a0: 2020 7265 7475 726e 2072 2225 7320 5c73    return r"%s \s
+000153b0: 6574 6d69 6e75 7320 2573 2220 2520 2870  etminus %s" % (p
+000153c0: 2e5f 7072 696e 7428 4129 2c20 4229 0a0a  ._print(A), B)..
+000153d0: 2020 2020 6465 6620 5f73 796d 7079 7374      def _sympyst
+000153e0: 7228 7365 6c66 2c20 7029 3a20 0a20 2020  r(self, p): .   
+000153f0: 2020 2020 2041 2c20 4220 3d20 7365 6c66       A, B = self
+00015400: 2e61 7267 730a 2020 2020 2020 2020 6966  .args.        if
+00015410: 2042 2e69 735f 436f 6d70 6c65 6d65 6e74   B.is_Complement
+00015420: 3a0a 2020 2020 2020 2020 2020 2020 4220  :.            B 
+00015430: 3d20 7222 2825 7329 2220 2520 702e 5f70  = r"(%s)" % p._p
+00015440: 7269 6e74 2842 290a 2020 2020 2020 2020  rint(B).        
+00015450: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
+00015460: 2020 4220 3d20 702e 5f70 7269 6e74 2842    B = p._print(B
+00015470: 290a 2020 2020 2020 2020 2020 2020 0a20  ).            . 
+00015480: 2020 2020 2020 2072 6574 7572 6e20 7222         return r"
+00015490: 2573 205c 2025 7322 2025 2028 702e 5f70  %s \ %s" % (p._p
+000154a0: 7269 6e74 2841 292c 2042 290a 0a20 2020  rint(A), B)..   
+000154b0: 2064 6566 2069 735f 636f 6e6e 6563 7465   def is_connecte
+000154c0: 645f 696e 7465 7276 616c 2873 656c 6629  d_interval(self)
+000154d0: 3a20 0a20 2020 2020 2020 2041 2c20 4220  : .        A, B 
+000154e0: 3d20 7365 6c66 2e61 7267 730a 2020 2020  = self.args.    
+000154f0: 2020 2020 0a20 2020 2020 2020 2069 6620      .        if 
+00015500: 6e6f 7420 2841 2e69 735f 496e 7465 7276  not (A.is_Interv
+00015510: 616c 206f 7220 412e 6973 5f52 616e 6765  al or A.is_Range
+00015520: 293a 0a20 2020 2020 2020 2020 2020 2072  ):.            r
+00015530: 6574 7572 6e20 4661 6c73 650a 2020 2020  eturn False.    
+00015540: 2020 2020 0a20 2020 2020 2020 2069 6620      .        if 
+00015550: 422e 6973 5f49 6e74 6572 7661 6c20 6f72  B.is_Interval or
+00015560: 2042 2e69 735f 5261 6e67 653a 0a20 2020   B.is_Range:.   
+00015570: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
+00015580: 5472 7565 0a20 2020 2020 2020 2020 2020  True.           
+00015590: 200a 2020 2020 2020 2020 6966 206e 6f74   .        if not
+000155a0: 2042 2e69 735f 4669 6e69 7465 5365 743a   B.is_FiniteSet:
+000155b0: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
+000155c0: 7572 6e20 4661 6c73 650a 2020 2020 2020  urn False.      
+000155d0: 2020 0a20 2020 2020 2020 2069 6620 6c65    .        if le
+000155e0: 6e28 4229 203d 3d20 313a 0a20 2020 2020  n(B) == 1:.     
+000155f0: 2020 2020 2020 2072 6574 7572 6e20 5472         return Tr
+00015600: 7565 0a20 2020 2020 2020 200a 2020 2020  ue.        .    
+00015610: 2020 2020 6966 206e 6f74 2041 2e69 735f      if not A.is_
+00015620: 696e 7465 6765 723a 0a20 2020 2020 2020  integer:.       
+00015630: 2020 2020 2072 6574 7572 6e20 4661 6c73       return Fals
+00015640: 650a 2020 2020 2020 2020 0a20 2020 2020  e.        .     
+00015650: 2020 2072 6574 7572 6e20 422e 6973 5f69     return B.is_i
+00015660: 6e74 6567 6572 2061 6e64 2042 2e6d 6178  nteger and B.max
+00015670: 2829 202d 2042 2e6d 696e 2829 203d 3d20  () - B.min() == 
+00015680: 6c65 6e28 4229 202d 2031 0a20 2020 2020  len(B) - 1.     
+00015690: 2020 200a 2020 2020 6465 6620 6d69 6e28     .    def min(
+000156a0: 7365 6c66 293a 200a 2020 2020 2020 2020  self): .        
 000156b0: 412c 2042 203d 2073 656c 662e 6172 6773  A, B = self.args
-000156c0: 0a20 2020 2020 2020 2069 6620 422e 6973  .        if B.is
-000156d0: 5f43 6f6d 706c 656d 656e 743a 0a20 2020  _Complement:.   
-000156e0: 2020 2020 2020 2020 2042 203d 2072 225c           B = r"\
-000156f0: 6c65 6674 2825 735c 7269 6768 7429 2220  left(%s\right)" 
-00015700: 2520 702e 5f70 7269 6e74 2842 290a 2020  % p._print(B).  
-00015710: 2020 2020 2020 656c 7365 3a0a 2020 2020        else:.    
-00015720: 2020 2020 2020 2020 4220 3d20 702e 5f70          B = p._p
-00015730: 7269 6e74 2842 290a 2020 2020 2020 2020  rint(B).        
-00015740: 2020 2020 0a20 2020 2020 2020 2072 6574      .        ret
-00015750: 7572 6e20 7222 2573 205c 7365 746d 696e  urn r"%s \setmin
-00015760: 7573 2025 7322 2025 2028 702e 5f70 7269  us %s" % (p._pri
-00015770: 6e74 2841 292c 2042 290a 0a20 2020 2064  nt(A), B)..    d
-00015780: 6566 205f 7379 6d70 7973 7472 2873 656c  ef _sympystr(sel
-00015790: 662c 2070 293a 200a 2020 2020 2020 2020  f, p): .        
-000157a0: 412c 2042 203d 2073 656c 662e 6172 6773  A, B = self.args
-000157b0: 0a20 2020 2020 2020 2069 6620 422e 6973  .        if B.is
-000157c0: 5f43 6f6d 706c 656d 656e 7420 6f72 2042  _Complement or B
-000157d0: 2e69 735f 496e 7465 7273 6563 7469 6f6e  .is_Intersection
-000157e0: 206f 7220 422e 6973 5f55 6e69 6f6e 3a0a   or B.is_Union:.
-000157f0: 2020 2020 2020 2020 2020 2020 4220 3d20              B = 
-00015800: 7222 2825 7329 2220 2520 702e 5f70 7269  r"(%s)" % p._pri
-00015810: 6e74 2842 290a 2020 2020 2020 2020 656c  nt(B).        el
-00015820: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
-00015830: 4220 3d20 702e 5f70 7269 6e74 2842 290a  B = p._print(B).
-00015840: 2020 2020 2020 2020 2020 2020 0a20 2020              .   
-00015850: 2020 2020 2072 6574 7572 6e20 7222 2573       return r"%s
-00015860: 202d 2025 7322 2025 2028 702e 5f70 7269   - %s" % (p._pri
-00015870: 6e74 2841 292c 2042 290a 0a20 2020 2064  nt(A), B)..    d
-00015880: 6566 2069 735f 636f 6e6e 6563 7465 645f  ef is_connected_
-00015890: 696e 7465 7276 616c 2873 656c 6629 3a20  interval(self): 
-000158a0: 0a20 2020 2020 2020 2041 2c20 4220 3d20  .        A, B = 
-000158b0: 7365 6c66 2e61 7267 730a 2020 2020 2020  self.args.      
-000158c0: 2020 0a20 2020 2020 2020 2069 6620 6e6f    .        if no
-000158d0: 7420 2841 2e69 735f 496e 7465 7276 616c  t (A.is_Interval
-000158e0: 206f 7220 412e 6973 5f52 616e 6765 293a   or A.is_Range):
-000158f0: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
-00015900: 7572 6e20 4661 6c73 650a 2020 2020 2020  urn False.      
-00015910: 2020 0a20 2020 2020 2020 2069 6620 422e    .        if B.
-00015920: 6973 5f49 6e74 6572 7661 6c20 6f72 2042  is_Interval or B
-00015930: 2e69 735f 5261 6e67 653a 0a20 2020 2020  .is_Range:.     
-00015940: 2020 2020 2020 2072 6574 7572 6e20 5472         return Tr
-00015950: 7565 0a20 2020 2020 2020 2020 2020 200a  ue.            .
-00015960: 2020 2020 2020 2020 6966 206e 6f74 2042          if not B
-00015970: 2e69 735f 4669 6e69 7465 5365 743a 0a20  .is_FiniteSet:. 
-00015980: 2020 2020 2020 2020 2020 2072 6574 7572             retur
-00015990: 6e20 4661 6c73 650a 2020 2020 2020 2020  n False.        
-000159a0: 0a20 2020 2020 2020 2069 6620 6c65 6e28  .        if len(
-000159b0: 4229 203d 3d20 313a 0a20 2020 2020 2020  B) == 1:.       
-000159c0: 2020 2020 2072 6574 7572 6e20 5472 7565       return True
-000159d0: 0a20 2020 2020 2020 200a 2020 2020 2020  .        .      
-000159e0: 2020 6966 206e 6f74 2041 2e65 7479 7065    if not A.etype
-000159f0: 2e69 735f 696e 7465 6765 723a 0a20 2020  .is_integer:.   
-00015a00: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
-00015a10: 4661 6c73 650a 2020 2020 2020 2020 0a20  False.        . 
-00015a20: 2020 2020 2020 2072 6574 7572 6e20 422e         return B.
-00015a30: 6574 7970 652e 6973 5f69 6e74 6567 6572  etype.is_integer
-00015a40: 2061 6e64 2042 2e6d 6178 2829 202d 2042   and B.max() - B
-00015a50: 2e6d 696e 2829 203d 3d20 6c65 6e28 4229  .min() == len(B)
-00015a60: 202d 2031 0a20 2020 2020 2020 200a 2020   - 1.        .  
-00015a70: 2020 6465 6620 6d69 6e28 7365 6c66 293a    def min(self):
-00015a80: 200a 2020 2020 2020 2020 412c 2042 203d   .        A, B =
-00015a90: 2073 656c 662e 6172 6773 0a20 2020 2020   self.args.     
-00015aa0: 2020 2078 203d 2041 2e6d 696e 2829 0a20     x = A.min(). 
-00015ab0: 2020 2020 2020 2020 2020 200a 2020 2020             .    
-00015ac0: 2020 2020 6966 2078 2e69 735f 696e 6669      if x.is_infi
-00015ad0: 6e69 7465 3a0a 2020 2020 2020 2020 2020  nite:.          
-00015ae0: 2020 6966 2045 6c65 6d65 6e74 2878 2c20    if Element(x, 
-00015af0: 4229 203d 3d20 4661 6c73 653a 0a20 2020  B) == False:.   
-00015b00: 2020 2020 2020 2020 2020 2020 2072 6574               ret
-00015b10: 7572 6e20 780a 2020 2020 2020 2020 2020  urn x.          
-00015b20: 2020 0a20 2020 2020 2020 2069 6620 7365    .        if se
-00015b30: 6c66 2e69 735f 636f 6e6e 6563 7465 645f  lf.is_connected_
-00015b40: 696e 7465 7276 616c 2829 3a0a 2020 2020  interval():.    
-00015b50: 2020 2020 2020 2020 6672 6f6d 2073 796d          from sym
-00015b60: 7079 2e63 6f72 652e 6e75 6d62 6572 7320  py.core.numbers 
-00015b70: 696d 706f 7274 2065 7073 696c 6f6e 0a20  import epsilon. 
-00015b80: 2020 2020 2020 2020 2020 2066 726f 6d20             from 
-00015b90: 7379 6d70 7920 696d 706f 7274 2066 6c6f  sympy import flo
-00015ba0: 6f72 0a20 2020 2020 2020 2020 2020 204d  or.            M
-00015bb0: 203d 2042 2e6d 6178 2829 2020 2020 2020   = B.max()      
-00015bc0: 2020 0a20 2020 2020 2020 2020 2020 2069    .            i
-00015bd0: 6620 412e 6574 7970 652e 6973 5f69 6e74  f A.etype.is_int
-00015be0: 6567 6572 3a20 0a20 2020 2020 2020 2020  eger: .         
-00015bf0: 2020 2020 2020 204d 203d 2066 6c6f 6f72         M = floor
-00015c00: 284d 2920 2b20 310a 2020 2020 2020 2020  (M) + 1.        
-00015c10: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
-00015c20: 2020 2020 2020 2020 2020 4d20 2b3d 2065            M += e
-00015c30: 7073 696c 6f6e 0a20 2020 2020 2020 2020  psilon.         
-00015c40: 2020 2020 2020 200a 2020 2020 2020 2020         .        
-00015c50: 2020 2020 6672 6f6d 2073 796d 7079 2e66      from sympy.f
-00015c60: 756e 6374 696f 6e73 2e65 6c65 6d65 6e74  unctions.element
-00015c70: 6172 792e 7069 6563 6577 6973 6520 696d  ary.piecewise im
-00015c80: 706f 7274 2050 6965 6365 7769 7365 0a20  port Piecewise. 
-00015c90: 2020 2020 2020 2020 2020 2072 6574 7572             retur
-00015ca0: 6e20 5069 6563 6577 6973 6528 284d 2c20  n Piecewise((M, 
-00015cb0: 456c 656d 656e 7428 782c 2042 292e 7369  Element(x, B).si
-00015cc0: 6d70 6c69 6679 2829 292c 2028 782c 2054  mplify()), (x, T
-00015cd0: 7275 6529 292e 7369 6d70 6c69 6679 2829  rue)).simplify()
-00015ce0: 0a20 2020 2020 2020 200a 2020 2020 2020  .        .      
-00015cf0: 2020 6d20 3d20 422e 6d69 6e28 290a 2020    m = B.min().  
-00015d00: 2020 2020 2020 6966 2078 203c 206d 3a0a        if x < m:.
-00015d10: 2020 2020 2020 2020 2020 2020 7265 7475              retu
-00015d20: 726e 2078 0a20 2020 2020 2020 200a 2020  rn x.        .  
-00015d30: 2020 2020 2020 6672 6f6d 2073 796d 7079        from sympy
-00015d40: 2e63 6f6e 6372 6574 652e 7265 6475 6365  .concrete.reduce
-00015d50: 6420 696d 706f 7274 2052 6564 7563 6564  d import Reduced
-00015d60: 4d69 6e0a 2020 2020 2020 2020 7265 7475  Min.        retu
-00015d70: 726e 2052 6564 7563 6564 4d69 6e28 7365  rn ReducedMin(se
-00015d80: 6c66 290a 0a20 2020 2064 6566 206d 6178  lf)..    def max
-00015d90: 2873 656c 6629 3a20 0a20 2020 2020 2020  (self): .       
-00015da0: 2041 2c20 4220 3d20 7365 6c66 2e61 7267   A, B = self.arg
-00015db0: 730a 2020 2020 2020 2020 7820 3d20 412e  s.        x = A.
-00015dc0: 6d61 7828 2920 2020 2020 200a 2020 2020  max()      .    
-00015dd0: 2020 2020 2020 0a20 2020 2020 2020 2069        .        i
-00015de0: 6620 782e 6973 5f69 6e66 696e 6974 653a  f x.is_infinite:
-00015df0: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
-00015e00: 456c 656d 656e 7428 782c 2042 2920 3d3d  Element(x, B) ==
-00015e10: 2046 616c 7365 3a0a 2020 2020 2020 2020   False:.        
-00015e20: 2020 2020 2020 2020 7265 7475 726e 2078          return x
-00015e30: 0a20 2020 2020 2020 200a 2020 2020 2020  .        .      
-00015e40: 2020 6966 2073 656c 662e 6973 5f63 6f6e    if self.is_con
-00015e50: 6e65 6374 6564 5f69 6e74 6572 7661 6c28  nected_interval(
-00015e60: 293a 0a20 2020 2020 2020 2020 2020 2066  ):.            f
-00015e70: 726f 6d20 7379 6d70 792e 636f 7265 2e6e  rom sympy.core.n
-00015e80: 756d 6265 7273 2069 6d70 6f72 7420 6570  umbers import ep
-00015e90: 7369 6c6f 6e0a 2020 2020 2020 2020 2020  silon.          
-00015ea0: 2020 6672 6f6d 2073 796d 7079 2069 6d70    from sympy imp
-00015eb0: 6f72 7420 6365 696c 696e 670a 2020 2020  ort ceiling.    
-00015ec0: 2020 2020 2020 2020 6d20 3d20 422e 6d69          m = B.mi
-00015ed0: 6e28 290a 2020 2020 2020 2020 2020 2020  n().            
-00015ee0: 6966 2041 2e65 7479 7065 2e69 735f 696e  if A.etype.is_in
-00015ef0: 7465 6765 723a 200a 2020 2020 2020 2020  teger: .        
-00015f00: 2020 2020 2020 2020 6d20 3d20 6365 696c          m = ceil
-00015f10: 696e 6728 6d29 202d 2031 0a20 2020 2020  ing(m) - 1.     
-00015f20: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
-00015f30: 2020 2020 2020 2020 2020 2020 206d 202d               m -
-00015f40: 3d20 6570 7369 6c6f 6e0a 2020 2020 2020  = epsilon.      
-00015f50: 2020 2020 2020 2020 2020 0a20 2020 2020            .     
-00015f60: 2020 2020 2020 2066 726f 6d20 7379 6d70         from symp
-00015f70: 792e 6675 6e63 7469 6f6e 732e 656c 656d  y.functions.elem
-00015f80: 656e 7461 7279 2e70 6965 6365 7769 7365  entary.piecewise
-00015f90: 2069 6d70 6f72 7420 5069 6563 6577 6973   import Piecewis
-00015fa0: 650a 2020 2020 2020 2020 2020 2020 7265  e.            re
-00015fb0: 7475 726e 2050 6965 6365 7769 7365 2828  turn Piecewise((
-00015fc0: 6d2c 2045 6c65 6d65 6e74 2878 2c20 4229  m, Element(x, B)
-00015fd0: 2e73 696d 706c 6966 7928 2929 2c20 2878  .simplify()), (x
-00015fe0: 2c20 5472 7565 2929 2e73 696d 706c 6966  , True)).simplif
-00015ff0: 7928 290a 2020 2020 2020 2020 0a20 2020  y().        .   
-00016000: 2020 2020 204d 203d 2042 2e6d 6178 2829       M = B.max()
-00016010: 0a20 2020 2020 2020 2069 6620 7820 3e20  .        if x > 
-00016020: 4d3a 0a20 2020 2020 2020 2020 2020 2072  M:.            r
-00016030: 6574 7572 6e20 780a 2020 2020 2020 2020  eturn x.        
-00016040: 0a20 2020 2020 2020 2066 726f 6d20 7379  .        from sy
-00016050: 6d70 792e 636f 6e63 7265 7465 2e72 6564  mpy.concrete.red
-00016060: 7563 6564 2069 6d70 6f72 7420 5265 6475  uced import Redu
-00016070: 6365 644d 6178 0a20 2020 2020 2020 2072  cedMax.        r
-00016080: 6574 7572 6e20 5265 6475 6365 644d 6178  eturn ReducedMax
-00016090: 2873 656c 6629 2020 0a0a 2020 2020 4070  (self)  ..    @p
-000160a0: 726f 7065 7274 790a 2020 2020 6465 6620  roperty.    def 
-000160b0: 6574 7970 6528 7365 6c66 293a 0a20 2020  etype(self):.   
-000160c0: 2020 2020 2072 6574 7572 6e20 7365 6c66       return self
-000160d0: 2e61 7267 735b 305d 2e65 7479 7065 0a0a  .args[0].etype..
-000160e0: 2020 2020 6465 6620 5f5f 6e65 775f 5f28      def __new__(
-000160f0: 636c 732c 2061 2c20 622c 2065 7661 6c75  cls, a, b, evalu
-00016100: 6174 653d 5472 7565 293a 0a20 2020 2020  ate=True):.     
-00016110: 2020 2066 726f 6d20 7379 6d70 7920 696d     from sympy im
-00016120: 706f 7274 2046 696e 6974 6553 6574 0a20  port FiniteSet. 
-00016130: 2020 2020 2020 2069 6620 6973 696e 7374         if isinst
-00016140: 616e 6365 2862 2c20 7365 7429 3a0a 2020  ance(b, set):.  
-00016150: 2020 2020 2020 2020 2020 6220 3d20 4669            b = Fi
-00016160: 6e69 7465 5365 7428 2a62 290a 0a20 2020  niteSet(*b)..   
-00016170: 2020 2020 2069 6620 6973 696e 7374 616e       if isinstan
-00016180: 6365 2861 2c20 7365 7429 3a0a 2020 2020  ce(a, set):.    
-00016190: 2020 2020 2020 2020 6120 3d20 4669 6e69          a = Fini
-000161a0: 7465 5365 7428 2a61 290a 0a20 2020 2020  teSet(*a)..     
-000161b0: 2020 2069 6620 6576 616c 7561 7465 3a0a     if evaluate:.
-000161c0: 2020 2020 2020 2020 2020 2020 7265 7475              retu
-000161d0: 726e 2043 6f6d 706c 656d 656e 742e 7265  rn Complement.re
-000161e0: 6475 6365 2861 2c20 6229 0a0a 2020 2020  duce(a, b)..    
-000161f0: 2020 2020 7265 7475 726e 2042 6173 6963      return Basic
-00016200: 2e5f 5f6e 6577 5f5f 2863 6c73 2c20 612c  .__new__(cls, a,
-00016210: 2062 290a 0a23 2041 202d 2028 4220 2d20   b)..# A - (B - 
-00016220: 2841 2026 2042 2929 203d 2041 0a23 2041  (A & B)) = A.# A
-00016230: 2020 2620 2028 4220 2d20 2841 2026 2042    &  (B - (A & B
-00016240: 2929 203d 2030 0a23 2028 4120 2620 4229  )) = 0.# (A & B)
-00016250: 2020 2620 2028 4220 2d20 2841 2026 2042    &  (B - (A & B
-00016260: 2929 203d 2030 0a23 2041 202d 2028 4220  )) = 0.# A - (B 
-00016270: 2d20 4120 2620 6229 2c20 6220 696e 2042  - A & b), b in B
-00016280: 0a20 2020 2064 6566 205f 636f 6d70 6c65  .    def _comple
-00016290: 6d65 6e74 2873 656c 662c 2041 293a 0a20  ment(self, A):. 
-000162a0: 2020 2020 2020 2042 2c20 4320 3d20 7365         B, C = se
-000162b0: 6c66 2e61 7267 730a 2020 2020 2020 2020  lf.args.        
-000162c0: 6966 2043 2e69 735f 496e 7465 7273 6563  if C.is_Intersec
-000162d0: 7469 6f6e 3a0a 2020 2020 2020 2020 2020  tion:.          
-000162e0: 2020 6172 6773 203d 205b 2a43 2e61 7267    args = [*C.arg
-000162f0: 735d 0a20 2020 2020 2020 2020 2020 2074  s].            t
-00016300: 7279 3a0a 2020 2020 2020 2020 2020 2020  ry:.            
-00016310: 2020 2020 696e 6465 7820 3d20 6172 6773      index = args
-00016320: 2e69 6e64 6578 2841 290a 2020 2020 2020  .index(A).      
-00016330: 2020 2020 2020 2020 2020 6465 6c20 6172            del ar
-00016340: 6773 5b69 6e64 6578 5d0a 2020 2020 2020  gs[index].      
-00016350: 2020 2020 2020 2020 2020 6220 3d20 432e            b = C.
-00016360: 6675 6e63 282a 6172 6773 2c20 6576 616c  func(*args, eval
-00016370: 7561 7465 3d46 616c 7365 290a 2020 2020  uate=False).    
-00016380: 2020 2020 2020 2020 2020 2020 6966 2062              if b
-00016390: 203d 3d20 423a 0a20 2020 2020 2020 2020   == B:.         
-000163a0: 2020 2020 2020 2020 2020 2072 6574 7572             retur
-000163b0: 6e20 410a 2020 2020 2020 2020 2020 2020  n A.            
-000163c0: 2020 2020 6966 2062 2069 6e20 423a 0a20      if b in B:. 
-000163d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000163e0: 2020 2042 203d 2043 6f6d 706c 656d 656e     B = Complemen
-000163f0: 7428 422c 2062 290a 2020 2020 2020 2020  t(B, b).        
-00016400: 2020 2020 2020 2020 2020 2020 7265 7475              retu
-00016410: 726e 2073 656c 662e 6675 6e63 2841 2c20  rn self.func(A, 
-00016420: 422c 2065 7661 6c75 6174 653d 4661 6c73  B, evaluate=Fals
-00016430: 6529 0a20 2020 2020 2020 2020 2020 2065  e).            e
-00016440: 7863 6570 743a 0a20 2020 2020 2020 2020  xcept:.         
-00016450: 2020 2020 2020 2072 6574 7572 6e0a 2020         return.  
-00016460: 2020 2020 2020 6966 2041 2069 6e20 4220        if A in B 
-00016470: 7c20 433a 0a20 2020 2020 2020 2020 2020  | C:.           
-00016480: 2072 6574 7572 6e20 4120 2620 430a 2020   return A & C.  
-00016490: 2020 2020 2020 6966 206e 6f74 2041 2026        if not A &
-000164a0: 2043 3a0a 2020 2020 2020 2020 2020 2020   C:.            
-000164b0: 7265 7475 726e 2043 6f6d 706c 656d 656e  return Complemen
-000164c0: 7428 412c 2042 290a 2020 2020 2020 2020  t(A, B).        
-000164d0: 6966 2042 2069 6e20 413a 0a23 2020 2020  if B in A:.#    
-000164e0: 2020 2020 2020 2020 2069 6620 4320 696e           if C in
-000164f0: 2042 3a0a 2320 2020 2020 2020 2020 2020   B:.#           
-00016500: 2020 2020 2020 7265 7475 726e 2028 4120        return (A 
-00016510: 2d20 4229 207c 2043 0a20 2020 2020 2020  - B) | C.       
-00016520: 2020 2020 2069 6620 4320 696e 2041 3a20       if C in A: 
-00016530: 2023 2043 2069 6e20 4220 3d3e 2043 2069   # C in B => C i
-00016540: 6e20 410a 2020 2020 2020 2020 2020 2020  n A.            
-00016550: 2020 2020 7265 7475 726e 2043 6f6d 706c      return Compl
-00016560: 656d 656e 7428 412c 2042 2920 7c20 430a  ement(A, B) | C.
-00016570: 2320 2020 2020 2020 2020 2020 2020 7265  #             re
-00016580: 7475 726e 2028 4120 2d20 4229 207c 2028  turn (A - B) | (
-00016590: 4220 2620 4329 0a0a 2020 2020 4073 7461  B & C)..    @sta
-000165a0: 7469 636d 6574 686f 640a 2020 2020 6465  ticmethod.    de
-000165b0: 6620 7265 6475 6365 2841 2c20 4229 3a0a  f reduce(A, B):.
-000165c0: 2020 2020 2020 2020 2222 220a 2020 2020          """.    
-000165d0: 2020 2020 5369 6d70 6c69 6679 2061 203a      Simplify a :
-000165e0: 636c 6173 733a 6043 6f6d 706c 656d 656e  class:`Complemen
-000165f0: 7460 2e0a 0a20 2020 2020 2020 2022 2222  t`...        """
-00016600: 0a20 2020 2020 2020 2023 2074 7279 2074  .        # try t
-00016610: 6f20 6576 616c 7561 7465 2041 205c 2042  o evaluate A \ B
-00016620: 0a20 2020 2020 2020 2069 6620 422e 6973  .        if B.is
-00016630: 5f55 6e69 7665 7273 616c 5365 743a 0a20  _UniversalSet:. 
-00016640: 2020 2020 2020 2020 2020 2069 6620 412e             if A.
-00016650: 6574 7970 6520 696e 2042 2e65 7479 7065  etype in B.etype
-00016660: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-00016670: 2020 7265 7475 726e 2041 2e65 7479 7065    return A.etype
-00016680: 2e65 6d70 7479 5365 740a 2020 2020 2020  .emptySet.      
-00016690: 2020 0a20 2020 2020 2020 2069 6620 412e    .        if A.
-000166a0: 6973 5f73 7562 7365 7428 4229 3a0a 2020  is_subset(B):.  
-000166b0: 2020 2020 2020 2020 2020 7265 7475 726e            return
-000166c0: 2041 2e65 7479 7065 2e65 6d70 7479 5365   A.etype.emptySe
-000166d0: 740a 0a20 2020 2020 2020 2069 6620 422e  t..        if B.
-000166e0: 6973 5f55 6e69 6f6e 3a0a 2020 2020 2020  is_Union:.      
-000166f0: 2020 2020 2020 6966 2041 2e69 735f 436f        if A.is_Co
-00016700: 6d70 6c65 6d65 6e74 3a0a 2020 2020 2020  mplement:.      
-00016710: 2020 2020 2020 2020 2020 6966 2042 2069            if B i
-00016720: 6e20 412e 6172 6773 5b31 5d3a 0a20 2020  n A.args[1]:.   
-00016730: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016740: 2072 6574 7572 6e20 410a 2020 2020 2020   return A.      
-00016750: 2020 2020 2020 2020 2020 6966 2041 2e61            if A.a
-00016760: 7267 735b 315d 2069 6e20 423a 0a20 2020  rgs[1] in B:.   
-00016770: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016780: 2072 6574 7572 6e20 436f 6d70 6c65 6d65   return Compleme
-00016790: 6e74 2841 2e61 7267 735b 305d 2c20 422c  nt(A.args[0], B,
-000167a0: 2065 7661 6c75 6174 653d 4661 6c73 6529   evaluate=False)
-000167b0: 200a 0a20 2020 2020 2020 2020 2020 2072   ..            r
-000167c0: 6574 7572 6e20 496e 7465 7273 6563 7469  eturn Intersecti
-000167d0: 6f6e 282a 2873 2e63 6f6d 706c 656d 656e  on(*(s.complemen
-000167e0: 7428 4129 2066 6f72 2073 2069 6e20 422e  t(A) for s in B.
-000167f0: 6172 6773 2929 0a0a 2020 2020 2020 2020  args))..        
-00016800: 7265 7375 6c74 203d 2042 2e5f 636f 6d70  result = B._comp
-00016810: 6c65 6d65 6e74 2841 290a 2020 2020 2020  lement(A).      
-00016820: 2020 6966 2072 6573 756c 7420 6973 206e    if result is n
-00016830: 6f74 204e 6f6e 653a 0a20 2020 2020 2020  ot None:.       
-00016840: 2020 2020 2072 6574 7572 6e20 7265 7375       return resu
-00016850: 6c74 0a0a 2020 2020 2020 2020 6966 2041  lt..        if A
-00016860: 2e69 735f 556e 696f 6e3a 0a20 2020 2020  .is_Union:.     
-00016870: 2020 2020 2020 2066 6f72 2069 2c20 6172         for i, ar
-00016880: 6720 696e 2065 6e75 6d65 7261 7465 2841  g in enumerate(A
-00016890: 2e61 7267 7329 3a0a 2020 2020 2020 2020  .args):.        
-000168a0: 2020 2020 2020 2020 6966 2061 7267 2069          if arg i
-000168b0: 6e20 423a 0a20 2020 2020 2020 2020 2020  n B:.           
-000168c0: 2020 2020 2020 2020 2061 7267 7320 3d20           args = 
-000168d0: 5b2a 412e 6172 6773 5d0a 2020 2020 2020  [*A.args].      
-000168e0: 2020 2020 2020 2020 2020 2020 2020 6465                de
-000168f0: 6c20 6172 6773 5b69 5d0a 2020 2020 2020  l args[i].      
-00016900: 2020 2020 2020 2020 2020 2020 2020 4120                A 
-00016910: 3d20 412e 6675 6e63 282a 6172 6773 290a  = A.func(*args).
-00016920: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016930: 2020 2020 7265 7475 726e 2043 6f6d 706c      return Compl
-00016940: 656d 656e 7428 412c 2042 290a 2020 2020  ement(A, B).    
-00016950: 2020 2020 2020 2020 2020 2020 200a 2020               .  
-00016960: 2020 2020 2020 6966 2041 2e69 735f 4375        if A.is_Cu
-00016970: 703a 0a20 2020 2020 2020 2020 2020 2069  p:.            i
-00016980: 6620 412e 6973 5f43 6f6e 6469 7469 6f6e  f A.is_Condition
-00016990: 5365 743a 0a20 2020 2020 2020 2020 2020  Set:.           
-000169a0: 2020 2020 2069 6620 6e6f 7420 422e 6973       if not B.is
-000169b0: 5f43 6f6e 6469 7469 6f6e 5365 743a 0a20  _ConditionSet:. 
-000169c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000169d0: 2020 2066 726f 6d20 7379 6d70 792e 7365     from sympy.se
-000169e0: 7473 2069 6d70 6f72 7420 636f 6e64 6974  ts import condit
-000169f0: 696f 6e73 6574 0a20 2020 2020 2020 2020  ionset.         
-00016a00: 2020 2020 2020 2020 2020 2062 6173 655f             base_
-00016a10: 7365 7420 3d20 422e 5f63 6f6d 706c 656d  set = B._complem
-00016a20: 656e 7428 412e 6261 7365 5f73 6574 290a  ent(A.base_set).
-00016a30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016a40: 2020 2020 6966 2062 6173 655f 7365 7420      if base_set 
-00016a50: 6973 206e 6f74 204e 6f6e 653a 0a20 2020  is not None:.   
-00016a60: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016a70: 2020 2020 2069 6620 412e 6261 7365 5f73       if A.base_s
-00016a80: 6574 203d 3d20 6261 7365 5f73 6574 3a0a  et == base_set:.
-00016a90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016aa0: 2020 2020 2020 2020 2020 2020 7265 7475              retu
-00016ab0: 726e 2041 0a20 2020 2020 2020 2020 2020  rn A.           
-00016ac0: 2020 2020 2020 2020 2020 2020 2072 6574               ret
-00016ad0: 7572 6e20 636f 6e64 6974 696f 6e73 6574  urn conditionset
-00016ae0: 2841 2e76 6172 6961 626c 652c 2041 2e63  (A.variable, A.c
-00016af0: 6f6e 6469 7469 6f6e 2c20 6261 7365 5f73  ondition, base_s
-00016b00: 6574 290a 2020 2020 2020 2020 2020 2020  et).            
-00016b10: 656c 6966 2041 2e72 616e 6765 5f63 6f6e  elif A.range_con
-00016b20: 7461 696e 7328 4229 2069 7320 4661 6c73  tains(B) is Fals
-00016b30: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
-00016b40: 2020 2072 6574 7572 6e20 410a 2020 2020     return A.    
-00016b50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016b60: 0a20 2020 2020 2020 2069 6620 422e 6973  .        if B.is
-00016b70: 5f49 6e74 6572 7365 6374 696f 6e20 616e  _Intersection an
-00016b80: 6420 4120 696e 2042 2e5f 6172 6773 6574  d A in B._argset
-00016b90: 3a0a 2020 2020 2020 2020 2020 2020 4220  :.            B 
-00016ba0: 3d20 422e 6675 6e63 282a 422e 5f61 7267  = B.func(*B._arg
-00016bb0: 7365 7420 2d20 7b41 7d2c 2065 7661 6c75  set - {A}, evalu
-00016bc0: 6174 653d 4661 6c73 6529 0a20 2020 2020  ate=False).     
-00016bd0: 2020 2020 2020 200a 2020 2020 2020 2020         .        
-00016be0: 6966 2041 2e69 735f 5069 6563 6577 6973  if A.is_Piecewis
-00016bf0: 653a 0a20 2020 2020 2020 2020 2020 2072  e:.            r
-00016c00: 6574 7572 6e20 412e 6675 6e63 282a 2828  eturn A.func(*((
-00016c10: 436f 6d70 6c65 6d65 6e74 2865 2c20 4229  Complement(e, B)
-00016c20: 2c20 6329 2066 6f72 2065 2c20 6320 696e  , c) for e, c in
-00016c30: 2041 2e61 7267 7329 292e 7369 6d70 6c69   A.args)).simpli
-00016c40: 6679 2829 0a20 2020 2020 2020 200a 2020  fy().        .  
-00016c50: 2020 2020 2020 6966 2041 2e69 735f 496e        if A.is_In
-00016c60: 7465 7273 6563 7469 6f6e 3a0a 2020 2020  tersection:.    
-00016c70: 2020 2020 2020 2020 666f 7220 692c 2061          for i, a
-00016c80: 7267 2069 6e20 656e 756d 6572 6174 6528  rg in enumerate(
-00016c90: 412e 6172 6773 293a 0a20 2020 2020 2020  A.args):.       
-00016ca0: 2020 2020 2020 2020 2069 6620 6172 672e           if arg.
-00016cb0: 6973 5f43 6f6d 706c 656d 656e 7420 616e  is_Complement an
-00016cc0: 6420 6172 672e 6172 6773 5b31 5d20 696e  d arg.args[1] in
-00016cd0: 2042 3a20 0a20 2020 2020 2020 2020 2020   B: .           
-00016ce0: 2020 2020 2020 2020 2061 7267 7320 3d20           args = 
-00016cf0: 5b2a 412e 6172 6773 5d0a 2020 2020 2020  [*A.args].      
-00016d00: 2020 2020 2020 2020 2020 2020 2020 6172                ar
-00016d10: 6773 5b69 5d20 3d20 6172 672e 6172 6773  gs[i] = arg.args
-00016d20: 5b30 5d0a 2020 2020 2020 2020 2020 2020  [0].            
-00016d30: 2020 2020 2020 2020 4120 3d20 412e 6675          A = A.fu
-00016d40: 6e63 282a 6172 6773 2c20 6576 616c 7561  nc(*args, evalua
-00016d50: 7465 3d46 616c 7365 290a 2020 2020 2020  te=False).      
-00016d60: 2020 2020 2020 2020 2020 2020 2020 7265                re
-00016d70: 7475 726e 2043 6f6d 706c 656d 656e 7428  turn Complement(
-00016d80: 412c 2042 290a 2020 2020 2020 2020 2020  A, B).          
-00016d90: 2020 2020 2020 2020 2020 200a 2020 2020             .    
-00016da0: 2020 2020 6966 2041 2e69 735f 436f 6d70      if A.is_Comp
-00016db0: 6c65 6d65 6e74 3a0a 2020 2020 2020 2020  lement:.        
-00016dc0: 2020 2020 5f41 2c20 5f42 203d 2041 2e61      _A, _B = A.a
-00016dd0: 7267 730a 2020 2020 2020 2020 2020 2020  rgs.            
-00016de0: 6966 2042 2069 6e20 5f42 3a0a 2020 2020  if B in _B:.    
-00016df0: 2020 2020 2020 2020 2020 2020 7265 7475              retu
-00016e00: 726e 2041 0a20 2020 2020 2020 2020 2020  rn A.           
-00016e10: 2041 2c20 4220 3d20 5f41 2c20 5f42 207c   A, B = _A, _B |
-00016e20: 2042 0a20 2020 2020 2020 2072 6574 7572   B.        retur
-00016e30: 6e20 436f 6d70 6c65 6d65 6e74 2841 2c20  n Complement(A, 
-00016e40: 422c 2065 7661 6c75 6174 653d 4661 6c73  B, evaluate=Fals
-00016e50: 6529 0a0a 2020 2020 6465 6620 5f63 6f6e  e)..    def _con
-00016e60: 7461 696e 7328 7365 6c66 2c20 6f74 6865  tains(self, othe
-00016e70: 7229 3a0a 2020 2020 2020 2020 4120 3d20  r):.        A = 
-00016e80: 7365 6c66 2e61 7267 735b 305d 0a20 2020  self.args[0].   
-00016e90: 2020 2020 2042 203d 2073 656c 662e 6172       B = self.ar
-00016ea0: 6773 5b31 5d0a 2020 2020 2020 2020 7265  gs[1].        re
-00016eb0: 7475 726e 2041 6e64 2845 6c65 6d65 6e74  turn And(Element
-00016ec0: 286f 7468 6572 2c20 4129 2c20 456c 656d  (other, A), Elem
-00016ed0: 656e 7428 6f74 6865 722c 2042 292e 696e  ent(other, B).in
-00016ee0: 7665 7274 2829 290a 0a20 2020 2064 6566  vert())..    def
-00016ef0: 2075 6e69 6f6e 5f73 6574 7328 7365 6c66   union_sets(self
-00016f00: 2c20 4329 3a0a 2020 2020 2020 2020 412c  , C):.        A,
-00016f10: 2042 203d 2073 656c 662e 6172 6773 0a20   B = self.args. 
-00016f20: 2020 2020 2020 2069 6620 4220 696e 2043         if B in C
-00016f30: 3a0a 2020 2020 2020 2020 2020 2020 7265  :.            re
-00016f40: 7475 726e 2041 207c 2043 0a20 2020 2020  turn A | C.     
-00016f50: 2020 2069 6620 4120 696e 2043 3a0a 2020     if A in C:.  
-00016f60: 2020 2020 2020 2020 2020 7265 7475 726e            return
-00016f70: 2043 0a20 2020 2020 2020 2069 6620 432e   C.        if C.
-00016f80: 6973 5f49 6e74 6572 7365 6374 696f 6e3a  is_Intersection:
-00016f90: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
-00016fa0: 4120 2620 4220 696e 2043 3a0a 2020 2020  A & B in C:.    
-00016fb0: 2020 2020 2020 2020 2020 2020 7265 7475              retu
-00016fc0: 726e 2041 207c 2043 0a20 2020 2020 2020  rn A | C.       
-00016fd0: 2020 2020 2074 7279 3a0a 2020 2020 2020       try:.      
-00016fe0: 2020 2020 2020 2020 2020 2320 4120 2620            # A & 
-00016ff0: 4220 7c20 2841 2d42 2920 3d20 410a 2020  B | (A-B) = A.  
-00017000: 2020 2020 2020 2020 2020 2020 2020 2320                # 
-00017010: 4120 2620 4220 7c20 2841 2d28 422b 4329  A & B | (A-(B+C)
-00017020: 2920 3d20 4120 2d20 430a 2020 2020 2020  ) = A - C.      
-00017030: 2020 2020 2020 2020 2020 6172 6773 203d            args =
-00017040: 205b 2a43 2e61 7267 735d 0a20 2020 2020   [*C.args].     
-00017050: 2020 2020 2020 2020 2020 2069 6e64 6578             index
-00017060: 203d 2061 7267 732e 696e 6465 7828 4129   = args.index(A)
-00017070: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00017080: 2064 656c 2061 7267 735b 696e 6465 785d   del args[index]
-00017090: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000170a0: 2072 6573 7420 3d20 432e 6675 6e63 282a   rest = C.func(*
-000170b0: 6172 6773 2c20 6576 616c 7561 7465 3d46  args, evaluate=F
-000170c0: 616c 7365 290a 2020 2020 2020 2020 2020  alse).          
-000170d0: 2020 2020 2020 6966 2072 6573 7420 696e        if rest in
-000170e0: 2042 3a0a 2020 2020 2020 2020 2020 2020   B:.            
-000170f0: 2020 2020 2020 2020 7265 7475 726e 2043          return C
-00017100: 6f6d 706c 656d 656e 7428 412c 2043 6f6d  omplement(A, Com
-00017110: 706c 656d 656e 7428 422c 2072 6573 7429  plement(B, rest)
-00017120: 290a 2020 2020 2020 2020 2020 2020 6578  ).            ex
-00017130: 6365 7074 3a0a 2020 2020 2020 2020 2020  cept:.          
-00017140: 2020 2020 2020 7265 7475 726e 0a20 2020        return.   
-00017150: 2020 2020 2069 6620 4320 696e 2042 3a0a       if C in B:.
-00017160: 2020 2020 2020 2020 2020 2020 4220 3d20              B = 
-00017170: 436f 6d70 6c65 6d65 6e74 2842 2c20 4329  Complement(B, C)
-00017180: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
-00017190: 7572 6e20 7365 6c66 2e66 756e 6328 4120  urn self.func(A 
-000171a0: 7c20 432c 2042 2c20 6576 616c 7561 7465  | C, B, evaluate
-000171b0: 3d46 616c 7365 290a 2020 2020 2020 2020  =False).        
-000171c0: 6966 2043 2e69 735f 436f 6d70 6c65 6d65  if C.is_Compleme
-000171d0: 6e74 3a0a 2020 2020 2020 2020 2020 2020  nt:.            
-000171e0: 5f41 2c20 5f42 203d 2043 2e61 7267 730a  _A, _B = C.args.
-000171f0: 2020 2020 2020 2020 2020 2020 6966 2042              if B
-00017200: 203d 3d20 5f42 3a0a 2020 2020 2020 2020   == _B:.        
-00017210: 2020 2020 2020 2020 7265 7475 726e 2043          return C
-00017220: 6f6d 706c 656d 656e 7428 4120 7c20 5f41  omplement(A | _A
-00017230: 2c20 4229 0a20 2020 2020 2020 2020 2020  , B).           
-00017240: 2069 6620 5f42 2069 6e20 7365 6c66 3a0a   if _B in self:.
-00017250: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00017260: 7265 7475 726e 205f 4120 7c20 7365 6c66  return _A | self
-00017270: 0a0a 2320 6966 2042 203d 3e20 432c 2028  ..# if B => C, (
-00017280: 4120 2d20 4229 207c 2043 203d 2041 207c  A - B) | C = A |
-00017290: 2043 0a23 2069 6620 4120 3d3e 2043 2c20   C.# if A => C, 
-000172a0: 2841 202d 2042 2920 7c20 4320 3d20 430a  (A - B) | C = C.
-000172b0: 0a20 2020 2064 6566 205f 6576 616c 5f69  .    def _eval_i
-000172c0: 735f 6578 7465 6e64 6564 5f69 6e74 6567  s_extended_integ
-000172d0: 6572 2873 656c 6629 3a0a 2020 2020 2020  er(self):.      
-000172e0: 2020 7265 7475 726e 2073 656c 662e 6172    return self.ar
-000172f0: 6773 5b30 5d2e 6973 5f65 7874 656e 6465  gs[0].is_extende
-00017300: 645f 696e 7465 6765 720a 0a20 2020 2064  d_integer..    d
-00017310: 6566 205f 6576 616c 5f69 735f 7375 7065  ef _eval_is_supe
-00017320: 725f 696e 7465 6765 7228 7365 6c66 293a  r_integer(self):
-00017330: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
-00017340: 7365 6c66 2e61 7267 735b 305d 2e69 735f  self.args[0].is_
-00017350: 7375 7065 725f 696e 7465 6765 720a 2020  super_integer.  
-00017360: 2020 0a20 2020 2064 6566 205f 6576 616c    .    def _eval
-00017370: 5f69 735f 6578 7465 6e64 6564 5f72 6174  _is_extended_rat
-00017380: 696f 6e61 6c28 7365 6c66 293a 0a20 2020  ional(self):.   
-00017390: 2020 2020 2072 6574 7572 6e20 7365 6c66       return self
-000173a0: 2e61 7267 735b 305d 2e69 735f 6578 7465  .args[0].is_exte
-000173b0: 6e64 6564 5f72 6174 696f 6e61 6c0a 2020  nded_rational.  
-000173c0: 2020 0a20 2020 2064 6566 205f 6576 616c    .    def _eval
-000173d0: 5f69 735f 6879 7065 725f 7261 7469 6f6e  _is_hyper_ration
-000173e0: 616c 2873 656c 6629 3a0a 2020 2020 2020  al(self):.      
-000173f0: 2020 7265 7475 726e 2073 656c 662e 6172    return self.ar
-00017400: 6773 5b30 5d2e 6973 5f68 7970 6572 5f72  gs[0].is_hyper_r
-00017410: 6174 696f 6e61 6c0a 2020 2020 0a20 2020  ational.    .   
-00017420: 2064 6566 205f 6576 616c 5f69 735f 7375   def _eval_is_su
-00017430: 7065 725f 7261 7469 6f6e 616c 2873 656c  per_rational(sel
-00017440: 6629 3a0a 2020 2020 2020 2020 7265 7475  f):.        retu
-00017450: 726e 2073 656c 662e 6172 6773 5b30 5d2e  rn self.args[0].
-00017460: 6973 5f73 7570 6572 5f72 6174 696f 6e61  is_super_rationa
-00017470: 6c0a 2020 2020 0a20 2020 2064 6566 205f  l.    .    def _
-00017480: 6576 616c 5f69 735f 6578 7465 6e64 6564  eval_is_extended
-00017490: 5f72 6561 6c28 7365 6c66 293a 0a20 2020  _real(self):.   
-000174a0: 2020 2020 2072 6574 7572 6e20 7365 6c66       return self
-000174b0: 2e61 7267 735b 305d 2e69 735f 6578 7465  .args[0].is_exte
-000174c0: 6e64 6564 5f72 6561 6c0a 2020 2020 0a20  nded_real.    . 
-000174d0: 2020 2064 6566 205f 6576 616c 5f69 735f     def _eval_is_
-000174e0: 6578 7465 6e64 6564 5f6e 6567 6174 6976  extended_negativ
-000174f0: 6528 7365 6c66 293a 0a20 2020 2020 2020  e(self):.       
-00017500: 2072 6574 7572 6e20 7365 6c66 2e61 7267   return self.arg
-00017510: 735b 305d 2e69 735f 6578 7465 6e64 6564  s[0].is_extended
-00017520: 5f6e 6567 6174 6976 650a 0a20 2020 2064  _negative..    d
-00017530: 6566 205f 6576 616c 5f69 735f 6578 7465  ef _eval_is_exte
-00017540: 6e64 6564 5f70 6f73 6974 6976 6528 7365  nded_positive(se
-00017550: 6c66 293a 0a20 2020 2020 2020 2072 6574  lf):.        ret
-00017560: 7572 6e20 7365 6c66 2e61 7267 735b 305d  urn self.args[0]
-00017570: 2e69 735f 6578 7465 6e64 6564 5f70 6f73  .is_extended_pos
-00017580: 6974 6976 650a 2020 2020 0a20 2020 2064  itive.    .    d
-00017590: 6566 205f 6576 616c 5f69 735f 6879 7065  ef _eval_is_hype
-000175a0: 725f 7265 616c 2873 656c 6629 3a0a 2020  r_real(self):.  
-000175b0: 2020 2020 2020 7265 7475 726e 2073 656c        return sel
-000175c0: 662e 6172 6773 5b30 5d2e 6973 5f68 7970  f.args[0].is_hyp
-000175d0: 6572 5f72 6561 6c0a 2020 2020 0a20 2020  er_real.    .   
-000175e0: 2064 6566 205f 6576 616c 5f69 735f 7375   def _eval_is_su
-000175f0: 7065 725f 7265 616c 2873 656c 6629 3a0a  per_real(self):.
-00017600: 2020 2020 2020 2020 7265 7475 726e 2073          return s
-00017610: 656c 662e 6172 6773 5b30 5d2e 6973 5f73  elf.args[0].is_s
-00017620: 7570 6572 5f72 6561 6c0a 2020 2020 0a20  uper_real.    . 
-00017630: 2020 2064 6566 205f 6576 616c 5f69 735f     def _eval_is_
-00017640: 6578 7465 6e64 6564 5f63 6f6d 706c 6578  extended_complex
-00017650: 2873 656c 6629 3a0a 2020 2020 2020 2020  (self):.        
-00017660: 7265 7475 726e 2073 656c 662e 6172 6773  return self.args
-00017670: 5b30 5d2e 6973 5f65 7874 656e 6465 645f  [0].is_extended_
-00017680: 636f 6d70 6c65 780a 0a20 2020 2064 6566  complex..    def
-00017690: 205f 6576 616c 5f69 735f 7a65 726f 2873   _eval_is_zero(s
-000176a0: 656c 6629 3a0a 2020 2020 2020 2020 7265  elf):.        re
-000176b0: 7475 726e 2073 656c 662e 6172 6773 5b30  turn self.args[0
-000176c0: 5d2e 6973 5f7a 6572 6f0a 0a20 2020 2064  ].is_zero..    d
-000176d0: 6566 205f 6576 616c 5f69 735f 6669 6e69  ef _eval_is_fini
-000176e0: 7465 7365 7428 7365 6c66 293a 0a20 2020  teset(self):.   
-000176f0: 2020 2020 2072 6574 7572 6e20 7365 6c66       return self
-00017700: 2e61 7267 735b 305d 2e69 735f 6669 6e69  .args[0].is_fini
-00017710: 7465 7365 740a 0a20 2020 2040 6361 6368  teset..    @cach
-00017720: 6569 740a 2020 2020 6465 6620 5f65 7661  eit.    def _eva
-00017730: 6c5f 646f 6d61 696e 5f64 6566 696e 6564  l_domain_defined
-00017740: 2873 656c 662c 2078 2c20 2a2a 5f29 3a0a  (self, x, **_):.
-00017750: 2020 2020 2020 2020 412c 2042 203d 2073          A, B = s
-00017760: 656c 662e 6172 6773 0a20 2020 2020 2020  elf.args.       
-00017770: 2072 6574 7572 6e20 412e 646f 6d61 696e   return A.domain
-00017780: 5f64 6566 696e 6564 2878 2920 2620 422e  _defined(x) & B.
-00017790: 646f 6d61 696e 5f64 6566 696e 6564 2878  domain_defined(x
-000177a0: 290a 0a20 2020 2064 6566 2073 7570 7265  )..    def supre
-000177b0: 6d75 6d28 7365 6c66 293a 0a20 2020 2020  mum(self):.     
-000177c0: 2020 2072 6574 7572 6e20 7365 6c66 2e61     return self.a
-000177d0: 7267 735b 305d 2e6d 6178 2829 0a0a 2020  rgs[0].max()..  
-000177e0: 2020 6465 6620 696e 6669 6d75 6d28 7365    def infimum(se
-000177f0: 6c66 293a 0a20 2020 2020 2020 2072 6574  lf):.        ret
-00017800: 7572 6e20 7365 6c66 2e61 7267 735b 305d  urn self.args[0]
-00017810: 2e6d 696e 2829 0a20 2020 200a 2020 2020  .min().    .    
-00017820: 6465 6620 5f5f 6164 645f 5f28 7365 6c66  def __add__(self
-00017830: 2c20 6f74 6865 7229 3a0a 2020 2020 2020  , other):.      
-00017840: 2020 412c 2042 203d 2073 656c 662e 6172    A, B = self.ar
-00017850: 6773 0a20 2020 2020 2020 2072 6574 7572  gs.        retur
-00017860: 6e20 7365 6c66 2e66 756e 6328 4120 2b20  n self.func(A + 
-00017870: 6f74 6865 722c 2042 202b 206f 7468 6572  other, B + other
-00017880: 290a 2020 2020 0a20 2020 2064 6566 2068  ).    .    def h
-00017890: 616e 646c 655f 6669 6e69 7465 5f73 6574  andle_finite_set
-000178a0: 7328 7365 6c66 2c20 756e 6b29 3a0a 2020  s(self, unk):.  
-000178b0: 2020 2020 2020 412c 2042 203d 2073 656c        A, B = sel
-000178c0: 662e 6172 6773 0a20 2020 2020 2020 2069  f.args.        i
-000178d0: 6e74 6572 7365 6374 696f 6e20 3d20 756e  ntersection = un
-000178e0: 6b20 2620 420a 2020 2020 2020 2020 6966  k & B.        if
-000178f0: 2069 6e74 6572 7365 6374 696f 6e20 3d3d   intersection ==
-00017900: 2075 6e6b 3a20 2365 7175 6976 616c 656e   unk: #equivalen
-00017910: 746c 792c 2075 6e6b 2069 6e20 420a 2020  tly, unk in B.  
-00017920: 2020 2020 2020 2020 2020 7265 7475 726e            return
-00017930: 2073 656c 662e 6574 7970 652e 656d 7074   self.etype.empt
-00017940: 7953 6574 0a20 2020 2020 2020 200a 2020  ySet.        .  
-00017950: 2020 2020 2020 6966 2069 6e74 6572 7365        if interse
-00017960: 6374 696f 6e2e 6973 5f45 6d70 7479 5365  ction.is_EmptySe
-00017970: 743a 0a20 2020 2020 2020 2020 2020 2072  t:.            r
-00017980: 6574 7572 6e20 4120 2620 756e 6b0a 0a20  eturn A & unk.. 
-00017990: 2020 2020 2020 2069 6620 756e 6b20 696e         if unk in
-000179a0: 2041 3a0a 2020 2020 2020 2020 2020 2020   A:.            
-000179b0: 6966 2042 2e69 735f 496e 7465 7273 6563  if B.is_Intersec
-000179c0: 7469 6f6e 3a0a 2020 2020 2020 2020 2020  tion:.          
-000179d0: 2020 2020 2020 6172 6773 203d 205b 5d0a        args = [].
-000179e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000179f0: 666f 7220 7320 696e 2042 2e61 7267 733a  for s in B.args:
-00017a00: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00017a10: 2020 2020 2069 6620 756e 6b20 696e 2073       if unk in s
-00017a20: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-00017a30: 2020 2020 2020 2020 2020 636f 6e74 696e            contin
-00017a40: 7565 0a20 2020 2020 2020 2020 2020 2020  ue.             
-00017a50: 2020 2020 2020 2061 7267 732e 6170 7065         args.appe
-00017a60: 6e64 2873 290a 2020 2020 2020 2020 2020  nd(s).          
-00017a70: 2020 2020 2020 6966 206c 656e 2861 7267        if len(arg
-00017a80: 7329 2021 3d20 6c65 6e28 422e 6172 6773  s) != len(B.args
-00017a90: 293a 0a20 2020 2020 2020 2020 2020 2020  ):.             
-00017aa0: 2020 2020 2020 2042 203d 2042 2e66 756e         B = B.fun
-00017ab0: 6328 2a61 7267 7329 0a20 2020 2020 2020  c(*args).       
-00017ac0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00017ad0: 200a 2020 2020 2020 2020 2020 2020 7265   .            re
-00017ae0: 7475 726e 2073 656c 662e 6675 6e63 2875  turn self.func(u
-00017af0: 6e6b 2c20 422c 2065 7661 6c75 6174 653d  nk, B, evaluate=
-00017b00: 4661 6c73 6529 0a20 2020 2020 2020 2069  False).        i
-00017b10: 6620 4120 696e 2075 6e6b 3a0a 2320 2020  f A in unk:.#   
-00017b20: 2020 2020 2020 2020 2020 636f 6e73 6964            consid
-00017b30: 6572 2074 6865 2063 6173 6520 3a20 5b30  er the case : [0
-00017b40: 3b20 6e29 2026 207b 6a7d 202f 205b 303b  ; n) & {j} / [0;
-00017b50: 206e 2920 2620 7b69 7d2c 207b 6a7d 0a20   n) & {i}, {j}. 
-00017b60: 2020 2020 2020 2020 2020 2072 6574 7572             retur
-00017b70: 6e20 7365 6c66 0a0a 2020 2020 4063 6c61  n self..    @cla
-00017b80: 7373 6d65 7468 6f64 0a20 2020 2064 6566  ssmethod.    def
-00017b90: 2073 696d 706c 6966 795f 556e 6571 7561   simplify_Unequa
-00017ba0: 6c28 636c 732c 2073 656c 662c 206c 6873  l(cls, self, lhs
-00017bb0: 2c20 7268 7329 3a0a 2020 2020 2020 2020  , rhs):.        
-00017bc0: 2222 220a 2020 2020 2020 2020 7072 6563  """.        prec
-00017bd0: 6f6e 6469 7469 6f6e 3a20 7365 6c66 2e6c  ondition: self.l
-00017be0: 6873 2069 7320 6120 436f 6d70 6c65 6d65  hs is a Compleme
-00017bf0: 6e74 206f 626a 6563 7421 0a20 2020 2020  nt object!.     
-00017c00: 2020 2022 2222 0a20 2020 2020 2020 2069     """.        i
-00017c10: 6620 7268 732e 6973 5f45 6d70 7479 5365  f rhs.is_EmptySe
-00017c20: 743a 0a20 2020 2020 2020 2020 2020 2041  t:.            A
-00017c30: 2c20 4220 3d20 6c68 732e 6172 6773 0a20  , B = lhs.args. 
-00017c40: 2020 2020 2020 2020 2020 2066 726f 6d20             from 
-00017c50: 7379 6d70 7920 696d 706f 7274 204e 6f74  sympy import Not
-00017c60: 5375 6273 6574 0a20 2020 2020 2020 2020  Subset.         
-00017c70: 2020 2072 6574 7572 6e20 4e6f 7453 7562     return NotSub
-00017c80: 7365 7428 412c 2042 292e 7369 6d70 6c69  set(A, B).simpli
-00017c90: 6679 2829 0a0a 2020 2020 4063 6c61 7373  fy()..    @class
-00017ca0: 6d65 7468 6f64 0a20 2020 2064 6566 2073  method.    def s
-00017cb0: 696d 706c 6966 795f 456c 656d 656e 7428  implify_Element(
-00017cc0: 636c 732c 2073 656c 662c 2065 2c20 7329  cls, self, e, s)
-00017cd0: 3a0a 2020 2020 2020 2020 2222 220a 2020  :.        """.  
-00017ce0: 2020 2020 2020 7072 6563 6f6e 6469 7469        preconditi
-00017cf0: 6f6e 3a20 7365 6c66 2e72 6873 2069 7320  on: self.rhs is 
-00017d00: 6120 436f 6d70 6c65 6d65 6e74 206f 626a  a Complement obj
-00017d10: 6563 7421 0a20 2020 2020 2020 2022 2222  ect!.        """
-00017d20: 0a20 2020 2020 2020 2055 2c20 4220 3d20  .        U, B = 
-00017d30: 732e 6172 6773 0a20 2020 2020 2020 2069  s.args.        i
-00017d40: 6620 552e 6973 5f55 6e69 7665 7273 616c  f U.is_Universal
-00017d50: 5365 743a 0a20 2020 2020 2020 2020 2020  Set:.           
-00017d60: 2072 6574 7572 6e20 7365 6c66 2e69 6e76   return self.inv
-00017d70: 6572 745f 7479 7065 2865 2c20 4229 2e73  ert_type(e, B).s
-00017d80: 696d 706c 6966 7928 2920 0a20 2020 2020  implify() .     
-00017d90: 2020 2065 6c69 6620 422e 6973 5f46 696e     elif B.is_Fin
-00017da0: 6974 6553 6574 2061 6e64 206c 656e 2842  iteSet and len(B
-00017db0: 2920 3d3d 2031 3a0a 2020 2020 2020 2020  ) == 1:.        
-00017dc0: 2020 2020 646f 6d61 696e 5f61 7373 756d      domain_assum
-00017dd0: 6564 203d 2065 2e64 6f6d 6169 6e5f 6173  ed = e.domain_as
-00017de0: 7375 6d65 640a 2020 2020 2020 2020 2020  sumed.          
-00017df0: 2020 6966 2064 6f6d 6169 6e5f 6173 7375    if domain_assu
-00017e00: 6d65 6420 616e 6420 646f 6d61 696e 5f61  med and domain_a
-00017e10: 7373 756d 6564 203d 3d20 553a 0a20 2020  ssumed == U:.   
-00017e20: 2020 2020 2020 2020 2020 2020 205f 652c               _e,
-00017e30: 202a 5f20 3d20 422e 6172 6773 0a20 2020   *_ = B.args.   
-00017e40: 2020 2020 2020 2020 2020 2020 2066 726f               fro
-00017e50: 6d20 7379 6d70 7920 696d 706f 7274 2055  m sympy import U
-00017e60: 6e65 7175 616c 0a20 2020 2020 2020 2020  nequal.         
-00017e70: 2020 2020 2020 2072 6574 7572 6e20 556e         return Un
-00017e80: 6571 7561 6c28 652c 205f 6529 0a20 2020  equal(e, _e).   
-00017e90: 2020 2020 2065 6c69 6620 6520 696e 2055       elif e in U
-00017ea0: 3a0a 2020 2020 2020 2020 2020 2020 6672  :.            fr
-00017eb0: 6f6d 2073 796d 7079 2069 6d70 6f72 7420  om sympy import 
-00017ec0: 4e6f 7445 6c65 6d65 6e74 0a20 2020 2020  NotElement.     
-00017ed0: 2020 2020 2020 2072 6574 7572 6e20 4e6f         return No
-00017ee0: 7445 6c65 6d65 6e74 2865 2c20 4229 0a0a  tElement(e, B)..
-00017ef0: 2020 2020 4063 6c61 7373 6d65 7468 6f64      @classmethod
-00017f00: 0a20 2020 2064 6566 2073 696d 706c 6966  .    def simplif
-00017f10: 795f 4e6f 7445 6c65 6d65 6e74 2863 6c73  y_NotElement(cls
-00017f20: 2c20 7365 6c66 2c20 652c 2073 293a 0a20  , self, e, s):. 
-00017f30: 2020 2020 2020 2022 2222 0a20 2020 2020         """.     
-00017f40: 2020 2070 7265 636f 6e64 6974 696f 6e3a     precondition:
-00017f50: 2073 656c 662e 7268 7320 6973 2061 2043   self.rhs is a C
-00017f60: 6f6d 706c 656d 656e 7420 6f62 6a65 6374  omplement object
-00017f70: 210a 2020 2020 2020 2020 2222 220a 2020  !.        """.  
-00017f80: 2020 2020 2020 552c 2042 203d 2073 2e61        U, B = s.a
-00017f90: 7267 730a 2020 2020 2020 2020 6966 2055  rgs.        if U
-00017fa0: 2e69 735f 556e 6976 6572 7361 6c53 6574  .is_UniversalSet
-00017fb0: 3a0a 2020 2020 2020 2020 2020 2020 7265  :.            re
-00017fc0: 7475 726e 2073 656c 662e 696e 7665 7274  turn self.invert
-00017fd0: 5f74 7970 6528 652c 2042 292e 7369 6d70  _type(e, B).simp
-00017fe0: 6c69 6679 2829 0a20 2020 2020 2020 2065  lify().        e
-00017ff0: 6c69 6620 422e 6973 5f46 696e 6974 6553  lif B.is_FiniteS
-00018000: 6574 2061 6e64 206c 656e 2842 2920 3d3d  et and len(B) ==
-00018010: 2031 3a0a 2020 2020 2020 2020 2020 2020   1:.            
-00018020: 646f 6d61 696e 5f61 7373 756d 6564 203d  domain_assumed =
-00018030: 2065 2e64 6f6d 6169 6e5f 6173 7375 6d65   e.domain_assume
-00018040: 640a 2020 2020 2020 2020 2020 2020 6966  d.            if
-00018050: 2064 6f6d 6169 6e5f 6173 7375 6d65 6420   domain_assumed 
-00018060: 616e 6420 646f 6d61 696e 5f61 7373 756d  and domain_assum
-00018070: 6564 203d 3d20 553a 0a20 2020 2020 2020  ed == U:.       
-00018080: 2020 2020 2020 2020 205f 652c 202a 5f20           _e, *_ 
-00018090: 3d20 422e 6172 6773 0a20 2020 2020 2020  = B.args.       
-000180a0: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
-000180b0: 4571 7561 6c28 652c 205f 6529 0a20 2020  Equal(e, _e).   
-000180c0: 2020 2020 2065 6c69 6620 6520 696e 2055       elif e in U
-000180d0: 3a0a 2020 2020 2020 2020 2020 2020 6672  :.            fr
-000180e0: 6f6d 2073 796d 7079 2069 6d70 6f72 7420  om sympy import 
-000180f0: 456c 656d 656e 740a 2020 2020 2020 2020  Element.        
-00018100: 2020 2020 7265 7475 726e 2045 6c65 6d65      return Eleme
-00018110: 6e74 2865 2c20 4229 0a20 2020 2020 2020  nt(e, B).       
-00018120: 200a 2020 2020 6465 6620 5f65 7661 6c5f   .    def _eval_
-00018130: 5375 6273 6574 2873 656c 662c 2072 6873  Subset(self, rhs
-00018140: 293a 0a20 2020 2020 2020 2041 2c20 7320  ):.        A, s 
-00018150: 3d20 7365 6c66 2e61 7267 730a 2020 2020  = self.args.    
-00018160: 2020 2020 6966 2072 6873 2e69 735f 436f      if rhs.is_Co
-00018170: 6d70 6c65 6d65 6e74 3a20 0a20 2020 2020  mplement: .     
-00018180: 2020 2020 2020 2042 2c20 5f73 203d 2072         B, _s = r
-00018190: 6873 2e61 7267 730a 2020 2020 2020 2020  hs.args.        
-000181a0: 2020 2020 6966 2073 203d 3d20 5f73 3a0a      if s == _s:.
-000181b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000181c0: 6672 6f6d 2073 796d 7079 2069 6d70 6f72  from sympy impor
-000181d0: 7420 5375 6273 6574 0a20 2020 2020 2020  t Subset.       
-000181e0: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
-000181f0: 5375 6273 6574 2e65 7661 6c28 412c 2042  Subset.eval(A, B
-00018200: 290a 2020 2020 2020 2020 656c 6966 2072  ).        elif r
-00018210: 6873 203d 3d20 413a 0a20 2020 2020 2020  hs == A:.       
-00018220: 2020 2020 2072 6574 7572 6e20 532e 426f       return S.Bo
-00018230: 6f6c 6561 6e54 7275 650a 2020 2020 2020  oleanTrue.      
-00018240: 2020 2020 2020 0a20 2020 2040 636c 6173        .    @clas
-00018250: 736d 6574 686f 640a 2020 2020 6465 6620  smethod.    def 
-00018260: 636c 6173 735f 6b65 7928 636c 7329 3a0a  class_key(cls):.
-00018270: 2020 2020 2020 2020 2222 224e 6963 6520          """Nice 
-00018280: 6f72 6465 7220 6f66 2063 6c61 7373 6573  order of classes
-00018290: 2e20 2222 220a 2020 2020 2020 2020 7265  . """.        re
-000182a0: 7475 726e 2035 2c20 392c 2063 6c73 2e5f  turn 5, 9, cls._
-000182b0: 5f6e 616d 655f 5f0a 0a0a 636c 6173 7320  _name__...class 
-000182c0: 456d 7074 7953 6574 2853 6574 293a 0a20  EmptySet(Set):. 
-000182d0: 2020 2022 2222 0a20 2020 2052 6570 7265     """.    Repre
-000182e0: 7365 6e74 7320 7468 6520 656d 7074 7920  sents the empty 
-000182f0: 7365 742e 2054 6865 2065 6d70 7479 2073  set. The empty s
-00018300: 6574 2069 7320 6176 6169 6c61 626c 6520  et is available 
-00018310: 6173 2061 2073 696e 676c 6574 6f6e 0a20  as a singleton. 
-00018320: 2020 2061 7320 456d 7074 7953 6574 2829     as EmptySet()
-00018330: 2e0a 0a20 2020 2045 7861 6d70 6c65 730a  ...    Examples.
-00018340: 2020 2020 3d3d 3d3d 3d3d 3d3d 0a0a 2020      ========..  
-00018350: 2020 3e3e 3e20 6672 6f6d 2073 796d 7079    >>> from sympy
-00018360: 2069 6d70 6f72 7420 532c 2049 6e74 6572   import S, Inter
-00018370: 7661 6c0a 2020 2020 3e3e 3e20 456d 7074  val.    >>> Empt
-00018380: 7953 6574 2829 0a20 2020 2045 6d70 7479  ySet().    Empty
-00018390: 5365 7428 290a 0a20 2020 203e 3e3e 2049  Set()..    >>> I
-000183a0: 6e74 6572 7661 6c28 312c 2032 292e 696e  nterval(1, 2).in
-000183b0: 7465 7273 6563 7428 456d 7074 7953 6574  tersect(EmptySet
-000183c0: 2829 290a 2020 2020 456d 7074 7953 6574  ()).    EmptySet
-000183d0: 2829 0a0a 2020 2020 5365 6520 416c 736f  ()..    See Also
-000183e0: 0a20 2020 203d 3d3d 3d3d 3d3d 3d0a 0a20  .    ========.. 
-000183f0: 2020 2055 6e69 7665 7273 616c 5365 740a     UniversalSet.
-00018400: 0a20 2020 2052 6566 6572 656e 6365 730a  .    References.
-00018410: 2020 2020 3d3d 3d3d 3d3d 3d3d 3d3d 0a0a      ==========..
-00018420: 2020 2020 2e2e 205b 315d 2068 7474 7073      .. [1] https
-00018430: 3a2f 2f65 6e2e 7769 6b69 7065 6469 612e  ://en.wikipedia.
-00018440: 6f72 672f 7769 6b69 2f45 6d70 7479 5f73  org/wiki/Empty_s
-00018450: 6574 0a20 2020 2022 2222 0a20 2020 2069  et.    """.    i
-00018460: 735f 4669 6e69 7465 5365 7420 3d20 5472  s_FiniteSet = Tr
-00018470: 7565 0a0a 2020 2020 6465 6620 5f65 7661  ue..    def _eva
-00018480: 6c5f 6973 5f65 7874 656e 6465 645f 696e  l_is_extended_in
-00018490: 7465 6765 7228 7365 6c66 293a 0a20 2020  teger(self):.   
-000184a0: 2020 2020 2072 6574 7572 6e20 7365 6c66       return self
-000184b0: 2e65 7479 7065 2e69 735f 6578 7465 6e64  .etype.is_extend
-000184c0: 6564 5f69 6e74 6567 6572 0a0a 2020 2020  ed_integer..    
-000184d0: 6465 6620 5f65 7661 6c5f 6973 5f73 7570  def _eval_is_sup
-000184e0: 6572 5f69 6e74 6567 6572 2873 656c 6629  er_integer(self)
-000184f0: 3a0a 2020 2020 2020 2020 7265 7475 726e  :.        return
-00018500: 2073 656c 662e 6574 7970 652e 6973 5f73   self.etype.is_s
-00018510: 7570 6572 5f69 6e74 6567 6572 0a20 2020  uper_integer.   
-00018520: 200a 2020 2020 6465 6620 5f65 7661 6c5f   .    def _eval_
-00018530: 6973 5f65 7874 656e 6465 645f 7261 7469  is_extended_rati
-00018540: 6f6e 616c 2873 656c 6629 3a0a 2020 2020  onal(self):.    
-00018550: 2020 2020 7265 7475 726e 2073 656c 662e      return self.
-00018560: 6574 7970 652e 6973 5f65 7874 656e 6465  etype.is_extende
-00018570: 645f 7261 7469 6f6e 616c 0a20 2020 200a  d_rational.    .
-00018580: 2020 2020 6465 6620 5f65 7661 6c5f 6973      def _eval_is
-00018590: 5f68 7970 6572 5f72 6174 696f 6e61 6c28  _hyper_rational(
-000185a0: 7365 6c66 293a 0a20 2020 2020 2020 2072  self):.        r
-000185b0: 6574 7572 6e20 7365 6c66 2e65 7479 7065  eturn self.etype
-000185c0: 2e69 735f 6879 7065 725f 7261 7469 6f6e  .is_hyper_ration
-000185d0: 616c 0a20 2020 200a 2020 2020 6465 6620  al.    .    def 
-000185e0: 5f65 7661 6c5f 6973 5f73 7570 6572 5f72  _eval_is_super_r
-000185f0: 6174 696f 6e61 6c28 7365 6c66 293a 0a20  ational(self):. 
-00018600: 2020 2020 2020 2072 6574 7572 6e20 7365         return se
-00018610: 6c66 2e65 7479 7065 2e69 735f 7375 7065  lf.etype.is_supe
-00018620: 725f 7261 7469 6f6e 616c 0a20 2020 200a  r_rational.    .
-00018630: 2020 2020 6465 6620 5f65 7661 6c5f 6973      def _eval_is
-00018640: 5f65 7874 656e 6465 645f 7265 616c 2873  _extended_real(s
-00018650: 656c 6629 3a0a 2020 2020 2020 2020 7265  elf):.        re
-00018660: 7475 726e 2073 656c 662e 6574 7970 652e  turn self.etype.
-00018670: 6973 5f65 7874 656e 6465 645f 7265 616c  is_extended_real
-00018680: 0a20 2020 200a 2020 2020 6465 6620 5f65  .    .    def _e
-00018690: 7661 6c5f 6973 5f68 7970 6572 5f72 6561  val_is_hyper_rea
-000186a0: 6c28 7365 6c66 293a 0a20 2020 2020 2020  l(self):.       
-000186b0: 2072 6574 7572 6e20 7365 6c66 2e65 7479   return self.ety
-000186c0: 7065 2e69 735f 6879 7065 725f 7265 616c  pe.is_hyper_real
-000186d0: 0a20 2020 200a 2020 2020 6465 6620 5f65  .    .    def _e
-000186e0: 7661 6c5f 6973 5f73 7570 6572 5f72 6561  val_is_super_rea
-000186f0: 6c28 7365 6c66 293a 0a20 2020 2020 2020  l(self):.       
-00018700: 2072 6574 7572 6e20 7365 6c66 2e65 7479   return self.ety
-00018710: 7065 2e69 735f 7375 7065 725f 7265 616c  pe.is_super_real
-00018720: 0a20 2020 200a 2020 2020 6465 6620 5f65  .    .    def _e
-00018730: 7661 6c5f 6973 5f65 7874 656e 6465 645f  val_is_extended_
-00018740: 636f 6d70 6c65 7828 7365 6c66 293a 0a20  complex(self):. 
-00018750: 2020 2020 2020 2072 6574 7572 6e20 7365         return se
-00018760: 6c66 2e65 7479 7065 2e69 735f 6578 7465  lf.etype.is_exte
-00018770: 6e64 6564 5f63 6f6d 706c 6578 0a20 2020  nded_complex.   
-00018780: 200a 2020 2020 6465 6620 5f65 7661 6c5f   .    def _eval_
-00018790: 6973 5f68 7970 6572 5f63 6f6d 706c 6578  is_hyper_complex
-000187a0: 2873 656c 6629 3a0a 2020 2020 2020 2020  (self):.        
-000187b0: 7265 7475 726e 2073 656c 662e 6574 7970  return self.etyp
-000187c0: 652e 6973 5f68 7970 6572 5f63 6f6d 706c  e.is_hyper_compl
-000187d0: 6578 0a20 2020 200a 2020 2020 6465 6620  ex.    .    def 
-000187e0: 5f65 7661 6c5f 6973 5f66 696e 6974 6573  _eval_is_finites
-000187f0: 6574 2873 656c 6629 3a0a 2020 2020 2020  et(self):.      
-00018800: 2020 7265 7475 726e 2054 7275 650a 2020    return True.  
-00018810: 2020 0a20 2020 2040 7072 6f70 6572 7479    .    @property
-00018820: 0a20 2020 2064 6566 2065 7479 7065 2873  .    def etype(s
-00018830: 656c 6629 3a0a 2020 2020 2020 2020 7265  elf):.        re
-00018840: 7475 726e 2073 656c 662e 5f61 7373 756d  turn self._assum
-00018850: 7074 696f 6e73 5b27 6574 7970 6527 5d0a  ptions['etype'].
-00018860: 0a20 2020 2064 6566 205f 6576 616c 5f43  .    def _eval_C
-00018870: 6172 6428 7365 6c66 293a 0a20 2020 2020  ard(self):.     
-00018880: 2020 2072 6574 7572 6e20 532e 5a65 726f     return S.Zero
-00018890: 0a0a 2020 2020 6465 6620 696e 7465 7273  ..    def inters
-000188a0: 6563 7469 6f6e 5f73 6574 7328 7365 6c66  ection_sets(self
-000188b0: 2c20 6229 3a0a 2020 2020 2020 2020 7265  , b):.        re
-000188c0: 7475 726e 2073 656c 660a 0a20 2020 2064  turn self..    d
-000188d0: 6566 2075 6e69 6f6e 5f73 6574 7328 7365  ef union_sets(se
-000188e0: 6c66 2c20 6229 3a0a 2020 2020 2020 2020  lf, b):.        
-000188f0: 7265 7475 726e 2062 0a0a 2020 2020 4070  return b..    @p
-00018900: 726f 7065 7274 790a 2020 2020 6465 6620  roperty.    def 
-00018910: 5f6d 6561 7375 7265 2873 656c 6629 3a0a  _measure(self):.
-00018920: 2020 2020 2020 2020 7265 7475 726e 2030          return 0
-00018930: 0a0a 2020 2020 6465 6620 5f63 6f6e 7461  ..    def _conta
-00018940: 696e 7328 7365 6c66 2c20 6f74 6865 7229  ins(self, other)
-00018950: 3a0a 2020 2020 2020 2020 7265 7475 726e  :.        return
-00018960: 2053 2e66 616c 7365 0a0a 2020 2020 6465   S.false..    de
-00018970: 6620 6173 5f72 656c 6174 696f 6e61 6c28  f as_relational(
-00018980: 7365 6c66 2c20 7379 6d62 6f6c 293a 0a20  self, symbol):. 
-00018990: 2020 2020 2020 2072 6574 7572 6e20 532e         return S.
-000189a0: 6661 6c73 650a 0a20 2020 2064 6566 205f  false..    def _
-000189b0: 5f6c 656e 5f5f 2873 656c 6629 3a0a 2020  _len__(self):.  
-000189c0: 2020 2020 2020 7265 7475 726e 2030 0a0a        return 0..
-000189d0: 2020 2020 6465 6620 5f5f 6974 6572 5f5f      def __iter__
-000189e0: 2873 656c 6629 3a0a 2020 2020 2020 2020  (self):.        
-000189f0: 7265 7475 726e 2069 7465 7228 5b5d 290a  return iter([]).
-00018a00: 0a20 2020 2064 6566 205f 6576 616c 5f70  .    def _eval_p
-00018a10: 6f77 6572 7365 7428 7365 6c66 293a 0a20  owerset(self):. 
-00018a20: 2020 2020 2020 2066 726f 6d20 7379 6d70         from symp
-00018a30: 7920 696d 706f 7274 2046 696e 6974 6553  y import FiniteS
-00018a40: 6574 0a20 2020 2020 2020 2072 6574 7572  et.        retur
-00018a50: 6e20 4669 6e69 7465 5365 7428 7365 6c66  n FiniteSet(self
-00018a60: 290a 0a20 2020 2040 7072 6f70 6572 7479  )..    @property
-00018a70: 0a20 2020 2064 6566 205f 626f 756e 6461  .    def _bounda
-00018a80: 7279 2873 656c 6629 3a0a 2020 2020 2020  ry(self):.      
-00018a90: 2020 7265 7475 726e 2073 656c 660a 0a20    return self.. 
-00018aa0: 2020 2064 6566 205f 636f 6d70 6c65 6d65     def _compleme
-00018ab0: 6e74 2873 656c 662c 206f 7468 6572 293a  nt(self, other):
-00018ac0: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
-00018ad0: 6f74 6865 720a 0a20 2020 2064 6566 205f  other..    def _
-00018ae0: 7379 6d6d 6574 7269 635f 6469 6666 6572  symmetric_differ
-00018af0: 656e 6365 2873 656c 662c 206f 7468 6572  ence(self, other
-00018b00: 293a 0a20 2020 2020 2020 2072 6574 7572  ):.        retur
-00018b10: 6e20 6f74 6865 720a 0a20 2020 2064 6566  n other..    def
-00018b20: 205f 7379 6d70 7973 7472 2873 656c 662c   _sympystr(self,
-00018b30: 205f 293a 0a20 2020 2020 2020 2072 6574   _):.        ret
-00018b40: 7572 6e20 275c 4e7b 4c41 5449 4e20 4341  urn '\N{LATIN CA
-00018b50: 5049 5441 4c20 4c45 5454 4552 204f 2057  PITAL LETTER O W
-00018b60: 4954 4820 5354 524f 4b45 7d27 0a0a 2020  ITH STROKE}'..  
-00018b70: 2020 6465 6620 5f6c 6174 6578 2873 656c    def _latex(sel
-00018b80: 662c 2070 293a 0a20 2020 2020 2020 2072  f, p):.        r
-00018b90: 6574 7572 6e20 7222 5c65 6d70 7479 7365  eturn r"\emptyse
-00018ba0: 7422 0a0a 2020 2020 6465 6620 5f5f 6164  t"..    def __ad
-00018bb0: 645f 5f28 7365 6c66 2c20 6f74 6865 7229  d__(self, other)
-00018bc0: 3a0a 2020 2020 2020 2020 7265 7475 726e  :.        return
-00018bd0: 2073 656c 660a 0a20 2020 2064 6566 205f   self..    def _
-00018be0: 5f73 7562 5f5f 2873 656c 662c 206f 7468  _sub__(self, oth
-00018bf0: 6572 293a 0a20 2020 2020 2020 2072 6574  er):.        ret
-00018c00: 7572 6e20 7365 6c66 0a0a 2020 2020 4063  urn self..    @c
-00018c10: 6c61 7373 6d65 7468 6f64 0a20 2020 2064  lassmethod.    d
-00018c20: 6566 2073 696d 706c 6966 795f 4571 7561  ef simplify_Equa
-00018c30: 6c28 636c 732c 2073 656c 662c 206c 6873  l(cls, self, lhs
-00018c40: 2c20 7268 7329 3a0a 2020 2020 2020 2020  , rhs):.        
-00018c50: 2222 220a 2020 2020 2020 2020 7072 6563  """.        prec
-00018c60: 6f6e 6469 7469 6f6e 3a20 7365 6c66 2e6c  ondition: self.l
-00018c70: 6873 2069 7320 6120 456d 7074 7953 6574  hs is a EmptySet
-00018c80: 206f 626a 6563 7421 0a20 2020 2020 2020   object!.       
-00018c90: 2022 2222 0a20 2020 2020 2020 2069 6620   """.        if 
-00018ca0: 7268 732e 6973 5f49 6e74 6572 7365 6374  rhs.is_Intersect
-00018cb0: 696f 6e3a 0a20 2020 2020 2020 2020 2020  ion:.           
-00018cc0: 2074 6869 7320 3d20 7365 6c66 2e73 696d   this = self.sim
-00018cd0: 706c 6966 795f 496e 7465 7273 6563 7469  plify_Intersecti
-00018ce0: 6f6e 2872 6873 290a 2020 2020 2020 2020  on(rhs).        
-00018cf0: 2020 2020 6966 2074 6869 7320 6973 206e      if this is n
-00018d00: 6f74 204e 6f6e 653a 0a20 2020 2020 2020  ot None:.       
-00018d10: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
-00018d20: 7468 6973 0a0a 2020 2020 6465 6620 5f65  this..    def _e
-00018d30: 7661 6c5f 5375 6273 6574 2873 656c 662c  val_Subset(self,
-00018d40: 2072 6873 293a 0a20 2020 2020 2020 2072   rhs):.        r
-00018d50: 6574 7572 6e20 532e 7472 7565 0a0a 2020  eturn S.true..  
-00018d60: 2020 6465 6620 5f65 7661 6c5f 4571 2873    def _eval_Eq(s
-00018d70: 656c 662c 2072 6873 293a 0a20 2020 2020  elf, rhs):.     
-00018d80: 2020 2069 6620 7268 732e 6973 5f65 6d70     if rhs.is_emp
-00018d90: 7479 2069 7320 4661 6c73 653a 0a20 2020  ty is False:.   
-00018da0: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
-00018db0: 532e 6661 6c73 650a 2020 2020 2020 2020  S.false.        
-00018dc0: 0a20 2020 2020 2020 2069 6620 7268 732e  .        if rhs.
-00018dd0: 6973 5f65 6d70 7479 2069 7320 5472 7565  is_empty is True
-00018de0: 3a0a 2020 2020 2020 2020 2020 2020 7265  :.            re
-00018df0: 7475 726e 2053 2e74 7275 650a 0a20 2020  turn S.true..   
-00018e00: 2020 2020 200a 636c 6173 7320 556e 6976       .class Univ
-00018e10: 6572 7361 6c53 6574 2853 6574 293a 0a20  ersalSet(Set):. 
-00018e20: 2020 2022 2222 0a20 2020 2052 6570 7265     """.    Repre
-00018e30: 7365 6e74 7320 7468 6520 7365 7420 6f66  sents the set of
-00018e40: 2061 6c6c 2074 6869 6e67 732e 0a20 2020   all things..   
-00018e50: 2054 6865 2075 6e69 7665 7273 616c 2073   The universal s
-00018e60: 6574 2069 7320 6176 6169 6c61 626c 6520  et is available 
-00018e70: 6173 2061 2073 696e 676c 6574 6f6e 2061  as a singleton a
-00018e80: 7320 556e 6976 6572 7361 6c53 6574 2829  s UniversalSet()
-00018e90: 0a0a 2020 2020 4578 616d 706c 6573 0a20  ..    Examples. 
-00018ea0: 2020 203d 3d3d 3d3d 3d3d 3d0a 0a20 2020     ========..   
-00018eb0: 203e 3e3e 2066 726f 6d20 7379 6d70 7920   >>> from sympy 
-00018ec0: 696d 706f 7274 2053 2c20 496e 7465 7276  import S, Interv
-00018ed0: 616c 0a20 2020 203e 3e3e 2055 6e69 7665  al.    >>> Unive
-00018ee0: 7273 616c 5365 7428 290a 2020 2020 556e  rsalSet().    Un
-00018ef0: 6976 6572 7361 6c53 6574 0a0a 2020 2020  iversalSet..    
-00018f00: 3e3e 3e20 496e 7465 7276 616c 2831 2c20  >>> Interval(1, 
-00018f10: 3229 2e69 6e74 6572 7365 6374 2855 6e69  2).intersect(Uni
-00018f20: 7665 7273 616c 5365 7428 2929 0a20 2020  versalSet()).   
-00018f30: 2049 6e74 6572 7661 6c28 312c 2032 290a   Interval(1, 2).
-00018f40: 0a20 2020 2053 6565 2041 6c73 6f0a 2020  .    See Also.  
-00018f50: 2020 3d3d 3d3d 3d3d 3d3d 0a0a 2020 2020    ========..    
-00018f60: 456d 7074 7953 6574 0a0a 2020 2020 5265  EmptySet..    Re
-00018f70: 6665 7265 6e63 6573 0a20 2020 203d 3d3d  ferences.    ===
-00018f80: 3d3d 3d3d 3d3d 3d0a 0a20 2020 202e 2e20  =======..    .. 
-00018f90: 5b31 5d20 6874 7470 733a 2f2f 656e 2e77  [1] https://en.w
-00018fa0: 696b 6970 6564 6961 2e6f 7267 2f77 696b  ikipedia.org/wik
-00018fb0: 692f 556e 6976 6572 7361 6c5f 7365 740a  i/Universal_set.
-00018fc0: 2020 2020 2222 220a 0a20 2020 2023 2069      """..    # i
-00018fd0: 6e20 6b77 6172 6773 2c20 6574 7970 6520  n kwargs, etype 
-00018fe0: 6d75 7374 2062 6520 7370 6563 6966 6965  must be specifie
-00018ff0: 6420 696e 206f 7264 6572 2074 6f20 6465  d in order to de
-00019000: 7465 726d 696e 6520 7468 6520 756e 6976  termine the univ
-00019010: 6572 7361 6c53 6574 2773 2074 7970 652c  ersalSet's type,
-00019020: 2073 6f20 6974 2069 7320 7769 7468 2045   so it is with E
-00019030: 6d70 7479 5365 7421 0a20 2020 2023 2074  mptySet!.    # t
-00019040: 6f20 696e 7374 616e 7469 6174 6520 6120  o instantiate a 
-00019050: 556e 6976 6572 7361 6c53 6574 2c20 7573  UniversalSet, us
-00019060: 6520 556e 6976 6572 7361 6c53 6574 2865  e UniversalSet(e
-00019070: 7479 7065 3d64 7479 7065 2e69 6e74 6567  type=dtype.integ
-00019080: 6572 2e73 6574 290a 2020 2020 6465 6620  er.set).    def 
-00019090: 5f5f 6e65 775f 5f28 636c 732c 202a 2a6b  __new__(cls, **k
-000190a0: 7761 7267 7329 3a0a 2020 2020 2020 2020  wargs):.        
-000190b0: 6574 7970 6520 3d20 6b77 6172 6773 2e67  etype = kwargs.g
-000190c0: 6574 2827 6574 7970 6527 290a 2020 2020  et('etype').    
-000190d0: 2020 2020 6966 2065 7479 7065 2069 7320      if etype is 
-000190e0: 6e6f 7420 4e6f 6e65 3a0a 2020 2020 2020  not None:.      
-000190f0: 2020 2020 2020 7265 7475 726e 2065 7479        return ety
-00019100: 7065 2e75 6e69 7665 7273 616c 5365 740a  pe.universalSet.
-00019110: 2020 2020 2020 2020 7265 7475 726e 2053          return S
-00019120: 6574 2e5f 5f6e 6577 5f5f 2863 6c73 2c20  et.__new__(cls, 
-00019130: 2a2a 6b77 6172 6773 290a 2020 2020 2020  **kwargs).      
-00019140: 2020 0a20 2020 2064 6566 2069 6e74 6572    .    def inter
-00019150: 7365 6374 696f 6e5f 7365 7473 2873 656c  section_sets(sel
-00019160: 662c 2062 293a 0a20 2020 2020 2020 2072  f, b):.        r
-00019170: 6574 7572 6e20 620a 0a20 2020 2064 6566  eturn b..    def
-00019180: 2075 6e69 6f6e 5f73 6574 7328 7365 6c66   union_sets(self
-00019190: 2c20 6229 3a0a 2020 2020 2020 2020 7265  , b):.        re
-000191a0: 7475 726e 2073 656c 660a 0a20 2020 2064  turn self..    d
-000191b0: 6566 205f 636f 6d70 6c65 6d65 6e74 2873  ef _complement(s
-000191c0: 656c 662c 206f 7468 6572 293a 0a20 2020  elf, other):.   
-000191d0: 2020 2020 2072 6574 7572 6e20 6f74 6865       return othe
-000191e0: 722e 6574 7970 652e 656d 7074 7953 6574  r.etype.emptySet
-000191f0: 0a0a 2020 2020 6465 6620 5f73 796d 6d65  ..    def _symme
-00019200: 7472 6963 5f64 6966 6665 7265 6e63 6528  tric_difference(
-00019210: 7365 6c66 2c20 6f74 6865 7229 3a0a 2020  self, other):.  
-00019220: 2020 2020 2020 7265 7475 726e 206f 7468        return oth
-00019230: 6572 0a0a 2020 2020 4070 726f 7065 7274  er..    @propert
-00019240: 790a 2020 2020 6465 6620 5f6d 6561 7375  y.    def _measu
-00019250: 7265 2873 656c 6629 3a0a 2020 2020 2020  re(self):.      
-00019260: 2020 7265 7475 726e 2053 2e49 6e66 696e    return S.Infin
-00019270: 6974 790a 0a20 2020 2064 6566 205f 636f  ity..    def _co
-00019280: 6e74 6169 6e73 2873 656c 662c 206f 7468  ntains(self, oth
-00019290: 6572 293a 0a20 2020 2020 2020 2072 6574  er):.        ret
-000192a0: 7572 6e20 532e 7472 7565 0a0a 2020 2020  urn S.true..    
-000192b0: 6465 6620 6173 5f72 656c 6174 696f 6e61  def as_relationa
-000192c0: 6c28 7365 6c66 2c20 7379 6d62 6f6c 293a  l(self, symbol):
-000192d0: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
-000192e0: 532e 7472 7565 0a0a 2020 2020 4070 726f  S.true..    @pro
-000192f0: 7065 7274 790a 2020 2020 6465 6620 5f62  perty.    def _b
-00019300: 6f75 6e64 6172 7928 7365 6c66 293a 0a20  oundary(self):. 
-00019310: 2020 2020 2020 2072 6574 7572 6e20 7365         return se
-00019320: 6c66 2e65 7479 7065 2e65 6d70 7479 5365  lf.etype.emptySe
-00019330: 740a 2020 2020 0a20 2020 2064 6566 205f  t.    .    def _
-00019340: 6576 616c 5f43 6172 6428 7365 6c66 293a  eval_Card(self):
-00019350: 0a20 2020 2020 2020 2023 2041 6c65 7068  .        # Aleph
-00019360: 275c 4e7b 4845 4252 4557 204c 4554 5445  '\N{HEBREW LETTE
-00019370: 5220 414c 4546 7d27 0a20 2020 2020 2020  R ALEF}'.       
-00019380: 2066 726f 6d20 7379 6d70 792e 636f 7265   from sympy.core
-00019390: 2e6e 756d 6265 7273 2069 6d70 6f72 7420  .numbers import 
-000193a0: 416c 6570 680a 2020 2020 2020 2020 6966  Aleph.        if
-000193b0: 2073 656c 662e 6574 7970 652e 6973 5f73   self.etype.is_s
-000193c0: 6574 3a0a 2020 2020 2020 2020 2020 2020  et:.            
-000193d0: 7072 696e 7428 2775 6e6b 6e6f 776e 2061  print('unknown a
-000193e0: 6c65 7068 206e 756d 6265 723f 3f27 290a  leph number??').
-000193f0: 2020 2020 2020 2020 2020 2020 7265 7475              retu
-00019400: 726e 2053 2e49 6e66 696e 6974 790a 2020  rn S.Infinity.  
-00019410: 2020 2020 2020 0a20 2020 2020 2020 2069        .        i
-00019420: 6620 7365 6c66 2e65 7479 7065 2e69 735f  f self.etype.is_
-00019430: 6578 7465 6e64 6564 5f72 6174 696f 6e61  extended_rationa
-00019440: 6c3a 0a20 2020 2020 2020 2020 2020 2072  l:.            r
-00019450: 6574 7572 6e20 416c 6570 6828 3029 0a20  eturn Aleph(0). 
-00019460: 2020 2020 2020 200a 2020 2020 2020 2020         .        
-00019470: 6966 2073 656c 662e 6574 7970 652e 6973  if self.etype.is
-00019480: 5f68 7970 6572 5f63 6f6d 706c 6578 3a0a  _hyper_complex:.
-00019490: 2020 2020 2020 2020 2020 2020 7265 7475              retu
-000194a0: 726e 2041 6c65 7068 2831 290a 2020 2020  rn Aleph(1).    
-000194b0: 2020 2020 0a20 2020 2020 2020 2070 7269      .        pri
-000194c0: 6e74 2827 756e 6b6e 6f77 6e20 616c 6570  nt('unknown alep
-000194d0: 6820 6e75 6d62 6572 3f3f 2729 0a20 2020  h number??').   
-000194e0: 2020 2020 2072 6574 7572 6e20 532e 496e       return S.In
-000194f0: 6669 6e69 7479 0a0a 2020 2020 4070 726f  finity..    @pro
-00019500: 7065 7274 790a 2020 2020 6465 6620 6574  perty.    def et
-00019510: 7970 6528 7365 6c66 293a 0a20 2020 2020  ype(self):.     
-00019520: 2020 2072 6574 7572 6e20 7365 6c66 2e5f     return self._
-00019530: 6173 7375 6d70 7469 6f6e 735b 2765 7479  assumptions['ety
-00019540: 7065 275d 0a0a 2020 2020 6465 6620 5f5f  pe']..    def __
-00019550: 6164 645f 5f28 7365 6c66 2c20 6f74 6865  add__(self, othe
-00019560: 7229 3a0a 2020 2020 2020 2020 6966 2073  r):.        if s
-00019570: 656c 662e 6574 7970 652e 6973 5f73 6574  elf.etype.is_set
-00019580: 3a20 0a20 2020 2020 2020 2020 2020 2072  : .            r
-00019590: 6169 7365 2045 7863 6570 7469 6f6e 2822  aise Exception("
-000195a0: 636f 756c 6420 6e6f 7420 6164 6420 2573  could not add %s
-000195b0: 2c20 2573 2077 6974 6820 6574 7970 6520  , %s with etype 
-000195c0: 3d20 2573 2220 2520 2873 656c 662c 206f  = %s" % (self, o
-000195d0: 7468 6572 2c20 7365 6c66 2e65 7479 7065  ther, self.etype
-000195e0: 2929 0a20 2020 200a 2020 2020 2020 2020  )).    .        
-000195f0: 7265 7475 726e 2073 656c 660a 2020 2020  return self.    
-00019600: 0a20 2020 2064 6566 205f 5f6d 756c 5f5f  .    def __mul__
-00019610: 2873 656c 662c 206f 7468 6572 293a 0a20  (self, other):. 
-00019620: 2020 2020 2020 2069 6620 7365 6c66 2e65         if self.e
-00019630: 7479 7065 2e69 735f 7365 743a 200a 2020  type.is_set: .  
-00019640: 2020 2020 2020 2020 2020 7261 6973 6520            raise 
-00019650: 4578 6365 7074 696f 6e28 2263 6f75 6c64  Exception("could
-00019660: 206e 6f74 2061 6464 2025 732c 2025 7320   not add %s, %s 
-00019670: 7769 7468 2065 7479 7065 203d 2025 7322  with etype = %s"
-00019680: 2025 2028 7365 6c66 2c20 6f74 6865 722c   % (self, other,
-00019690: 2073 656c 662e 6574 7970 6529 290a 2020   self.etype)).  
-000196a0: 2020 2020 2020 0a20 2020 2020 2020 2072        .        r
-000196b0: 6574 7572 6e20 7365 6c66 0a20 2020 200a  eturn self.    .
-000196c0: 2020 2020 0a48 7970 6572 5265 616c 7320      .HyperReals 
-000196d0: 3d20 556e 6976 6572 7361 6c53 6574 2865  = UniversalSet(e
-000196e0: 7479 7065 3d64 7479 7065 2e68 7970 6572  type=dtype.hyper
-000196f0: 5f72 6561 6c29 0a53 7570 6572 5265 616c  _real).SuperReal
-00019700: 7320 3d20 556e 6976 6572 7361 6c53 6574  s = UniversalSet
-00019710: 2865 7479 7065 3d64 7479 7065 2e73 7570  (etype=dtype.sup
-00019720: 6572 5f72 6561 6c29 0a48 7970 6572 436f  er_real).HyperCo
-00019730: 6d70 6c65 7865 7320 3d20 556e 6976 6572  mplexes = Univer
-00019740: 7361 6c53 6574 2865 7479 7065 3d64 7479  salSet(etype=dty
-00019750: 7065 2e68 7970 6572 5f63 6f6d 706c 6578  pe.hyper_complex
-00019760: 290a 5375 7065 7243 6f6d 706c 6578 6573  ).SuperComplexes
-00019770: 203d 2055 6e69 7665 7273 616c 5365 7428   = UniversalSet(
-00019780: 6574 7970 653d 6474 7970 652e 7375 7065  etype=dtype.supe
-00019790: 725f 636f 6d70 6c65 7829 0a0a 2020 2020  r_complex)..    
-000197a0: 0a63 6c61 7373 2046 696e 6974 6553 6574  .class FiniteSet
-000197b0: 2853 6574 293a 0a20 2020 2022 2222 0a20  (Set):.    """. 
-000197c0: 2020 2052 6570 7265 7365 6e74 7320 6120     Represents a 
-000197d0: 6669 6e69 7465 2073 6574 206f 6620 6469  finite set of di
-000197e0: 7363 7265 7465 206e 756d 6265 7273 0a0a  screte numbers..
-000197f0: 2020 2020 4578 616d 706c 6573 0a20 2020      Examples.   
-00019800: 203d 3d3d 3d3d 3d3d 3d0a 0a20 2020 203e   ========..    >
-00019810: 3e3e 2066 726f 6d20 7379 6d70 7920 696d  >> from sympy im
-00019820: 706f 7274 2046 696e 6974 6553 6574 0a20  port FiniteSet. 
-00019830: 2020 203e 3e3e 2046 696e 6974 6553 6574     >>> FiniteSet
-00019840: 2831 2c20 322c 2033 2c20 3429 0a20 2020  (1, 2, 3, 4).   
-00019850: 2046 696e 6974 6553 6574 2831 2c20 322c   FiniteSet(1, 2,
-00019860: 2033 2c20 3429 0a20 2020 203e 3e3e 2033   3, 4).    >>> 3
-00019870: 2069 6e20 4669 6e69 7465 5365 7428 312c   in FiniteSet(1,
-00019880: 2032 2c20 332c 2034 290a 2020 2020 5472   2, 3, 4).    Tr
-00019890: 7565 0a0a 2020 2020 3e3e 3e20 6d65 6d62  ue..    >>> memb
-000198a0: 6572 7320 3d20 5b31 2c20 322c 2033 2c20  ers = [1, 2, 3, 
-000198b0: 345d 0a20 2020 203e 3e3e 2066 203d 2046  4].    >>> f = F
-000198c0: 696e 6974 6553 6574 282a 6d65 6d62 6572  initeSet(*member
-000198d0: 7329 0a20 2020 203e 3e3e 2066 0a20 2020  s).    >>> f.   
-000198e0: 2046 696e 6974 6553 6574 2831 2c20 322c   FiniteSet(1, 2,
-000198f0: 2033 2c20 3429 0a20 2020 203e 3e3e 2066   3, 4).    >>> f
-00019900: 202d 2046 696e 6974 6553 6574 2832 290a   - FiniteSet(2).
-00019910: 2020 2020 4669 6e69 7465 5365 7428 312c      FiniteSet(1,
-00019920: 2033 2c20 3429 0a20 2020 203e 3e3e 2066   3, 4).    >>> f
-00019930: 202b 2046 696e 6974 6553 6574 2832 2c20   + FiniteSet(2, 
-00019940: 3529 0a20 2020 2046 696e 6974 6553 6574  5).    FiniteSet
-00019950: 2831 2c20 322c 2033 2c20 342c 2035 290a  (1, 2, 3, 4, 5).
-00019960: 0a20 2020 2052 6566 6572 656e 6365 730a  .    References.
-00019970: 2020 2020 3d3d 3d3d 3d3d 3d3d 3d3d 0a0a      ==========..
-00019980: 2020 2020 2e2e 205b 315d 2068 7474 7073      .. [1] https
-00019990: 3a2f 2f65 6e2e 7769 6b69 7065 6469 612e  ://en.wikipedia.
-000199a0: 6f72 672f 7769 6b69 2f46 696e 6974 655f  org/wiki/Finite_
-000199b0: 7365 740a 2020 2020 2222 220a 2020 2020  set.    """.    
-000199c0: 6973 5f69 7465 7261 626c 6520 3d20 5472  is_iterable = Tr
-000199d0: 7565 0a0a 2020 2020 6465 6620 696e 7465  ue..    def inte
-000199e0: 7273 6563 7469 6f6e 5f73 6574 7328 7365  rsection_sets(se
-000199f0: 6c66 2c20 6229 3a0a 2020 2020 2020 2020  lf, b):.        
-00019a00: 6966 2062 2e69 735f 4669 6e69 7465 5365  if b.is_FiniteSe
-00019a10: 743a 0a20 2020 2020 2020 2020 2020 2072  t:.            r
-00019a20: 6574 7572 6e20 4669 6e69 7465 5365 7428  eturn FiniteSet(
-00019a30: 2a28 7365 6c66 2e5f 656c 656d 656e 7473  *(self._elements
-00019a40: 2026 2062 2e5f 656c 656d 656e 7473 2929   & b._elements))
-00019a50: 0a0a 2020 2020 2020 2020 7472 793a 0a20  ..        try:. 
-00019a60: 2020 2020 2020 2020 2020 2072 6574 7572             retur
-00019a70: 6e20 4669 6e69 7465 5365 7428 2a5b 656c  n FiniteSet(*[el
-00019a80: 2066 6f72 2065 6c20 696e 2073 656c 6620   for el in self 
-00019a90: 6966 2065 6c20 696e 2062 5d29 0a20 2020  if el in b]).   
-00019aa0: 2020 2020 2065 7863 6570 7420 5479 7065       except Type
-00019ab0: 4572 726f 723a 0a20 2020 2020 2020 2020  Error:.         
-00019ac0: 2020 2072 6574 7572 6e20 4e6f 6e65 2020     return None  
-00019ad0: 2320 636f 756c 6420 6e6f 7420 6576 616c  # could not eval
-00019ae0: 7561 7465 2060 656c 2069 6e20 6260 2064  uate `el in b` d
-00019af0: 7565 2074 6f20 7379 6d62 6f6c 6963 2072  ue to symbolic r
-00019b00: 616e 6765 732e 0a0a 2020 2020 6465 6620  anges...    def 
-00019b10: 756e 696f 6e5f 7365 7473 2873 656c 662c  union_sets(self,
-00019b20: 2062 293a 0a20 2020 2020 2020 2069 6620   b):.        if 
-00019b30: 622e 6973 5f46 696e 6974 6553 6574 3a0a  b.is_FiniteSet:.
-00019b40: 2020 2020 2020 2020 2020 2020 7265 7475              retu
-00019b50: 726e 2046 696e 6974 6553 6574 282a 2873  rn FiniteSet(*(s
-00019b60: 6574 2873 656c 662e 6172 6773 2920 7c20  et(self.args) | 
-00019b70: 7365 7428 622e 6172 6773 2929 290a 2020  set(b.args))).  
-00019b80: 2020 2020 2020 2320 4966 2060 6260 2073        # If `b` s
-00019b90: 6574 2063 6f6e 7461 696e 7320 6f6e 6520  et contains one 
-00019ba0: 6f66 206d 7920 656c 656d 656e 7473 2c20  of my elements, 
-00019bb0: 7265 6d6f 7665 2069 7420 6672 6f6d 2060  remove it from `
-00019bc0: 6160 0a20 2020 2020 2020 2069 6620 616e  a`.        if an
-00019bd0: 7928 622e 636f 6e74 6169 6e73 2878 2920  y(b.contains(x) 
-00019be0: 3d3d 2054 7275 6520 666f 7220 7820 696e  == True for x in
-00019bf0: 2073 656c 6629 3a0a 2020 2020 2020 2020   self):.        
-00019c00: 2020 2020 7265 7475 726e 2073 6574 2828      return set((
-00019c10: 4669 6e69 7465 5365 7428 2a5b 7820 666f  FiniteSet(*[x fo
-00019c20: 7220 7820 696e 2073 656c 6620 6966 206e  r x in self if n
-00019c30: 6f74 2062 2e63 6f6e 7461 696e 7328 7829  ot b.contains(x)
-00019c40: 5d29 2c20 6229 290a 2020 2020 2020 2020  ]), b)).        
-00019c50: 0a20 2020 2020 2020 2069 6620 622e 6973  .        if b.is
-00019c60: 5f49 6e74 6572 7365 6374 696f 6e3a 0a20  _Intersection:. 
-00019c70: 2020 2020 2020 2020 2020 2066 6f72 2069             for i
-00019c80: 2c20 7320 696e 2065 6e75 6d65 7261 7465  , s in enumerate
-00019c90: 2862 2e61 7267 7329 3a0a 2020 2020 2020  (b.args):.      
-00019ca0: 2020 2020 2020 2020 2020 6966 2073 2e69            if s.i
-00019cb0: 735f 4669 6e69 7465 5365 743a 0a20 2020  s_FiniteSet:.   
-00019cc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00019cd0: 2075 203d 205b 2a62 2e61 7267 735d 0a20   u = [*b.args]. 
-00019ce0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00019cf0: 2020 2064 656c 2075 5b69 5d0a 2020 2020     del u[i].    
-00019d00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00019d10: 7520 3d20 622e 6675 6e63 282a 752c 2065  u = b.func(*u, e
-00019d20: 7661 6c75 6174 653d 4661 6c73 6529 0a20  valuate=False). 
-00019d30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00019d40: 2020 2069 6620 7365 6c66 2069 6e20 753a     if self in u:
-00019d50: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00019d60: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
-00019d70: 622e 6675 6e63 2828 7365 6c66 207c 2073  b.func((self | s
-00019d80: 292c 2075 2c20 6576 616c 7561 7465 3d46  ), u, evaluate=F
-00019d90: 616c 7365 290a 2020 2020 2020 2020 6966  alse).        if
-00019da0: 2062 2e69 735f 436f 6d70 6c65 6d65 6e74   b.is_Complement
-00019db0: 3a0a 2020 2020 2020 2020 2020 2020 412c  :.            A,
-00019dc0: 2042 203d 2062 2e61 7267 730a 2020 2020   B = b.args.    
-00019dd0: 2020 2020 2020 2020 6966 2042 2069 6e20          if B in 
-00019de0: 7365 6c66 3a0a 2020 2020 2020 2020 2020  self:.          
-00019df0: 2020 2020 2020 7265 7475 726e 2041 207c        return A |
-00019e00: 2073 656c 660a 2320 2020 2020 2020 2020   self.#         
-00019e10: 7265 7475 726e 204e 6f6e 650a 0a20 2020  return None..   
-00019e20: 2064 6566 205f 5f6e 6577 5f5f 2863 6c73   def __new__(cls
-00019e30: 2c20 2a61 7267 732c 202a 2a6b 7761 7267  , *args, **kwarg
-00019e40: 7329 3a0a 2020 2020 2020 2020 6576 616c  s):.        eval
-00019e50: 7561 7465 203d 206b 7761 7267 732e 6765  uate = kwargs.ge
-00019e60: 7428 2765 7661 6c75 6174 6527 2c20 676c  t('evaluate', gl
-00019e70: 6f62 616c 5f70 6172 616d 6574 6572 732e  obal_parameters.
-00019e80: 6576 616c 7561 7465 290a 2020 2020 2020  evaluate).      
-00019e90: 2020 6966 2065 7661 6c75 6174 653a 0a20    if evaluate:. 
-00019ea0: 2020 2020 2020 2020 2020 2061 7267 7320             args 
-00019eb0: 3d20 6c69 7374 286d 6170 2873 796d 7069  = list(map(sympi
-00019ec0: 6679 2c20 6172 6773 2929 0a0a 2020 2020  fy, args))..    
-00019ed0: 2020 2020 2020 2020 6966 206c 656e 2861          if len(a
-00019ee0: 7267 7329 203d 3d20 303a 0a20 2020 2020  rgs) == 0:.     
-00019ef0: 2020 2020 2020 2020 2020 2072 6574 7572             retur
-00019f00: 6e20 456d 7074 7953 6574 2829 0a20 2020  n EmptySet().   
-00019f10: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
-00019f20: 2020 2020 2020 2061 7267 7320 3d20 6c69         args = li
-00019f30: 7374 286d 6170 2873 796d 7069 6679 2c20  st(map(sympify, 
-00019f40: 6172 6773 2929 0a0a 2020 2020 2020 2020  args))..        
-00019f50: 6172 6773 203d 206c 6973 7428 6f72 6465  args = list(orde
-00019f60: 7265 6428 7365 7428 6172 6773 292c 2053  red(set(args), S
-00019f70: 6574 2e5f 696e 6669 6d75 6d5f 6b65 7929  et._infimum_key)
-00019f80: 290a 2020 2020 2020 2020 6f62 6a20 3d20  ).        obj = 
-00019f90: 4261 7369 632e 5f5f 6e65 775f 5f28 636c  Basic.__new__(cl
-00019fa0: 732c 202a 6172 6773 290a 2020 2020 2020  s, *args).      
-00019fb0: 2020 7265 7475 726e 206f 626a 0a0a 2020    return obj..  
-00019fc0: 2020 6465 6620 5f65 7661 6c5f 4571 2873    def _eval_Eq(s
-00019fd0: 656c 662c 206f 7468 6572 293a 0a20 2020  elf, other):.   
-00019fe0: 2020 2020 2069 6620 6e6f 7420 6973 696e       if not isin
-00019ff0: 7374 616e 6365 286f 7468 6572 2c20 4669  stance(other, Fi
-0001a000: 6e69 7465 5365 7429 3a0a 2020 2020 2020  niteSet):.      
-0001a010: 2020 2020 2020 6966 206f 7468 6572 2e69        if other.i
-0001a020: 735f 456d 7074 7953 6574 3a0a 2020 2020  s_EmptySet:.    
-0001a030: 2020 2020 2020 2020 2020 2020 7265 7475              retu
-0001a040: 726e 2053 2e66 616c 7365 0a20 2020 2020  rn S.false.     
-0001a050: 2020 2020 2020 200a 2020 2020 2020 2020         .        
-0001a060: 2020 2020 6966 206f 7468 6572 2e69 735f      if other.is_
-0001a070: 496e 7465 7276 616c 3a0a 2020 2020 2020  Interval:.      
-0001a080: 2020 2020 2020 2020 2020 6966 206e 6f74            if not
-0001a090: 206f 7468 6572 2e65 7479 7065 2e69 735f   other.etype.is_
-0001a0a0: 696e 7465 6765 723a 0a20 2020 2020 2020  integer:.       
-0001a0b0: 2020 2020 2020 2020 2020 2020 2072 6574               ret
-0001a0c0: 7572 6e20 532e 6661 6c73 650a 2020 2020  urn S.false.    
-0001a0d0: 2020 2020 2020 2020 2020 2020 0a20 2020              .   
-0001a0e0: 2020 2020 2020 2020 2069 6620 6f74 6865           if othe
-0001a0f0: 722e 6973 5f73 6574 3a0a 2020 2020 2020  r.is_set:.      
-0001a100: 2020 2020 2020 2020 2020 7265 7475 726e            return
-0001a110: 204e 6f6e 650a 2020 2020 2020 2020 2020   None.          
-0001a120: 2020 7265 7475 726e 2053 2e66 616c 7365    return S.false
-0001a130: 0a0a 2020 2020 2020 2020 6966 206c 656e  ..        if len
-0001a140: 2873 656c 6629 2021 3d20 6c65 6e28 6f74  (self) != len(ot
-0001a150: 6865 7229 3a0a 2020 2020 2020 2020 2020  her):.          
-0001a160: 2020 7265 7475 726e 2053 2e66 616c 7365    return S.false
-0001a170: 0a0a 2020 2020 6465 6620 5f5f 6974 6572  ..    def __iter
-0001a180: 5f5f 2873 656c 6629 3a0a 2020 2020 2020  __(self):.      
-0001a190: 2020 7265 7475 726e 2069 7465 7228 7365    return iter(se
-0001a1a0: 6c66 2e61 7267 7329 0a0a 2020 2020 6465  lf.args)..    de
-0001a1b0: 6620 5f63 6f6d 706c 656d 656e 7428 7365  f _complement(se
-0001a1c0: 6c66 2c20 6f74 6865 7229 3a0a 2020 2020  lf, other):.    
-0001a1d0: 2020 2020 6672 6f6d 2073 796d 7079 2069      from sympy i
-0001a1e0: 6d70 6f72 7420 5261 6e67 650a 2020 2020  mport Range.    
-0001a1f0: 2020 2020 6966 206f 7468 6572 2e69 735f      if other.is_
-0001a200: 5261 6e67 653a 0a20 2020 2020 2020 2020  Range:.         
-0001a210: 2020 206e 756d 7320 3d20 736f 7274 6564     nums = sorted
-0001a220: 286d 2066 6f72 206d 2069 6e20 7365 6c66  (m for m in self
-0001a230: 2e61 7267 7320 6966 206d 2e69 735f 6e75  .args if m.is_nu
-0001a240: 6d62 6572 2920 2020 2020 2020 2020 2020  mber)           
-0001a250: 200a 2020 2020 2020 2020 2020 2020 6966   .            if
-0001a260: 2046 616c 7365 2061 6e64 206e 756d 7320   False and nums 
-0001a270: 213d 205b 5d3a 0a20 2020 2020 2020 2020  != []:.         
-0001a280: 2020 2020 2020 2073 796d 7320 3d20 5b6d         syms = [m
-0001a290: 2066 6f72 206d 2069 6e20 7365 6c66 2e61   for m in self.a
-0001a2a0: 7267 7320 6966 206d 2e69 735f 5379 6d62  rgs if m.is_Symb
-0001a2b0: 6f6c 5d0a 2020 2020 2020 2020 2020 2020  ol].            
-0001a2c0: 2020 2020 2320 5265 616c 7320 6361 6e6e      # Reals cann
-0001a2d0: 6f74 2063 6f6e 7461 696e 2065 6c65 6d65  ot contain eleme
-0001a2e0: 6e74 7320 6f74 6865 7220 7468 616e 206e  nts other than n
-0001a2f0: 756d 6265 7273 2061 6e64 2073 796d 626f  umbers and symbo
-0001a300: 6c73 2e0a 0a20 2020 2020 2020 2020 2020  ls...           
-0001a310: 2020 2020 2069 6e74 6572 7661 6c73 203d       intervals =
-0001a320: 205b 5d20 2023 2042 7569 6c64 2075 7020   []  # Build up 
-0001a330: 6120 6c69 7374 206f 6620 696e 7465 7276  a list of interv
-0001a340: 616c 7320 6265 7477 6565 6e20 7468 6520  als between the 
-0001a350: 656c 656d 656e 7473 0a20 2020 2020 2020  elements.       
-0001a360: 2020 2020 2020 2020 2069 6e74 6572 7661           interva
-0001a370: 6c73 202b 3d20 5b52 616e 6765 2853 2e4e  ls += [Range(S.N
-0001a380: 6567 6174 6976 6549 6e66 696e 6974 792c  egativeInfinity,
-0001a390: 206e 756d 735b 305d 295d 0a20 2020 2020   nums[0])].     
-0001a3a0: 2020 2020 2020 2020 2020 2066 6f72 2061             for a
-0001a3b0: 2c20 6220 696e 207a 6970 286e 756d 735b  , b in zip(nums[
-0001a3c0: 3a2d 315d 2c20 6e75 6d73 5b31 3a5d 293a  :-1], nums[1:]):
-0001a3d0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0001a3e0: 2020 2020 2069 6e74 6572 7661 6c73 2e61       intervals.a
-0001a3f0: 7070 656e 6428 5261 6e67 6528 6120 2b20  ppend(Range(a + 
-0001a400: 312c 2062 2929 2020 2320 626f 7468 206f  1, b))  # both o
-0001a410: 7065 6e0a 2020 2020 2020 2020 2020 2020  pen.            
-0001a420: 2020 2020 696e 7465 7276 616c 732e 6170      intervals.ap
-0001a430: 7065 6e64 2852 616e 6765 286e 756d 735b  pend(Range(nums[
-0001a440: 2d31 5d20 2b20 312c 2053 2e49 6e66 696e  -1] + 1, S.Infin
-0001a450: 6974 7929 290a 0a20 2020 2020 2020 2020  ity))..         
-0001a460: 2020 2020 2020 2069 6620 7379 6d73 2021         if syms !
-0001a470: 3d20 5b5d 3a0a 2020 2020 2020 2020 2020  = []:.          
-0001a480: 2020 2020 2020 2020 2020 7265 7475 726e            return
-0001a490: 2043 6f6d 706c 656d 656e 7428 556e 696f   Complement(Unio
-0001a4a0: 6e28 2a69 6e74 6572 7661 6c73 2c20 6576  n(*intervals, ev
-0001a4b0: 616c 7561 7465 3d46 616c 7365 292c 2046  aluate=False), F
-0001a4c0: 696e 6974 6553 6574 282a 7379 6d73 292c  initeSet(*syms),
-0001a4d0: 2065 7661 6c75 6174 653d 4661 6c73 6529   evaluate=False)
-0001a4e0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0001a4f0: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
-0001a500: 2020 2020 2020 2020 2020 2072 6574 7572             retur
-0001a510: 6e20 556e 696f 6e28 2a69 6e74 6572 7661  n Union(*interva
-0001a520: 6c73 2c20 6576 616c 7561 7465 3d46 616c  ls, evaluate=Fal
-0001a530: 7365 290a 2020 2020 2020 2020 2020 2020  se).            
-0001a540: 656c 7365 3a0a 0a20 2020 2020 2020 2020  else:..         
-0001a550: 2020 2020 2020 2066 6f72 2069 2c20 6520         for i, e 
-0001a560: 696e 2065 6e75 6d65 7261 7465 2873 656c  in enumerate(sel
-0001a570: 662e 6172 6773 293a 0a20 2020 2020 2020  f.args):.       
-0001a580: 2020 2020 2020 2020 2020 2020 206d 2c20               m, 
-0001a590: 4d20 3d20 6f74 6865 722e 6d69 6e28 292c  M = other.min(),
-0001a5a0: 206f 7468 6572 2e6d 6178 2829 0a20 2020   other.max().   
-0001a5b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001a5c0: 2069 6620 6520 3d3d 204d 3a0a 2020 2020   if e == M:.    
-0001a5d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001a5e0: 2020 2020 6172 6773 203d 205b 2a73 656c      args = [*sel
-0001a5f0: 662e 6172 6773 5d0a 2020 2020 2020 2020  f.args].        
-0001a600: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001a610: 6465 6c20 6172 6773 5b69 5d0a 2020 2020  del args[i].    
-0001a620: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001a630: 2020 2020 7265 7475 726e 206f 7468 6572      return other
-0001a640: 2e63 6f70 7928 7374 6f70 3d4d 2c20 7269  .copy(stop=M, ri
-0001a650: 6768 745f 6f70 656e 3d54 7275 6529 202d  ght_open=True) -
-0001a660: 2073 656c 662e 6675 6e63 282a 6172 6773   self.func(*args
-0001a670: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
-0001a680: 2020 2020 2020 6966 2065 203d 3d20 6d3a        if e == m:
-0001a690: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0001a6a0: 2020 2020 2020 2020 2061 7267 7320 3d20           args = 
-0001a6b0: 5b2a 7365 6c66 2e61 7267 735d 0a20 2020  [*self.args].   
-0001a6c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001a6d0: 2020 2020 2064 656c 2061 7267 735b 695d       del args[i]
-0001a6e0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0001a6f0: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
-0001a700: 6f74 6865 722e 636f 7079 2873 7461 7274  other.copy(start
-0001a710: 3d6d 2c20 6c65 6674 5f6f 7065 6e3d 5472  =m, left_open=Tr
-0001a720: 7565 292e 7369 6d70 6c69 6679 2829 202d  ue).simplify() -
-0001a730: 2073 656c 662e 6675 6e63 282a 6172 6773   self.func(*args
-0001a740: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
-0001a750: 2020 2020 2020 6966 2065 203e 204d 206f        if e > M o
-0001a760: 7220 6520 3c20 6d3a 0a20 2020 2020 2020  r e < m:.       
-0001a770: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001a780: 2061 7267 7320 3d20 5b2a 7365 6c66 2e61   args = [*self.a
-0001a790: 7267 735d 0a20 2020 2020 2020 2020 2020  rgs].           
-0001a7a0: 2020 2020 2020 2020 2020 2020 2064 656c               del
-0001a7b0: 2061 7267 735b 695d 0a20 2020 2020 2020   args[i].       
-0001a7c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001a7d0: 2072 6574 7572 6e20 6f74 6865 7220 2d20   return other - 
-0001a7e0: 7365 6c66 2e66 756e 6328 2a61 7267 7329  self.func(*args)
-0001a7f0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0001a800: 2072 6574 7572 6e0a 2020 2020 2020 2020   return.        
-0001a810: 2020 2020 0a20 2020 2020 2020 2020 2020      .           
-0001a820: 2069 6620 6f74 6865 722e 6574 7970 652e   if other.etype.
-0001a830: 6973 5f69 6e74 6567 6572 3a0a 2020 2020  is_integer:.    
-0001a840: 2020 2020 2020 2020 2020 2020 6966 206f              if o
-0001a850: 7468 6572 2e6d 696e 2829 2069 6e20 7365  ther.min() in se
-0001a860: 6c66 3a20 0a20 2020 2020 2020 2020 2020  lf: .           
-0001a870: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
-0001a880: 6f74 6865 722e 636f 7079 2873 7461 7274  other.copy(start
-0001a890: 3d6f 7468 6572 2e73 7461 7274 202b 2031  =other.start + 1
-0001a8a0: 2920 2d20 7365 6c66 2e66 756e 6328 2a7b  ) - self.func(*{
-0001a8b0: 2a73 656c 662e 6172 6773 7d20 2d20 7b6f  *self.args} - {o
-0001a8c0: 7468 6572 2e6d 696e 2829 7d29 2020 2020  ther.min()})    
-0001a8d0: 2020 2020 2020 2020 2020 2020 0a20 2020              .   
-0001a8e0: 2020 2020 2020 2020 2020 2020 2069 6620               if 
-0001a8f0: 6f74 6865 722e 6d61 7828 2920 696e 2073  other.max() in s
-0001a900: 656c 663a 200a 2020 2020 2020 2020 2020  elf: .          
-0001a910: 2020 2020 2020 2020 2020 7265 7475 726e            return
-0001a920: 206f 7468 6572 2e63 6f70 7928 7374 6f70   other.copy(stop
-0001a930: 3d6f 7468 6572 2e73 746f 7020 2d20 3129  =other.stop - 1)
-0001a940: 202d 2073 656c 662e 6675 6e63 282a 7b2a   - self.func(*{*
-0001a950: 7365 6c66 2e61 7267 737d 202d 207b 6f74  self.args} - {ot
-0001a960: 6865 722e 6d61 7828 297d 290a 2020 2020  her.max()}).    
-0001a970: 2020 2020 656c 6966 206f 7468 6572 2e69      elif other.i
-0001a980: 735f 496e 7465 7276 616c 3a0a 2020 2020  s_Interval:.    
-0001a990: 2020 2020 2020 2020 6e75 6d73 203d 2073          nums = s
-0001a9a0: 6f72 7465 6428 6d20 666f 7220 6d20 696e  orted(m for m in
-0001a9b0: 2073 656c 662e 6172 6773 2069 6620 6d2e   self.args if m.
-0001a9c0: 6973 5f6e 756d 6265 7229 0a20 2020 2020  is_number).     
-0001a9d0: 2020 2020 2020 2069 6620 6f74 6865 722e         if other.
-0001a9e0: 7374 6172 742e 6973 5f4e 6567 6174 6976  start.is_Negativ
-0001a9f0: 6549 6e66 696e 6974 7920 616e 6420 6f74  eInfinity and ot
-0001aa00: 6865 722e 7374 6f70 2e69 735f 496e 6669  her.stop.is_Infi
-0001aa10: 6e69 7479 2061 6e64 206e 756d 7320 213d  nity and nums !=
-0001aa20: 205b 5d3a 0a20 2020 2020 2020 2020 2020   []:.           
-0001aa30: 2020 2020 206c 6566 745f 6f70 656e 203d       left_open =
-0001aa40: 206f 7468 6572 2e6c 6566 745f 6f70 656e   other.left_open
-0001aa50: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0001aa60: 2072 6967 6874 5f6f 7065 6e20 3d20 6f74   right_open = ot
-0001aa70: 6865 722e 7269 6768 745f 6f70 656e 0a20  her.right_open. 
-0001aa80: 2020 2020 2020 2020 2020 2020 2020 2073                 s
-0001aa90: 796d 7320 3d20 5b6d 2066 6f72 206d 2069  yms = [m for m i
-0001aaa0: 6e20 7365 6c66 2e61 7267 7320 6966 206d  n self.args if m
-0001aab0: 2e69 735f 5379 6d62 6f6c 5d0a 2020 2020  .is_Symbol].    
-0001aac0: 2020 2020 2020 2020 2020 2020 2320 5265              # Re
-0001aad0: 616c 7320 6361 6e6e 6f74 2063 6f6e 7461  als cannot conta
-0001aae0: 696e 2065 6c65 6d65 6e74 7320 6f74 6865  in elements othe
-0001aaf0: 7220 7468 616e 206e 756d 6265 7273 2061  r than numbers a
-0001ab00: 6e64 2073 796d 626f 6c73 2e0a 0a20 2020  nd symbols...   
-0001ab10: 2020 2020 2020 2020 2020 2020 2069 6e74               int
-0001ab20: 6572 7661 6c73 203d 205b 5d20 2023 2042  ervals = []  # B
-0001ab30: 7569 6c64 2075 7020 6120 6c69 7374 206f  uild up a list o
-0001ab40: 6620 696e 7465 7276 616c 7320 6265 7477  f intervals betw
-0001ab50: 6565 6e20 7468 6520 656c 656d 656e 7473  een the elements
-0001ab60: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0001ab70: 2069 6e74 6572 7661 6c73 202b 3d20 5b49   intervals += [I
-0001ab80: 6e74 6572 7661 6c28 532e 4e65 6761 7469  nterval(S.Negati
-0001ab90: 7665 496e 6669 6e69 7479 2c20 6e75 6d73  veInfinity, nums
-0001aba0: 5b30 5d2c 206c 6566 745f 6f70 656e 3d6c  [0], left_open=l
-0001abb0: 6566 745f 6f70 656e 2c20 7269 6768 745f  eft_open, right_
-0001abc0: 6f70 656e 3d54 7275 6529 5d0a 2020 2020  open=True)].    
-0001abd0: 2020 2020 2020 2020 2020 2020 666f 7220              for 
-0001abe0: 612c 2062 2069 6e20 7a69 7028 6e75 6d73  a, b in zip(nums
-0001abf0: 5b3a 2d31 5d2c 206e 756d 735b 313a 5d29  [:-1], nums[1:])
-0001ac00: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-0001ac10: 2020 2020 2020 696e 7465 7276 616c 732e        intervals.
-0001ac20: 6170 7065 6e64 2849 6e74 6572 7661 6c28  append(Interval(
-0001ac30: 612c 2062 2c20 6c65 6674 5f6f 7065 6e3d  a, b, left_open=
-0001ac40: 5472 7565 2c20 7269 6768 745f 6f70 656e  True, right_open
-0001ac50: 3d54 7275 6529 2920 2023 2062 6f74 6820  =True))  # both 
-0001ac60: 6f70 656e 0a20 2020 2020 2020 2020 2020  open.           
-0001ac70: 2020 2020 2069 6e74 6572 7661 6c73 2e61       intervals.a
-0001ac80: 7070 656e 6428 496e 7465 7276 616c 286e  ppend(Interval(n
-0001ac90: 756d 735b 2d31 5d2c 2053 2e49 6e66 696e  ums[-1], S.Infin
-0001aca0: 6974 792c 206c 6566 745f 6f70 656e 3d54  ity, left_open=T
-0001acb0: 7275 652c 2072 6967 6874 5f6f 7065 6e3d  rue, right_open=
-0001acc0: 7269 6768 745f 6f70 656e 2929 0a0a 2020  right_open))..  
-0001acd0: 2020 2020 2020 2020 2020 2020 2020 6966                if
-0001ace0: 2073 796d 7320 213d 205b 5d3a 0a20 2020   syms != []:.   
-0001acf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001ad00: 2072 6574 7572 6e20 436f 6d70 6c65 6d65   return Compleme
-0001ad10: 6e74 2855 6e69 6f6e 282a 696e 7465 7276  nt(Union(*interv
-0001ad20: 616c 732c 2065 7661 6c75 6174 653d 4661  als, evaluate=Fa
-0001ad30: 6c73 6529 2c0a 2020 2020 2020 2020 2020  lse),.          
-0001ad40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001ad50: 2020 4669 6e69 7465 5365 7428 2a73 796d    FiniteSet(*sym
-0001ad60: 7329 2c20 6576 616c 7561 7465 3d46 616c  s), evaluate=Fal
-0001ad70: 7365 290a 2020 2020 2020 2020 2020 2020  se).            
-0001ad80: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
-0001ad90: 2020 2020 2020 2020 2020 2020 2020 7265                re
-0001ada0: 7475 726e 2055 6e69 6f6e 282a 696e 7465  turn Union(*inte
-0001adb0: 7276 616c 732c 2065 7661 6c75 6174 653d  rvals, evaluate=
-0001adc0: 4661 6c73 6529 0a20 2020 2020 2020 2020  False).         
-0001add0: 2020 2065 6c73 653a 0a0a 2020 2020 2020     else:..      
-0001ade0: 2020 2020 2020 2020 2020 666f 7220 692c            for i,
-0001adf0: 2065 2069 6e20 656e 756d 6572 6174 6528   e in enumerate(
-0001ae00: 7365 6c66 2e61 7267 7329 3a0a 2020 2020  self.args):.    
-0001ae10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001ae20: 6d2c 204d 203d 206f 7468 6572 2e6d 696e  m, M = other.min
-0001ae30: 2829 2c20 6f74 6865 722e 6d61 7828 290a  (), other.max().
-0001ae40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001ae50: 2020 2020 6966 2065 203d 3d20 4d3a 0a20      if e == M:. 
-0001ae60: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001ae70: 2020 2020 2020 2061 7267 7320 3d20 5b2a         args = [*
-0001ae80: 7365 6c66 2e61 7267 735d 0a20 2020 2020  self.args].     
-0001ae90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001aea0: 2020 2064 656c 2061 7267 735b 695d 0a20     del args[i]. 
-0001aeb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001aec0: 2020 2020 2020 2072 6574 7572 6e20 6f74         return ot
-0001aed0: 6865 722e 636f 7079 2873 746f 703d 4d2c  her.copy(stop=M,
-0001aee0: 2072 6967 6874 5f6f 7065 6e3d 5472 7565   right_open=True
-0001aef0: 2920 2d20 7365 6c66 2e66 756e 6328 2a61  ) - self.func(*a
-0001af00: 7267 7329 0a20 2020 2020 2020 2020 2020  rgs).           
-0001af10: 2020 2020 2020 2020 2069 6620 6520 3d3d           if e ==
-0001af20: 206d 3a0a 2020 2020 2020 2020 2020 2020   m:.            
-0001af30: 2020 2020 2020 2020 2020 2020 6172 6773              args
-0001af40: 203d 205b 2a73 656c 662e 6172 6773 5d0a   = [*self.args].
-0001af50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001af60: 2020 2020 2020 2020 6465 6c20 6172 6773          del args
-0001af70: 5b69 5d0a 2020 2020 2020 2020 2020 2020  [i].            
-0001af80: 2020 2020 2020 2020 2020 2020 7265 7475              retu
-0001af90: 726e 206f 7468 6572 2e63 6f70 7928 7374  rn other.copy(st
-0001afa0: 6172 743d 6d2c 206c 6566 745f 6f70 656e  art=m, left_open
-0001afb0: 3d54 7275 6529 2e73 696d 706c 6966 7928  =True).simplify(
-0001afc0: 2920 2d20 7365 6c66 2e66 756e 6328 2a61  ) - self.func(*a
-0001afd0: 7267 7329 0a20 2020 2020 2020 2020 2020  rgs).           
-0001afe0: 2020 2020 2020 2020 2069 6620 6520 3e20           if e > 
-0001aff0: 4d20 6f72 2065 203c 206d 3a0a 2020 2020  M or e < m:.    
-0001b000: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001b010: 2020 2020 6172 6773 203d 205b 2a73 656c      args = [*sel
-0001b020: 662e 6172 6773 5d0a 2020 2020 2020 2020  f.args].        
-0001b030: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001b040: 6465 6c20 6172 6773 5b69 5d0a 2020 2020  del args[i].    
-0001b050: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001b060: 2020 2020 7265 7475 726e 206f 7468 6572      return other
-0001b070: 202d 2073 656c 662e 6675 6e63 282a 6172   - self.func(*ar
-0001b080: 6773 290a 2020 2020 2020 2020 2020 2020  gs).            
-0001b090: 2020 2020 7265 7475 726e 0a20 2020 2020      return.     
-0001b0a0: 2020 2020 2020 200a 2020 2020 2020 2020         .        
-0001b0b0: 2020 2020 6966 206f 7468 6572 2e65 7479      if other.ety
-0001b0c0: 7065 2e69 735f 696e 7465 6765 723a 0a20  pe.is_integer:. 
-0001b0d0: 2020 2020 2020 2020 2020 2020 2020 2069                 i
-0001b0e0: 6620 6f74 6865 722e 6d69 6e28 2920 696e  f other.min() in
-0001b0f0: 2073 656c 663a 200a 2020 2020 2020 2020   self: .        
-0001b100: 2020 2020 2020 2020 2020 2020 7265 7475              retu
-0001b110: 726e 206f 7468 6572 2e63 6f70 7928 7374  rn other.copy(st
-0001b120: 6172 743d 6f74 6865 722e 7374 6172 7420  art=other.start 
-0001b130: 2b20 3129 202d 2073 656c 662e 6675 6e63  + 1) - self.func
-0001b140: 282a 7b2a 7365 6c66 2e61 7267 737d 202d  (*{*self.args} -
-0001b150: 207b 6f74 6865 722e 6d69 6e28 297d 2920   {other.min()}) 
-0001b160: 2020 2020 2020 2020 2020 2020 2020 200a                 .
-0001b170: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001b180: 6966 206f 7468 6572 2e6d 6178 2829 2069  if other.max() i
-0001b190: 6e20 7365 6c66 3a20 0a20 2020 2020 2020  n self: .       
-0001b1a0: 2020 2020 2020 2020 2020 2020 2072 6574               ret
-0001b1b0: 7572 6e20 6f74 6865 722e 636f 7079 2873  urn other.copy(s
-0001b1c0: 746f 703d 6f74 6865 722e 7374 6f70 202d  top=other.stop -
-0001b1d0: 2031 2920 2d20 7365 6c66 2e66 756e 6328   1) - self.func(
-0001b1e0: 2a7b 2a73 656c 662e 6172 6773 7d20 2d20  *{*self.args} - 
-0001b1f0: 7b6f 7468 6572 2e6d 6178 2829 7d29 0a20  {other.max()}). 
-0001b200: 2020 2020 2020 2020 2020 200a 2020 2020             .    
-0001b210: 2020 2020 656c 6966 2069 7369 6e73 7461      elif isinsta
-0001b220: 6e63 6528 6f74 6865 722c 2046 696e 6974  nce(other, Finit
-0001b230: 6553 6574 293a 0a20 2020 2020 2020 2020  eSet):.         
-0001b240: 2020 2073 203d 2073 6574 2873 656c 662e     s = set(self.
-0001b250: 6172 6773 290a 2020 2020 2020 2020 2020  args).          
-0001b260: 2020 5f73 203d 2073 6574 286f 7468 6572    _s = set(other
-0001b270: 2e61 7267 7329 0a20 2020 2020 2020 2020  .args).         
-0001b280: 2020 200a 2020 2020 2020 2020 2020 2020     .            
-0001b290: 6173 7365 7274 2073 2061 6e64 205f 730a  assert s and _s.
-0001b2a0: 2020 2020 2020 2020 2020 2020 696e 7465              inte
-0001b2b0: 7273 6563 7469 6f6e 203d 2073 2026 205f  rsection = s & _
-0001b2c0: 730a 2320 2020 2020 2020 2020 2020 2020  s.#             
-0001b2d0: 7320 2d3d 2069 6e74 6572 7365 6374 696f  s -= intersectio
-0001b2e0: 6e0a 2020 2020 2020 2020 2020 2020 5f73  n.            _s
-0001b2f0: 202d 3d20 696e 7465 7273 6563 7469 6f6e   -= intersection
-0001b300: 0a20 2020 2020 2020 2020 2020 200a 2020  .            .  
-0001b310: 2020 2020 2020 2020 2020 756e 6b20 3d20            unk = 
-0001b320: 5b5d 0a20 2020 2020 2020 2020 2020 200a  [].            .
-0001b330: 2020 2020 2020 2020 2020 2020 666f 7220              for 
-0001b340: 6920 696e 2073 3a0a 2020 2020 2020 2020  i in s:.        
-0001b350: 2020 2020 2020 2020 6966 206e 6f74 2061          if not a
-0001b360: 6c6c 2845 7175 616c 2865 2c20 6929 2e69  ll(Equal(e, i).i
-0001b370: 735f 426f 6f6c 6561 6e46 616c 7365 2066  s_BooleanFalse f
-0001b380: 6f72 2065 2069 6e20 5f73 293a 0a20 2020  or e in _s):.   
-0001b390: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001b3a0: 2075 6e6b 2e61 7070 656e 6428 6929 0a20   unk.append(i). 
-0001b3b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001b3c0: 2020 200a 2020 2020 2020 2020 2020 2020     .            
-0001b3d0: 6966 206c 656e 2875 6e6b 2920 3d3d 206c  if len(unk) == l
-0001b3e0: 656e 2873 2920 616e 6420 6e6f 7420 696e  en(s) and not in
-0001b3f0: 7465 7273 6563 7469 6f6e 3a0a 2020 2020  tersection:.    
-0001b400: 2020 2020 2020 2020 2020 2020 7265 7475              retu
-0001b410: 726e 0a20 2020 2020 2020 2020 2020 2020  rn.             
-0001b420: 2020 200a 2020 2020 2020 2020 2020 2020     .            
-0001b430: 7265 7475 726e 2043 6f6d 706c 656d 656e  return Complemen
-0001b440: 7428 4669 6e69 7465 5365 7428 2a5f 7329  t(FiniteSet(*_s)
-0001b450: 2c20 4669 6e69 7465 5365 7428 2a75 6e6b  , FiniteSet(*unk
-0001b460: 2929 0a0a 2020 2020 2020 2020 7265 7475  ))..        retu
-0001b470: 726e 2053 6574 2e5f 636f 6d70 6c65 6d65  rn Set._compleme
-0001b480: 6e74 2873 656c 662c 206f 7468 6572 290a  nt(self, other).
-0001b490: 0a20 2020 2064 6566 205f 636f 6e74 6169  .    def _contai
-0001b4a0: 6e73 2873 656c 662c 206f 7468 6572 293a  ns(self, other):
-0001b4b0: 0a20 2020 2020 2020 2022 2222 0a20 2020  .        """.   
-0001b4c0: 2020 2020 2054 6573 7473 2077 6865 7468       Tests wheth
-0001b4d0: 6572 2061 6e20 656c 656d 656e 742c 206f  er an element, o
-0001b4e0: 7468 6572 2c20 6973 2069 6e20 7468 6520  ther, is in the 
-0001b4f0: 7365 742e 0a0a 2020 2020 2020 2020 5265  set...        Re
-0001b500: 6c69 6573 206f 6e20 5079 7468 6f6e 2773  lies on Python's
-0001b510: 2073 6574 2063 6c61 7373 2e20 5468 6973   set class. This
-0001b520: 2074 6573 7473 2066 6f72 206f 626a 6563   tests for objec
-0001b530: 7420 6571 7561 6c69 7479 0a20 2020 2020  t equality.     
-0001b540: 2020 2041 6c6c 2069 6e70 7574 7320 6172     All inputs ar
-0001b550: 6520 7379 6d70 6966 6965 640a 0a20 2020  e sympified..   
-0001b560: 2020 2020 2045 7861 6d70 6c65 730a 2020       Examples.  
-0001b570: 2020 2020 2020 3d3d 3d3d 3d3d 3d3d 0a0a        ========..
-0001b580: 2020 2020 2020 2020 3e3e 3e20 6672 6f6d          >>> from
-0001b590: 2073 796d 7079 2069 6d70 6f72 7420 4669   sympy import Fi
-0001b5a0: 6e69 7465 5365 740a 2020 2020 2020 2020  niteSet.        
-0001b5b0: 3e3e 3e20 3120 696e 2046 696e 6974 6553  >>> 1 in FiniteS
-0001b5c0: 6574 2831 2c20 3229 0a20 2020 2020 2020  et(1, 2).       
-0001b5d0: 2054 7275 650a 2020 2020 2020 2020 3e3e   True.        >>
-0001b5e0: 3e20 3520 696e 2046 696e 6974 6553 6574  > 5 in FiniteSet
-0001b5f0: 2831 2c20 3229 0a20 2020 2020 2020 2046  (1, 2).        F
-0001b600: 616c 7365 0a0a 2020 2020 2020 2020 2222  alse..        ""
-0001b610: 220a 2320 2020 2020 2020 2020 7220 3d20  ".#         r = 
-0001b620: 532e 6661 6c73 650a 2020 2020 2020 2020  S.false.        
-0001b630: 6172 6773 203d 205b 5d0a 2020 2020 2020  args = [].      
-0001b640: 2020 666f 7220 6520 696e 2073 656c 662e    for e in self.
-0001b650: 6172 6773 3a0a 2020 2020 2020 2020 2020  args:.          
-0001b660: 2020 2320 6f76 6572 7269 6465 2067 6c6f    # override glo
-0001b670: 6261 6c20 6576 616c 7561 7469 6f6e 2073  bal evaluation s
-0001b680: 6f20 7765 2063 616e 2075 7365 2045 7120  o we can use Eq 
-0001b690: 746f 2064 6f0a 2020 2020 2020 2020 2020  to do.          
-0001b6a0: 2020 2320 646f 2074 6865 2065 7661 6c75    # do the evalu
-0001b6b0: 6174 696f 6e0a 2020 2020 2020 2020 2020  ation.          
-0001b6c0: 2020 7420 3d20 4571 2865 2c20 6f74 6865    t = Eq(e, othe
-0001b6d0: 722c 2065 7661 6c75 6174 653d 5472 7565  r, evaluate=True
-0001b6e0: 290a 2020 2020 2020 2020 2020 2020 6966  ).            if
-0001b6f0: 2074 2069 7320 532e 7472 7565 3a0a 2020   t is S.true:.  
-0001b700: 2020 2020 2020 2020 2020 2020 2020 7265                re
-0001b710: 7475 726e 2074 0a20 2020 2020 2020 2020  turn t.         
-0001b720: 2020 2065 6c69 6620 7420 6973 206e 6f74     elif t is not
-0001b730: 2053 2e66 616c 7365 3a0a 2020 2020 2020   S.false:.      
-0001b740: 2020 2020 2020 2020 2020 6172 6773 2e61            args.a
-0001b750: 7070 656e 6428 7429 0a23 2020 2020 2020  ppend(t).#      
-0001b760: 2020 2020 2020 2020 2020 2072 203d 204e             r = N
-0001b770: 6f6e 650a 2020 2020 2020 2020 7265 7475  one.        retu
-0001b780: 726e 204f 7228 2a61 7267 7329 0a23 2020  rn Or(*args).#  
-0001b790: 2020 2020 2020 2072 6574 7572 6e20 720a         return r.
-0001b7a0: 0a20 2020 2040 7072 6f70 6572 7479 0a20  .    @property. 
-0001b7b0: 2020 2064 6566 205f 626f 756e 6461 7279     def _boundary
-0001b7c0: 2873 656c 6629 3a0a 2020 2020 2020 2020  (self):.        
-0001b7d0: 7265 7475 726e 2073 656c 660a 0a20 2020  return self..   
-0001b7e0: 2040 7072 6f70 6572 7479 0a20 2020 2064   @property.    d
-0001b7f0: 6566 205f 696e 6628 7365 6c66 293a 0a20  ef _inf(self):. 
-0001b800: 2020 2020 2020 2066 726f 6d20 7379 6d70         from symp
-0001b810: 792e 6675 6e63 7469 6f6e 732e 656c 656d  y.functions.elem
-0001b820: 656e 7461 7279 2e6d 6973 6365 6c6c 616e  entary.miscellan
-0001b830: 656f 7573 2069 6d70 6f72 7420 4d69 6e0a  eous import Min.
-0001b840: 2020 2020 2020 2020 7265 7475 726e 204d          return M
-0001b850: 696e 282a 7365 6c66 290a 0a20 2020 2040  in(*self)..    @
-0001b860: 7072 6f70 6572 7479 0a20 2020 2064 6566  property.    def
-0001b870: 205f 7375 7028 7365 6c66 293a 0a20 2020   _sup(self):.   
-0001b880: 2020 2020 2066 726f 6d20 7379 6d70 792e       from sympy.
-0001b890: 6675 6e63 7469 6f6e 732e 656c 656d 656e  functions.elemen
-0001b8a0: 7461 7279 2e6d 6973 6365 6c6c 616e 656f  tary.miscellaneo
-0001b8b0: 7573 2069 6d70 6f72 7420 4d61 780a 2020  us import Max.  
-0001b8c0: 2020 2020 2020 7265 7475 726e 204d 6178        return Max
-0001b8d0: 282a 7365 6c66 290a 0a20 2020 2040 7072  (*self)..    @pr
-0001b8e0: 6f70 6572 7479 0a20 2020 2064 6566 206d  operty.    def m
-0001b8f0: 6561 7375 7265 2873 656c 6629 3a0a 2020  easure(self):.  
-0001b900: 2020 2020 2020 7265 7475 726e 2030 0a0a        return 0..
-0001b910: 2020 2020 6465 6620 5f5f 6c65 6e5f 5f28      def __len__(
-0001b920: 7365 6c66 293a 0a20 2020 2020 2020 2072  self):.        r
-0001b930: 6574 7572 6e20 6c65 6e28 7365 6c66 2e61  eturn len(self.a
-0001b940: 7267 7329 0a0a 2020 2020 6465 6620 6173  rgs)..    def as
-0001b950: 5f72 656c 6174 696f 6e61 6c28 7365 6c66  _relational(self
-0001b960: 2c20 7379 6d62 6f6c 293a 0a20 2020 2020  , symbol):.     
-0001b970: 2020 2022 2222 5265 7772 6974 6520 6120     """Rewrite a 
-0001b980: 4669 6e69 7465 5365 7420 696e 2074 6572  FiniteSet in ter
-0001b990: 6d73 206f 6620 6571 7561 6c69 7469 6573  ms of equalities
-0001b9a0: 2061 6e64 206c 6f67 6963 206f 7065 7261   and logic opera
-0001b9b0: 746f 7273 2e20 2222 220a 2020 2020 2020  tors. """.      
-0001b9c0: 2020 6672 6f6d 2073 796d 7079 2e63 6f72    from sympy.cor
-0001b9d0: 652e 7265 6c61 7469 6f6e 616c 2069 6d70  e.relational imp
-0001b9e0: 6f72 7420 4571 0a20 2020 2020 2020 2072  ort Eq.        r
-0001b9f0: 6574 7572 6e20 4f72 282a 5b45 7128 7379  eturn Or(*[Eq(sy
-0001ba00: 6d62 6f6c 2c20 656c 656d 2920 666f 7220  mbol, elem) for 
-0001ba10: 656c 656d 2069 6e20 7365 6c66 5d29 0a0a  elem in self])..
-0001ba20: 2020 2020 6465 6620 636f 6d70 6172 6528      def compare(
-0001ba30: 7365 6c66 2c20 6f74 6865 7229 3a0a 2020  self, other):.  
-0001ba40: 2020 2020 2020 7265 7475 726e 2028 6861        return (ha
-0001ba50: 7368 2873 656c 6629 202d 2068 6173 6828  sh(self) - hash(
-0001ba60: 6f74 6865 7229 290a 0a20 2020 2064 6566  other))..    def
-0001ba70: 205f 6576 616c 5f65 7661 6c66 2873 656c   _eval_evalf(sel
-0001ba80: 662c 2070 7265 6329 3a0a 2020 2020 2020  f, prec):.      
-0001ba90: 2020 7265 7475 726e 2046 696e 6974 6553    return FiniteS
-0001baa0: 6574 282a 5b65 6c65 6d2e 5f65 7661 6c5f  et(*[elem._eval_
-0001bab0: 6576 616c 6628 7072 6563 2920 666f 7220  evalf(prec) for 
-0001bac0: 656c 656d 2069 6e20 7365 6c66 5d29 0a0a  elem in self])..
-0001bad0: 2020 2020 4070 726f 7065 7274 790a 2020      @property.  
-0001bae0: 2020 6465 6620 5f73 6f72 7465 645f 6172    def _sorted_ar
-0001baf0: 6773 2873 656c 6629 3a0a 2020 2020 2020  gs(self):.      
-0001bb00: 2020 7265 7475 726e 2073 656c 662e 6172    return self.ar
-0001bb10: 6773 0a0a 2020 2020 6465 6620 5f65 7661  gs..    def _eva
-0001bb20: 6c5f 706f 7765 7273 6574 2873 656c 6629  l_powerset(self)
-0001bb30: 3a0a 2020 2020 2020 2020 7265 7475 726e  :.        return
-0001bb40: 2073 656c 662e 6675 6e63 282a 5b73 656c   self.func(*[sel
-0001bb50: 662e 6675 6e63 282a 7329 2066 6f72 2073  f.func(*s) for s
-0001bb60: 2069 6e20 7375 6273 6574 7328 7365 6c66   in subsets(self
-0001bb70: 2e61 7267 7329 5d29 0a0a 2020 2020 6465  .args)])..    de
-0001bb80: 6620 5f5f 6765 5f5f 2873 656c 662c 206f  f __ge__(self, o
-0001bb90: 7468 6572 293a 0a20 2020 2020 2020 2069  ther):.        i
-0001bba0: 6620 6e6f 7420 6f74 6865 722e 6973 5f73  f not other.is_s
-0001bbb0: 6574 3a0a 2020 2020 2020 2020 2020 2020  et:.            
-0001bbc0: 7261 6973 6520 5479 7065 4572 726f 7228  raise TypeError(
-0001bbd0: 2249 6e76 616c 6964 2063 6f6d 7061 7269  "Invalid compari
-0001bbe0: 736f 6e20 6f66 2073 6574 2077 6974 6820  son of set with 
-0001bbf0: 2573 2220 2520 6675 6e63 5f6e 616d 6528  %s" % func_name(
-0001bc00: 6f74 6865 7229 290a 2020 2020 2020 2020  other)).        
-0001bc10: 7265 7475 726e 206f 7468 6572 2e69 735f  return other.is_
-0001bc20: 7375 6273 6574 2873 656c 6629 0a0a 2020  subset(self)..  
-0001bc30: 2020 6465 6620 5f5f 6774 5f5f 2873 656c    def __gt__(sel
-0001bc40: 662c 206f 7468 6572 293a 0a20 2020 2020  f, other):.     
-0001bc50: 2020 2069 6620 6e6f 7420 6f74 6865 722e     if not other.
-0001bc60: 6973 5f73 6574 3a0a 2020 2020 2020 2020  is_set:.        
-0001bc70: 2020 2020 7261 6973 6520 5479 7065 4572      raise TypeEr
-0001bc80: 726f 7228 2249 6e76 616c 6964 2063 6f6d  ror("Invalid com
-0001bc90: 7061 7269 736f 6e20 6f66 2073 6574 2077  parison of set w
-0001bca0: 6974 6820 2573 2220 2520 6675 6e63 5f6e  ith %s" % func_n
-0001bcb0: 616d 6528 6f74 6865 7229 290a 2020 2020  ame(other)).    
-0001bcc0: 2020 2020 7265 7475 726e 2073 656c 662e      return self.
-0001bcd0: 6973 5f70 726f 7065 725f 7375 7065 7273  is_proper_supers
-0001bce0: 6574 286f 7468 6572 290a 0a20 2020 2064  et(other)..    d
-0001bcf0: 6566 205f 5f6c 655f 5f28 7365 6c66 2c20  ef __le__(self, 
-0001bd00: 6f74 6865 7229 3a0a 2020 2020 2020 2020  other):.        
-0001bd10: 6966 206e 6f74 206f 7468 6572 2e69 735f  if not other.is_
-0001bd20: 7365 743a 0a20 2020 2020 2020 2020 2020  set:.           
-0001bd30: 2072 6169 7365 2054 7970 6545 7272 6f72   raise TypeError
-0001bd40: 2822 496e 7661 6c69 6420 636f 6d70 6172  ("Invalid compar
-0001bd50: 6973 6f6e 206f 6620 7365 7420 7769 7468  ison of set with
-0001bd60: 2025 7322 2025 2066 756e 635f 6e61 6d65   %s" % func_name
-0001bd70: 286f 7468 6572 2929 0a20 2020 2020 2020  (other)).       
-0001bd80: 2072 6574 7572 6e20 7365 6c66 2e69 735f   return self.is_
-0001bd90: 7375 6273 6574 286f 7468 6572 290a 0a20  subset(other).. 
-0001bda0: 2020 2064 6566 205f 5f6c 745f 5f28 7365     def __lt__(se
-0001bdb0: 6c66 2c20 6f74 6865 7229 3a0a 2020 2020  lf, other):.    
-0001bdc0: 2020 2020 6966 206e 6f74 206f 7468 6572      if not other
-0001bdd0: 2e69 735f 7365 743a 0a20 2020 2020 2020  .is_set:.       
-0001bde0: 2020 2020 2072 6169 7365 2054 7970 6545       raise TypeE
-0001bdf0: 7272 6f72 2822 496e 7661 6c69 6420 636f  rror("Invalid co
-0001be00: 6d70 6172 6973 6f6e 206f 6620 7365 7420  mparison of set 
-0001be10: 7769 7468 2025 7322 2025 2066 756e 635f  with %s" % func_
-0001be20: 6e61 6d65 286f 7468 6572 2929 0a20 2020  name(other)).   
-0001be30: 2020 2020 2072 6574 7572 6e20 7365 6c66       return self
-0001be40: 2e69 735f 7072 6f70 6572 5f73 7562 7365  .is_proper_subse
-0001be50: 7428 6f74 6865 7229 0a0a 2020 2020 6465  t(other)..    de
-0001be60: 6620 5f65 7661 6c5f 4361 7264 2873 656c  f _eval_Card(sel
-0001be70: 6629 3a0a 2020 2020 2020 2020 6c65 6e67  f):.        leng
-0001be80: 7468 203d 206c 656e 2873 656c 6629 0a20  th = len(self). 
-0001be90: 2020 2020 2020 2069 6620 6c65 6e67 7468         if length
-0001bea0: 203d 3d20 313a 0a20 2020 2020 2020 2020   == 1:.         
-0001beb0: 2020 2072 6574 7572 6e20 532e 4f6e 650a     return S.One.
-0001bec0: 2020 2020 2020 2020 6672 6f6d 2073 796d          from sym
-0001bed0: 7079 2e66 756e 6374 696f 6e73 2e65 6c65  py.functions.ele
-0001bee0: 6d65 6e74 6172 792e 7069 6563 6577 6973  mentary.piecewis
-0001bef0: 6520 696d 706f 7274 2050 6965 6365 7769  e import Piecewi
-0001bf00: 7365 0a20 2020 2020 2020 202a 2062 6566  se.        * bef
-0001bf10: 6f72 652c 206c 6173 7420 3d20 7365 6c66  ore, last = self
-0001bf20: 2e61 7267 730a 2020 2020 2020 2020 6672  .args.        fr
-0001bf30: 6f6d 2073 796d 7079 2069 6d70 6f72 7420  om sympy import 
-0001bf40: 4361 7264 0a20 2020 2020 2020 2062 6566  Card.        bef
-0001bf50: 6f72 6520 3d20 7365 6c66 2e66 756e 6328  ore = self.func(
-0001bf60: 2a62 6566 6f72 6529 0a20 2020 2020 2020  *before).       
-0001bf70: 206c 656e 6774 6820 3d20 4361 7264 2862   length = Card(b
-0001bf80: 6566 6f72 6529 0a20 2020 2020 2020 2072  efore).        r
-0001bf90: 6574 7572 6e20 5069 6563 6577 6973 6528  eturn Piecewise(
-0001bfa0: 286c 656e 6774 682c 2045 6c65 6d65 6e74  (length, Element
-0001bfb0: 286c 6173 742c 2062 6566 6f72 6529 2e73  (last, before).s
-0001bfc0: 696d 706c 6966 7928 2929 2c20 286c 656e  implify()), (len
-0001bfd0: 6774 6820 2b20 312c 2054 7275 6529 292e  gth + 1, True)).
-0001bfe0: 7369 6d70 6c69 6679 2829 0a0a 2020 2020  simplify()..    
-0001bff0: 6465 6620 5f65 7661 6c5f 6973 5f66 696e  def _eval_is_fin
-0001c000: 6974 6573 6574 2873 656c 6629 3a0a 2020  iteset(self):.  
-0001c010: 2020 2020 2020 7265 7475 726e 2054 7275        return Tru
-0001c020: 650a 0a20 2020 2064 6566 205f 6576 616c  e..    def _eval
-0001c030: 5f69 735f 6578 7465 6e64 6564 5f69 6e74  _is_extended_int
-0001c040: 6567 6572 2873 656c 6629 3a0a 2020 2020  eger(self):.    
-0001c050: 2020 2020 7265 7475 726e 2066 757a 7a79      return fuzzy
-0001c060: 5f65 7428 652e 6973 5f65 7874 656e 6465  _et(e.is_extende
-0001c070: 645f 696e 7465 6765 7220 666f 7220 6520  d_integer for e 
-0001c080: 696e 2073 656c 662e 6172 6773 290a 2020  in self.args).  
-0001c090: 2020 0a20 2020 2064 6566 205f 6576 616c    .    def _eval
-0001c0a0: 5f69 735f 7375 7065 725f 696e 7465 6765  _is_super_intege
-0001c0b0: 7228 7365 6c66 293a 0a20 2020 2020 2020  r(self):.       
-0001c0c0: 2072 6574 7572 6e20 6675 7a7a 795f 6574   return fuzzy_et
-0001c0d0: 2865 2e69 735f 7375 7065 725f 696e 7465  (e.is_super_inte
-0001c0e0: 6765 7220 666f 7220 6520 696e 2073 656c  ger for e in sel
-0001c0f0: 662e 6172 6773 290a 2020 2020 0a20 2020  f.args).    .   
-0001c100: 2064 6566 205f 6576 616c 5f69 735f 6578   def _eval_is_ex
-0001c110: 7465 6e64 6564 5f72 6174 696f 6e61 6c28  tended_rational(
-0001c120: 7365 6c66 293a 0a20 2020 2020 2020 2072  self):.        r
-0001c130: 6574 7572 6e20 6675 7a7a 795f 6574 2865  eturn fuzzy_et(e
-0001c140: 2e69 735f 6578 7465 6e64 6564 5f72 6174  .is_extended_rat
-0001c150: 696f 6e61 6c20 666f 7220 6520 696e 2073  ional for e in s
-0001c160: 656c 662e 6172 6773 290a 2020 2020 0a20  elf.args).    . 
-0001c170: 2020 2064 6566 205f 6576 616c 5f69 735f     def _eval_is_
-0001c180: 7375 7065 725f 7261 7469 6f6e 616c 2873  super_rational(s
-0001c190: 656c 6629 3a0a 2020 2020 2020 2020 7265  elf):.        re
-0001c1a0: 7475 726e 2066 757a 7a79 5f65 7428 652e  turn fuzzy_et(e.
-0001c1b0: 6973 5f73 7570 6572 5f72 6174 696f 6e61  is_super_rationa
-0001c1c0: 6c20 666f 7220 6520 696e 2073 656c 662e  l for e in self.
-0001c1d0: 6172 6773 290a 0a20 2020 2064 6566 205f  args)..    def _
-0001c1e0: 6576 616c 5f69 735f 6879 7065 725f 7261  eval_is_hyper_ra
-0001c1f0: 7469 6f6e 616c 2873 656c 6629 3a0a 2020  tional(self):.  
-0001c200: 2020 2020 2020 7265 7475 726e 2066 757a        return fuz
-0001c210: 7a79 5f65 7428 652e 6973 5f68 7970 6572  zy_et(e.is_hyper
-0001c220: 5f72 6174 696f 6e61 6c20 666f 7220 6520  _rational for e 
-0001c230: 696e 2073 656c 662e 6172 6773 290a 2020  in self.args).  
-0001c240: 2020 0a20 2020 2064 6566 205f 6576 616c    .    def _eval
-0001c250: 5f69 735f 6578 7465 6e64 6564 5f72 6561  _is_extended_rea
-0001c260: 6c28 7365 6c66 293a 0a20 2020 2020 2020  l(self):.       
-0001c270: 2072 6574 7572 6e20 6675 7a7a 795f 6574   return fuzzy_et
-0001c280: 2865 2e69 735f 6578 7465 6e64 6564 5f72  (e.is_extended_r
-0001c290: 6561 6c20 666f 7220 6520 696e 2073 656c  eal for e in sel
-0001c2a0: 662e 6172 6773 2920 0a0a 2020 2020 6465  f.args) ..    de
-0001c2b0: 6620 5f65 7661 6c5f 6973 5f68 7970 6572  f _eval_is_hyper
-0001c2c0: 5f72 6561 6c28 7365 6c66 293a 0a20 2020  _real(self):.   
-0001c2d0: 2020 2020 2072 6574 7572 6e20 6675 7a7a       return fuzz
-0001c2e0: 795f 6574 2865 2e69 735f 6879 7065 725f  y_et(e.is_hyper_
-0001c2f0: 7265 616c 2066 6f72 2065 2069 6e20 7365  real for e in se
-0001c300: 6c66 2e61 7267 7329 0a20 2020 200a 2020  lf.args).    .  
-0001c310: 2020 6465 6620 5f65 7661 6c5f 6973 5f73    def _eval_is_s
-0001c320: 7570 6572 5f72 6561 6c28 7365 6c66 293a  uper_real(self):
-0001c330: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
-0001c340: 6675 7a7a 795f 6574 2865 2e69 735f 7375  fuzzy_et(e.is_su
-0001c350: 7065 725f 7265 616c 2066 6f72 2065 2069  per_real for e i
-0001c360: 6e20 7365 6c66 2e61 7267 7329 0a20 2020  n self.args).   
-0001c370: 200a 2020 2020 6465 6620 5f65 7661 6c5f   .    def _eval_
-0001c380: 6973 5f65 7874 656e 6465 645f 636f 6d70  is_extended_comp
-0001c390: 6c65 7828 7365 6c66 293a 0a20 2020 2020  lex(self):.     
-0001c3a0: 2020 2072 6574 7572 6e20 6675 7a7a 795f     return fuzzy_
-0001c3b0: 6574 2865 2e69 735f 6578 7465 6e64 6564  et(e.is_extended
-0001c3c0: 5f63 6f6d 706c 6578 2066 6f72 2065 2069  _complex for e i
-0001c3d0: 6e20 7365 6c66 2e61 7267 7329 0a20 2020  n self.args).   
-0001c3e0: 2020 0a20 2020 2064 6566 205f 6576 616c    .    def _eval
-0001c3f0: 5f69 735f 6879 7065 725f 636f 6d70 6c65  _is_hyper_comple
-0001c400: 7828 7365 6c66 293a 0a20 2020 2020 2020  x(self):.       
-0001c410: 2072 6574 7572 6e20 6675 7a7a 795f 6574   return fuzzy_et
-0001c420: 2865 2e69 735f 6879 7065 725f 636f 6d70  (e.is_hyper_comp
-0001c430: 6c65 7820 666f 7220 6520 696e 2073 656c  lex for e in sel
-0001c440: 662e 6172 6773 290a 2020 2020 0a20 2020  f.args).    .   
-0001c450: 2040 7072 6f70 6572 7479 0a20 2020 2064   @property.    d
-0001c460: 6566 2065 7479 7065 2873 656c 6629 3a0a  ef etype(self):.
-0001c470: 2020 2020 2020 2020 6474 7970 6520 3d20          dtype = 
-0001c480: 4e6f 6e65 0a20 2020 2020 2020 2066 6f72  None.        for
-0001c490: 2065 2069 6e20 7365 6c66 3a0a 2020 2020   e in self:.    
-0001c4a0: 2020 2020 2020 2020 5f64 7479 7065 203d          _dtype =
-0001c4b0: 2065 2e74 7970 650a 2020 2020 2020 2020   e.type.        
-0001c4c0: 2020 2020 6966 2064 7479 7065 2069 7320      if dtype is 
-0001c4d0: 4e6f 6e65 3a0a 2020 2020 2020 2020 2020  None:.          
-0001c4e0: 2020 2020 2020 6474 7970 6520 3d20 5f64        dtype = _d
-0001c4f0: 7479 7065 0a20 2020 2020 2020 2020 2020  type.           
-0001c500: 2020 2020 2063 6f6e 7469 6e75 650a 2020       continue.  
-0001c510: 2020 2020 2020 2020 2020 6966 2064 7479            if dty
-0001c520: 7065 2021 3d20 5f64 7479 7065 3a0a 2020  pe != _dtype:.  
-0001c530: 2020 2020 2020 2020 2020 2020 2020 6966                if
-0001c540: 2064 7479 7065 2069 6e20 5f64 7479 7065   dtype in _dtype
-0001c550: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-0001c560: 2020 2020 2020 6474 7970 6520 3d20 5f64        dtype = _d
-0001c570: 7479 7065 0a20 2020 2020 2020 2020 2020  type.           
-0001c580: 2020 2020 2065 6c69 6620 5f64 7479 7065       elif _dtype
-0001c590: 2069 6e20 6474 7970 653a 0a20 2020 2020   in dtype:.     
-0001c5a0: 2020 2020 2020 2020 2020 2020 2020 202e                 .
-0001c5b0: 2e2e 0a20 2020 2020 2020 2020 2020 2020  ...             
-0001c5c0: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
-0001c5d0: 2020 2020 2020 2020 2020 2020 2072 6169               rai
-0001c5e0: 7365 2045 7863 6570 7469 6f6e 2827 696e  se Exception('in
-0001c5f0: 636f 6e73 6973 7465 6e74 2064 7479 7065  consistent dtype
-0001c600: 2064 6574 6563 7465 643a 2025 7320 213d   detected: %s !=
-0001c610: 2025 7327 2025 2028 6474 7970 652c 205f   %s' % (dtype, _
-0001c620: 6474 7970 6529 290a 2020 2020 2020 2020  dtype)).        
-0001c630: 7265 7475 726e 2064 7479 7065 0a0a 2020  return dtype..  
-0001c640: 2020 6465 6620 6d69 6e28 7365 6c66 293a    def min(self):
-0001c650: 0a20 2020 2020 2020 2066 726f 6d20 7379  .        from sy
-0001c660: 6d70 792e 6675 6e63 7469 6f6e 732e 656c  mpy.functions.el
-0001c670: 656d 656e 7461 7279 2e6d 6973 6365 6c6c  ementary.miscell
-0001c680: 616e 656f 7573 2069 6d70 6f72 7420 4d69  aneous import Mi
-0001c690: 6e0a 2020 2020 2020 2020 7265 7475 726e  n.        return
-0001c6a0: 204d 696e 282a 7365 6c66 2e61 7267 7329   Min(*self.args)
-0001c6b0: 2020 2020 2020 2020 0a0a 2020 2020 6465          ..    de
-0001c6c0: 6620 6d61 7828 7365 6c66 293a 0a20 2020  f max(self):.   
-0001c6d0: 2020 2020 2066 726f 6d20 7379 6d70 792e       from sympy.
-0001c6e0: 6675 6e63 7469 6f6e 732e 656c 656d 656e  functions.elemen
-0001c6f0: 7461 7279 2e6d 6973 6365 6c6c 616e 656f  tary.miscellaneo
-0001c700: 7573 2069 6d70 6f72 7420 4d61 780a 2020  us import Max.  
-0001c710: 2020 2020 2020 7265 7475 726e 204d 6178        return Max
-0001c720: 282a 7365 6c66 2e61 7267 7329 2020 2020  (*self.args)    
-0001c730: 2020 2020 0a0a 2020 2020 6465 6620 5f5f      ..    def __
-0001c740: 6164 645f 5f28 7365 6c66 2c20 6f74 6865  add__(self, othe
-0001c750: 7229 3a0a 2020 2020 2020 2020 6966 206f  r):.        if o
-0001c760: 7468 6572 2e69 735f 7365 743a 0a20 2020  ther.is_set:.   
-0001c770: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
-0001c780: 556e 696f 6e28 2a28 6f74 6865 7220 2b20  Union(*(other + 
-0001c790: 6172 6720 666f 7220 6172 6720 696e 2073  arg for arg in s
-0001c7a0: 656c 662e 6172 6773 2929 0a20 2020 2020  elf.args)).     
-0001c7b0: 2020 2072 6574 7572 6e20 7365 6c66 2e66     return self.f
-0001c7c0: 756e 6328 2a28 6172 6720 2b20 6f74 6865  unc(*(arg + othe
-0001c7d0: 7220 666f 7220 6172 6720 696e 2073 656c  r for arg in sel
-0001c7e0: 662e 6172 6773 2929 0a0a 2020 2020 6465  f.args))..    de
-0001c7f0: 6620 5f5f 6e65 675f 5f28 7365 6c66 293a  f __neg__(self):
-0001c800: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
-0001c810: 7365 6c66 2e66 756e 6328 2a28 2d61 7267  self.func(*(-arg
-0001c820: 2066 6f72 2061 7267 2069 6e20 7365 6c66   for arg in self
-0001c830: 2e61 7267 7329 290a 2020 2020 0a20 2020  .args)).    .   
-0001c840: 2064 6566 2068 616e 646c 655f 6669 6e69   def handle_fini
-0001c850: 7465 5f73 6574 7328 7365 6c66 2c20 756e  te_sets(self, un
-0001c860: 6b29 3a0a 2020 2020 2020 2020 6966 206c  k):.        if l
-0001c870: 656e 2875 6e6b 2920 3d3d 206c 656e 2873  en(unk) == len(s
-0001c880: 656c 6629 203d 3d20 313a 0a20 2020 2020  elf) == 1:.     
-0001c890: 2020 2020 2020 2072 6574 7572 6e20 496e         return In
-0001c8a0: 7465 7273 6563 7469 6f6e 2875 6e6b 2c20  tersection(unk, 
-0001c8b0: 7365 6c66 2c20 6576 616c 7561 7465 3d46  self, evaluate=F
-0001c8c0: 616c 7365 290a 0a20 2020 2040 6361 6368  alse)..    @cach
-0001c8d0: 6569 740a 2020 2020 6465 6620 5f65 7661  eit.    def _eva
-0001c8e0: 6c5f 646f 6d61 696e 5f64 6566 696e 6564  l_domain_defined
-0001c8f0: 2873 656c 662c 2078 2c20 2a2a 5f29 3a0a  (self, x, **_):.
-0001c900: 2020 2020 2020 2020 646f 6d61 696e 203d          domain =
-0001c910: 2053 6574 2e5f 6576 616c 5f64 6f6d 6169   Set._eval_domai
-0001c920: 6e5f 6465 6669 6e65 6428 7365 6c66 2c20  n_defined(self, 
-0001c930: 7829 2020 2020 2020 2020 0a20 2020 2020  x)        .     
-0001c940: 2020 2066 6f72 2061 7267 2069 6e20 7365     for arg in se
-0001c950: 6c66 2e61 7267 733a 0a20 2020 2020 2020  lf.args:.       
-0001c960: 2020 2020 2064 6f6d 6169 6e20 263d 2061       domain &= a
-0001c970: 7267 2e64 6f6d 6169 6e5f 6465 6669 6e65  rg.domain_define
-0001c980: 6428 7829 2020 2020 2020 2020 0a20 2020  d(x)        .   
-0001c990: 2020 2020 2072 6574 7572 6e20 646f 6d61       return doma
-0001c9a0: 696e 0a0a 2020 2020 6465 6620 7375 6d28  in..    def sum(
-0001c9b0: 7365 6c66 293a 0a20 2020 2020 2020 2023  self):.        #
-0001c9c0: 2072 6574 7572 6e20 7468 6520 7375 6d20   return the sum 
-0001c9d0: 6f66 2065 6c65 6d65 6e74 7320 696e 2074  of elements in t
-0001c9e0: 6865 2066 696e 6974 6573 6574 0a20 2020  he finiteset.   
-0001c9f0: 2020 2020 206c 656e 6774 6820 3d20 6c65       length = le
-0001ca00: 6e28 7365 6c66 290a 2020 2020 2020 2020  n(self).        
-0001ca10: 6966 206c 656e 6774 6820 3d3d 2031 3a0a  if length == 1:.
-0001ca20: 2020 2020 2020 2020 2020 2020 7265 7475              retu
-0001ca30: 726e 2073 656c 662e 6172 670a 2020 2020  rn self.arg.    
-0001ca40: 2020 2020 6672 6f6d 2073 796d 7079 2e66      from sympy.f
-0001ca50: 756e 6374 696f 6e73 2e65 6c65 6d65 6e74  unctions.element
-0001ca60: 6172 792e 7069 6563 6577 6973 6520 696d  ary.piecewise im
-0001ca70: 706f 7274 2050 6965 6365 7769 7365 0a20  port Piecewise. 
-0001ca80: 2020 2020 2020 202a 2062 6566 6f72 652c         * before,
-0001ca90: 206c 6173 7420 3d20 7365 6c66 2e61 7267   last = self.arg
-0001caa0: 730a 2020 2020 2020 2020 6265 666f 7265  s.        before
-0001cab0: 203d 2073 656c 662e 6675 6e63 282a 6265   = self.func(*be
-0001cac0: 666f 7265 290a 2020 2020 2020 2020 7375  fore).        su
-0001cad0: 6d5f 6f66 5f62 6566 6f72 6520 3d20 6265  m_of_before = be
-0001cae0: 666f 7265 2e73 756d 2829 0a20 2020 2020  fore.sum().     
-0001caf0: 2020 2072 6574 7572 6e20 5069 6563 6577     return Piecew
-0001cb00: 6973 6528 2873 756d 5f6f 665f 6265 666f  ise((sum_of_befo
-0001cb10: 7265 2c20 456c 656d 656e 7428 6c61 7374  re, Element(last
-0001cb20: 2c20 6265 666f 7265 292e 7369 6d70 6c69  , before).simpli
-0001cb30: 6679 2829 292c 2028 7375 6d5f 6f66 5f62  fy()), (sum_of_b
-0001cb40: 6566 6f72 6520 2b20 6c61 7374 2c20 5472  efore + last, Tr
-0001cb50: 7565 2929 2e73 696d 706c 6966 7928 290a  ue)).simplify().
-0001cb60: 0a20 2020 2040 636c 6173 736d 6574 686f  .    @classmetho
-0001cb70: 640a 2020 2020 6465 6620 7369 6d70 6c69  d.    def simpli
-0001cb80: 6679 5f45 7175 616c 2863 6c73 2c20 7365  fy_Equal(cls, se
-0001cb90: 6c66 2c20 6c68 732c 2072 6873 293a 0a20  lf, lhs, rhs):. 
-0001cba0: 2020 2020 2020 2022 2222 0a20 2020 2020         """.     
-0001cbb0: 2020 2070 7265 636f 6e64 6974 696f 6e3a     precondition:
-0001cbc0: 2073 656c 662e 6c68 7320 6973 2061 2046   self.lhs is a F
-0001cbd0: 696e 6974 6553 6574 206f 626a 6563 7421  initeSet object!
-0001cbe0: 0a20 2020 2020 2020 2022 2222 0a20 2020  .        """.   
-0001cbf0: 2020 2020 2069 6620 7268 732e 6973 5f46       if rhs.is_F
-0001cc00: 696e 6974 6553 6574 3a0a 2020 2020 2020  initeSet:.      
-0001cc10: 2020 2020 2020 6966 206c 656e 286c 6873        if len(lhs
-0001cc20: 2920 3d3d 206c 656e 2872 6873 2920 3d3d  ) == len(rhs) ==
-0001cc30: 2031 3a0a 2020 2020 2020 2020 2020 2020   1:.            
-0001cc40: 2020 2020 7265 7475 726e 2073 656c 662e      return self.
-0001cc50: 6675 6e63 286c 6873 2e61 7267 2c20 7268  func(lhs.arg, rh
-0001cc60: 732e 6172 6729 0a20 2020 2020 2020 200a  s.arg).        .
-0001cc70: 2020 2020 4063 6c61 7373 6d65 7468 6f64      @classmethod
-0001cc80: 0a20 2020 2064 6566 2073 696d 706c 6966  .    def simplif
-0001cc90: 795f 456c 656d 656e 7428 636c 732c 2073  y_Element(cls, s
-0001cca0: 656c 662c 2065 2c20 7329 3a0a 2020 2020  elf, e, s):.    
-0001ccb0: 2020 2020 2222 220a 2020 2020 2020 2020      """.        
-0001ccc0: 7072 6563 6f6e 6469 7469 6f6e 3a20 7365  precondition: se
-0001ccd0: 6c66 2e6c 6873 2069 7320 6120 4669 6e69  lf.lhs is a Fini
-0001cce0: 7465 5365 7420 6f62 6a65 6374 210a 2020  teSet object!.  
-0001ccf0: 2020 2020 2020 2222 220a 2020 2020 2020        """.      
-0001cd00: 2020 6966 206c 656e 2873 2920 3d3d 2031    if len(s) == 1
-0001cd10: 3a0a 2020 2020 2020 2020 2020 2020 792c  :.            y,
-0001cd20: 202a 5f20 3d20 730a 2020 2020 2020 2020   *_ = s.        
-0001cd30: 2020 2020 6966 206e 6f74 2065 2e5f 6861      if not e._ha
-0001cd40: 7328 5379 6d62 6f6c 2920 616e 6420 792e  s(Symbol) and y.
-0001cd50: 5f68 6173 2853 796d 626f 6c29 3a0a 2020  _has(Symbol):.  
-0001cd60: 2020 2020 2020 2020 2020 2020 2020 7265                re
-0001cd70: 7475 726e 2045 7175 616c 2879 2c20 6529  turn Equal(y, e)
-0001cd80: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
-0001cd90: 7572 6e20 4571 7561 6c28 652c 2079 290a  urn Equal(e, y).
-0001cda0: 0a20 2020 2040 636c 6173 736d 6574 686f  .    @classmetho
-0001cdb0: 640a 2020 2020 6465 6620 7369 6d70 6c69  d.    def simpli
-0001cdc0: 6679 5f4e 6f74 456c 656d 656e 7428 636c  fy_NotElement(cl
-0001cdd0: 732c 2073 656c 662c 2065 2c20 7329 3a0a  s, self, e, s):.
-0001cde0: 2020 2020 2020 2020 2222 220a 2020 2020          """.    
-0001cdf0: 2020 2020 7072 6563 6f6e 6469 7469 6f6e      precondition
-0001ce00: 3a20 7365 6c66 2e6c 6873 2069 7320 6120  : self.lhs is a 
-0001ce10: 4669 6e69 7465 5365 7420 6f62 6a65 6374  FiniteSet object
-0001ce20: 210a 2020 2020 2020 2020 2222 220a 2020  !.        """.  
-0001ce30: 2020 2020 2020 6672 6f6d 2073 796d 7079        from sympy
-0001ce40: 2069 6d70 6f72 7420 556e 6571 7561 6c0a   import Unequal.
-0001ce50: 2020 2020 2020 2020 6966 206c 656e 2873          if len(s
-0001ce60: 2920 3d3d 2031 3a0a 2020 2020 2020 2020  ) == 1:.        
-0001ce70: 2020 2020 792c 202a 5f20 3d20 730a 2020      y, *_ = s.  
-0001ce80: 2020 2020 2020 2020 2020 7265 7475 726e            return
-0001ce90: 2055 6e65 7175 616c 2865 2c20 7929 0a20   Unequal(e, y). 
-0001cea0: 2020 2020 2020 2072 6574 7572 6e20 416e         return An
-0001ceb0: 6428 2a28 556e 6571 7561 6c28 652c 2079  d(*(Unequal(e, y
-0001cec0: 2920 666f 7220 7920 696e 2073 2929 0a0a  ) for y in s))..
-0001ced0: 2020 2020 6465 6620 5f65 7661 6c5f 5375      def _eval_Su
-0001cee0: 6273 6574 5f72 6576 6572 7365 6428 7365  bset_reversed(se
-0001cef0: 6c66 2c20 6c68 7329 3a0a 2020 2020 2020  lf, lhs):.      
-0001cf00: 2020 6966 206c 6873 2e69 735f 556e 6976    if lhs.is_Univ
-0001cf10: 6572 7361 6c53 6574 3a0a 2020 2020 2020  ersalSet:.      
-0001cf20: 2020 2020 2020 7265 7475 726e 2053 2e66        return S.f
-0001cf30: 616c 7365 0a20 2020 200a 0a66 726f 6d20  alse.    ..from 
-0001cf40: 7379 6d70 792e 636f 7265 2e73 796d 7069  sympy.core.sympi
-0001cf50: 6679 2069 6d70 6f72 7420 636f 6e76 6572  fy import conver
-0001cf60: 7465 720a 636f 6e76 6572 7465 725b 7365  ter.converter[se
-0001cf70: 745d 203d 206c 616d 6264 6120 783a 2046  t] = lambda x: F
-0001cf80: 696e 6974 6553 6574 282a 7829 0a63 6f6e  initeSet(*x).con
-0001cf90: 7665 7274 6572 5b66 726f 7a65 6e73 6574  verter[frozenset
-0001cfa0: 5d20 3d20 6c61 6d62 6461 2078 3a20 4669  ] = lambda x: Fi
-0001cfb0: 6e69 7465 5365 7428 2a78 290a 0a0a 636c  niteSet(*x)...cl
-0001cfc0: 6173 7320 5379 6d6d 6574 7269 6344 6966  ass SymmetricDif
-0001cfd0: 6665 7265 6e63 6528 5365 7429 3a0a 2020  ference(Set):.  
-0001cfe0: 2020 2222 2252 6570 7265 7365 6e74 7320    """Represents 
-0001cff0: 7468 6520 7365 7420 6f66 2065 6c65 6d65  the set of eleme
-0001d000: 6e74 7320 7768 6963 6820 6172 6520 696e  nts which are in
-0001d010: 2065 6974 6865 7220 6f66 2074 6865 0a20   either of the. 
-0001d020: 2020 2073 6574 7320 616e 6420 6e6f 7420     sets and not 
-0001d030: 696e 2074 6865 6972 2069 6e74 6572 7365  in their interse
-0001d040: 6374 696f 6e2e 0a0a 2020 2020 4578 616d  ction...    Exam
-0001d050: 706c 6573 0a20 2020 203d 3d3d 3d3d 3d3d  ples.    =======
-0001d060: 3d0a 0a20 2020 203e 3e3e 2066 726f 6d20  =..    >>> from 
-0001d070: 7379 6d70 7920 696d 706f 7274 2053 796d  sympy import Sym
-0001d080: 6d65 7472 6963 4469 6666 6572 656e 6365  metricDifference
-0001d090: 2c20 4669 6e69 7465 5365 740a 2020 2020  , FiniteSet.    
-0001d0a0: 3e3e 3e20 5379 6d6d 6574 7269 6344 6966  >>> SymmetricDif
-0001d0b0: 6665 7265 6e63 6528 4669 6e69 7465 5365  ference(FiniteSe
-0001d0c0: 7428 312c 2032 2c20 3329 2c20 4669 6e69  t(1, 2, 3), Fini
-0001d0d0: 7465 5365 7428 332c 2034 2c20 3529 290a  teSet(3, 4, 5)).
-0001d0e0: 2020 2020 4669 6e69 7465 5365 7428 312c      FiniteSet(1,
-0001d0f0: 2032 2c20 342c 2035 290a 0a20 2020 2053   2, 4, 5)..    S
-0001d100: 6565 2041 6c73 6f0a 2020 2020 3d3d 3d3d  ee Also.    ====
-0001d110: 3d3d 3d3d 0a0a 2020 2020 436f 6d70 6c65  ====..    Comple
-0001d120: 6d65 6e74 2c20 556e 696f 6e0a 0a20 2020  ment, Union..   
-0001d130: 2052 6566 6572 656e 6365 730a 2020 2020   References.    
-0001d140: 3d3d 3d3d 3d3d 3d3d 3d3d 0a0a 2020 2020  ==========..    
-0001d150: 2e2e 205b 315d 2068 7474 7073 3a2f 2f65  .. [1] https://e
-0001d160: 6e2e 7769 6b69 7065 6469 612e 6f72 672f  n.wikipedia.org/
-0001d170: 7769 6b69 2f53 796d 6d65 7472 6963 5f64  wiki/Symmetric_d
-0001d180: 6966 6665 7265 6e63 650a 2020 2020 2222  ifference.    ""
-0001d190: 220a 0a20 2020 2069 735f 5379 6d6d 6574  "..    is_Symmet
-0001d1a0: 7269 6344 6966 6665 7265 6e63 6520 3d20  ricDifference = 
-0001d1b0: 5472 7565 0a0a 2020 2020 6465 6620 5f5f  True..    def __
-0001d1c0: 6e65 775f 5f28 636c 732c 2061 2c20 622c  new__(cls, a, b,
-0001d1d0: 2065 7661 6c75 6174 653d 5472 7565 293a   evaluate=True):
-0001d1e0: 0a20 2020 2020 2020 2069 6620 6576 616c  .        if eval
-0001d1f0: 7561 7465 3a0a 2020 2020 2020 2020 2020  uate:.          
-0001d200: 2020 7265 7475 726e 2053 796d 6d65 7472    return Symmetr
-0001d210: 6963 4469 6666 6572 656e 6365 2e72 6564  icDifference.red
-0001d220: 7563 6528 612c 2062 290a 0a20 2020 2020  uce(a, b)..     
-0001d230: 2020 2072 6574 7572 6e20 4261 7369 632e     return Basic.
-0001d240: 5f5f 6e65 775f 5f28 636c 732c 2061 2c20  __new__(cls, a, 
-0001d250: 6229 0a0a 2020 2020 4073 7461 7469 636d  b)..    @staticm
-0001d260: 6574 686f 640a 2020 2020 6465 6620 7265  ethod.    def re
-0001d270: 6475 6365 2841 2c20 4229 3a0a 2020 2020  duce(A, B):.    
-0001d280: 2020 2020 7265 7375 6c74 203d 2042 2e5f      result = B._
-0001d290: 7379 6d6d 6574 7269 635f 6469 6666 6572  symmetric_differ
-0001d2a0: 656e 6365 2841 290a 2020 2020 2020 2020  ence(A).        
-0001d2b0: 6966 2072 6573 756c 7420 6973 206e 6f74  if result is not
-0001d2c0: 204e 6f6e 653a 0a20 2020 2020 2020 2020   None:.         
-0001d2d0: 2020 2072 6574 7572 6e20 7265 7375 6c74     return result
-0001d2e0: 0a20 2020 2020 2020 2065 6c73 653a 0a20  .        else:. 
-0001d2f0: 2020 2020 2020 2020 2020 2072 6574 7572             retur
-0001d300: 6e20 5379 6d6d 6574 7269 6344 6966 6665  n SymmetricDiffe
-0001d310: 7265 6e63 6528 412c 2042 2c20 6576 616c  rence(A, B, eval
-0001d320: 7561 7465 3d46 616c 7365 290a 0a0a 6465  uate=False)...de
-0001d330: 6620 696d 6167 6573 6574 2873 796d 2c20  f imageset(sym, 
-0001d340: 6578 7072 2c20 6261 7365 7365 7429 3a0a  expr, baseset):.
-0001d350: 2020 2020 6672 6f6d 2073 796d 7079 2e63      from sympy.c
-0001d360: 6f6e 6372 6574 652e 7365 7473 2069 6d70  oncrete.sets imp
-0001d370: 6f72 7420 4375 700a 2020 2020 6966 2062  ort Cup.    if b
-0001d380: 6173 6573 6574 2e69 735f 5261 6e67 653a  aseset.is_Range:
-0001d390: 0a20 2020 2020 2020 206c 696d 6974 203d  .        limit =
-0001d3a0: 2028 7379 6d2c 2062 6173 6573 6574 2e6d   (sym, baseset.m
-0001d3b0: 696e 2829 2c20 6261 7365 7365 742e 6d61  in(), baseset.ma
-0001d3c0: 7828 2920 2b20 3129 0a20 2020 2065 6c69  x() + 1).    eli
-0001d3d0: 6620 6261 7365 7365 742e 6973 5f45 6c65  f baseset.is_Ele
-0001d3e0: 6d65 6e74 2061 6e64 2062 6173 6573 6574  ment and baseset
-0001d3f0: 2e6c 6873 203d 3d20 7379 6d3a 0a20 2020  .lhs == sym:.   
-0001d400: 2020 2020 206c 696d 6974 203d 2028 7379       limit = (sy
-0001d410: 6d2c 2062 6173 6573 6574 2e72 6873 290a  m, baseset.rhs).
-0001d420: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
-0001d430: 2020 6c69 6d69 7420 3d20 2873 796d 2c20    limit = (sym, 
-0001d440: 6261 7365 7365 7429 0a20 2020 2072 6574  baseset).    ret
-0001d450: 7572 6e20 4375 7028 7b65 7870 727d 2c20  urn Cup({expr}, 
-0001d460: 6c69 6d69 7429 0a0a 0a23 2062 7920 6465  limit)...# by de
-0001d470: 6669 6e69 7469 6f6e 2c20 7765 2068 6176  finition, we hav
-0001d480: 650a 2320 436f 6e64 6974 696f 6e53 6574  e.# ConditionSet
-0001d490: 2876 6172 6961 626c 652c 2063 6f6e 6469  (variable, condi
-0001d4a0: 7469 6f6e 2c20 6261 7365 5f73 6574 2920  tion, base_set) 
-0001d4b0: 3d3d 2055 6e69 6f6e 5b76 6172 6961 626c  == Union[variabl
-0001d4c0: 653a 636f 6e64 6974 696f 6e3a 6261 7365  e:condition:base
-0001d4d0: 5f73 6574 5d28 7b76 6172 6961 626c 657d  _set]({variable}
-0001d4e0: 290a 6465 6620 636f 6e64 6974 696f 6e73  ).def conditions
-0001d4f0: 6574 282a 6c69 6d69 7429 3a0a 2020 2020  et(*limit):.    
-0001d500: 6672 6f6d 2073 796d 7079 2e63 6f6e 6372  from sympy.concr
-0001d510: 6574 652e 7365 7473 2069 6d70 6f72 7420  ete.sets import 
-0001d520: 4375 700a 2020 2020 6966 206c 656e 286c  Cup.    if len(l
-0001d530: 696d 6974 2920 3e20 3220 616e 6420 286c  imit) > 2 and (l
-0001d540: 696d 6974 5b32 5d20 6973 204e 6f6e 6520  imit[2] is None 
-0001d550: 6f72 206c 696d 6974 5b32 5d2e 6973 5f55  or limit[2].is_U
-0001d560: 6e69 7665 7273 616c 5365 7429 3a0a 2020  niversalSet):.  
-0001d570: 2020 2020 2020 6c69 6d69 7420 3d20 6c69        limit = li
-0001d580: 6d69 745b 3a32 5d0a 2020 2020 7661 7269  mit[:2].    vari
-0001d590: 6162 6c65 2c20 636f 6e64 6974 696f 6e2c  able, condition,
-0001d5a0: 202a 6261 7365 5f73 6574 203d 206c 696d   *base_set = lim
-0001d5b0: 6974 0a20 2020 2069 6620 6261 7365 5f73  it.    if base_s
-0001d5c0: 6574 3a0a 2020 2020 2020 2020 6261 7365  et:.        base
-0001d5d0: 5f73 6574 203d 2062 6173 655f 7365 745b  _set = base_set[
-0001d5e0: 305d 0a20 2020 2020 2020 2069 6620 6e6f  0].        if no
-0001d5f0: 7420 6261 7365 5f73 6574 3a0a 2020 2020  t base_set:.    
-0001d600: 2020 2020 2020 2020 7265 7475 726e 2062          return b
-0001d610: 6173 655f 7365 740a 2020 2020 656c 7365  ase_set.    else
-0001d620: 3a0a 2020 2020 2020 2020 6261 7365 5f73  :.        base_s
-0001d630: 6574 203d 2076 6172 6961 626c 652e 756e  et = variable.un
-0001d640: 6976 6572 7361 6c53 6574 0a20 2020 2020  iversalSet.     
-0001d650: 2020 0a20 2020 2069 6620 636f 6e64 6974    .    if condit
-0001d660: 696f 6e3a 0a20 2020 2020 2020 2072 6574  ion:.        ret
-0001d670: 7572 6e20 6261 7365 5f73 6574 0a20 2020  urn base_set.   
-0001d680: 2069 6620 636f 6e64 6974 696f 6e2e 6973   if condition.is
-0001d690: 5f42 6f6f 6c65 616e 4661 6c73 653a 0a20  _BooleanFalse:. 
-0001d6a0: 2020 2020 2020 2072 6574 7572 6e20 7661         return va
-0001d6b0: 7269 6162 6c65 2e65 6d70 7479 5365 740a  riable.emptySet.
-0001d6c0: 0a20 2020 2072 6574 7572 6e20 4375 7028  .    return Cup(
-0001d6d0: 7b76 6172 6961 626c 657d 2c20 6c69 6d69  {variable}, limi
-0001d6e0: 7429 0a0a 0a64 6566 205f 696d 6167 6573  t)...def _images
-0001d6f0: 6574 282a 6172 6773 293a 0a20 2020 2072  et(*args):.    r
-0001d700: 2222 220a 2020 2020 5265 7475 726e 2061  """.    Return a
-0001d710: 6e20 696d 6167 6520 6f66 2074 6865 2073  n image of the s
-0001d720: 6574 2075 6e64 6572 2074 7261 6e73 666f  et under transfo
-0001d730: 726d 6174 696f 6e20 6060 6660 602e 0a0a  rmation ``f``...
-0001d740: 2020 2020 4966 2074 6869 7320 6675 6e63      If this func
-0001d750: 7469 6f6e 2063 616e 2774 2063 6f6d 7075  tion can't compu
-0001d760: 7465 2074 6865 2069 6d61 6765 2c20 6974  te the image, it
-0001d770: 2072 6574 7572 6e73 2061 6e0a 2020 2020   returns an.    
-0001d780: 756e 6576 616c 7561 7465 6420 496d 6167  unevaluated Imag
-0001d790: 6553 6574 206f 626a 6563 742e 0a0a 2020  eSet object...  
-0001d7a0: 2020 2e2e 206d 6174 683a 3a0a 2020 2020    .. math::.    
-0001d7b0: 2020 2020 7b20 6628 7829 207c 2078 205c      { f(x) | x \
-0001d7c0: 696e 2073 656c 6620 7d0a 0a20 2020 2045  in self }..    E
-0001d7d0: 7861 6d70 6c65 730a 2020 2020 3d3d 3d3d  xamples.    ====
-0001d7e0: 3d3d 3d3d 0a0a 2020 2020 3e3e 3e20 6672  ====..    >>> fr
-0001d7f0: 6f6d 2073 796d 7079 2069 6d70 6f72 7420  om sympy import 
-0001d800: 532c 2049 6e74 6572 7661 6c2c 2053 796d  S, Interval, Sym
-0001d810: 626f 6c2c 2069 6d61 6765 7365 742c 2073  bol, imageset, s
-0001d820: 696e 2c20 4c61 6d62 6461 0a20 2020 203e  in, Lambda.    >
-0001d830: 3e3e 2066 726f 6d20 7379 6d70 792e 6162  >> from sympy.ab
-0001d840: 6320 696d 706f 7274 2078 2c20 790a 0a20  c import x, y.. 
-0001d850: 2020 203e 3e3e 2069 6d61 6765 7365 7428     >>> imageset(
-0001d860: 782c 2032 2a78 2c20 496e 7465 7276 616c  x, 2*x, Interval
-0001d870: 2830 2c20 3229 290a 2020 2020 496e 7465  (0, 2)).    Inte
-0001d880: 7276 616c 2830 2c20 3429 0a0a 2020 2020  rval(0, 4)..    
-0001d890: 3e3e 3e20 696d 6167 6573 6574 286c 616d  >>> imageset(lam
-0001d8a0: 6264 6120 783a 2032 2a78 2c20 496e 7465  bda x: 2*x, Inte
-0001d8b0: 7276 616c 2830 2c20 3229 290a 2020 2020  rval(0, 2)).    
-0001d8c0: 496e 7465 7276 616c 2830 2c20 3429 0a0a  Interval(0, 4)..
-0001d8d0: 2020 2020 3e3e 3e20 696d 6167 6573 6574      >>> imageset
-0001d8e0: 284c 616d 6264 6128 782c 2073 696e 2878  (Lambda(x, sin(x
-0001d8f0: 2929 2c20 496e 7465 7276 616c 282d 322c  )), Interval(-2,
-0001d900: 2031 2929 0a20 2020 2049 6d61 6765 5365   1)).    ImageSe
-0001d910: 7428 4c61 6d62 6461 2878 2c20 7369 6e28  t(Lambda(x, sin(
-0001d920: 7829 292c 2049 6e74 6572 7661 6c28 2d32  x)), Interval(-2
-0001d930: 2c20 3129 290a 0a20 2020 203e 3e3e 2069  , 1))..    >>> i
-0001d940: 6d61 6765 7365 7428 7369 6e2c 2049 6e74  mageset(sin, Int
-0001d950: 6572 7661 6c28 2d32 2c20 3129 290a 2020  erval(-2, 1)).  
-0001d960: 2020 496d 6167 6553 6574 284c 616d 6264    ImageSet(Lambd
-0001d970: 6128 782c 2073 696e 2878 2929 2c20 496e  a(x, sin(x)), In
-0001d980: 7465 7276 616c 282d 322c 2031 2929 0a20  terval(-2, 1)). 
-0001d990: 2020 203e 3e3e 2069 6d61 6765 7365 7428     >>> imageset(
-0001d9a0: 6c61 6d62 6461 2079 3a20 7820 2b20 792c  lambda y: x + y,
-0001d9b0: 2049 6e74 6572 7661 6c28 2d32 2c20 3129   Interval(-2, 1)
-0001d9c0: 290a 2020 2020 496d 6167 6553 6574 284c  ).    ImageSet(L
-0001d9d0: 616d 6264 6128 792c 2078 202b 2079 292c  ambda(y, x + y),
-0001d9e0: 2049 6e74 6572 7661 6c28 2d32 2c20 3129   Interval(-2, 1)
-0001d9f0: 290a 0a20 2020 2045 7870 7265 7373 696f  )..    Expressio
-0001da00: 6e73 2061 7070 6c69 6564 2074 6f20 7468  ns applied to th
-0001da10: 6520 7365 7420 6f66 2049 6e74 6567 6572  e set of Integer
-0001da20: 7320 6172 6520 7369 6d70 6c69 6669 6564  s are simplified
-0001da30: 0a20 2020 2074 6f20 7368 6f77 2061 7320  .    to show as 
-0001da40: 6665 7720 6e65 6761 7469 7665 7320 6173  few negatives as
-0001da50: 2070 6f73 7369 626c 6520 616e 6420 6c69   possible and li
-0001da60: 6e65 6172 2065 7870 7265 7373 696f 6e73  near expressions
-0001da70: 0a20 2020 2061 7265 2063 6f6e 7665 7274  .    are convert
-0001da80: 6564 2074 6f20 6120 6361 6e6f 6e69 6361  ed to a canonica
-0001da90: 6c20 666f 726d 2e20 4966 2074 6869 7320  l form. If this 
-0001daa0: 6973 206e 6f74 2064 6573 6972 6162 6c65  is not desirable
-0001dab0: 0a20 2020 2074 6865 6e20 7468 6520 756e  .    then the un
-0001dac0: 6576 616c 7561 7465 6420 496d 6167 6553  evaluated ImageS
-0001dad0: 6574 2073 686f 756c 6420 6265 2075 7365  et should be use
-0001dae0: 642e 0a0a 2020 2020 3e3e 3e20 696d 6167  d...    >>> imag
-0001daf0: 6573 6574 2878 2c20 2d32 2a78 202b 2035  eset(x, -2*x + 5
-0001db00: 2c20 532e 496e 7465 6765 7273 290a 2020  , S.Integers).  
-0001db10: 2020 496d 6167 6553 6574 284c 616d 6264    ImageSet(Lambd
-0001db20: 6128 782c 2032 2a78 202b 2031 292c 2049  a(x, 2*x + 1), I
-0001db30: 6e74 6567 6572 7329 0a0a 2020 2020 5365  ntegers)..    Se
-0001db40: 6520 416c 736f 0a20 2020 203d 3d3d 3d3d  e Also.    =====
-0001db50: 3d3d 3d0a 0a20 2020 2073 796d 7079 2e73  ===..    sympy.s
-0001db60: 6574 732e 6661 6e63 7973 6574 732e 496d  ets.fancysets.Im
-0001db70: 6167 6553 6574 0a0a 2020 2020 2222 220a  ageSet..    """.
-0001db80: 2020 2020 6672 6f6d 2073 796d 7079 2e63      from sympy.c
-0001db90: 6f72 6520 696d 706f 7274 204c 616d 6264  ore import Lambd
-0001dba0: 610a 2020 2020 6672 6f6d 2073 796d 7079  a.    from sympy
-0001dbb0: 2e73 6574 732e 6661 6e63 7973 6574 7320  .sets.fancysets 
-0001dbc0: 696d 706f 7274 2049 6d61 6765 5365 740a  import ImageSet.
-0001dbd0: 2020 2020 6672 6f6d 2073 796d 7079 2e73      from sympy.s
-0001dbe0: 6574 732e 7365 7465 7870 7220 696d 706f  ets.setexpr impo
-0001dbf0: 7274 2073 6574 5f66 756e 6374 696f 6e0a  rt set_function.
-0001dc00: 0a20 2020 2069 6620 6c65 6e28 6172 6773  .    if len(args
-0001dc10: 2920 3c20 323a 0a20 2020 2020 2020 2072  ) < 2:.        r
-0001dc20: 6169 7365 2056 616c 7565 4572 726f 7228  aise ValueError(
-0001dc30: 2769 6d61 6765 7365 7420 6578 7065 6374  'imageset expect
-0001dc40: 7320 6174 206c 6561 7374 2032 2061 7267  s at least 2 arg
-0001dc50: 732c 2067 6f74 3a20 2573 2720 2520 6c65  s, got: %s' % le
-0001dc60: 6e28 6172 6773 2929 0a0a 2020 2020 6672  n(args))..    fr
-0001dc70: 6f6d 2073 796d 7079 2e74 656e 736f 722e  om sympy.tensor.
-0001dc80: 696e 6465 7865 6420 696d 706f 7274 2053  indexed import S
-0001dc90: 6c69 6365 640a 2020 2020 6966 2069 7369  liced.    if isi
-0001dca0: 6e73 7461 6e63 6528 6172 6773 5b30 5d2c  nstance(args[0],
-0001dcb0: 2028 5379 6d62 6f6c 2c20 7475 706c 652c   (Symbol, tuple,
-0001dcc0: 2053 6c69 6365 6429 2920 616e 6420 6c65   Sliced)) and le
-0001dcd0: 6e28 6172 6773 2920 3e20 323a 0a20 2020  n(args) > 2:.   
-0001dce0: 2020 2020 2066 203d 204c 616d 6264 6128       f = Lambda(
-0001dcf0: 6172 6773 5b30 5d2c 2061 7267 735b 315d  args[0], args[1]
-0001dd00: 290a 2020 2020 2020 2020 7365 745f 6c69  ).        set_li
-0001dd10: 7374 203d 2061 7267 735b 323a 5d0a 2020  st = args[2:].  
-0001dd20: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
-0001dd30: 6620 3d20 6172 6773 5b30 5d0a 2020 2020  f = args[0].    
-0001dd40: 2020 2020 7365 745f 6c69 7374 203d 2061      set_list = a
-0001dd50: 7267 735b 313a 5d0a 0a20 2020 2069 6620  rgs[1:]..    if 
-0001dd60: 6973 696e 7374 616e 6365 2866 2c20 4c61  isinstance(f, La
-0001dd70: 6d62 6461 293a 0a20 2020 2020 2020 2070  mbda):.        p
-0001dd80: 6173 730a 2020 2020 656c 6966 2063 616c  ass.    elif cal
-0001dd90: 6c61 626c 6528 6629 3a0a 2020 2020 2020  lable(f):.      
-0001dda0: 2020 6e61 7267 7320 3d20 6765 7461 7474    nargs = getatt
-0001ddb0: 7228 662c 2027 6e61 7267 7327 2c20 7b7d  r(f, 'nargs', {}
-0001ddc0: 290a 2020 2020 2020 2020 6966 206e 6172  ).        if nar
-0001ddd0: 6773 3a0a 2020 2020 2020 2020 2020 2020  gs:.            
-0001dde0: 6966 206c 656e 286e 6172 6773 2920 213d  if len(nargs) !=
-0001ddf0: 2031 3a0a 2020 2020 2020 2020 2020 2020   1:.            
-0001de00: 2020 2020 7261 6973 6520 4e6f 7449 6d70      raise NotImp
-0001de10: 6c65 6d65 6e74 6564 2866 696c 6c64 6564  lemented(fillded
-0001de20: 656e 7428 2727 270a 2020 2020 2020 2020  ent('''.        
-0001de30: 2020 2020 2020 2020 2020 2020 5468 6973              This
-0001de40: 2066 756e 6374 696f 6e20 6361 6e20 7461   function can ta
-0001de50: 6b65 206d 6f72 6520 7468 616e 2031 2061  ke more than 1 a
-0001de60: 7267 0a20 2020 2020 2020 2020 2020 2020  rg.             
-0001de70: 2020 2020 2020 2062 7574 2074 6865 2070         but the p
-0001de80: 6f74 656e 7469 616c 6c79 2063 6f6d 706c  otentially compl
-0001de90: 6963 6174 6564 2073 6574 2069 6e70 7574  icated set input
-0001dea0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0001deb0: 2020 2020 2068 6173 206e 6f74 2062 6565       has not bee
-0001dec0: 6e20 616e 616c 797a 6564 2061 7420 7468  n analyzed at th
-0001ded0: 6973 2070 6f69 6e74 2074 6f0a 2020 2020  is point to.    
-0001dee0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001def0: 6b6e 6f77 2069 7473 2064 696d 656e 7369  know its dimensi
-0001df00: 6f6e 732e 2054 4f44 4f0a 2020 2020 2020  ons. TODO.      
-0001df10: 2020 2020 2020 2020 2020 2020 2020 2727                ''
-0001df20: 2729 290a 2020 2020 2020 2020 2020 2020  ')).            
-0001df30: 4e20 3d20 6e61 7267 732e 6172 6773 5b30  N = nargs.args[0
-0001df40: 5d0a 2020 2020 2020 2020 2020 2020 6966  ].            if
-0001df50: 204e 203d 3d20 313a 0a20 2020 2020 2020   N == 1:.       
-0001df60: 2020 2020 2020 2020 2073 203d 2027 7827           s = 'x'
-0001df70: 0a20 2020 2020 2020 2020 2020 2065 6c73  .            els
-0001df80: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
-0001df90: 2020 2073 203d 205b 5379 6d62 6f6c 2827     s = [Symbol('
-0001dfa0: 7825 6927 2025 2069 2920 666f 7220 6920  x%i' % i) for i 
-0001dfb0: 696e 2072 616e 6765 2831 2c20 4e20 2b20  in range(1, N + 
-0001dfc0: 3129 5d0a 2020 2020 2020 2020 656c 7365  1)].        else
-0001dfd0: 3a0a 2020 2020 2020 2020 2020 2020 7320  :.            s 
-0001dfe0: 3d20 696e 7370 6563 742e 7369 676e 6174  = inspect.signat
-0001dff0: 7572 6528 6629 2e70 6172 616d 6574 6572  ure(f).parameter
-0001e000: 730a 0a20 2020 2020 2020 2064 6578 7072  s..        dexpr
-0001e010: 203d 205f 7379 6d70 6966 7928 6628 2a5b   = _sympify(f(*[
-0001e020: 4475 6d6d 7928 2920 666f 7220 6920 696e  Dummy() for i in
-0001e030: 2073 5d29 290a 2020 2020 2020 2020 7661   s])).        va
-0001e040: 7220 3d20 5b5f 756e 6971 7565 6c79 5f6e  r = [_uniquely_n
-0001e050: 616d 6564 5f73 796d 626f 6c28 5379 6d62  amed_symbol(Symb
-0001e060: 6f6c 2869 292c 2064 6578 7072 2920 666f  ol(i), dexpr) fo
-0001e070: 7220 6920 696e 2073 5d0a 2020 2020 2020  r i in s].      
-0001e080: 2020 6578 7072 203d 2066 282a 7661 7229    expr = f(*var)
-0001e090: 0a20 2020 2020 2020 2066 203d 204c 616d  .        f = Lam
-0001e0a0: 6264 6128 7661 722c 2065 7870 7229 0a20  bda(var, expr). 
-0001e0b0: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
-0001e0c0: 2072 6169 7365 2054 7970 6545 7272 6f72   raise TypeError
-0001e0d0: 2866 696c 6c64 6564 656e 7428 2727 270a  (filldedent('''.
-0001e0e0: 2020 2020 2020 2020 2020 2020 6578 7065              expe
-0001e0f0: 6374 696e 6720 6c61 6d62 6461 2c20 4c61  cting lambda, La
-0001e100: 6d62 6461 0a20 2020 2020 2020 2020 2020  mbda.           
-0001e110: 206e 6f74 205c 2725 735c 272e 2727 2720   not \'%s\'.''' 
-0001e120: 2520 6675 6e63 5f6e 616d 6528 6629 2929  % func_name(f)))
-0001e130: 0a0a 2020 2020 6966 2061 6e79 286e 6f74  ..    if any(not
-0001e140: 2073 2e69 735f 7365 7420 666f 7220 7320   s.is_set for s 
-0001e150: 696e 2073 6574 5f6c 6973 7429 3a0a 2020  in set_list):.  
-0001e160: 2020 2020 2020 6e61 6d65 203d 205b 6675        name = [fu
-0001e170: 6e63 5f6e 616d 6528 7329 2066 6f72 2073  nc_name(s) for s
-0001e180: 2069 6e20 7365 745f 6c69 7374 5d0a 2020   in set_list].  
-0001e190: 2020 2020 2020 7261 6973 6520 5661 6c75        raise Valu
-0001e1a0: 6545 7272 6f72 2827 6172 6775 6d65 6e74  eError('argument
-0001e1b0: 7320 6166 7465 7220 6d61 7070 696e 6720  s after mapping 
-0001e1c0: 7368 6f75 6c64 2062 6520 7365 7473 2c20  should be sets, 
-0001e1d0: 6e6f 7420 2573 2720 2520 6e61 6d65 290a  not %s' % name).
-0001e1e0: 0a20 2020 2069 6620 6c65 6e28 7365 745f  .    if len(set_
-0001e1f0: 6c69 7374 2920 3d3d 2031 3a0a 2020 2020  list) == 1:.    
-0001e200: 2020 2020 7365 7420 3d20 7365 745f 6c69      set = set_li
-0001e210: 7374 5b30 5d0a 2020 2020 2020 2020 7472  st[0].        tr
-0001e220: 793a 0a20 2020 2020 2020 2020 2020 2023  y:.            #
-0001e230: 2054 7970 6545 7272 6f72 2069 6620 6172   TypeError if ar
-0001e240: 6720 636f 756e 7420 213d 2073 6574 2064  g count != set d
-0001e250: 696d 656e 7369 6f6e 730a 2020 2020 2020  imensions.      
-0001e260: 2020 2020 2020 7220 3d20 7365 745f 6675        r = set_fu
-0001e270: 6e63 7469 6f6e 2866 2c20 7365 7429 0a20  nction(f, set). 
-0001e280: 2020 2020 2020 2020 2020 2069 6620 7220             if r 
-0001e290: 6973 204e 6f6e 653a 0a20 2020 2020 2020  is None:.       
-0001e2a0: 2020 2020 2020 2020 2072 6169 7365 2054           raise T
-0001e2b0: 7970 6545 7272 6f72 0a20 2020 2020 2020  ypeError.       
-0001e2c0: 2020 2020 2069 6620 6e6f 7420 723a 0a20       if not r:. 
-0001e2d0: 2020 2020 2020 2020 2020 2020 2020 2072                 r
-0001e2e0: 6574 7572 6e20 720a 2020 2020 2020 2020  eturn r.        
-0001e2f0: 6578 6365 7074 2054 7970 6545 7272 6f72  except TypeError
-0001e300: 3a0a 2020 2020 2020 2020 2020 2020 7220  :.            r 
-0001e310: 3d20 496d 6167 6553 6574 2866 2c20 7365  = ImageSet(f, se
-0001e320: 7429 0a20 2020 2020 2020 2069 6620 6973  t).        if is
-0001e330: 696e 7374 616e 6365 2872 2c20 496d 6167  instance(r, Imag
-0001e340: 6553 6574 293a 0a20 2020 2020 2020 2020  eSet):.         
-0001e350: 2020 2066 2c20 7365 7420 3d20 722e 6172     f, set = r.ar
-0001e360: 6773 0a0a 2020 2020 2020 2020 6966 2066  gs..        if f
-0001e370: 2e76 6172 6961 626c 6573 203d 3d20 662e  .variables == f.
-0001e380: 6578 7072 3a0a 2020 2020 2020 2020 2020  expr:.          
-0001e390: 2020 7265 7475 726e 2073 6574 0a0a 2020    return set..  
-0001e3a0: 2020 2020 2020 6966 2069 7369 6e73 7461        if isinsta
-0001e3b0: 6e63 6528 7365 742c 2049 6d61 6765 5365  nce(set, ImageSe
-0001e3c0: 7429 3a0a 2020 2020 2020 2020 2020 2020  t):.            
-0001e3d0: 6966 206c 656e 2873 6574 2e6c 616d 6461  if len(set.lamda
-0001e3e0: 2e76 6172 6961 626c 6573 2920 3d3d 2031  .variables) == 1
-0001e3f0: 2061 6e64 206c 656e 2866 2e76 6172 6961   and len(f.varia
-0001e400: 626c 6573 2920 3d3d 2031 3a0a 2020 2020  bles) == 1:.    
-0001e410: 2020 2020 2020 2020 2020 2020 7265 7475              retu
-0001e420: 726e 2069 6d61 6765 7365 7428 4c61 6d62  rn imageset(Lamb
-0001e430: 6461 2873 6574 2e6c 616d 6461 2e76 6172  da(set.lamda.var
-0001e440: 6961 626c 6573 5b30 5d2c 0a20 2020 2020  iables[0],.     
-0001e450: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001e460: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001e470: 2020 662e 6578 7072 2e73 7562 7328 662e    f.expr.subs(f.
-0001e480: 7661 7269 6162 6c65 735b 305d 2c20 7365  variables[0], se
-0001e490: 742e 6c61 6d64 612e 6578 7072 2929 2c0a  t.lamda.expr)),.
-0001e4a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001e4b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001e4c0: 7365 742e 6261 7365 5f73 6574 290a 0a20  set.base_set).. 
-0001e4d0: 2020 2020 2020 2069 6620 7220 6973 206e         if r is n
-0001e4e0: 6f74 204e 6f6e 653a 0a20 2020 2020 2020  ot None:.       
-0001e4f0: 2020 2020 2072 6574 7572 6e20 720a 0a20       return r.. 
-0001e500: 2020 2072 6574 7572 6e20 496d 6167 6553     return ImageS
-0001e510: 6574 2866 2c20 2a73 6574 5f6c 6973 7429  et(f, *set_list)
-0001e520: 0a0a 0a64 6566 2069 735f 6675 6e63 7469  ...def is_functi
-0001e530: 6f6e 5f69 6e76 6572 7469 626c 655f 696e  on_invertible_in
-0001e540: 5f73 6574 2866 756e 632c 2073 6574 7629  _set(func, setv)
-0001e550: 3a0a 2020 2020 2222 220a 2020 2020 4368  :.    """.    Ch
-0001e560: 6563 6b73 2077 6865 7468 6572 2066 756e  ecks whether fun
-0001e570: 6374 696f 6e20 6060 6675 6e63 6060 2069  ction ``func`` i
-0001e580: 7320 696e 7665 7274 6962 6c65 2077 6865  s invertible whe
-0001e590: 6e20 7468 6520 646f 6d61 696e 2069 730a  n the domain is.
-0001e5a0: 2020 2020 7265 7374 7269 6374 6564 2074      restricted t
-0001e5b0: 6f20 7365 7420 6060 7365 7476 6060 2e0a  o set ``setv``..
-0001e5c0: 2020 2020 2222 220a 2020 2020 6672 6f6d      """.    from
-0001e5d0: 2073 796d 7079 2069 6d70 6f72 7420 6578   sympy import ex
-0001e5e0: 702c 206c 6f67 0a20 2020 2023 2046 756e  p, log.    # Fun
-0001e5f0: 6374 696f 6e73 206b 6e6f 776e 2074 6f20  ctions known to 
-0001e600: 616c 7761 7973 2062 6520 696e 7665 7274  always be invert
-0001e610: 6962 6c65 3a0a 2020 2020 6966 2066 756e  ible:.    if fun
-0001e620: 6320 696e 2028 6578 702c 206c 6f67 293a  c in (exp, log):
-0001e630: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
-0001e640: 5472 7565 0a20 2020 2075 203d 2044 756d  True.    u = Dum
-0001e650: 6d79 2822 7522 290a 2020 2020 6664 6966  my("u").    fdif
-0001e660: 6620 3d20 6675 6e63 2875 292e 6469 6666  f = func(u).diff
-0001e670: 2875 290a 2020 2020 2320 6d6f 6e6f 746f  (u).    # monoto
-0001e680: 6e6f 7573 2066 756e 6374 696f 6e73 3a0a  nous functions:.
-0001e690: 2020 2020 2320 544f 444f 3a20 6368 6563      # TODO: chec
-0001e6a0: 6b20 7375 6273 6574 7320 2860 6675 6e63  k subsets (`func
-0001e6b0: 6020 696e 2060 7365 7476 6029 0a20 2020  ` in `setv`).   
-0001e6c0: 2069 6620 2866 6469 6666 203e 2030 2920   if (fdiff > 0) 
-0001e6d0: 3d3d 2054 7275 6520 6f72 2028 6664 6966  == True or (fdif
-0001e6e0: 6620 3c20 3029 203d 3d20 5472 7565 3a0a  f < 0) == True:.
-0001e6f0: 2020 2020 2020 2020 7265 7475 726e 2054          return T
-0001e700: 7275 650a 2020 2020 2320 544f 444f 3a20  rue.    # TODO: 
-0001e710: 7375 7070 6f72 7420 6d6f 7265 0a20 2020  support more.   
-0001e720: 2072 6574 7572 6e20 4e6f 6e65 0a0a 0a64   return None...d
-0001e730: 6566 2073 696d 706c 6966 795f 756e 696f  ef simplify_unio
-0001e740: 6e28 6172 6773 293a 0a20 2020 2022 2222  n(args):.    """
-0001e750: 0a20 2020 2053 696d 706c 6966 7920 6120  .    Simplify a 
-0001e760: 3a63 6c61 7373 3a60 556e 696f 6e60 2075  :class:`Union` u
-0001e770: 7369 6e67 206b 6e6f 776e 2072 756c 6573  sing known rules
-0001e780: 0a0a 2020 2020 5765 2066 6972 7374 2073  ..    We first s
-0001e790: 7461 7274 2077 6974 6820 676c 6f62 616c  tart with global
-0001e7a0: 2072 756c 6573 206c 696b 6520 274d 6572   rules like 'Mer
-0001e7b0: 6765 2061 6c6c 2046 696e 6974 6553 6574  ge all FiniteSet
-0001e7c0: 7327 0a0a 2020 2020 5468 656e 2077 6520  s'..    Then we 
-0001e7d0: 6974 6572 6174 6520 7468 726f 7567 6820  iterate through 
-0001e7e0: 616c 6c20 7061 6972 7320 616e 6420 6173  all pairs and as
-0001e7f0: 6b20 7468 6520 636f 6e73 7469 7475 656e  k the constituen
-0001e800: 7420 7365 7473 2069 6620 7468 6579 0a20  t sets if they. 
-0001e810: 2020 2063 616e 2073 696d 706c 6966 7920     can simplify 
-0001e820: 7468 656d 7365 6c76 6573 2077 6974 6820  themselves with 
-0001e830: 616e 7920 6f74 6865 7220 636f 6e73 7469  any other consti
-0001e840: 7475 656e 742e 2020 5468 6973 2070 726f  tuent.  This pro
-0001e850: 6365 7373 2064 6570 656e 6473 0a20 2020  cess depends.   
-0001e860: 206f 6e20 6060 756e 696f 6e5f 7365 7473   on ``union_sets
-0001e870: 2861 2c20 6229 6060 2066 756e 6374 696f  (a, b)`` functio
-0001e880: 6e73 2e0a 2020 2020 2222 220a 2320 2020  ns..    """.#   
-0001e890: 2020 6672 6f6d 2073 796d 7079 2e73 6574    from sympy.set
-0001e8a0: 732e 6861 6e64 6c65 7273 2e75 6e69 6f6e  s.handlers.union
-0001e8b0: 2069 6d70 6f72 7420 756e 696f 6e5f 7365   import union_se
-0001e8c0: 7473 0a0a 2020 2020 2320 3d3d 3d3d 3d20  ts..    # ===== 
-0001e8d0: 476c 6f62 616c 2052 756c 6573 203d 3d3d  Global Rules ===
-0001e8e0: 3d3d 0a20 2020 2069 6620 6e6f 7420 6172  ==.    if not ar
-0001e8f0: 6773 3a0a 2020 2020 2020 2020 7265 7475  gs:.        retu
-0001e900: 726e 2045 6d70 7479 5365 7428 290a 0a20  rn EmptySet().. 
-0001e910: 2020 2066 6f72 2061 7267 2069 6e20 6172     for arg in ar
-0001e920: 6773 3a0a 2020 2020 2020 2020 6966 206e  gs:.        if n
-0001e930: 6f74 2061 7267 2e69 735f 7365 743a 0a20  ot arg.is_set:. 
-0001e940: 2020 2020 2020 2020 2020 2072 6169 7365             raise
-0001e950: 2054 7970 6545 7272 6f72 2822 496e 7075   TypeError("Inpu
-0001e960: 7420 6172 6773 2074 6f20 556e 696f 6e20  t args to Union 
-0001e970: 6d75 7374 2062 6520 5365 7473 2229 0a0a  must be Sets")..
-0001e980: 2020 2020 2320 4d65 7267 6520 616c 6c20      # Merge all 
-0001e990: 6669 6e69 7465 2073 6574 730a 2020 2020  finite sets.    
-0001e9a0: 6669 6e69 7465 5f73 6574 7320 3d20 5b78  finite_sets = [x
-0001e9b0: 2066 6f72 2078 2069 6e20 6172 6773 2069   for x in args i
-0001e9c0: 6620 782e 6973 5f46 696e 6974 6553 6574  f x.is_FiniteSet
-0001e9d0: 5d0a 2020 2020 6966 206c 656e 2866 696e  ].    if len(fin
-0001e9e0: 6974 655f 7365 7473 2920 3e20 313a 0a20  ite_sets) > 1:. 
-0001e9f0: 2020 2020 2020 2061 7267 7320 3d20 5b78         args = [x
-0001ea00: 2066 6f72 2078 2069 6e20 6172 6773 2069   for x in args i
-0001ea10: 6620 6e6f 7420 782e 6973 5f46 696e 6974  f not x.is_Finit
-0001ea20: 6553 6574 5d20 2020 2020 2020 200a 2020  eSet]        .  
-0001ea30: 2020 2020 2020 6120 3d20 5b78 2066 6f72        a = [x for
-0001ea40: 2073 2069 6e20 6669 6e69 7465 5f73 6574   s in finite_set
-0001ea50: 7320 666f 7220 7820 696e 2073 5d0a 2020  s for x in s].  
-0001ea60: 2020 2020 2020 6966 2061 3a0a 2020 2020        if a:.    
-0001ea70: 2020 2020 2020 2020 6672 6f6d 2073 796d          from sym
-0001ea80: 7079 2069 6d70 6f72 7420 4669 6e69 7465  py import Finite
-0001ea90: 5365 740a 2020 2020 2020 2020 2020 2020  Set.            
-0001eaa0: 6172 6773 2e61 7070 656e 6428 4669 6e69  args.append(Fini
-0001eab0: 7465 5365 7428 2a61 2929 0a20 2020 2020  teSet(*a)).     
-0001eac0: 2020 2065 6c69 6620 6e6f 7420 6172 6773     elif not args
-0001ead0: 3a0a 2020 2020 2020 2020 2020 2020 6172  :.            ar
-0001eae0: 6773 203d 2066 696e 6974 655f 7365 7473  gs = finite_sets
-0001eaf0: 5b3a 315d 2020 2020 2020 2020 2020 2020  [:1]            
-0001eb00: 0a0a 2020 2020 2320 3d3d 3d3d 3d20 5061  ..    # ===== Pa
-0001eb10: 6972 2d77 6973 6520 5275 6c65 7320 3d3d  ir-wise Rules ==
-0001eb20: 3d3d 3d0a 2020 2020 2320 4865 7265 2077  ===.    # Here w
-0001eb30: 6520 6465 7065 6e64 206f 6e20 7275 6c65  e depend on rule
-0001eb40: 7320 6275 696c 7420 696e 746f 2074 6865  s built into the
-0001eb50: 2063 6f6e 7374 6974 7565 6e74 2073 6574   constituent set
-0001eb60: 730a 2020 2020 6172 6773 203d 2073 6574  s.    args = set
-0001eb70: 2861 7267 7329 0a20 2020 206e 6577 5f61  (args).    new_a
-0001eb80: 7267 7320 3d20 5472 7565 0a20 2020 2077  rgs = True.    w
-0001eb90: 6869 6c65 206e 6577 5f61 7267 733a 0a20  hile new_args:. 
-0001eba0: 2020 2020 2020 2066 6f72 2073 2069 6e20         for s in 
-0001ebb0: 6172 6773 3a0a 2020 2020 2020 2020 2020  args:.          
-0001ebc0: 2020 6e65 775f 6172 6773 203d 2046 616c    new_args = Fal
-0001ebd0: 7365 0a20 2020 2020 2020 2020 2020 2066  se.            f
-0001ebe0: 6f72 2074 2069 6e20 6172 6773 202d 2073  or t in args - s
-0001ebf0: 6574 2828 732c 2929 3a0a 2020 2020 2020  et((s,)):.      
-0001ec00: 2020 2020 2020 2020 2020 6e65 775f 7365            new_se
-0001ec10: 7420 3d20 732e 756e 696f 6e5f 7365 7473  t = s.union_sets
-0001ec20: 2874 290a 2020 2020 2020 2020 2020 2020  (t).            
-0001ec30: 2020 2020 2320 5468 6973 2072 6574 7572      # This retur
-0001ec40: 6e73 204e 6f6e 6520 6966 2073 2064 6f65  ns None if s doe
-0001ec50: 7320 6e6f 7420 6b6e 6f77 2068 6f77 2074  s not know how t
-0001ec60: 6f20 696e 7465 7273 6563 740a 2020 2020  o intersect.    
-0001ec70: 2020 2020 2020 2020 2020 2020 2320 7769              # wi
-0001ec80: 7468 2074 2e20 5265 7475 726e 7320 7468  th t. Returns th
-0001ec90: 6520 6e65 776c 7920 696e 7465 7273 6563  e newly intersec
-0001eca0: 7465 6420 7365 7420 6f74 6865 7277 6973  ted set otherwis
-0001ecb0: 650a 2020 2020 2020 2020 2020 2020 2020  e.              
-0001ecc0: 2020 6966 206e 6577 5f73 6574 2069 7320    if new_set is 
-0001ecd0: 6e6f 7420 4e6f 6e65 3a0a 2020 2020 2020  not None:.      
-0001ece0: 2020 2020 2020 2020 2020 2020 2020 6966                if
-0001ecf0: 206e 6f74 2069 7369 6e73 7461 6e63 6528   not isinstance(
-0001ed00: 6e65 775f 7365 742c 2073 6574 293a 0a20  new_set, set):. 
-0001ed10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001ed20: 2020 2020 2020 206e 6577 5f73 6574 203d         new_set =
-0001ed30: 2073 6574 2828 6e65 775f 7365 742c 2929   set((new_set,))
-0001ed40: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0001ed50: 2020 2020 206e 6577 5f61 7267 7320 3d20       new_args = 
-0001ed60: 2861 7267 7320 2d20 7365 7428 2873 2c20  (args - set((s, 
-0001ed70: 7429 2929 2e75 6e69 6f6e 286e 6577 5f73  t))).union(new_s
-0001ed80: 6574 290a 2020 2020 2020 2020 2020 2020  et).            
-0001ed90: 2020 2020 2020 2020 6272 6561 6b0a 2020          break.  
-0001eda0: 2020 2020 2020 2020 2020 6966 206e 6577            if new
-0001edb0: 5f61 7267 733a 0a20 2020 2020 2020 2020  _args:.         
-0001edc0: 2020 2020 2020 2061 7267 7320 3d20 6e65         args = ne
-0001edd0: 775f 6172 6773 0a20 2020 2020 2020 2020  w_args.         
-0001ede0: 2020 2020 2020 2062 7265 616b 0a0a 2020         break..  
-0001edf0: 2020 6966 206c 656e 2861 7267 7329 203d    if len(args) =
-0001ee00: 3d20 313a 0a20 2020 2020 2020 2072 6574  = 1:.        ret
-0001ee10: 7572 6e20 6172 6773 2e70 6f70 2829 0a20  urn args.pop(). 
-0001ee20: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
-0001ee30: 2072 6574 7572 6e20 556e 696f 6e28 2a61   return Union(*a
-0001ee40: 7267 732c 2065 7661 6c75 6174 653d 4661  rgs, evaluate=Fa
-0001ee50: 6c73 6529 0a0a 0a64 6566 2073 696d 706c  lse)...def simpl
-0001ee60: 6966 795f 696e 7465 7273 6563 7469 6f6e  ify_intersection
-0001ee70: 2861 7267 7329 3a0a 2020 2020 2222 220a  (args):.    """.
-0001ee80: 2020 2020 5369 6d70 6c69 6679 2061 6e20      Simplify an 
-0001ee90: 696e 7465 7273 6563 7469 6f6e 2075 7369  intersection usi
-0001eea0: 6e67 206b 6e6f 776e 2072 756c 6573 0a0a  ng known rules..
-0001eeb0: 2020 2020 5765 2066 6972 7374 2073 7461      We first sta
-0001eec0: 7274 2077 6974 6820 676c 6f62 616c 2072  rt with global r
-0001eed0: 756c 6573 206c 696b 650a 2020 2020 2769  ules like.    'i
-0001eee0: 6620 616e 7920 656d 7074 7920 7365 7473  f any empty sets
-0001eef0: 2072 6574 7572 6e20 656d 7074 7920 7365   return empty se
-0001ef00: 7427 2061 6e64 2027 6469 7374 7269 6275  t' and 'distribu
-0001ef10: 7465 2061 6e79 2075 6e69 6f6e 7327 0a0a  te any unions'..
-0001ef20: 2020 2020 5468 656e 2077 6520 6974 6572      Then we iter
-0001ef30: 6174 6520 7468 726f 7567 6820 616c 6c20  ate through all 
-0001ef40: 7061 6972 7320 616e 6420 6173 6b20 7468  pairs and ask th
-0001ef50: 6520 636f 6e73 7469 7475 656e 7420 7365  e constituent se
-0001ef60: 7473 2069 6620 7468 6579 0a20 2020 2063  ts if they.    c
-0001ef70: 616e 2073 696d 706c 6966 7920 7468 656d  an simplify them
-0001ef80: 7365 6c76 6573 2077 6974 6820 616e 7920  selves with any 
-0001ef90: 6f74 6865 7220 636f 6e73 7469 7475 656e  other constituen
-0001efa0: 740a 2020 2020 2222 220a 0a20 2020 2023  t.    """..    #
-0001efb0: 203d 3d3d 3d3d 2047 6c6f 6261 6c20 5275   ===== Global Ru
-0001efc0: 6c65 7320 3d3d 3d3d 3d0a 2020 2020 6966  les =====.    if
-0001efd0: 206e 6f74 2061 7267 733a 0a20 2020 2020   not args:.     
-0001efe0: 2020 2070 7269 6e74 2827 7761 726e 696e     print('warnin
-0001eff0: 673a 2055 6e69 7665 7273 616c 5365 7420  g: UniversalSet 
-0001f000: 7769 7468 6f75 7420 6574 7970 6520 6973  without etype is
-0001f010: 2070 726f 6869 6269 7465 6421 2729 0a20   prohibited!'). 
-0001f020: 2020 2020 2020 2072 6574 7572 6e20 556e         return Un
-0001f030: 6976 6572 7361 6c53 6574 2829 0a20 2020  iversalSet().   
-0001f040: 2023 2049 6620 616e 7920 456d 7074 7953   # If any EmptyS
-0001f050: 6574 7320 7265 7475 726e 2045 6d70 7479  ets return Empty
-0001f060: 5365 740a 2020 2020 666f 7220 7320 696e  Set.    for s in
-0001f070: 2061 7267 733a 0a20 2020 2020 2020 2069   args:.        i
-0001f080: 6620 6e6f 7420 732e 6973 5f73 6574 3a0a  f not s.is_set:.
-0001f090: 2020 2020 2020 2020 2020 2020 7261 6973              rais
-0001f0a0: 6520 5479 7065 4572 726f 7228 2249 6e70  e TypeError("Inp
-0001f0b0: 7574 2061 7267 7320 746f 2055 6e69 6f6e  ut args to Union
-0001f0c0: 206d 7573 7420 6265 2053 6574 7322 290a   must be Sets").
-0001f0d0: 2020 2020 2020 2020 0a20 2020 2020 2020          .       
-0001f0e0: 2069 6620 732e 6973 5f45 6d70 7479 5365   if s.is_EmptySe
-0001f0f0: 743a 0a20 2020 2020 2020 2020 2020 2072  t:.            r
-0001f100: 6574 7572 6e20 730a 2020 2020 2320 4861  eturn s.    # Ha
-0001f110: 6e64 6c65 2046 696e 6974 6520 7365 7473  ndle Finite sets
-0001f120: 0a20 2020 2072 7620 3d20 496e 7465 7273  .    rv = Inters
-0001f130: 6563 7469 6f6e 2e5f 6861 6e64 6c65 5f66  ection._handle_f
-0001f140: 696e 6974 655f 7365 7473 2861 7267 7329  inite_sets(args)
-0001f150: 0a0a 2020 2020 6966 2072 7620 6973 206e  ..    if rv is n
-0001f160: 6f74 204e 6f6e 653a 0a20 2020 2020 2020  ot None:.       
-0001f170: 2072 6574 7572 6e20 7276 0a0a 2020 2020   return rv..    
-0001f180: 2320 4966 2061 6e79 206f 6620 7468 6520  # If any of the 
-0001f190: 7365 7473 2061 7265 2075 6e69 6f6e 732c  sets are unions,
-0001f1a0: 2072 6574 7572 6e20 6120 556e 696f 6e20   return a Union 
-0001f1b0: 6f66 2049 6e74 6572 7365 6374 696f 6e73  of Intersections
-0001f1c0: 0a20 2020 2066 6f72 2073 2069 6e20 6172  .    for s in ar
-0001f1d0: 6773 3a0a 2020 2020 2020 2020 6966 2073  gs:.        if s
-0001f1e0: 2e69 735f 556e 696f 6e3a 0a20 2020 2020  .is_Union:.     
-0001f1f0: 2020 2020 2020 206f 7468 6572 5f73 6574         other_set
-0001f200: 7320 3d20 7365 7428 6172 6773 2920 2d20  s = set(args) - 
-0001f210: 7365 7428 2873 2c29 290a 2020 2020 2020  set((s,)).      
-0001f220: 2020 2020 2020 6966 206c 656e 286f 7468        if len(oth
-0001f230: 6572 5f73 6574 7329 203e 2030 3a0a 2020  er_sets) > 0:.  
-0001f240: 2020 2020 2020 2020 2020 2020 2020 6f74                ot
-0001f250: 6865 7220 3d20 496e 7465 7273 6563 7469  her = Intersecti
-0001f260: 6f6e 282a 6f74 6865 725f 7365 7473 290a  on(*other_sets).
-0001f270: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001f280: 7265 7475 726e 2055 6e69 6f6e 282a 2849  return Union(*(I
-0001f290: 6e74 6572 7365 6374 696f 6e28 6172 672c  ntersection(arg,
-0001f2a0: 206f 7468 6572 2920 666f 7220 6172 6720   other) for arg 
-0001f2b0: 696e 2073 2e61 7267 7329 290a 2020 2020  in s.args)).    
-0001f2c0: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
-0001f2d0: 2020 2020 2020 2020 2020 2020 2020 7265                re
-0001f2e0: 7475 726e 2055 6e69 6f6e 282a 5b61 7267  turn Union(*[arg
-0001f2f0: 2066 6f72 2061 7267 2069 6e20 732e 6172   for arg in s.ar
-0001f300: 6773 5d29 0a0a 2020 2020 666f 7220 7320  gs])..    for s 
-0001f310: 696e 2061 7267 733a 0a20 2020 2020 2020  in args:.       
-0001f320: 2069 6620 732e 6973 5f43 6f6d 706c 656d   if s.is_Complem
-0001f330: 656e 743a 0a20 2020 2020 2020 2020 2020  ent:.           
-0001f340: 2061 7267 732e 7265 6d6f 7665 2873 290a   args.remove(s).
-0001f350: 2020 2020 2020 2020 2020 2020 6f74 6865              othe
-0001f360: 725f 7365 7473 203d 2061 7267 7320 2b20  r_sets = args + 
-0001f370: 5b73 2e61 7267 735b 305d 5d0a 2020 2020  [s.args[0]].    
-0001f380: 2020 2020 2020 2020 7265 7475 726e 2043          return C
-0001f390: 6f6d 706c 656d 656e 7428 496e 7465 7273  omplement(Inters
-0001f3a0: 6563 7469 6f6e 282a 6f74 6865 725f 7365  ection(*other_se
-0001f3b0: 7473 292c 2073 2e61 7267 735b 315d 290a  ts), s.args[1]).
-0001f3c0: 0a0a 0a20 2020 2023 2041 7420 7468 6973  ...    # At this
-0001f3d0: 2073 7461 6765 2077 6520 6172 6520 6775   stage we are gu
-0001f3e0: 6172 616e 7465 6564 206e 6f74 2074 6f20  aranteed not to 
-0001f3f0: 6861 7665 2061 6e79 0a20 2020 2023 2045  have any.    # E
-0001f400: 6d70 7479 5365 7473 2c20 4669 6e69 7465  mptySets, Finite
-0001f410: 5365 7473 2c20 6f72 2055 6e69 6f6e 7320  Sets, or Unions 
-0001f420: 696e 2074 6865 2069 6e74 6572 7365 6374  in the intersect
-0001f430: 696f 6e0a 0a20 2020 2023 203d 3d3d 3d3d  ion..    # =====
-0001f440: 2050 6169 722d 7769 7365 2052 756c 6573   Pair-wise Rules
-0001f450: 203d 3d3d 3d3d 0a20 2020 2023 2048 6572   =====.    # Her
-0001f460: 6520 7765 2064 6570 656e 6420 6f6e 2072  e we depend on r
-0001f470: 756c 6573 2062 7569 6c74 2069 6e74 6f20  ules built into 
-0001f480: 7468 6520 636f 6e73 7469 7475 656e 7420  the constituent 
-0001f490: 7365 7473 0a20 2020 2061 7267 7320 3d20  sets.    args = 
-0001f4a0: 7365 7428 6172 6773 290a 2020 2020 6e65  set(args).    ne
-0001f4b0: 775f 6172 6773 203d 2054 7275 650a 2020  w_args = True.  
-0001f4c0: 2020 7768 696c 6520 6e65 775f 6172 6773    while new_args
-0001f4d0: 3a0a 2020 2020 2020 2020 666f 7220 7320  :.        for s 
-0001f4e0: 696e 2061 7267 733a 0a20 2020 2020 2020  in args:.       
-0001f4f0: 2020 2020 206e 6577 5f61 7267 7320 3d20       new_args = 
-0001f500: 4661 6c73 650a 2020 2020 2020 2020 2020  False.          
-0001f510: 2020 666f 7220 7420 696e 2061 7267 7320    for t in args 
-0001f520: 2d20 7365 7428 2873 2c29 293a 0a20 2020  - set((s,)):.   
-0001f530: 2020 2020 2020 2020 2020 2020 206e 6577               new
-0001f540: 5f73 6574 203d 2073 2e69 6e74 6572 7365  _set = s.interse
-0001f550: 6374 696f 6e5f 7365 7473 2874 290a 2020  ction_sets(t).  
-0001f560: 2020 2020 2020 2020 2020 2020 2020 2320                # 
-0001f570: 5468 6973 2072 6574 7572 6e73 204e 6f6e  This returns Non
-0001f580: 6520 6966 2073 2064 6f65 7320 6e6f 7420  e if s does not 
-0001f590: 6b6e 6f77 2068 6f77 2074 6f20 696e 7465  know how to inte
-0001f5a0: 7273 6563 740a 2020 2020 2020 2020 2020  rsect.          
-0001f5b0: 2020 2020 2020 2320 7769 7468 2074 2e20        # with t. 
-0001f5c0: 5265 7475 726e 7320 7468 6520 6e65 776c  Returns the newl
-0001f5d0: 7920 696e 7465 7273 6563 7465 6420 7365  y intersected se
-0001f5e0: 7420 6f74 6865 7277 6973 650a 0a20 2020  t otherwise..   
-0001f5f0: 2020 2020 2020 2020 2020 2020 2069 6620               if 
-0001f600: 6e65 775f 7365 7420 6973 206e 6f74 204e  new_set is not N
-0001f610: 6f6e 653a 0a20 2020 2020 2020 2020 2020  one:.           
-0001f620: 2020 2020 2020 2020 206e 6577 5f61 7267           new_arg
-0001f630: 7320 3d20 2861 7267 7320 2d20 7365 7428  s = (args - set(
-0001f640: 2873 2c20 7429 2929 2e75 6e69 6f6e 2873  (s, t))).union(s
-0001f650: 6574 2828 6e65 775f 7365 742c 2929 290a  et((new_set,))).
-0001f660: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001f670: 2020 2020 6272 6561 6b0a 2020 2020 2020      break.      
-0001f680: 2020 2020 2020 6966 206e 6577 5f61 7267        if new_arg
-0001f690: 733a 0a20 2020 2020 2020 2020 2020 2020  s:.             
-0001f6a0: 2020 2061 7267 7320 3d20 6e65 775f 6172     args = new_ar
-0001f6b0: 6773 0a20 2020 2020 2020 2020 2020 2020  gs.             
-0001f6c0: 2020 2062 7265 616b 0a0a 2020 2020 6966     break..    if
-0001f6d0: 206c 656e 2861 7267 7329 203d 3d20 313a   len(args) == 1:
-0001f6e0: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
-0001f6f0: 6172 6773 2e70 6f70 2829 0a20 2020 2065  args.pop().    e
-0001f700: 6c73 653a 0a20 2020 2020 2020 2072 6574  lse:.        ret
-0001f710: 7572 6e20 496e 7465 7273 6563 7469 6f6e  urn Intersection
-0001f720: 282a 6172 6773 2c20 6576 616c 7561 7465  (*args, evaluate
-0001f730: 3d46 616c 7365 290a 0a0a 6465 6620 5f68  =False)...def _h
-0001f740: 616e 646c 655f 6669 6e69 7465 5f73 6574  andle_finite_set
-0001f750: 7328 6f70 2c20 782c 2079 2c20 636f 6d6d  s(op, x, y, comm
-0001f760: 7574 6174 6976 6529 3a0a 2020 2020 2320  utative):.    # 
-0001f770: 4861 6e64 6c65 2066 696e 6974 6520 7365  Handle finite se
-0001f780: 7473 3a0a 2020 2020 6672 6f6d 2073 796d  ts:.    from sym
-0001f790: 7079 2069 6d70 6f72 7420 4669 6e69 7465  py import Finite
-0001f7a0: 5365 740a 2020 2020 6673 5f61 7267 732c  Set.    fs_args,
-0001f7b0: 206f 7468 6572 203d 2073 6966 7428 5b78   other = sift([x
-0001f7c0: 2c20 795d 2c20 6c61 6d62 6461 2078 3a20  , y], lambda x: 
-0001f7d0: 6973 696e 7374 616e 6365 2878 2c20 4669  isinstance(x, Fi
-0001f7e0: 6e69 7465 5365 7429 2c20 6269 6e61 7279  niteSet), binary
-0001f7f0: 3d54 7275 6529 0a20 2020 2069 6620 6c65  =True).    if le
-0001f800: 6e28 6673 5f61 7267 7329 203d 3d20 323a  n(fs_args) == 2:
-0001f810: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
-0001f820: 4669 6e69 7465 5365 7428 2a5b 6f70 2869  FiniteSet(*[op(i
-0001f830: 2c20 6a29 2066 6f72 2069 2069 6e20 6673  , j) for i in fs
-0001f840: 5f61 7267 735b 305d 2066 6f72 206a 2069  _args[0] for j i
-0001f850: 6e20 6673 5f61 7267 735b 315d 5d29 0a20  n fs_args[1]]). 
-0001f860: 2020 2065 6c69 6620 6c65 6e28 6673 5f61     elif len(fs_a
-0001f870: 7267 7329 203d 3d20 313a 0a20 2020 2020  rgs) == 1:.     
-0001f880: 2020 2073 6574 7320 3d20 5b5f 6170 706c     sets = [_appl
-0001f890: 795f 6f70 6572 6174 696f 6e28 6f70 2c20  y_operation(op, 
-0001f8a0: 6f74 6865 725b 305d 2c20 692c 2063 6f6d  other[0], i, com
-0001f8b0: 6d75 7461 7469 7665 2920 666f 7220 6920  mutative) for i 
-0001f8c0: 696e 2066 735f 6172 6773 5b30 5d5d 0a20  in fs_args[0]]. 
-0001f8d0: 2020 2020 2020 2072 6574 7572 6e20 556e         return Un
-0001f8e0: 696f 6e28 2a73 6574 7329 0a20 2020 2065  ion(*sets).    e
-0001f8f0: 6c73 653a 0a20 2020 2020 2020 2072 6574  lse:.        ret
-0001f900: 7572 6e20 4e6f 6e65 0a0a 0a64 6566 205f  urn None...def _
-0001f910: 6170 706c 795f 6f70 6572 6174 696f 6e28  apply_operation(
-0001f920: 6f70 2c20 782c 2079 2c20 636f 6d6d 7574  op, x, y, commut
-0001f930: 6174 6976 6529 3a0a 2020 2020 6672 6f6d  ative):.    from
-0001f940: 2073 796d 7079 2e73 6574 7320 696d 706f   sympy.sets impo
-0001f950: 7274 2049 6d61 6765 5365 740a 2020 2020  rt ImageSet.    
-0001f960: 6672 6f6d 2073 796d 7079 2069 6d70 6f72  from sympy impor
-0001f970: 7420 7379 6d62 6f6c 732c 204c 616d 6264  t symbols, Lambd
-0001f980: 610a 2020 2020 6420 3d20 4475 6d6d 7928  a.    d = Dummy(
-0001f990: 2764 2729 0a0a 2020 2020 6f75 7420 3d20  'd')..    out = 
-0001f9a0: 5f68 616e 646c 655f 6669 6e69 7465 5f73  _handle_finite_s
-0001f9b0: 6574 7328 6f70 2c20 782c 2079 2c20 636f  ets(op, x, y, co
-0001f9c0: 6d6d 7574 6174 6976 6529 0a20 2020 2069  mmutative).    i
-0001f9d0: 6620 6f75 7420 6973 204e 6f6e 653a 0a20  f out is None:. 
-0001f9e0: 2020 2020 2020 206f 7574 203d 206f 7028         out = op(
-0001f9f0: 782c 2079 290a 0a20 2020 2069 6620 6f75  x, y)..    if ou
-0001fa00: 7420 6973 204e 6f6e 6520 616e 6420 636f  t is None and co
-0001fa10: 6d6d 7574 6174 6976 653a 0a20 2020 2020  mmutative:.     
-0001fa20: 2020 206f 7574 203d 206f 7028 792c 2078     out = op(y, x
-0001fa30: 290a 2020 2020 6966 206f 7574 2069 7320  ).    if out is 
-0001fa40: 4e6f 6e65 3a0a 2020 2020 2020 2020 5f78  None:.        _x
-0001fa50: 2c20 5f79 203d 2073 796d 626f 6c73 2822  , _y = symbols("
-0001fa60: 7820 7922 290a 2020 2020 2020 2020 6966  x y").        if
-0001fa70: 2078 2e69 735f 7365 7420 616e 6420 6e6f   x.is_set and no
-0001fa80: 7420 792e 6973 5f73 6574 3a0a 2020 2020  t y.is_set:.    
-0001fa90: 2020 2020 2020 2020 6f75 7420 3d20 496d          out = Im
-0001faa0: 6167 6553 6574 284c 616d 6264 6128 642c  ageSet(Lambda(d,
-0001fab0: 206f 7028 642c 2079 2929 2c20 7829 2e64   op(d, y)), x).d
-0001fac0: 6f69 7428 290a 2020 2020 2020 2020 656c  oit().        el
-0001fad0: 6966 206e 6f74 2078 2e69 735f 7365 7420  if not x.is_set 
-0001fae0: 616e 6420 792e 6973 5f73 6574 3a0a 2020  and y.is_set:.  
-0001faf0: 2020 2020 2020 2020 2020 6f75 7420 3d20            out = 
-0001fb00: 496d 6167 6553 6574 284c 616d 6264 6128  ImageSet(Lambda(
-0001fb10: 642c 206f 7028 782c 2064 2929 2c20 7929  d, op(x, d)), y)
-0001fb20: 2e64 6f69 7428 290a 2020 2020 2020 2020  .doit().        
-0001fb30: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
-0001fb40: 2020 6f75 7420 3d20 496d 6167 6553 6574    out = ImageSet
-0001fb50: 284c 616d 6264 6128 285f 782c 205f 7929  (Lambda((_x, _y)
-0001fb60: 2c20 6f70 285f 782c 205f 7929 292c 2078  , op(_x, _y)), x
-0001fb70: 2c20 7929 0a20 2020 2072 6574 7572 6e20  , y).    return 
-0001fb80: 6f75 740a 0a0a 6465 6620 7365 745f 6164  out...def set_ad
-0001fb90: 6428 782c 2079 293a 0a20 2020 2066 726f  d(x, y):.    fro
-0001fba0: 6d20 7379 6d70 792e 7365 7473 2e68 616e  m sympy.sets.han
-0001fbb0: 646c 6572 732e 6164 6420 696d 706f 7274  dlers.add import
-0001fbc0: 205f 7365 745f 6164 640a 2020 2020 7265   _set_add.    re
-0001fbd0: 7475 726e 205f 6170 706c 795f 6f70 6572  turn _apply_oper
-0001fbe0: 6174 696f 6e28 5f73 6574 5f61 6464 2c20  ation(_set_add, 
-0001fbf0: 782c 2079 2c20 636f 6d6d 7574 6174 6976  x, y, commutativ
-0001fc00: 653d 5472 7565 290a 0a0a 6465 6620 7365  e=True)...def se
-0001fc10: 745f 7375 6228 782c 2079 293a 0a20 2020  t_sub(x, y):.   
-0001fc20: 2066 726f 6d20 7379 6d70 792e 7365 7473   from sympy.sets
-0001fc30: 2e68 616e 646c 6572 732e 6164 6420 696d  .handlers.add im
-0001fc40: 706f 7274 205f 7365 745f 7375 620a 2020  port _set_sub.  
-0001fc50: 2020 7265 7475 726e 205f 6170 706c 795f    return _apply_
-0001fc60: 6f70 6572 6174 696f 6e28 5f73 6574 5f73  operation(_set_s
-0001fc70: 7562 2c20 782c 2079 2c20 636f 6d6d 7574  ub, x, y, commut
-0001fc80: 6174 6976 653d 4661 6c73 6529 0a0a 0a64  ative=False)...d
-0001fc90: 6566 2073 6574 5f6d 756c 2878 2c20 7929  ef set_mul(x, y)
-0001fca0: 3a0a 2020 2020 6672 6f6d 2073 796d 7079  :.    from sympy
-0001fcb0: 2e73 6574 732e 6861 6e64 6c65 7273 2e6d  .sets.handlers.m
-0001fcc0: 756c 2069 6d70 6f72 7420 5f73 6574 5f6d  ul import _set_m
-0001fcd0: 756c 0a20 2020 2072 6574 7572 6e20 5f61  ul.    return _a
-0001fce0: 7070 6c79 5f6f 7065 7261 7469 6f6e 285f  pply_operation(_
-0001fcf0: 7365 745f 6d75 6c2c 2078 2c20 792c 2063  set_mul, x, y, c
-0001fd00: 6f6d 6d75 7461 7469 7665 3d54 7275 6529  ommutative=True)
-0001fd10: 0a0a 0a64 6566 2073 6574 5f64 6976 2878  ...def set_div(x
-0001fd20: 2c20 7929 3a0a 2020 2020 6672 6f6d 2073  , y):.    from s
-0001fd30: 796d 7079 2e73 6574 732e 6861 6e64 6c65  ympy.sets.handle
-0001fd40: 7273 2e6d 756c 2069 6d70 6f72 7420 5f73  rs.mul import _s
-0001fd50: 6574 5f64 6976 0a20 2020 2072 6574 7572  et_div.    retur
-0001fd60: 6e20 5f61 7070 6c79 5f6f 7065 7261 7469  n _apply_operati
-0001fd70: 6f6e 285f 7365 745f 6469 762c 2078 2c20  on(_set_div, x, 
-0001fd80: 792c 2063 6f6d 6d75 7461 7469 7665 3d46  y, commutative=F
-0001fd90: 616c 7365 290a 0a0a 6465 6620 7365 745f  alse)...def set_
-0001fda0: 706f 7728 782c 2079 293a 0a20 2020 2066  pow(x, y):.    f
-0001fdb0: 726f 6d20 7379 6d70 792e 7365 7473 2e68  rom sympy.sets.h
-0001fdc0: 616e 646c 6572 732e 706f 7765 7220 696d  andlers.power im
-0001fdd0: 706f 7274 205f 7365 745f 706f 770a 2020  port _set_pow.  
-0001fde0: 2020 7265 7475 726e 205f 6170 706c 795f    return _apply_
-0001fdf0: 6f70 6572 6174 696f 6e28 5f73 6574 5f70  operation(_set_p
-0001fe00: 6f77 2c20 782c 2079 2c20 636f 6d6d 7574  ow, x, y, commut
-0001fe10: 6174 6976 653d 4661 6c73 6529 0a0a 0a64  ative=False)...d
-0001fe20: 6566 2073 6574 5f66 756e 6374 696f 6e28  ef set_function(
-0001fe30: 662c 2078 293a 0a20 2020 2066 726f 6d20  f, x):.    from 
-0001fe40: 7379 6d70 792e 7365 7473 2e68 616e 646c  sympy.sets.handl
-0001fe50: 6572 732e 6675 6e63 7469 6f6e 7320 696d  ers.functions im
-0001fe60: 706f 7274 205f 7365 745f 6675 6e63 7469  port _set_functi
-0001fe70: 6f6e 0a20 2020 2072 6574 7572 6e20 5f73  on.    return _s
-0001fe80: 6574 5f66 756e 6374 696f 6e28 662c 2078  et_function(f, x
-0001fe90: 290a                                     ).
+000156c0: 0a20 2020 2020 2020 2078 203d 2041 2e6d  .        x = A.m
+000156d0: 696e 2829 0a20 2020 2020 2020 2020 2020  in().           
+000156e0: 200a 2020 2020 2020 2020 6966 2078 2e69   .        if x.i
+000156f0: 735f 696e 6669 6e69 7465 3a0a 2020 2020  s_infinite:.    
+00015700: 2020 2020 2020 2020 6966 2045 6c65 6d65          if Eleme
+00015710: 6e74 2878 2c20 4229 203d 3d20 4661 6c73  nt(x, B) == Fals
+00015720: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
+00015730: 2020 2072 6574 7572 6e20 780a 2020 2020     return x.    
+00015740: 2020 2020 2020 2020 0a20 2020 2020 2020          .       
+00015750: 2069 6620 7365 6c66 2e69 735f 636f 6e6e   if self.is_conn
+00015760: 6563 7465 645f 696e 7465 7276 616c 2829  ected_interval()
+00015770: 3a0a 2020 2020 2020 2020 2020 2020 6672  :.            fr
+00015780: 6f6d 2073 796d 7079 2e63 6f72 652e 6e75  om sympy.core.nu
+00015790: 6d62 6572 7320 696d 706f 7274 2065 7073  mbers import eps
+000157a0: 696c 6f6e 0a20 2020 2020 2020 2020 2020  ilon.           
+000157b0: 2066 726f 6d20 7379 6d70 7920 696d 706f   from sympy impo
+000157c0: 7274 2066 6c6f 6f72 0a20 2020 2020 2020  rt floor.       
+000157d0: 2020 2020 204d 203d 2042 2e6d 6178 2829       M = B.max()
+000157e0: 2020 2020 2020 2020 0a20 2020 2020 2020          .       
+000157f0: 2020 2020 2069 6620 412e 6973 5f69 6e74       if A.is_int
+00015800: 6567 6572 3a20 0a20 2020 2020 2020 2020  eger: .         
+00015810: 2020 2020 2020 204d 203d 2066 6c6f 6f72         M = floor
+00015820: 284d 2920 2b20 310a 2020 2020 2020 2020  (M) + 1.        
+00015830: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
+00015840: 2020 2020 2020 2020 2020 4d20 2b3d 2065            M += e
+00015850: 7073 696c 6f6e 0a20 2020 2020 2020 2020  psilon.         
+00015860: 2020 2020 2020 200a 2020 2020 2020 2020         .        
+00015870: 2020 2020 6672 6f6d 2073 796d 7079 2e66      from sympy.f
+00015880: 756e 6374 696f 6e73 2e65 6c65 6d65 6e74  unctions.element
+00015890: 6172 792e 7069 6563 6577 6973 6520 696d  ary.piecewise im
+000158a0: 706f 7274 2050 6965 6365 7769 7365 0a20  port Piecewise. 
+000158b0: 2020 2020 2020 2020 2020 2072 6574 7572             retur
+000158c0: 6e20 5069 6563 6577 6973 6528 284d 2c20  n Piecewise((M, 
+000158d0: 456c 656d 656e 7428 782c 2042 292e 7369  Element(x, B).si
+000158e0: 6d70 6c69 6679 2829 292c 2028 782c 2054  mplify()), (x, T
+000158f0: 7275 6529 292e 7369 6d70 6c69 6679 2829  rue)).simplify()
+00015900: 0a20 2020 2020 2020 200a 2020 2020 2020  .        .      
+00015910: 2020 6d20 3d20 422e 6d69 6e28 290a 2020    m = B.min().  
+00015920: 2020 2020 2020 6966 2078 203c 206d 3a0a        if x < m:.
+00015930: 2020 2020 2020 2020 2020 2020 7265 7475              retu
+00015940: 726e 2078 0a20 2020 2020 2020 200a 2020  rn x.        .  
+00015950: 2020 2020 2020 6672 6f6d 2073 796d 7079        from sympy
+00015960: 2e63 6f6e 6372 6574 652e 7265 6475 6365  .concrete.reduce
+00015970: 6420 696d 706f 7274 2052 6564 7563 6564  d import Reduced
+00015980: 4d69 6e0a 2020 2020 2020 2020 7265 7475  Min.        retu
+00015990: 726e 2052 6564 7563 6564 4d69 6e28 7365  rn ReducedMin(se
+000159a0: 6c66 290a 0a20 2020 2064 6566 206d 6178  lf)..    def max
+000159b0: 2873 656c 6629 3a20 0a20 2020 2020 2020  (self): .       
+000159c0: 2041 2c20 4220 3d20 7365 6c66 2e61 7267   A, B = self.arg
+000159d0: 730a 2020 2020 2020 2020 7820 3d20 412e  s.        x = A.
+000159e0: 6d61 7828 2920 2020 2020 200a 2020 2020  max()      .    
+000159f0: 2020 2020 2020 0a20 2020 2020 2020 2069        .        i
+00015a00: 6620 782e 6973 5f69 6e66 696e 6974 653a  f x.is_infinite:
+00015a10: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
+00015a20: 456c 656d 656e 7428 782c 2042 2920 3d3d  Element(x, B) ==
+00015a30: 2046 616c 7365 3a0a 2020 2020 2020 2020   False:.        
+00015a40: 2020 2020 2020 2020 7265 7475 726e 2078          return x
+00015a50: 0a20 2020 2020 2020 200a 2020 2020 2020  .        .      
+00015a60: 2020 6966 2073 656c 662e 6973 5f63 6f6e    if self.is_con
+00015a70: 6e65 6374 6564 5f69 6e74 6572 7661 6c28  nected_interval(
+00015a80: 293a 0a20 2020 2020 2020 2020 2020 2066  ):.            f
+00015a90: 726f 6d20 7379 6d70 792e 636f 7265 2e6e  rom sympy.core.n
+00015aa0: 756d 6265 7273 2069 6d70 6f72 7420 6570  umbers import ep
+00015ab0: 7369 6c6f 6e0a 2020 2020 2020 2020 2020  silon.          
+00015ac0: 2020 6672 6f6d 2073 796d 7079 2069 6d70    from sympy imp
+00015ad0: 6f72 7420 6365 696c 696e 670a 2020 2020  ort ceiling.    
+00015ae0: 2020 2020 2020 2020 6d20 3d20 422e 6d69          m = B.mi
+00015af0: 6e28 2920 2020 2020 2020 200a 2020 2020  n()        .    
+00015b00: 2020 2020 2020 2020 6966 2041 2e69 735f          if A.is_
+00015b10: 696e 7465 6765 723a 200a 2020 2020 2020  integer: .      
+00015b20: 2020 2020 2020 2020 2020 6d20 3d20 6365            m = ce
+00015b30: 696c 696e 6728 6d29 202d 2031 0a20 2020  iling(m) - 1.   
+00015b40: 2020 2020 2020 2020 2065 6c73 653a 0a20           else:. 
+00015b50: 2020 2020 2020 2020 2020 2020 2020 206d                 m
+00015b60: 202d 3d20 6570 7369 6c6f 6e0a 2020 2020   -= epsilon.    
+00015b70: 2020 2020 2020 2020 2020 2020 0a20 2020              .   
+00015b80: 2020 2020 2020 2020 2066 726f 6d20 7379           from sy
+00015b90: 6d70 792e 6675 6e63 7469 6f6e 732e 656c  mpy.functions.el
+00015ba0: 656d 656e 7461 7279 2e70 6965 6365 7769  ementary.piecewi
+00015bb0: 7365 2069 6d70 6f72 7420 5069 6563 6577  se import Piecew
+00015bc0: 6973 650a 2020 2020 2020 2020 2020 2020  ise.            
+00015bd0: 7265 7475 726e 2050 6965 6365 7769 7365  return Piecewise
+00015be0: 2828 6d2c 2045 6c65 6d65 6e74 2878 2c20  ((m, Element(x, 
+00015bf0: 4229 2e73 696d 706c 6966 7928 2929 2c20  B).simplify()), 
+00015c00: 2878 2c20 5472 7565 2929 2e73 696d 706c  (x, True)).simpl
+00015c10: 6966 7928 290a 2020 2020 2020 2020 0a20  ify().        . 
+00015c20: 2020 2020 2020 204d 203d 2042 2e6d 6178         M = B.max
+00015c30: 2829 0a20 2020 2020 2020 2069 6620 7820  ().        if x 
+00015c40: 3e20 4d3a 0a20 2020 2020 2020 2020 2020  > M:.           
+00015c50: 2072 6574 7572 6e20 780a 2020 2020 2020   return x.      
+00015c60: 2020 0a20 2020 2020 2020 2066 726f 6d20    .        from 
+00015c70: 7379 6d70 792e 636f 6e63 7265 7465 2e72  sympy.concrete.r
+00015c80: 6564 7563 6564 2069 6d70 6f72 7420 5265  educed import Re
+00015c90: 6475 6365 644d 6178 0a20 2020 2020 2020  ducedMax.       
+00015ca0: 2072 6574 7572 6e20 5265 6475 6365 644d   return ReducedM
+00015cb0: 6178 2873 656c 6629 2020 0a0a 2020 2020  ax(self)  ..    
+00015cc0: 4070 726f 7065 7274 790a 2020 2020 6465  @property.    de
+00015cd0: 6620 6574 7970 6528 7365 6c66 293a 0a20  f etype(self):. 
+00015ce0: 2020 2020 2020 2072 6574 7572 6e20 7365         return se
+00015cf0: 6c66 2e61 7267 735b 305d 2e65 7479 7065  lf.args[0].etype
+00015d00: 0a0a 2020 2020 6465 6620 5f5f 6e65 775f  ..    def __new_
+00015d10: 5f28 636c 732c 2061 2c20 622c 2065 7661  _(cls, a, b, eva
+00015d20: 6c75 6174 653d 5472 7565 293a 0a20 2020  luate=True):.   
+00015d30: 2020 2020 2066 726f 6d20 7379 6d70 7920       from sympy 
+00015d40: 696d 706f 7274 2046 696e 6974 6553 6574  import FiniteSet
+00015d50: 0a20 2020 2020 2020 2069 6620 6973 696e  .        if isin
+00015d60: 7374 616e 6365 2862 2c20 7365 7429 3a0a  stance(b, set):.
+00015d70: 2020 2020 2020 2020 2020 2020 6220 3d20              b = 
+00015d80: 4669 6e69 7465 5365 7428 2a62 290a 0a20  FiniteSet(*b).. 
+00015d90: 2020 2020 2020 2069 6620 6973 696e 7374         if isinst
+00015da0: 616e 6365 2861 2c20 7365 7429 3a0a 2020  ance(a, set):.  
+00015db0: 2020 2020 2020 2020 2020 6120 3d20 4669            a = Fi
+00015dc0: 6e69 7465 5365 7428 2a61 290a 0a20 2020  niteSet(*a)..   
+00015dd0: 2020 2020 2069 6620 6576 616c 7561 7465       if evaluate
+00015de0: 3a0a 2020 2020 2020 2020 2020 2020 7265  :.            re
+00015df0: 7475 726e 2043 6f6d 706c 656d 656e 742e  turn Complement.
+00015e00: 7265 6475 6365 2861 2c20 6229 0a0a 2020  reduce(a, b)..  
+00015e10: 2020 2020 2020 7265 7475 726e 2042 6173        return Bas
+00015e20: 6963 2e5f 5f6e 6577 5f5f 2863 6c73 2c20  ic.__new__(cls, 
+00015e30: 612c 2062 290a 0a23 2041 202d 2028 4220  a, b)..# A - (B 
+00015e40: 2d20 2841 2026 2042 2929 203d 2041 0a23  - (A & B)) = A.#
+00015e50: 2041 2020 2620 2028 4220 2d20 2841 2026   A  &  (B - (A &
+00015e60: 2042 2929 203d 2030 0a23 2028 4120 2620   B)) = 0.# (A & 
+00015e70: 4229 2020 2620 2028 4220 2d20 2841 2026  B)  &  (B - (A &
+00015e80: 2042 2929 203d 2030 0a23 2041 202d 2028   B)) = 0.# A - (
+00015e90: 4220 2d20 4120 2620 6229 2c20 6220 696e  B - A & b), b in
+00015ea0: 2042 0a20 2020 2064 6566 205f 636f 6d70   B.    def _comp
+00015eb0: 6c65 6d65 6e74 2873 656c 662c 2041 293a  lement(self, A):
+00015ec0: 0a20 2020 2020 2020 2042 2c20 4320 3d20  .        B, C = 
+00015ed0: 7365 6c66 2e61 7267 730a 2020 2020 2020  self.args.      
+00015ee0: 2020 6966 2043 2e69 735f 496e 7465 7273    if C.is_Inters
+00015ef0: 6563 7469 6f6e 3a0a 2020 2020 2020 2020  ection:.        
+00015f00: 2020 2020 6172 6773 203d 205b 2a43 2e61      args = [*C.a
+00015f10: 7267 735d 0a20 2020 2020 2020 2020 2020  rgs].           
+00015f20: 2074 7279 3a0a 2020 2020 2020 2020 2020   try:.          
+00015f30: 2020 2020 2020 696e 6465 7820 3d20 6172        index = ar
+00015f40: 6773 2e69 6e64 6578 2841 290a 2020 2020  gs.index(A).    
+00015f50: 2020 2020 2020 2020 2020 2020 6465 6c20              del 
+00015f60: 6172 6773 5b69 6e64 6578 5d0a 2020 2020  args[index].    
+00015f70: 2020 2020 2020 2020 2020 2020 6220 3d20              b = 
+00015f80: 432e 6675 6e63 282a 6172 6773 2c20 6576  C.func(*args, ev
+00015f90: 616c 7561 7465 3d46 616c 7365 290a 2020  aluate=False).  
+00015fa0: 2020 2020 2020 2020 2020 2020 2020 6966                if
+00015fb0: 2062 203d 3d20 423a 0a20 2020 2020 2020   b == B:.       
+00015fc0: 2020 2020 2020 2020 2020 2020 2072 6574               ret
+00015fd0: 7572 6e20 410a 2020 2020 2020 2020 2020  urn A.          
+00015fe0: 2020 2020 2020 6966 2062 2069 6e20 423a        if b in B:
+00015ff0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00016000: 2020 2020 2042 203d 2043 6f6d 706c 656d       B = Complem
+00016010: 656e 7428 422c 2062 290a 2020 2020 2020  ent(B, b).      
+00016020: 2020 2020 2020 2020 2020 2020 2020 7265                re
+00016030: 7475 726e 2073 656c 662e 6675 6e63 2841  turn self.func(A
+00016040: 2c20 422c 2065 7661 6c75 6174 653d 4661  , B, evaluate=Fa
+00016050: 6c73 6529 0a20 2020 2020 2020 2020 2020  lse).           
+00016060: 2065 7863 6570 743a 0a20 2020 2020 2020   except:.       
+00016070: 2020 2020 2020 2020 2072 6574 7572 6e0a           return.
+00016080: 2020 2020 2020 2020 6966 2041 2069 6e20          if A in 
+00016090: 4220 7c20 433a 0a20 2020 2020 2020 2020  B | C:.         
+000160a0: 2020 2072 6574 7572 6e20 4120 2620 430a     return A & C.
+000160b0: 2020 2020 2020 2020 6966 206e 6f74 2041          if not A
+000160c0: 2026 2043 3a0a 2020 2020 2020 2020 2020   & C:.          
+000160d0: 2020 7265 7475 726e 2043 6f6d 706c 656d    return Complem
+000160e0: 656e 7428 412c 2042 290a 2020 2020 2020  ent(A, B).      
+000160f0: 2020 6966 2042 2069 6e20 413a 0a23 2020    if B in A:.#  
+00016100: 2020 2020 2020 2020 2020 2069 6620 4320             if C 
+00016110: 696e 2042 3a0a 2320 2020 2020 2020 2020  in B:.#         
+00016120: 2020 2020 2020 2020 7265 7475 726e 2028          return (
+00016130: 4120 2d20 4229 207c 2043 0a20 2020 2020  A - B) | C.     
+00016140: 2020 2020 2020 2069 6620 4320 696e 2041         if C in A
+00016150: 3a20 2023 2043 2069 6e20 4220 3d3e 2043  :  # C in B => C
+00016160: 2069 6e20 410a 2020 2020 2020 2020 2020   in A.          
+00016170: 2020 2020 2020 7265 7475 726e 2043 6f6d        return Com
+00016180: 706c 656d 656e 7428 412c 2042 2920 7c20  plement(A, B) | 
+00016190: 430a 2320 2020 2020 2020 2020 2020 2020  C.#             
+000161a0: 7265 7475 726e 2028 4120 2d20 4229 207c  return (A - B) |
+000161b0: 2028 4220 2620 4329 0a0a 2020 2020 4073   (B & C)..    @s
+000161c0: 7461 7469 636d 6574 686f 640a 2020 2020  taticmethod.    
+000161d0: 6465 6620 7265 6475 6365 2841 2c20 4229  def reduce(A, B)
+000161e0: 3a0a 2020 2020 2020 2020 2222 220a 2020  :.        """.  
+000161f0: 2020 2020 2020 5369 6d70 6c69 6679 2061        Simplify a
+00016200: 203a 636c 6173 733a 6043 6f6d 706c 656d   :class:`Complem
+00016210: 656e 7460 2e0a 0a20 2020 2020 2020 2022  ent`...        "
+00016220: 2222 0a20 2020 2020 2020 2023 2074 7279  "".        # try
+00016230: 2074 6f20 6576 616c 7561 7465 2041 205c   to evaluate A \
+00016240: 2042 0a20 2020 2020 2020 2069 6620 422e   B.        if B.
+00016250: 6973 5f55 6e69 7665 7273 616c 5365 743a  is_UniversalSet:
+00016260: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
+00016270: 412e 6574 7970 6520 696e 2042 2e65 7479  A.etype in B.ety
+00016280: 7065 3a0a 2020 2020 2020 2020 2020 2020  pe:.            
+00016290: 2020 2020 7265 7475 726e 2041 2e65 7479      return A.ety
+000162a0: 7065 2e65 6d70 7479 5365 740a 2020 2020  pe.emptySet.    
+000162b0: 2020 2020 0a20 2020 2020 2020 2069 6620      .        if 
+000162c0: 412e 6973 5f73 7562 7365 7428 4229 3a0a  A.is_subset(B):.
+000162d0: 2020 2020 2020 2020 2020 2020 7265 7475              retu
+000162e0: 726e 2041 2e65 7479 7065 2e65 6d70 7479  rn A.etype.empty
+000162f0: 5365 740a 0a20 2020 2020 2020 2069 6620  Set..        if 
+00016300: 422e 6973 5f55 6e69 6f6e 3a0a 2020 2020  B.is_Union:.    
+00016310: 2020 2020 2020 2020 7265 7475 726e 2049          return I
+00016320: 6e74 6572 7365 6374 696f 6e28 2a28 732e  ntersection(*(s.
+00016330: 636f 6d70 6c65 6d65 6e74 2841 2920 666f  complement(A) fo
+00016340: 7220 7320 696e 2042 2e61 7267 7329 290a  r s in B.args)).
+00016350: 0a20 2020 2020 2020 2072 6573 756c 7420  .        result 
+00016360: 3d20 422e 5f63 6f6d 706c 656d 656e 7428  = B._complement(
+00016370: 4129 0a20 2020 2020 2020 2069 6620 7265  A).        if re
+00016380: 7375 6c74 2069 7320 6e6f 7420 4e6f 6e65  sult is not None
+00016390: 3a0a 2020 2020 2020 2020 2020 2020 7265  :.            re
+000163a0: 7475 726e 2072 6573 756c 740a 0a20 2020  turn result..   
+000163b0: 2020 2020 2069 6620 412e 6973 5f55 6e69       if A.is_Uni
+000163c0: 6f6e 3a0a 2020 2020 2020 2020 2020 2020  on:.            
+000163d0: 666f 7220 692c 2061 7267 2069 6e20 656e  for i, arg in en
+000163e0: 756d 6572 6174 6528 412e 6172 6773 293a  umerate(A.args):
+000163f0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00016400: 2069 6620 6172 6720 696e 2042 3a0a 2020   if arg in B:.  
+00016410: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00016420: 2020 6172 6773 203d 205b 2a41 2e61 7267    args = [*A.arg
+00016430: 735d 0a20 2020 2020 2020 2020 2020 2020  s].             
+00016440: 2020 2020 2020 2064 656c 2061 7267 735b         del args[
+00016450: 695d 0a20 2020 2020 2020 2020 2020 2020  i].             
+00016460: 2020 2020 2020 2041 203d 2041 2e66 756e         A = A.fun
+00016470: 6328 2a61 7267 7329 0a20 2020 2020 2020  c(*args).       
+00016480: 2020 2020 2020 2020 2020 2020 2072 6574               ret
+00016490: 7572 6e20 436f 6d70 6c65 6d65 6e74 2841  urn Complement(A
+000164a0: 2c20 4229 0a20 2020 2020 2020 2020 2020  , B).           
+000164b0: 2020 2020 2020 0a20 2020 2020 2020 2069        .        i
+000164c0: 6620 412e 6973 5f43 7570 3a0a 2020 2020  f A.is_Cup:.    
+000164d0: 2020 2020 2020 2020 6966 2041 2e69 735f          if A.is_
+000164e0: 436f 6e64 6974 696f 6e53 6574 3a0a 2020  ConditionSet:.  
+000164f0: 2020 2020 2020 2020 2020 2020 2020 6966                if
+00016500: 206e 6f74 2042 2e69 735f 436f 6e64 6974   not B.is_Condit
+00016510: 696f 6e53 6574 3a0a 2020 2020 2020 2020  ionSet:.        
+00016520: 2020 2020 2020 2020 2020 2020 6672 6f6d              from
+00016530: 2073 796d 7079 2e73 6574 7320 696d 706f   sympy.sets impo
+00016540: 7274 2063 6f6e 6469 7469 6f6e 7365 740a  rt conditionset.
+00016550: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00016560: 2020 2020 6261 7365 5f73 6574 203d 2042      base_set = B
+00016570: 2e5f 636f 6d70 6c65 6d65 6e74 2841 2e62  ._complement(A.b
+00016580: 6173 655f 7365 7429 0a20 2020 2020 2020  ase_set).       
+00016590: 2020 2020 2020 2020 2020 2020 2069 6620               if 
+000165a0: 6261 7365 5f73 6574 2069 7320 6e6f 7420  base_set is not 
+000165b0: 4e6f 6e65 3a0a 2020 2020 2020 2020 2020  None:.          
+000165c0: 2020 2020 2020 2020 2020 2020 2020 6966                if
+000165d0: 2041 2e62 6173 655f 7365 7420 3d3d 2062   A.base_set == b
+000165e0: 6173 655f 7365 743a 0a20 2020 2020 2020  ase_set:.       
+000165f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00016600: 2020 2020 2072 6574 7572 6e20 410a 2020       return A.  
+00016610: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00016620: 2020 2020 2020 7265 7475 726e 2063 6f6e        return con
+00016630: 6469 7469 6f6e 7365 7428 412e 7661 7269  ditionset(A.vari
+00016640: 6162 6c65 2c20 412e 636f 6e64 6974 696f  able, A.conditio
+00016650: 6e2c 2062 6173 655f 7365 7429 0a20 2020  n, base_set).   
+00016660: 2020 2020 2020 2020 2065 6c69 6620 412e           elif A.
+00016670: 7261 6e67 655f 636f 6e74 6169 6e73 2842  range_contains(B
+00016680: 2920 6973 2046 616c 7365 3a0a 2020 2020  ) is False:.    
+00016690: 2020 2020 2020 2020 2020 2020 7265 7475              retu
+000166a0: 726e 2041 0a20 2020 2020 2020 2020 2020  rn A.           
+000166b0: 2020 2020 2020 2020 200a 2020 2020 2020           .      
+000166c0: 2020 6966 2042 2e69 735f 496e 7465 7273    if B.is_Inters
+000166d0: 6563 7469 6f6e 2061 6e64 2041 2069 6e20  ection and A in 
+000166e0: 422e 5f61 7267 7365 743a 0a20 2020 2020  B._argset:.     
+000166f0: 2020 2020 2020 2042 203d 2042 2e66 756e         B = B.fun
+00016700: 6328 2a42 2e5f 6172 6773 6574 202d 207b  c(*B._argset - {
+00016710: 417d 2c20 6576 616c 7561 7465 3d46 616c  A}, evaluate=Fal
+00016720: 7365 290a 2020 2020 2020 2020 2020 2020  se).            
+00016730: 0a20 2020 2020 2020 2069 6620 412e 6973  .        if A.is
+00016740: 5f50 6965 6365 7769 7365 3a0a 2020 2020  _Piecewise:.    
+00016750: 2020 2020 2020 2020 7265 7475 726e 2041          return A
+00016760: 2e66 756e 6328 2a28 2843 6f6d 706c 656d  .func(*((Complem
+00016770: 656e 7428 652c 2042 292c 2063 2920 666f  ent(e, B), c) fo
+00016780: 7220 652c 2063 2069 6e20 412e 6172 6773  r e, c in A.args
+00016790: 2929 2e73 696d 706c 6966 7928 290a 2020  )).simplify().  
+000167a0: 2020 2020 2020 0a20 2020 2020 2020 2069        .        i
+000167b0: 6620 412e 6973 5f49 6e74 6572 7365 6374  f A.is_Intersect
+000167c0: 696f 6e3a 0a20 2020 2020 2020 2020 2020  ion:.           
+000167d0: 2066 6f72 2069 2c20 6172 6720 696e 2065   for i, arg in e
+000167e0: 6e75 6d65 7261 7465 2841 2e61 7267 7329  numerate(A.args)
+000167f0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+00016800: 2020 6966 2061 7267 2e69 735f 436f 6d70    if arg.is_Comp
+00016810: 6c65 6d65 6e74 2061 6e64 2061 7267 2e61  lement and arg.a
+00016820: 7267 735b 315d 2069 6e20 423a 200a 2020  rgs[1] in B: .  
+00016830: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00016840: 2020 6172 6773 203d 205b 2a41 2e61 7267    args = [*A.arg
+00016850: 735d 0a20 2020 2020 2020 2020 2020 2020  s].             
+00016860: 2020 2020 2020 2061 7267 735b 695d 203d         args[i] =
+00016870: 2061 7267 2e61 7267 735b 305d 0a20 2020   arg.args[0].   
+00016880: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00016890: 2041 203d 2041 2e66 756e 6328 2a61 7267   A = A.func(*arg
+000168a0: 732c 2065 7661 6c75 6174 653d 4661 6c73  s, evaluate=Fals
+000168b0: 6529 0a20 2020 2020 2020 2020 2020 2020  e).             
+000168c0: 2020 2020 2020 2072 6574 7572 6e20 436f         return Co
+000168d0: 6d70 6c65 6d65 6e74 2841 2c20 4229 0a20  mplement(A, B). 
+000168e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000168f0: 2020 2020 0a20 2020 2020 2020 2069 6620      .        if 
+00016900: 412e 6973 5f43 6f6d 706c 656d 656e 743a  A.is_Complement:
+00016910: 0a20 2020 2020 2020 2020 2020 205f 412c  .            _A,
+00016920: 205f 4220 3d20 412e 6172 6773 0a20 2020   _B = A.args.   
+00016930: 2020 2020 2020 2020 2069 6620 4220 696e           if B in
+00016940: 205f 423a 0a20 2020 2020 2020 2020 2020   _B:.           
+00016950: 2020 2020 2072 6574 7572 6e20 410a 2020       return A.  
+00016960: 2020 2020 2020 2020 2020 412c 2042 203d            A, B =
+00016970: 205f 412c 205f 4220 7c20 420a 2020 2020   _A, _B | B.    
+00016980: 2020 2020 7265 7475 726e 2043 6f6d 706c      return Compl
+00016990: 656d 656e 7428 412c 2042 2c20 6576 616c  ement(A, B, eval
+000169a0: 7561 7465 3d46 616c 7365 290a 0a20 2020  uate=False)..   
+000169b0: 2064 6566 205f 636f 6e74 6169 6e73 2873   def _contains(s
+000169c0: 656c 662c 206f 7468 6572 293a 0a20 2020  elf, other):.   
+000169d0: 2020 2020 2041 203d 2073 656c 662e 6172       A = self.ar
+000169e0: 6773 5b30 5d0a 2020 2020 2020 2020 4220  gs[0].        B 
+000169f0: 3d20 7365 6c66 2e61 7267 735b 315d 0a20  = self.args[1]. 
+00016a00: 2020 2020 2020 2072 6574 7572 6e20 416e         return An
+00016a10: 6428 456c 656d 656e 7428 6f74 6865 722c  d(Element(other,
+00016a20: 2041 292c 2045 6c65 6d65 6e74 286f 7468   A), Element(oth
+00016a30: 6572 2c20 4229 2e69 6e76 6572 7428 2929  er, B).invert())
+00016a40: 0a0a 2020 2020 6465 6620 756e 696f 6e5f  ..    def union_
+00016a50: 7365 7473 2873 656c 662c 2043 293a 0a20  sets(self, C):. 
+00016a60: 2020 2020 2020 2041 2c20 4220 3d20 7365         A, B = se
+00016a70: 6c66 2e61 7267 730a 2020 2020 2020 2020  lf.args.        
+00016a80: 6966 2042 2069 6e20 433a 0a20 2020 2020  if B in C:.     
+00016a90: 2020 2020 2020 2072 6574 7572 6e20 4120         return A 
+00016aa0: 7c20 430a 2020 2020 2020 2020 6966 2041  | C.        if A
+00016ab0: 2069 6e20 433a 0a20 2020 2020 2020 2020   in C:.         
+00016ac0: 2020 2072 6574 7572 6e20 430a 2020 2020     return C.    
+00016ad0: 2020 2020 6966 2043 2e69 735f 496e 7465      if C.is_Inte
+00016ae0: 7273 6563 7469 6f6e 3a0a 2020 2020 2020  rsection:.      
+00016af0: 2020 2020 2020 6966 2041 2026 2042 2069        if A & B i
+00016b00: 6e20 433a 0a20 2020 2020 2020 2020 2020  n C:.           
+00016b10: 2020 2020 2072 6574 7572 6e20 4120 7c20       return A | 
+00016b20: 430a 2020 2020 2020 2020 2020 2020 7472  C.            tr
+00016b30: 793a 0a20 2020 2020 2020 2020 2020 2020  y:.             
+00016b40: 2020 2023 2041 2026 2042 207c 2028 412d     # A & B | (A-
+00016b50: 4229 203d 2041 0a20 2020 2020 2020 2020  B) = A.         
+00016b60: 2020 2020 2020 2023 2041 2026 2042 207c         # A & B |
+00016b70: 2028 412d 2842 2b43 2929 203d 2041 202d   (A-(B+C)) = A -
+00016b80: 2043 0a20 2020 2020 2020 2020 2020 2020   C.             
+00016b90: 2020 2061 7267 7320 3d20 5b2a 432e 6172     args = [*C.ar
+00016ba0: 6773 5d0a 2020 2020 2020 2020 2020 2020  gs].            
+00016bb0: 2020 2020 696e 6465 7820 3d20 6172 6773      index = args
+00016bc0: 2e69 6e64 6578 2841 290a 2020 2020 2020  .index(A).      
+00016bd0: 2020 2020 2020 2020 2020 6465 6c20 6172            del ar
+00016be0: 6773 5b69 6e64 6578 5d0a 2020 2020 2020  gs[index].      
+00016bf0: 2020 2020 2020 2020 2020 7265 7374 203d            rest =
+00016c00: 2043 2e66 756e 6328 2a61 7267 732c 2065   C.func(*args, e
+00016c10: 7661 6c75 6174 653d 4661 6c73 6529 0a20  valuate=False). 
+00016c20: 2020 2020 2020 2020 2020 2020 2020 2069                 i
+00016c30: 6620 7265 7374 2069 6e20 423a 0a20 2020  f rest in B:.   
+00016c40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00016c50: 2072 6574 7572 6e20 436f 6d70 6c65 6d65   return Compleme
+00016c60: 6e74 2841 2c20 436f 6d70 6c65 6d65 6e74  nt(A, Complement
+00016c70: 2842 2c20 7265 7374 2929 0a20 2020 2020  (B, rest)).     
+00016c80: 2020 2020 2020 2065 7863 6570 743a 0a20         except:. 
+00016c90: 2020 2020 2020 2020 2020 2020 2020 2072                 r
+00016ca0: 6574 7572 6e0a 2020 2020 2020 2020 6966  eturn.        if
+00016cb0: 2043 2069 6e20 423a 0a20 2020 2020 2020   C in B:.       
+00016cc0: 2020 2020 2042 203d 2043 6f6d 706c 656d       B = Complem
+00016cd0: 656e 7428 422c 2043 290a 2020 2020 2020  ent(B, C).      
+00016ce0: 2020 2020 2020 7265 7475 726e 2073 656c        return sel
+00016cf0: 662e 6675 6e63 2841 207c 2043 2c20 422c  f.func(A | C, B,
+00016d00: 2065 7661 6c75 6174 653d 4661 6c73 6529   evaluate=False)
+00016d10: 0a20 2020 2020 2020 2069 6620 432e 6973  .        if C.is
+00016d20: 5f43 6f6d 706c 656d 656e 743a 0a20 2020  _Complement:.   
+00016d30: 2020 2020 2020 2020 205f 412c 205f 4220           _A, _B 
+00016d40: 3d20 432e 6172 6773 0a20 2020 2020 2020  = C.args.       
+00016d50: 2020 2020 2069 6620 4220 3d3d 205f 423a       if B == _B:
+00016d60: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00016d70: 2072 6574 7572 6e20 436f 6d70 6c65 6d65   return Compleme
+00016d80: 6e74 2841 207c 205f 412c 2042 290a 2020  nt(A | _A, B).  
+00016d90: 2020 2020 2020 2020 2020 6966 205f 4220            if _B 
+00016da0: 696e 2073 656c 663a 0a20 2020 2020 2020  in self:.       
+00016db0: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
+00016dc0: 5f41 207c 2073 656c 660a 0a23 2069 6620  _A | self..# if 
+00016dd0: 4220 3d3e 2043 2c20 2841 202d 2042 2920  B => C, (A - B) 
+00016de0: 7c20 4320 3d20 4120 7c20 430a 2320 6966  | C = A | C.# if
+00016df0: 2041 203d 3e20 432c 2028 4120 2d20 4229   A => C, (A - B)
+00016e00: 207c 2043 203d 2043 0a0a 2020 2020 6465   | C = C..    de
+00016e10: 6620 5f65 7661 6c5f 6973 5f65 7874 656e  f _eval_is_exten
+00016e20: 6465 645f 696e 7465 6765 7228 7365 6c66  ded_integer(self
+00016e30: 293a 0a20 2020 2020 2020 2072 6574 7572  ):.        retur
+00016e40: 6e20 7365 6c66 2e61 7267 735b 305d 2e69  n self.args[0].i
+00016e50: 735f 6578 7465 6e64 6564 5f69 6e74 6567  s_extended_integ
+00016e60: 6572 0a0a 2020 2020 6465 6620 5f65 7661  er..    def _eva
+00016e70: 6c5f 6973 5f73 7570 6572 5f69 6e74 6567  l_is_super_integ
+00016e80: 6572 2873 656c 6629 3a0a 2020 2020 2020  er(self):.      
+00016e90: 2020 7265 7475 726e 2073 656c 662e 6172    return self.ar
+00016ea0: 6773 5b30 5d2e 6973 5f73 7570 6572 5f69  gs[0].is_super_i
+00016eb0: 6e74 6567 6572 0a20 2020 200a 2020 2020  nteger.    .    
+00016ec0: 6465 6620 5f65 7661 6c5f 6973 5f65 7874  def _eval_is_ext
+00016ed0: 656e 6465 645f 7261 7469 6f6e 616c 2873  ended_rational(s
+00016ee0: 656c 6629 3a0a 2020 2020 2020 2020 7265  elf):.        re
+00016ef0: 7475 726e 2073 656c 662e 6172 6773 5b30  turn self.args[0
+00016f00: 5d2e 6973 5f65 7874 656e 6465 645f 7261  ].is_extended_ra
+00016f10: 7469 6f6e 616c 0a20 2020 200a 2020 2020  tional.    .    
+00016f20: 6465 6620 5f65 7661 6c5f 6973 5f68 7970  def _eval_is_hyp
+00016f30: 6572 5f72 6174 696f 6e61 6c28 7365 6c66  er_rational(self
+00016f40: 293a 0a20 2020 2020 2020 2072 6574 7572  ):.        retur
+00016f50: 6e20 7365 6c66 2e61 7267 735b 305d 2e69  n self.args[0].i
+00016f60: 735f 6879 7065 725f 7261 7469 6f6e 616c  s_hyper_rational
+00016f70: 0a20 2020 200a 2020 2020 6465 6620 5f65  .    .    def _e
+00016f80: 7661 6c5f 6973 5f73 7570 6572 5f72 6174  val_is_super_rat
+00016f90: 696f 6e61 6c28 7365 6c66 293a 0a20 2020  ional(self):.   
+00016fa0: 2020 2020 2072 6574 7572 6e20 7365 6c66       return self
+00016fb0: 2e61 7267 735b 305d 2e69 735f 7375 7065  .args[0].is_supe
+00016fc0: 725f 7261 7469 6f6e 616c 0a20 2020 200a  r_rational.    .
+00016fd0: 2020 2020 6465 6620 5f65 7661 6c5f 6973      def _eval_is
+00016fe0: 5f65 7874 656e 6465 645f 7265 616c 2873  _extended_real(s
+00016ff0: 656c 6629 3a0a 2020 2020 2020 2020 7265  elf):.        re
+00017000: 7475 726e 2073 656c 662e 6172 6773 5b30  turn self.args[0
+00017010: 5d2e 6973 5f65 7874 656e 6465 645f 7265  ].is_extended_re
+00017020: 616c 0a20 2020 200a 2020 2020 6465 6620  al.    .    def 
+00017030: 5f65 7661 6c5f 6973 5f65 7874 656e 6465  _eval_is_extende
+00017040: 645f 6e65 6761 7469 7665 2873 656c 6629  d_negative(self)
+00017050: 3a0a 2020 2020 2020 2020 7265 7475 726e  :.        return
+00017060: 2073 656c 662e 6172 6773 5b30 5d2e 6973   self.args[0].is
+00017070: 5f65 7874 656e 6465 645f 6e65 6761 7469  _extended_negati
+00017080: 7665 0a0a 2020 2020 6465 6620 5f65 7661  ve..    def _eva
+00017090: 6c5f 6973 5f65 7874 656e 6465 645f 706f  l_is_extended_po
+000170a0: 7369 7469 7665 2873 656c 6629 3a0a 2020  sitive(self):.  
+000170b0: 2020 2020 2020 7265 7475 726e 2073 656c        return sel
+000170c0: 662e 6172 6773 5b30 5d2e 6973 5f65 7874  f.args[0].is_ext
+000170d0: 656e 6465 645f 706f 7369 7469 7665 0a20  ended_positive. 
+000170e0: 2020 200a 2020 2020 6465 6620 5f65 7661     .    def _eva
+000170f0: 6c5f 6973 5f68 7970 6572 5f72 6561 6c28  l_is_hyper_real(
+00017100: 7365 6c66 293a 0a20 2020 2020 2020 2072  self):.        r
+00017110: 6574 7572 6e20 7365 6c66 2e61 7267 735b  eturn self.args[
+00017120: 305d 2e69 735f 6879 7065 725f 7265 616c  0].is_hyper_real
+00017130: 0a20 2020 200a 2020 2020 6465 6620 5f65  .    .    def _e
+00017140: 7661 6c5f 6973 5f73 7570 6572 5f72 6561  val_is_super_rea
+00017150: 6c28 7365 6c66 293a 0a20 2020 2020 2020  l(self):.       
+00017160: 2072 6574 7572 6e20 7365 6c66 2e61 7267   return self.arg
+00017170: 735b 305d 2e69 735f 7375 7065 725f 7265  s[0].is_super_re
+00017180: 616c 0a20 2020 200a 2020 2020 6465 6620  al.    .    def 
+00017190: 5f65 7661 6c5f 6973 5f65 7874 656e 6465  _eval_is_extende
+000171a0: 645f 636f 6d70 6c65 7828 7365 6c66 293a  d_complex(self):
+000171b0: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
+000171c0: 7365 6c66 2e61 7267 735b 305d 2e69 735f  self.args[0].is_
+000171d0: 6578 7465 6e64 6564 5f63 6f6d 706c 6578  extended_complex
+000171e0: 0a0a 2020 2020 6465 6620 5f65 7661 6c5f  ..    def _eval_
+000171f0: 6973 5f7a 6572 6f28 7365 6c66 293a 0a20  is_zero(self):. 
+00017200: 2020 2020 2020 2072 6574 7572 6e20 7365         return se
+00017210: 6c66 2e61 7267 735b 305d 2e69 735f 7a65  lf.args[0].is_ze
+00017220: 726f 0a0a 2020 2020 6465 6620 5f65 7661  ro..    def _eva
+00017230: 6c5f 6973 5f66 696e 6974 6528 7365 6c66  l_is_finite(self
+00017240: 293a 0a20 2020 2020 2020 2072 6574 7572  ):.        retur
+00017250: 6e20 7365 6c66 2e61 7267 735b 305d 2e69  n self.args[0].i
+00017260: 735f 6669 6e69 7465 0a0a 2020 2020 4063  s_finite..    @c
+00017270: 6163 6865 6974 0a20 2020 2064 6566 205f  acheit.    def _
+00017280: 6576 616c 5f64 6f6d 6169 6e5f 6465 6669  eval_domain_defi
+00017290: 6e65 6428 7365 6c66 2c20 782c 202a 2a5f  ned(self, x, **_
+000172a0: 293a 0a20 2020 2020 2020 2041 2c20 4220  ):.        A, B 
+000172b0: 3d20 7365 6c66 2e61 7267 730a 2020 2020  = self.args.    
+000172c0: 2020 2020 7265 7475 726e 2041 2e64 6f6d      return A.dom
+000172d0: 6169 6e5f 6465 6669 6e65 6428 7829 2026  ain_defined(x) &
+000172e0: 2042 2e64 6f6d 6169 6e5f 6465 6669 6e65   B.domain_define
+000172f0: 6428 7829 0a0a 2020 2020 6465 6620 7375  d(x)..    def su
+00017300: 7072 656d 756d 2873 656c 6629 3a0a 2020  premum(self):.  
+00017310: 2020 2020 2020 7265 7475 726e 2073 656c        return sel
+00017320: 662e 6172 6773 5b30 5d2e 6d61 7828 290a  f.args[0].max().
+00017330: 0a20 2020 2064 6566 2069 6e66 696d 756d  .    def infimum
+00017340: 2873 656c 6629 3a0a 2020 2020 2020 2020  (self):.        
+00017350: 7265 7475 726e 2073 656c 662e 6172 6773  return self.args
+00017360: 5b30 5d2e 6d69 6e28 290a 2020 2020 0a20  [0].min().    . 
+00017370: 2020 2064 6566 205f 5f61 6464 5f5f 2873     def __add__(s
+00017380: 656c 662c 206f 7468 6572 293a 0a20 2020  elf, other):.   
+00017390: 2020 2020 2041 2c20 4220 3d20 7365 6c66       A, B = self
+000173a0: 2e61 7267 730a 2020 2020 2020 2020 7265  .args.        re
+000173b0: 7475 726e 2073 656c 662e 6675 6e63 2841  turn self.func(A
+000173c0: 202b 206f 7468 6572 2c20 4220 2b20 6f74   + other, B + ot
+000173d0: 6865 7229 0a20 2020 200a 2020 2020 6465  her).    .    de
+000173e0: 6620 6861 6e64 6c65 5f66 696e 6974 655f  f handle_finite_
+000173f0: 7365 7473 2873 656c 662c 2075 6e6b 293a  sets(self, unk):
+00017400: 0a20 2020 2020 2020 2041 2c20 4220 3d20  .        A, B = 
+00017410: 7365 6c66 2e61 7267 730a 2020 2020 2020  self.args.      
+00017420: 2020 6966 2075 6e6b 2069 6e20 423a 0a20    if unk in B:. 
+00017430: 2020 2020 2020 2020 2020 2072 6574 7572             retur
+00017440: 6e20 7365 6c66 2e65 7479 7065 2e65 6d70  n self.etype.emp
+00017450: 7479 5365 740a 2020 2020 2020 2020 6966  tySet.        if
+00017460: 2075 6e6b 2069 6e20 413a 0a20 2020 2020   unk in A:.     
+00017470: 2020 2020 2020 2069 6620 422e 6973 5f49         if B.is_I
+00017480: 6e74 6572 7365 6374 696f 6e3a 0a20 2020  ntersection:.   
+00017490: 2020 2020 2020 2020 2020 2020 2061 7267               arg
+000174a0: 7320 3d20 5b5d 0a20 2020 2020 2020 2020  s = [].         
+000174b0: 2020 2020 2020 2066 6f72 2073 2069 6e20         for s in 
+000174c0: 422e 6172 6773 3a0a 2020 2020 2020 2020  B.args:.        
+000174d0: 2020 2020 2020 2020 2020 2020 6966 2075              if u
+000174e0: 6e6b 2069 6e20 733a 0a20 2020 2020 2020  nk in s:.       
+000174f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00017500: 2063 6f6e 7469 6e75 650a 2020 2020 2020   continue.      
+00017510: 2020 2020 2020 2020 2020 2020 2020 6172                ar
+00017520: 6773 2e61 7070 656e 6428 7329 0a20 2020  gs.append(s).   
+00017530: 2020 2020 2020 2020 2020 2020 2069 6620               if 
+00017540: 6c65 6e28 6172 6773 2920 213d 206c 656e  len(args) != len
+00017550: 2842 2e61 7267 7329 3a0a 2020 2020 2020  (B.args):.      
+00017560: 2020 2020 2020 2020 2020 2020 2020 4220                B 
+00017570: 3d20 422e 6675 6e63 282a 6172 6773 290a  = B.func(*args).
+00017580: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00017590: 2020 2020 2020 2020 0a20 2020 2020 2020          .       
+000175a0: 2020 2020 2072 6574 7572 6e20 7365 6c66       return self
+000175b0: 2e66 756e 6328 756e 6b2c 2042 2c20 6576  .func(unk, B, ev
+000175c0: 616c 7561 7465 3d46 616c 7365 290a 2020  aluate=False).  
+000175d0: 2020 2020 2020 6966 2041 2069 6e20 756e        if A in un
+000175e0: 6b3a 0a23 2020 2020 2020 2020 2020 2020  k:.#            
+000175f0: 2063 6f6e 7369 6465 7220 7468 6520 6361   consider the ca
+00017600: 7365 203a 205b 303b 206e 2920 e288 a920  se : [0; n) ... 
+00017610: 7b6a 7d20 2f20 5b30 3b20 6e29 20e2 88a9  {j} / [0; n) ...
+00017620: 207b 697d 2c20 7b6a 7d0a 2020 2020 2020   {i}, {j}.      
+00017630: 2020 2020 2020 7265 7475 726e 2073 656c        return sel
+00017640: 660a 0a20 2020 2040 636c 6173 736d 6574  f..    @classmet
+00017650: 686f 640a 2020 2020 6465 6620 7369 6d70  hod.    def simp
+00017660: 6c69 6679 5f55 6e65 7175 616c 2863 6c73  lify_Unequal(cls
+00017670: 2c20 7365 6c66 2c20 6c68 732c 2072 6873  , self, lhs, rhs
+00017680: 293a 0a20 2020 2020 2020 2022 2222 0a20  ):.        """. 
+00017690: 2020 2020 2020 2070 7265 636f 6e64 6974         precondit
+000176a0: 696f 6e3a 2073 656c 662e 6c68 7320 6973  ion: self.lhs is
+000176b0: 2061 2043 6f6d 706c 656d 656e 7420 6f62   a Complement ob
+000176c0: 6a65 6374 210a 2020 2020 2020 2020 2222  ject!.        ""
+000176d0: 220a 2020 2020 2020 2020 6966 2072 6873  ".        if rhs
+000176e0: 2e69 735f 456d 7074 7953 6574 3a0a 2020  .is_EmptySet:.  
+000176f0: 2020 2020 2020 2020 2020 412c 2042 203d            A, B =
+00017700: 206c 6873 2e61 7267 730a 2020 2020 2020   lhs.args.      
+00017710: 2020 2020 2020 6672 6f6d 2073 796d 7079        from sympy
+00017720: 2069 6d70 6f72 7420 4e6f 7453 7562 7365   import NotSubse
+00017730: 740a 2020 2020 2020 2020 2020 2020 7265  t.            re
+00017740: 7475 726e 204e 6f74 5375 6273 6574 2841  turn NotSubset(A
+00017750: 2c20 4229 2e73 696d 706c 6966 7928 290a  , B).simplify().
+00017760: 0a20 2020 2040 636c 6173 736d 6574 686f  .    @classmetho
+00017770: 640a 2020 2020 6465 6620 7369 6d70 6c69  d.    def simpli
+00017780: 6679 5f45 6c65 6d65 6e74 2863 6c73 2c20  fy_Element(cls, 
+00017790: 7365 6c66 2c20 652c 2073 293a 0a20 2020  self, e, s):.   
+000177a0: 2020 2020 2022 2222 0a20 2020 2020 2020       """.       
+000177b0: 2070 7265 636f 6e64 6974 696f 6e3a 2073   precondition: s
+000177c0: 656c 662e 7268 7320 6973 2061 2043 6f6d  elf.rhs is a Com
+000177d0: 706c 656d 656e 7420 6f62 6a65 6374 210a  plement object!.
+000177e0: 2020 2020 2020 2020 2222 220a 2020 2020          """.    
+000177f0: 2020 2020 552c 2042 203d 2073 2e61 7267      U, B = s.arg
+00017800: 730a 2020 2020 2020 2020 6966 2055 2e69  s.        if U.i
+00017810: 735f 556e 6976 6572 7361 6c53 6574 3a0a  s_UniversalSet:.
+00017820: 2020 2020 2020 2020 2020 2020 7265 7475              retu
+00017830: 726e 2073 656c 662e 696e 7665 7274 5f74  rn self.invert_t
+00017840: 7970 6528 652c 2042 292e 7369 6d70 6c69  ype(e, B).simpli
+00017850: 6679 2829 200a 2020 2020 2020 2020 656c  fy() .        el
+00017860: 6966 2042 2e69 735f 4669 6e69 7465 5365  if B.is_FiniteSe
+00017870: 7420 616e 6420 6c65 6e28 4229 203d 3d20  t and len(B) == 
+00017880: 313a 0a20 2020 2020 2020 2020 2020 2064  1:.            d
+00017890: 6f6d 6169 6e5f 6173 7375 6d65 6420 3d20  omain_assumed = 
+000178a0: 652e 646f 6d61 696e 5f61 7373 756d 6564  e.domain_assumed
+000178b0: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
+000178c0: 646f 6d61 696e 5f61 7373 756d 6564 2061  domain_assumed a
+000178d0: 6e64 2064 6f6d 6169 6e5f 6173 7375 6d65  nd domain_assume
+000178e0: 6420 3d3d 2055 3a0a 2020 2020 2020 2020  d == U:.        
+000178f0: 2020 2020 2020 2020 5f65 2c20 2a5f 203d          _e, *_ =
+00017900: 2042 2e61 7267 730a 2020 2020 2020 2020   B.args.        
+00017910: 2020 2020 2020 2020 6672 6f6d 2073 796d          from sym
+00017920: 7079 2069 6d70 6f72 7420 556e 6571 7561  py import Unequa
+00017930: 6c0a 2020 2020 2020 2020 2020 2020 2020  l.              
+00017940: 2020 7265 7475 726e 2055 6e65 7175 616c    return Unequal
+00017950: 2865 2c20 5f65 290a 0a20 2020 2040 636c  (e, _e)..    @cl
+00017960: 6173 736d 6574 686f 640a 2020 2020 6465  assmethod.    de
+00017970: 6620 7369 6d70 6c69 6679 5f4e 6f74 456c  f simplify_NotEl
+00017980: 656d 656e 7428 636c 732c 2073 656c 662c  ement(cls, self,
+00017990: 2065 2c20 7329 3a0a 2020 2020 2020 2020   e, s):.        
+000179a0: 2222 220a 2020 2020 2020 2020 7072 6563  """.        prec
+000179b0: 6f6e 6469 7469 6f6e 3a20 7365 6c66 2e72  ondition: self.r
+000179c0: 6873 2069 7320 6120 436f 6d70 6c65 6d65  hs is a Compleme
+000179d0: 6e74 206f 626a 6563 7421 0a20 2020 2020  nt object!.     
+000179e0: 2020 2022 2222 0a20 2020 2020 2020 2055     """.        U
+000179f0: 2c20 4220 3d20 732e 6172 6773 0a20 2020  , B = s.args.   
+00017a00: 2020 2020 2069 6620 552e 6973 5f55 6e69       if U.is_Uni
+00017a10: 7665 7273 616c 5365 743a 0a20 2020 2020  versalSet:.     
+00017a20: 2020 2020 2020 2072 6574 7572 6e20 7365         return se
+00017a30: 6c66 2e69 6e76 6572 745f 7479 7065 2865  lf.invert_type(e
+00017a40: 2c20 4229 2e73 696d 706c 6966 7928 290a  , B).simplify().
+00017a50: 2020 2020 2020 2020 656c 6966 2042 2e69          elif B.i
+00017a60: 735f 4669 6e69 7465 5365 7420 616e 6420  s_FiniteSet and 
+00017a70: 6c65 6e28 4229 203d 3d20 313a 0a20 2020  len(B) == 1:.   
+00017a80: 2020 2020 2020 2020 2064 6f6d 6169 6e5f           domain_
+00017a90: 6173 7375 6d65 6420 3d20 652e 646f 6d61  assumed = e.doma
+00017aa0: 696e 5f61 7373 756d 6564 0a20 2020 2020  in_assumed.     
+00017ab0: 2020 2020 2020 2069 6620 646f 6d61 696e         if domain
+00017ac0: 5f61 7373 756d 6564 2061 6e64 2064 6f6d  _assumed and dom
+00017ad0: 6169 6e5f 6173 7375 6d65 6420 3d3d 2055  ain_assumed == U
+00017ae0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+00017af0: 2020 5f65 2c20 2a5f 203d 2042 2e61 7267    _e, *_ = B.arg
+00017b00: 730a 2020 2020 2020 2020 2020 2020 2020  s.              
+00017b10: 2020 7265 7475 726e 2045 7175 616c 2865    return Equal(e
+00017b20: 2c20 5f65 290a 2020 2020 2020 2020 0a20  , _e).        . 
+00017b30: 2020 2064 6566 205f 6576 616c 5f53 7562     def _eval_Sub
+00017b40: 7365 7428 7365 6c66 2c20 7268 7329 3a0a  set(self, rhs):.
+00017b50: 2020 2020 2020 2020 412c 2073 203d 2073          A, s = s
+00017b60: 656c 662e 6172 6773 0a20 2020 2020 2020  elf.args.       
+00017b70: 2069 6620 7268 732e 6973 5f43 6f6d 706c   if rhs.is_Compl
+00017b80: 656d 656e 743a 200a 2020 2020 2020 2020  ement: .        
+00017b90: 2020 2020 422c 205f 7320 3d20 7268 732e      B, _s = rhs.
+00017ba0: 6172 6773 0a20 2020 2020 2020 2020 2020  args.           
+00017bb0: 2069 6620 7320 3d3d 205f 733a 0a20 2020   if s == _s:.   
+00017bc0: 2020 2020 2020 2020 2020 2020 2066 726f               fro
+00017bd0: 6d20 7379 6d70 7920 696d 706f 7274 2053  m sympy import S
+00017be0: 7562 7365 740a 2020 2020 2020 2020 2020  ubset.          
+00017bf0: 2020 2020 2020 7265 7475 726e 2053 7562        return Sub
+00017c00: 7365 742e 6576 616c 2841 2c20 4229 0a20  set.eval(A, B). 
+00017c10: 2020 2020 2020 2065 6c69 6620 7268 7320         elif rhs 
+00017c20: 3d3d 2041 3a0a 2020 2020 2020 2020 2020  == A:.          
+00017c30: 2020 7265 7475 726e 2053 2e42 6f6f 6c65    return S.Boole
+00017c40: 616e 5472 7565 0a20 2020 2020 2020 2020  anTrue.         
+00017c50: 2020 200a 2020 2020 2020 2020 2020 2020     .            
+00017c60: 0a63 6c61 7373 2045 6d70 7479 5365 7428  .class EmptySet(
+00017c70: 5365 7429 3a0a 2020 2020 2222 220a 2020  Set):.    """.  
+00017c80: 2020 5265 7072 6573 656e 7473 2074 6865    Represents the
+00017c90: 2065 6d70 7479 2073 6574 2e20 5468 6520   empty set. The 
+00017ca0: 656d 7074 7920 7365 7420 6973 2061 7661  empty set is ava
+00017cb0: 696c 6162 6c65 2061 7320 6120 7369 6e67  ilable as a sing
+00017cc0: 6c65 746f 6e0a 2020 2020 6173 2045 6d70  leton.    as Emp
+00017cd0: 7479 5365 7428 292e 0a0a 2020 2020 4578  tySet()...    Ex
+00017ce0: 616d 706c 6573 0a20 2020 203d 3d3d 3d3d  amples.    =====
+00017cf0: 3d3d 3d0a 0a20 2020 203e 3e3e 2066 726f  ===..    >>> fro
+00017d00: 6d20 7379 6d70 7920 696d 706f 7274 2053  m sympy import S
+00017d10: 2c20 496e 7465 7276 616c 0a20 2020 203e  , Interval.    >
+00017d20: 3e3e 2045 6d70 7479 5365 7428 290a 2020  >> EmptySet().  
+00017d30: 2020 456d 7074 7953 6574 2829 0a0a 2020    EmptySet()..  
+00017d40: 2020 3e3e 3e20 496e 7465 7276 616c 2831    >>> Interval(1
+00017d50: 2c20 3229 2e69 6e74 6572 7365 6374 2845  , 2).intersect(E
+00017d60: 6d70 7479 5365 7428 2929 0a20 2020 2045  mptySet()).    E
+00017d70: 6d70 7479 5365 7428 290a 0a20 2020 2053  mptySet()..    S
+00017d80: 6565 2041 6c73 6f0a 2020 2020 3d3d 3d3d  ee Also.    ====
+00017d90: 3d3d 3d3d 0a0a 2020 2020 556e 6976 6572  ====..    Univer
+00017da0: 7361 6c53 6574 0a0a 2020 2020 5265 6665  salSet..    Refe
+00017db0: 7265 6e63 6573 0a20 2020 203d 3d3d 3d3d  rences.    =====
+00017dc0: 3d3d 3d3d 3d0a 0a20 2020 202e 2e20 5b31  =====..    .. [1
+00017dd0: 5d20 6874 7470 733a 2f2f 656e 2e77 696b  ] https://en.wik
+00017de0: 6970 6564 6961 2e6f 7267 2f77 696b 692f  ipedia.org/wiki/
+00017df0: 456d 7074 795f 7365 740a 2020 2020 2222  Empty_set.    ""
+00017e00: 220a 2020 2020 6973 5f46 696e 6974 6553  ".    is_FiniteS
+00017e10: 6574 203d 2054 7275 650a 0a20 2020 2064  et = True..    d
+00017e20: 6566 205f 6576 616c 5f69 735f 6669 6e69  ef _eval_is_fini
+00017e30: 7465 2873 656c 6629 3a0a 2020 2020 2020  te(self):.      
+00017e40: 2020 7265 7475 726e 2073 656c 662e 6574    return self.et
+00017e50: 7970 652e 6973 5f66 696e 6974 650a 0a20  ype.is_finite.. 
+00017e60: 2020 2064 6566 205f 6576 616c 5f69 735f     def _eval_is_
+00017e70: 6578 7465 6e64 6564 5f69 6e74 6567 6572  extended_integer
+00017e80: 2873 656c 6629 3a0a 2020 2020 2020 2020  (self):.        
+00017e90: 7265 7475 726e 2073 656c 662e 6574 7970  return self.etyp
+00017ea0: 652e 6973 5f65 7874 656e 6465 645f 696e  e.is_extended_in
+00017eb0: 7465 6765 720a 0a20 2020 2064 6566 205f  teger..    def _
+00017ec0: 6576 616c 5f69 735f 7375 7065 725f 696e  eval_is_super_in
+00017ed0: 7465 6765 7228 7365 6c66 293a 0a20 2020  teger(self):.   
+00017ee0: 2020 2020 2072 6574 7572 6e20 7365 6c66       return self
+00017ef0: 2e65 7479 7065 2e69 735f 7375 7065 725f  .etype.is_super_
+00017f00: 696e 7465 6765 720a 2020 2020 0a20 2020  integer.    .   
+00017f10: 2064 6566 205f 6576 616c 5f69 735f 6578   def _eval_is_ex
+00017f20: 7465 6e64 6564 5f72 6174 696f 6e61 6c28  tended_rational(
+00017f30: 7365 6c66 293a 0a20 2020 2020 2020 2072  self):.        r
+00017f40: 6574 7572 6e20 7365 6c66 2e65 7479 7065  eturn self.etype
+00017f50: 2e69 735f 6578 7465 6e64 6564 5f72 6174  .is_extended_rat
+00017f60: 696f 6e61 6c0a 2020 2020 0a20 2020 2064  ional.    .    d
+00017f70: 6566 205f 6576 616c 5f69 735f 6879 7065  ef _eval_is_hype
+00017f80: 725f 7261 7469 6f6e 616c 2873 656c 6629  r_rational(self)
+00017f90: 3a0a 2020 2020 2020 2020 7265 7475 726e  :.        return
+00017fa0: 2073 656c 662e 6574 7970 652e 6973 5f68   self.etype.is_h
+00017fb0: 7970 6572 5f72 6174 696f 6e61 6c0a 2020  yper_rational.  
+00017fc0: 2020 0a20 2020 2064 6566 205f 6576 616c    .    def _eval
+00017fd0: 5f69 735f 7375 7065 725f 7261 7469 6f6e  _is_super_ration
+00017fe0: 616c 2873 656c 6629 3a0a 2020 2020 2020  al(self):.      
+00017ff0: 2020 7265 7475 726e 2073 656c 662e 6574    return self.et
+00018000: 7970 652e 6973 5f73 7570 6572 5f72 6174  ype.is_super_rat
+00018010: 696f 6e61 6c0a 2020 2020 0a20 2020 2064  ional.    .    d
+00018020: 6566 205f 6576 616c 5f69 735f 6578 7465  ef _eval_is_exte
+00018030: 6e64 6564 5f72 6561 6c28 7365 6c66 293a  nded_real(self):
+00018040: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
+00018050: 7365 6c66 2e65 7479 7065 2e69 735f 6578  self.etype.is_ex
+00018060: 7465 6e64 6564 5f72 6561 6c0a 2020 2020  tended_real.    
+00018070: 0a20 2020 2064 6566 205f 6576 616c 5f69  .    def _eval_i
+00018080: 735f 6879 7065 725f 7265 616c 2873 656c  s_hyper_real(sel
+00018090: 6629 3a0a 2020 2020 2020 2020 7265 7475  f):.        retu
+000180a0: 726e 2073 656c 662e 6574 7970 652e 6973  rn self.etype.is
+000180b0: 5f68 7970 6572 5f72 6561 6c0a 2020 2020  _hyper_real.    
+000180c0: 0a20 2020 2064 6566 205f 6576 616c 5f69  .    def _eval_i
+000180d0: 735f 7375 7065 725f 7265 616c 2873 656c  s_super_real(sel
+000180e0: 6629 3a0a 2020 2020 2020 2020 7265 7475  f):.        retu
+000180f0: 726e 2073 656c 662e 6574 7970 652e 6973  rn self.etype.is
+00018100: 5f73 7570 6572 5f72 6561 6c0a 2020 2020  _super_real.    
+00018110: 0a20 2020 2064 6566 205f 6576 616c 5f69  .    def _eval_i
+00018120: 735f 6578 7465 6e64 6564 5f63 6f6d 706c  s_extended_compl
+00018130: 6578 2873 656c 6629 3a0a 2020 2020 2020  ex(self):.      
+00018140: 2020 7265 7475 726e 2073 656c 662e 6574    return self.et
+00018150: 7970 652e 6973 5f65 7874 656e 6465 645f  ype.is_extended_
+00018160: 636f 6d70 6c65 780a 2020 2020 0a20 2020  complex.    .   
+00018170: 2064 6566 205f 6576 616c 5f69 735f 6879   def _eval_is_hy
+00018180: 7065 725f 636f 6d70 6c65 7828 7365 6c66  per_complex(self
+00018190: 293a 0a20 2020 2020 2020 2072 6574 7572  ):.        retur
+000181a0: 6e20 7365 6c66 2e65 7479 7065 2e69 735f  n self.etype.is_
+000181b0: 6879 7065 725f 636f 6d70 6c65 780a 2020  hyper_complex.  
+000181c0: 2020 0a20 2020 2064 6566 205f 6576 616c    .    def _eval
+000181d0: 5f69 735f 6669 6e69 7465 7365 7428 7365  _is_finiteset(se
+000181e0: 6c66 293a 0a20 2020 2020 2020 2072 6574  lf):.        ret
+000181f0: 7572 6e20 5472 7565 0a20 2020 200a 2020  urn True.    .  
+00018200: 2020 4070 726f 7065 7274 790a 2020 2020    @property.    
+00018210: 6465 6620 6574 7970 6528 7365 6c66 293a  def etype(self):
+00018220: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
+00018230: 7365 6c66 2e5f 6173 7375 6d70 7469 6f6e  self._assumption
+00018240: 735b 2765 7479 7065 275d 0a0a 2020 2020  s['etype']..    
+00018250: 6465 6620 5f65 7661 6c5f 4361 7264 2873  def _eval_Card(s
+00018260: 656c 6629 3a0a 2020 2020 2020 2020 7265  elf):.        re
+00018270: 7475 726e 2053 2e5a 6572 6f0a 0a20 2020  turn S.Zero..   
+00018280: 2064 6566 2069 6e74 6572 7365 6374 696f   def intersectio
+00018290: 6e5f 7365 7473 2873 656c 662c 2062 293a  n_sets(self, b):
+000182a0: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
+000182b0: 7365 6c66 0a0a 2020 2020 6465 6620 756e  self..    def un
+000182c0: 696f 6e5f 7365 7473 2873 656c 662c 2062  ion_sets(self, b
+000182d0: 293a 0a20 2020 2020 2020 2072 6574 7572  ):.        retur
+000182e0: 6e20 620a 0a20 2020 2040 7072 6f70 6572  n b..    @proper
+000182f0: 7479 0a20 2020 2064 6566 205f 6d65 6173  ty.    def _meas
+00018300: 7572 6528 7365 6c66 293a 0a20 2020 2020  ure(self):.     
+00018310: 2020 2072 6574 7572 6e20 300a 0a20 2020     return 0..   
+00018320: 2064 6566 205f 636f 6e74 6169 6e73 2873   def _contains(s
+00018330: 656c 662c 206f 7468 6572 293a 0a20 2020  elf, other):.   
+00018340: 2020 2020 2072 6574 7572 6e20 532e 6661       return S.fa
+00018350: 6c73 650a 0a20 2020 2064 6566 2061 735f  lse..    def as_
+00018360: 7265 6c61 7469 6f6e 616c 2873 656c 662c  relational(self,
+00018370: 2073 796d 626f 6c29 3a0a 2020 2020 2020   symbol):.      
+00018380: 2020 7265 7475 726e 2053 2e66 616c 7365    return S.false
+00018390: 0a0a 2020 2020 6465 6620 5f5f 6c65 6e5f  ..    def __len_
+000183a0: 5f28 7365 6c66 293a 0a20 2020 2020 2020  _(self):.       
+000183b0: 2072 6574 7572 6e20 300a 0a20 2020 2064   return 0..    d
+000183c0: 6566 205f 5f69 7465 725f 5f28 7365 6c66  ef __iter__(self
+000183d0: 293a 0a20 2020 2020 2020 2072 6574 7572  ):.        retur
+000183e0: 6e20 6974 6572 285b 5d29 0a0a 2020 2020  n iter([])..    
+000183f0: 6465 6620 5f65 7661 6c5f 706f 7765 7273  def _eval_powers
+00018400: 6574 2873 656c 6629 3a0a 2020 2020 2020  et(self):.      
+00018410: 2020 6672 6f6d 2073 796d 7079 2069 6d70    from sympy imp
+00018420: 6f72 7420 4669 6e69 7465 5365 740a 2020  ort FiniteSet.  
+00018430: 2020 2020 2020 7265 7475 726e 2046 696e        return Fin
+00018440: 6974 6553 6574 2873 656c 6629 0a0a 2020  iteSet(self)..  
+00018450: 2020 4070 726f 7065 7274 790a 2020 2020    @property.    
+00018460: 6465 6620 5f62 6f75 6e64 6172 7928 7365  def _boundary(se
+00018470: 6c66 293a 0a20 2020 2020 2020 2072 6574  lf):.        ret
+00018480: 7572 6e20 7365 6c66 0a0a 2020 2020 6465  urn self..    de
+00018490: 6620 5f63 6f6d 706c 656d 656e 7428 7365  f _complement(se
+000184a0: 6c66 2c20 6f74 6865 7229 3a0a 2020 2020  lf, other):.    
+000184b0: 2020 2020 7265 7475 726e 206f 7468 6572      return other
+000184c0: 0a0a 2020 2020 6465 6620 5f73 796d 6d65  ..    def _symme
+000184d0: 7472 6963 5f64 6966 6665 7265 6e63 6528  tric_difference(
+000184e0: 7365 6c66 2c20 6f74 6865 7229 3a0a 2020  self, other):.  
+000184f0: 2020 2020 2020 7265 7475 726e 206f 7468        return oth
+00018500: 6572 0a0a 2020 2020 6465 6620 5f73 796d  er..    def _sym
+00018510: 7079 7374 7228 7365 6c66 2c20 5f29 3a0a  pystr(self, _):.
+00018520: 2020 2020 2020 2020 7265 7475 726e 2027          return '
+00018530: 5c4e 7b4c 4154 494e 2043 4150 4954 414c  \N{LATIN CAPITAL
+00018540: 204c 4554 5445 5220 4f20 5749 5448 2053   LETTER O WITH S
+00018550: 5452 4f4b 457d 270a 0a20 2020 2064 6566  TROKE}'..    def
+00018560: 205f 6c61 7465 7828 7365 6c66 2c20 7029   _latex(self, p)
+00018570: 3a0a 2020 2020 2020 2020 7265 7475 726e  :.        return
+00018580: 2072 225c 656d 7074 7973 6574 220a 0a20   r"\emptyset".. 
+00018590: 2020 2064 6566 205f 5f61 6464 5f5f 2873     def __add__(s
+000185a0: 656c 662c 206f 7468 6572 293a 0a20 2020  elf, other):.   
+000185b0: 2020 2020 2072 6574 7572 6e20 7365 6c66       return self
+000185c0: 0a0a 2020 2020 6465 6620 5f5f 7375 625f  ..    def __sub_
+000185d0: 5f28 7365 6c66 2c20 6f74 6865 7229 3a0a  _(self, other):.
+000185e0: 2020 2020 2020 2020 7265 7475 726e 2073          return s
+000185f0: 656c 660a 0a20 2020 2040 636c 6173 736d  elf..    @classm
+00018600: 6574 686f 640a 2020 2020 6465 6620 7369  ethod.    def si
+00018610: 6d70 6c69 6679 5f45 7175 616c 2863 6c73  mplify_Equal(cls
+00018620: 2c20 7365 6c66 2c20 6c68 732c 2072 6873  , self, lhs, rhs
+00018630: 293a 0a20 2020 2020 2020 2022 2222 0a20  ):.        """. 
+00018640: 2020 2020 2020 2070 7265 636f 6e64 6974         precondit
+00018650: 696f 6e3a 2073 656c 662e 6c68 7320 6973  ion: self.lhs is
+00018660: 2061 2045 6d70 7479 5365 7420 6f62 6a65   a EmptySet obje
+00018670: 6374 210a 2020 2020 2020 2020 2222 220a  ct!.        """.
+00018680: 2020 2020 2020 2020 6966 2072 6873 2e69          if rhs.i
+00018690: 735f 496e 7465 7273 6563 7469 6f6e 3a0a  s_Intersection:.
+000186a0: 2020 2020 2020 2020 2020 2020 7468 6973              this
+000186b0: 203d 2073 656c 662e 7369 6d70 6c69 6679   = self.simplify
+000186c0: 5f49 6e74 6572 7365 6374 696f 6e28 7268  _Intersection(rh
+000186d0: 7329 0a20 2020 2020 2020 2020 2020 2069  s).            i
+000186e0: 6620 7468 6973 2069 7320 6e6f 7420 4e6f  f this is not No
+000186f0: 6e65 3a0a 2020 2020 2020 2020 2020 2020  ne:.            
+00018700: 2020 2020 7265 7475 726e 2074 6869 730a      return this.
+00018710: 0a20 2020 2064 6566 205f 6576 616c 5f53  .    def _eval_S
+00018720: 7562 7365 7428 7365 6c66 2c20 7268 7329  ubset(self, rhs)
+00018730: 3a0a 2020 2020 2020 2020 7265 7475 726e  :.        return
+00018740: 2053 2e74 7275 650a 0a20 2020 2064 6566   S.true..    def
+00018750: 205f 6576 616c 5f45 7128 7365 6c66 2c20   _eval_Eq(self, 
+00018760: 7268 7329 3a0a 2020 2020 2020 2020 6966  rhs):.        if
+00018770: 2072 6873 2e69 735f 656d 7074 7920 6973   rhs.is_empty is
+00018780: 2046 616c 7365 3a0a 2020 2020 2020 2020   False:.        
+00018790: 2020 2020 7265 7475 726e 2053 2e66 616c      return S.fal
+000187a0: 7365 0a20 2020 2020 2020 200a 2020 2020  se.        .    
+000187b0: 2020 2020 6966 2072 6873 2e69 735f 656d      if rhs.is_em
+000187c0: 7074 7920 6973 2054 7275 653a 0a20 2020  pty is True:.   
+000187d0: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
+000187e0: 532e 7472 7565 0a0a 2020 2020 2020 2020  S.true..        
+000187f0: 0a63 6c61 7373 2055 6e69 7665 7273 616c  .class Universal
+00018800: 5365 7428 5365 7429 3a0a 2020 2020 2222  Set(Set):.    ""
+00018810: 220a 2020 2020 5265 7072 6573 656e 7473  ".    Represents
+00018820: 2074 6865 2073 6574 206f 6620 616c 6c20   the set of all 
+00018830: 7468 696e 6773 2e0a 2020 2020 5468 6520  things..    The 
+00018840: 756e 6976 6572 7361 6c20 7365 7420 6973  universal set is
+00018850: 2061 7661 696c 6162 6c65 2061 7320 6120   available as a 
+00018860: 7369 6e67 6c65 746f 6e20 6173 2055 6e69  singleton as Uni
+00018870: 7665 7273 616c 5365 7428 290a 0a20 2020  versalSet()..   
+00018880: 2045 7861 6d70 6c65 730a 2020 2020 3d3d   Examples.    ==
+00018890: 3d3d 3d3d 3d3d 0a0a 2020 2020 3e3e 3e20  ======..    >>> 
+000188a0: 6672 6f6d 2073 796d 7079 2069 6d70 6f72  from sympy impor
+000188b0: 7420 532c 2049 6e74 6572 7661 6c0a 2020  t S, Interval.  
+000188c0: 2020 3e3e 3e20 556e 6976 6572 7361 6c53    >>> UniversalS
+000188d0: 6574 2829 0a20 2020 2055 6e69 7665 7273  et().    Univers
+000188e0: 616c 5365 740a 0a20 2020 203e 3e3e 2049  alSet..    >>> I
+000188f0: 6e74 6572 7661 6c28 312c 2032 292e 696e  nterval(1, 2).in
+00018900: 7465 7273 6563 7428 556e 6976 6572 7361  tersect(Universa
+00018910: 6c53 6574 2829 290a 2020 2020 496e 7465  lSet()).    Inte
+00018920: 7276 616c 2831 2c20 3229 0a0a 2020 2020  rval(1, 2)..    
+00018930: 5365 6520 416c 736f 0a20 2020 203d 3d3d  See Also.    ===
+00018940: 3d3d 3d3d 3d0a 0a20 2020 2045 6d70 7479  =====..    Empty
+00018950: 5365 740a 0a20 2020 2052 6566 6572 656e  Set..    Referen
+00018960: 6365 730a 2020 2020 3d3d 3d3d 3d3d 3d3d  ces.    ========
+00018970: 3d3d 0a0a 2020 2020 2e2e 205b 315d 2068  ==..    .. [1] h
+00018980: 7474 7073 3a2f 2f65 6e2e 7769 6b69 7065  ttps://en.wikipe
+00018990: 6469 612e 6f72 672f 7769 6b69 2f55 6e69  dia.org/wiki/Uni
+000189a0: 7665 7273 616c 5f73 6574 0a20 2020 2022  versal_set.    "
+000189b0: 2222 0a0a 2020 2020 2320 696e 206b 7761  ""..    # in kwa
+000189c0: 7267 732c 2065 7479 7065 206d 7573 7420  rgs, etype must 
+000189d0: 6265 2073 7065 6369 6669 6564 2069 6e20  be specified in 
+000189e0: 6f72 6465 7220 746f 2064 6574 6572 6d69  order to determi
+000189f0: 6e65 2074 6865 2075 6e69 7665 7273 616c  ne the universal
+00018a00: 5365 7427 7320 7479 7065 2c20 736f 2069  Set's type, so i
+00018a10: 7420 6973 2077 6974 6820 456d 7074 7953  t is with EmptyS
+00018a20: 6574 210a 2020 2020 2320 746f 2069 6e73  et!.    # to ins
+00018a30: 7461 6e74 6961 7465 2061 2055 6e69 7665  tantiate a Unive
+00018a40: 7273 616c 5365 742c 2075 7365 2055 6e69  rsalSet, use Uni
+00018a50: 7665 7273 616c 5365 7428 6574 7970 653d  versalSet(etype=
+00018a60: 6474 7970 652e 696e 7465 6765 722e 7365  dtype.integer.se
+00018a70: 7429 0a20 2020 2064 6566 205f 5f6e 6577  t).    def __new
+00018a80: 5f5f 2863 6c73 2c20 2a2a 6b77 6172 6773  __(cls, **kwargs
+00018a90: 293a 0a20 2020 2020 2020 2065 7479 7065  ):.        etype
+00018aa0: 203d 206b 7761 7267 732e 6765 7428 2765   = kwargs.get('e
+00018ab0: 7479 7065 2729 0a20 2020 2020 2020 2069  type').        i
+00018ac0: 6620 6574 7970 6520 6973 206e 6f74 204e  f etype is not N
+00018ad0: 6f6e 653a 0a20 2020 2020 2020 2020 2020  one:.           
+00018ae0: 2072 6574 7572 6e20 6574 7970 652e 756e   return etype.un
+00018af0: 6976 6572 7361 6c53 6574 0a20 2020 2020  iversalSet.     
+00018b00: 2020 2072 6574 7572 6e20 5365 742e 5f5f     return Set.__
+00018b10: 6e65 775f 5f28 636c 732c 202a 2a6b 7761  new__(cls, **kwa
+00018b20: 7267 7329 0a20 2020 2020 2020 200a 2020  rgs).        .  
+00018b30: 2020 6465 6620 696e 7465 7273 6563 7469    def intersecti
+00018b40: 6f6e 5f73 6574 7328 7365 6c66 2c20 6229  on_sets(self, b)
+00018b50: 3a0a 2020 2020 2020 2020 7265 7475 726e  :.        return
+00018b60: 2062 0a0a 2020 2020 6465 6620 756e 696f   b..    def unio
+00018b70: 6e5f 7365 7473 2873 656c 662c 2062 293a  n_sets(self, b):
+00018b80: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
+00018b90: 7365 6c66 0a0a 2020 2020 6465 6620 5f63  self..    def _c
+00018ba0: 6f6d 706c 656d 656e 7428 7365 6c66 2c20  omplement(self, 
+00018bb0: 6f74 6865 7229 3a0a 2020 2020 2020 2020  other):.        
+00018bc0: 7265 7475 726e 206f 7468 6572 2e65 7479  return other.ety
+00018bd0: 7065 2e65 6d70 7479 5365 740a 0a20 2020  pe.emptySet..   
+00018be0: 2064 6566 205f 7379 6d6d 6574 7269 635f   def _symmetric_
+00018bf0: 6469 6666 6572 656e 6365 2873 656c 662c  difference(self,
+00018c00: 206f 7468 6572 293a 0a20 2020 2020 2020   other):.       
+00018c10: 2072 6574 7572 6e20 6f74 6865 720a 0a20   return other.. 
+00018c20: 2020 2040 7072 6f70 6572 7479 0a20 2020     @property.   
+00018c30: 2064 6566 205f 6d65 6173 7572 6528 7365   def _measure(se
+00018c40: 6c66 293a 0a20 2020 2020 2020 2072 6574  lf):.        ret
+00018c50: 7572 6e20 532e 496e 6669 6e69 7479 0a0a  urn S.Infinity..
+00018c60: 2020 2020 6465 6620 5f63 6f6e 7461 696e      def _contain
+00018c70: 7328 7365 6c66 2c20 6f74 6865 7229 3a0a  s(self, other):.
+00018c80: 2020 2020 2020 2020 7265 7475 726e 2053          return S
+00018c90: 2e74 7275 650a 0a20 2020 2064 6566 2061  .true..    def a
+00018ca0: 735f 7265 6c61 7469 6f6e 616c 2873 656c  s_relational(sel
+00018cb0: 662c 2073 796d 626f 6c29 3a0a 2020 2020  f, symbol):.    
+00018cc0: 2020 2020 7265 7475 726e 2053 2e74 7275      return S.tru
+00018cd0: 650a 0a20 2020 2040 7072 6f70 6572 7479  e..    @property
+00018ce0: 0a20 2020 2064 6566 205f 626f 756e 6461  .    def _bounda
+00018cf0: 7279 2873 656c 6629 3a0a 2020 2020 2020  ry(self):.      
+00018d00: 2020 7265 7475 726e 2073 656c 662e 6574    return self.et
+00018d10: 7970 652e 656d 7074 7953 6574 0a20 2020  ype.emptySet.   
+00018d20: 200a 2020 2020 6465 6620 5f65 7661 6c5f   .    def _eval_
+00018d30: 4361 7264 2873 656c 6629 3a0a 2020 2020  Card(self):.    
+00018d40: 2020 2020 2320 416c 6570 6827 5c4e 7b48      # Aleph'\N{H
+00018d50: 4542 5245 5720 4c45 5454 4552 2041 4c45  EBREW LETTER ALE
+00018d60: 467d 270a 2020 2020 2020 2020 6672 6f6d  F}'.        from
+00018d70: 2073 796d 7079 2e63 6f72 652e 6e75 6d62   sympy.core.numb
+00018d80: 6572 7320 696d 706f 7274 2041 6c65 7068  ers import Aleph
+00018d90: 0a20 2020 2020 2020 2069 6620 7365 6c66  .        if self
+00018da0: 2e65 7479 7065 2e69 735f 7365 743a 0a20  .etype.is_set:. 
+00018db0: 2020 2020 2020 2020 2020 2070 7269 6e74             print
+00018dc0: 2827 756e 6b6e 6f77 6e20 616c 6570 6820  ('unknown aleph 
+00018dd0: 6e75 6d62 6572 3f3f 2729 0a20 2020 2020  number??').     
+00018de0: 2020 2020 2020 2072 6574 7572 6e20 532e         return S.
+00018df0: 496e 6669 6e69 7479 0a20 2020 2020 2020  Infinity.       
+00018e00: 200a 2020 2020 2020 2020 6966 2073 656c   .        if sel
+00018e10: 662e 6574 7970 652e 6973 5f65 7874 656e  f.etype.is_exten
+00018e20: 6465 645f 7261 7469 6f6e 616c 3a0a 2020  ded_rational:.  
+00018e30: 2020 2020 2020 2020 2020 7265 7475 726e            return
+00018e40: 2041 6c65 7068 2830 290a 2020 2020 2020   Aleph(0).      
+00018e50: 2020 0a20 2020 2020 2020 2069 6620 7365    .        if se
+00018e60: 6c66 2e65 7479 7065 2e69 735f 6879 7065  lf.etype.is_hype
+00018e70: 725f 636f 6d70 6c65 783a 0a20 2020 2020  r_complex:.     
+00018e80: 2020 2020 2020 2072 6574 7572 6e20 416c         return Al
+00018e90: 6570 6828 3129 0a20 2020 2020 2020 200a  eph(1).        .
+00018ea0: 2020 2020 2020 2020 7072 696e 7428 2775          print('u
+00018eb0: 6e6b 6e6f 776e 2061 6c65 7068 206e 756d  nknown aleph num
+00018ec0: 6265 723f 3f27 290a 2020 2020 2020 2020  ber??').        
+00018ed0: 7265 7475 726e 2053 2e49 6e66 696e 6974  return S.Infinit
+00018ee0: 790a 0a20 2020 2040 7072 6f70 6572 7479  y..    @property
+00018ef0: 0a20 2020 2064 6566 2065 7479 7065 2873  .    def etype(s
+00018f00: 656c 6629 3a0a 2020 2020 2020 2020 7265  elf):.        re
+00018f10: 7475 726e 2073 656c 662e 5f61 7373 756d  turn self._assum
+00018f20: 7074 696f 6e73 5b27 6574 7970 6527 5d0a  ptions['etype'].
+00018f30: 0a20 2020 2064 6566 205f 5f61 6464 5f5f  .    def __add__
+00018f40: 2873 656c 662c 206f 7468 6572 293a 0a20  (self, other):. 
+00018f50: 2020 2020 2020 2069 6620 7365 6c66 2e65         if self.e
+00018f60: 7479 7065 2e69 735f 7365 743a 200a 2020  type.is_set: .  
+00018f70: 2020 2020 2020 2020 2020 7261 6973 6520            raise 
+00018f80: 4578 6365 7074 696f 6e28 2263 6f75 6c64  Exception("could
+00018f90: 206e 6f74 2061 6464 2025 732c 2025 7320   not add %s, %s 
+00018fa0: 7769 7468 2065 7479 7065 203d 2025 7322  with etype = %s"
+00018fb0: 2025 2028 7365 6c66 2c20 6f74 6865 722c   % (self, other,
+00018fc0: 2073 656c 662e 6574 7970 6529 290a 2020   self.etype)).  
+00018fd0: 2020 0a20 2020 2020 2020 2072 6574 7572    .        retur
+00018fe0: 6e20 7365 6c66 0a20 2020 200a 2020 2020  n self.    .    
+00018ff0: 6465 6620 5f5f 6d75 6c5f 5f28 7365 6c66  def __mul__(self
+00019000: 2c20 6f74 6865 7229 3a0a 2020 2020 2020  , other):.      
+00019010: 2020 6966 2073 656c 662e 6574 7970 652e    if self.etype.
+00019020: 6973 5f73 6574 3a20 0a20 2020 2020 2020  is_set: .       
+00019030: 2020 2020 2072 6169 7365 2045 7863 6570       raise Excep
+00019040: 7469 6f6e 2822 636f 756c 6420 6e6f 7420  tion("could not 
+00019050: 6164 6420 2573 2c20 2573 2077 6974 6820  add %s, %s with 
+00019060: 6574 7970 6520 3d20 2573 2220 2520 2873  etype = %s" % (s
+00019070: 656c 662c 206f 7468 6572 2c20 7365 6c66  elf, other, self
+00019080: 2e65 7479 7065 2929 0a20 2020 2020 2020  .etype)).       
+00019090: 200a 2020 2020 2020 2020 7265 7475 726e   .        return
+000190a0: 2073 656c 660a 2020 2020 0a20 2020 200a   self.    .    .
+000190b0: 4879 7065 7252 6561 6c73 203d 2055 6e69  HyperReals = Uni
+000190c0: 7665 7273 616c 5365 7428 6574 7970 653d  versalSet(etype=
+000190d0: 6474 7970 652e 6879 7065 725f 7265 616c  dtype.hyper_real
+000190e0: 290a 5375 7065 7252 6561 6c73 203d 2055  ).SuperReals = U
+000190f0: 6e69 7665 7273 616c 5365 7428 6574 7970  niversalSet(etyp
+00019100: 653d 6474 7970 652e 7375 7065 725f 7265  e=dtype.super_re
+00019110: 616c 290a 4879 7065 7243 6f6d 706c 6578  al).HyperComplex
+00019120: 6573 203d 2055 6e69 7665 7273 616c 5365  es = UniversalSe
+00019130: 7428 6574 7970 653d 6474 7970 652e 6879  t(etype=dtype.hy
+00019140: 7065 725f 636f 6d70 6c65 7829 0a53 7570  per_complex).Sup
+00019150: 6572 436f 6d70 6c65 7865 7320 3d20 556e  erComplexes = Un
+00019160: 6976 6572 7361 6c53 6574 2865 7479 7065  iversalSet(etype
+00019170: 3d64 7479 7065 2e73 7570 6572 5f63 6f6d  =dtype.super_com
+00019180: 706c 6578 290a 0a20 2020 200a 636c 6173  plex)..    .clas
+00019190: 7320 4669 6e69 7465 5365 7428 5365 7429  s FiniteSet(Set)
+000191a0: 3a0a 2020 2020 2222 220a 2020 2020 5265  :.    """.    Re
+000191b0: 7072 6573 656e 7473 2061 2066 696e 6974  presents a finit
+000191c0: 6520 7365 7420 6f66 2064 6973 6372 6574  e set of discret
+000191d0: 6520 6e75 6d62 6572 730a 0a20 2020 2045  e numbers..    E
+000191e0: 7861 6d70 6c65 730a 2020 2020 3d3d 3d3d  xamples.    ====
+000191f0: 3d3d 3d3d 0a0a 2020 2020 3e3e 3e20 6672  ====..    >>> fr
+00019200: 6f6d 2073 796d 7079 2069 6d70 6f72 7420  om sympy import 
+00019210: 4669 6e69 7465 5365 740a 2020 2020 3e3e  FiniteSet.    >>
+00019220: 3e20 4669 6e69 7465 5365 7428 312c 2032  > FiniteSet(1, 2
+00019230: 2c20 332c 2034 290a 2020 2020 4669 6e69  , 3, 4).    Fini
+00019240: 7465 5365 7428 312c 2032 2c20 332c 2034  teSet(1, 2, 3, 4
+00019250: 290a 2020 2020 3e3e 3e20 3320 696e 2046  ).    >>> 3 in F
+00019260: 696e 6974 6553 6574 2831 2c20 322c 2033  initeSet(1, 2, 3
+00019270: 2c20 3429 0a20 2020 2054 7275 650a 0a20  , 4).    True.. 
+00019280: 2020 203e 3e3e 206d 656d 6265 7273 203d     >>> members =
+00019290: 205b 312c 2032 2c20 332c 2034 5d0a 2020   [1, 2, 3, 4].  
+000192a0: 2020 3e3e 3e20 6620 3d20 4669 6e69 7465    >>> f = Finite
+000192b0: 5365 7428 2a6d 656d 6265 7273 290a 2020  Set(*members).  
+000192c0: 2020 3e3e 3e20 660a 2020 2020 4669 6e69    >>> f.    Fini
+000192d0: 7465 5365 7428 312c 2032 2c20 332c 2034  teSet(1, 2, 3, 4
+000192e0: 290a 2020 2020 3e3e 3e20 6620 2d20 4669  ).    >>> f - Fi
+000192f0: 6e69 7465 5365 7428 3229 0a20 2020 2046  niteSet(2).    F
+00019300: 696e 6974 6553 6574 2831 2c20 332c 2034  initeSet(1, 3, 4
+00019310: 290a 2020 2020 3e3e 3e20 6620 2b20 4669  ).    >>> f + Fi
+00019320: 6e69 7465 5365 7428 322c 2035 290a 2020  niteSet(2, 5).  
+00019330: 2020 4669 6e69 7465 5365 7428 312c 2032    FiniteSet(1, 2
+00019340: 2c20 332c 2034 2c20 3529 0a0a 2020 2020  , 3, 4, 5)..    
+00019350: 5265 6665 7265 6e63 6573 0a20 2020 203d  References.    =
+00019360: 3d3d 3d3d 3d3d 3d3d 3d0a 0a20 2020 202e  =========..    .
+00019370: 2e20 5b31 5d20 6874 7470 733a 2f2f 656e  . [1] https://en
+00019380: 2e77 696b 6970 6564 6961 2e6f 7267 2f77  .wikipedia.org/w
+00019390: 696b 692f 4669 6e69 7465 5f73 6574 0a20  iki/Finite_set. 
+000193a0: 2020 2022 2222 0a20 2020 2069 735f 6974     """.    is_it
+000193b0: 6572 6162 6c65 203d 2054 7275 650a 0a20  erable = True.. 
+000193c0: 2020 2064 6566 2069 6e74 6572 7365 6374     def intersect
+000193d0: 696f 6e5f 7365 7473 2873 656c 662c 2062  ion_sets(self, b
+000193e0: 293a 0a20 2020 2020 2020 2069 6620 622e  ):.        if b.
+000193f0: 6973 5f46 696e 6974 6553 6574 3a0a 2020  is_FiniteSet:.  
+00019400: 2020 2020 2020 2020 2020 7265 7475 726e            return
+00019410: 2046 696e 6974 6553 6574 282a 2873 656c   FiniteSet(*(sel
+00019420: 662e 5f65 6c65 6d65 6e74 7320 2620 622e  f._elements & b.
+00019430: 5f65 6c65 6d65 6e74 7329 290a 0a20 2020  _elements))..   
+00019440: 2020 2020 2074 7279 3a0a 2020 2020 2020       try:.      
+00019450: 2020 2020 2020 7265 7475 726e 2046 696e        return Fin
+00019460: 6974 6553 6574 282a 5b65 6c20 666f 7220  iteSet(*[el for 
+00019470: 656c 2069 6e20 7365 6c66 2069 6620 656c  el in self if el
+00019480: 2069 6e20 625d 290a 2020 2020 2020 2020   in b]).        
+00019490: 6578 6365 7074 2054 7970 6545 7272 6f72  except TypeError
+000194a0: 3a0a 2020 2020 2020 2020 2020 2020 7265  :.            re
+000194b0: 7475 726e 204e 6f6e 6520 2023 2063 6f75  turn None  # cou
+000194c0: 6c64 206e 6f74 2065 7661 6c75 6174 6520  ld not evaluate 
+000194d0: 6065 6c20 696e 2062 6020 6475 6520 746f  `el in b` due to
+000194e0: 2073 796d 626f 6c69 6320 7261 6e67 6573   symbolic ranges
+000194f0: 2e0a 0a20 2020 2064 6566 2075 6e69 6f6e  ...    def union
+00019500: 5f73 6574 7328 7365 6c66 2c20 6229 3a0a  _sets(self, b):.
+00019510: 2020 2020 2020 2020 6966 2062 2e69 735f          if b.is_
+00019520: 4669 6e69 7465 5365 743a 0a20 2020 2020  FiniteSet:.     
+00019530: 2020 2020 2020 2072 6574 7572 6e20 4669         return Fi
+00019540: 6e69 7465 5365 7428 2a28 7365 7428 7365  niteSet(*(set(se
+00019550: 6c66 2e61 7267 7329 207c 2073 6574 2862  lf.args) | set(b
+00019560: 2e61 7267 7329 2929 0a20 2020 2020 2020  .args))).       
+00019570: 2023 2049 6620 6062 6020 7365 7420 636f   # If `b` set co
+00019580: 6e74 6169 6e73 206f 6e65 206f 6620 6d79  ntains one of my
+00019590: 2065 6c65 6d65 6e74 732c 2072 656d 6f76   elements, remov
+000195a0: 6520 6974 2066 726f 6d20 6061 600a 2020  e it from `a`.  
+000195b0: 2020 2020 2020 6966 2061 6e79 2862 2e63        if any(b.c
+000195c0: 6f6e 7461 696e 7328 7829 203d 3d20 5472  ontains(x) == Tr
+000195d0: 7565 2066 6f72 2078 2069 6e20 7365 6c66  ue for x in self
+000195e0: 293a 0a20 2020 2020 2020 2020 2020 2072  ):.            r
+000195f0: 6574 7572 6e20 7365 7428 2846 696e 6974  eturn set((Finit
+00019600: 6553 6574 282a 5b78 2066 6f72 2078 2069  eSet(*[x for x i
+00019610: 6e20 7365 6c66 2069 6620 6e6f 7420 622e  n self if not b.
+00019620: 636f 6e74 6169 6e73 2878 295d 292c 2062  contains(x)]), b
+00019630: 2929 0a20 2020 2020 2020 200a 2020 2020  )).        .    
+00019640: 2020 2020 6966 2062 2e69 735f 496e 7465      if b.is_Inte
+00019650: 7273 6563 7469 6f6e 3a0a 2020 2020 2020  rsection:.      
+00019660: 2020 2020 2020 666f 7220 692c 2073 2069        for i, s i
+00019670: 6e20 656e 756d 6572 6174 6528 622e 6172  n enumerate(b.ar
+00019680: 6773 293a 0a20 2020 2020 2020 2020 2020  gs):.           
+00019690: 2020 2020 2069 6620 732e 6973 5f46 696e       if s.is_Fin
+000196a0: 6974 6553 6574 3a0a 2020 2020 2020 2020  iteSet:.        
+000196b0: 2020 2020 2020 2020 2020 2020 7520 3d20              u = 
+000196c0: 5b2a 622e 6172 6773 5d0a 2020 2020 2020  [*b.args].      
+000196d0: 2020 2020 2020 2020 2020 2020 2020 6465                de
+000196e0: 6c20 755b 695d 0a20 2020 2020 2020 2020  l u[i].         
+000196f0: 2020 2020 2020 2020 2020 2075 203d 2062             u = b
+00019700: 2e66 756e 6328 2a75 2c20 6576 616c 7561  .func(*u, evalua
+00019710: 7465 3d46 616c 7365 290a 2020 2020 2020  te=False).      
+00019720: 2020 2020 2020 2020 2020 2020 2020 6966                if
+00019730: 2073 656c 6620 696e 2075 3a0a 2020 2020   self in u:.    
+00019740: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00019750: 2020 2020 7265 7475 726e 2062 2e66 756e      return b.fun
+00019760: 6328 2873 656c 6620 7c20 7329 2c20 752c  c((self | s), u,
+00019770: 2065 7661 6c75 6174 653d 4661 6c73 6529   evaluate=False)
+00019780: 0a20 2020 2020 2020 2069 6620 622e 6973  .        if b.is
+00019790: 5f43 6f6d 706c 656d 656e 743a 0a20 2020  _Complement:.   
+000197a0: 2020 2020 2020 2020 2041 2c20 4220 3d20           A, B = 
+000197b0: 622e 6172 6773 0a20 2020 2020 2020 2020  b.args.         
+000197c0: 2020 2069 6620 4220 696e 2073 656c 663a     if B in self:
+000197d0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000197e0: 2072 6574 7572 6e20 4120 7c20 7365 6c66   return A | self
+000197f0: 0a23 2020 2020 2020 2020 2072 6574 7572  .#         retur
+00019800: 6e20 4e6f 6e65 0a0a 2020 2020 6465 6620  n None..    def 
+00019810: 5f5f 6e65 775f 5f28 636c 732c 202a 6172  __new__(cls, *ar
+00019820: 6773 2c20 2a2a 6b77 6172 6773 293a 0a20  gs, **kwargs):. 
+00019830: 2020 2020 2020 2065 7661 6c75 6174 6520         evaluate 
+00019840: 3d20 6b77 6172 6773 2e67 6574 2827 6576  = kwargs.get('ev
+00019850: 616c 7561 7465 272c 2067 6c6f 6261 6c5f  aluate', global_
+00019860: 7061 7261 6d65 7465 7273 2e65 7661 6c75  parameters.evalu
+00019870: 6174 6529 0a20 2020 2020 2020 2069 6620  ate).        if 
+00019880: 6576 616c 7561 7465 3a0a 2020 2020 2020  evaluate:.      
+00019890: 2020 2020 2020 6172 6773 203d 206c 6973        args = lis
+000198a0: 7428 6d61 7028 7379 6d70 6966 792c 2061  t(map(sympify, a
+000198b0: 7267 7329 290a 0a20 2020 2020 2020 2020  rgs))..         
+000198c0: 2020 2069 6620 6c65 6e28 6172 6773 2920     if len(args) 
+000198d0: 3d3d 2030 3a0a 2020 2020 2020 2020 2020  == 0:.          
+000198e0: 2020 2020 2020 7265 7475 726e 2045 6d70        return Emp
+000198f0: 7479 5365 7428 290a 2020 2020 2020 2020  tySet().        
+00019900: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
+00019910: 2020 6172 6773 203d 206c 6973 7428 6d61    args = list(ma
+00019920: 7028 7379 6d70 6966 792c 2061 7267 7329  p(sympify, args)
+00019930: 290a 0a20 2020 2020 2020 2061 7267 7320  )..        args 
+00019940: 3d20 6c69 7374 286f 7264 6572 6564 2873  = list(ordered(s
+00019950: 6574 2861 7267 7329 2c20 5365 742e 5f69  et(args), Set._i
+00019960: 6e66 696d 756d 5f6b 6579 2929 0a20 2020  nfimum_key)).   
+00019970: 2020 2020 206f 626a 203d 2042 6173 6963       obj = Basic
+00019980: 2e5f 5f6e 6577 5f5f 2863 6c73 2c20 2a61  .__new__(cls, *a
+00019990: 7267 7329 0a20 2020 2020 2020 2072 6574  rgs).        ret
+000199a0: 7572 6e20 6f62 6a0a 0a20 2020 2064 6566  urn obj..    def
+000199b0: 205f 6576 616c 5f45 7128 7365 6c66 2c20   _eval_Eq(self, 
+000199c0: 6f74 6865 7229 3a0a 2020 2020 2020 2020  other):.        
+000199d0: 6966 206e 6f74 2069 7369 6e73 7461 6e63  if not isinstanc
+000199e0: 6528 6f74 6865 722c 2046 696e 6974 6553  e(other, FiniteS
+000199f0: 6574 293a 0a20 2020 2020 2020 2020 2020  et):.           
+00019a00: 2069 6620 6f74 6865 722e 6973 5f45 6d70   if other.is_Emp
+00019a10: 7479 5365 743a 0a20 2020 2020 2020 2020  tySet:.         
+00019a20: 2020 2020 2020 2072 6574 7572 6e20 532e         return S.
+00019a30: 6661 6c73 650a 2020 2020 2020 2020 2020  false.          
+00019a40: 2020 0a20 2020 2020 2020 2020 2020 2069    .            i
+00019a50: 6620 6f74 6865 722e 6973 5f49 6e74 6572  f other.is_Inter
+00019a60: 7661 6c3a 0a20 2020 2020 2020 2020 2020  val:.           
+00019a70: 2020 2020 2069 6620 6e6f 7420 6f74 6865       if not othe
+00019a80: 722e 6973 5f69 6e74 6567 6572 3a0a 2020  r.is_integer:.  
+00019a90: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00019aa0: 2020 7265 7475 726e 2053 2e66 616c 7365    return S.false
+00019ab0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00019ac0: 200a 2020 2020 2020 2020 2020 2020 6966   .            if
+00019ad0: 206f 7468 6572 2e69 735f 7365 743a 0a20   other.is_set:. 
+00019ae0: 2020 2020 2020 2020 2020 2020 2020 2072                 r
+00019af0: 6574 7572 6e20 4e6f 6e65 0a20 2020 2020  eturn None.     
+00019b00: 2020 2020 2020 2072 6574 7572 6e20 532e         return S.
+00019b10: 6661 6c73 650a 0a20 2020 2020 2020 2069  false..        i
+00019b20: 6620 6c65 6e28 7365 6c66 2920 213d 206c  f len(self) != l
+00019b30: 656e 286f 7468 6572 293a 0a20 2020 2020  en(other):.     
+00019b40: 2020 2020 2020 2072 6574 7572 6e20 532e         return S.
+00019b50: 6661 6c73 650a 0a20 2020 2064 6566 205f  false..    def _
+00019b60: 5f69 7465 725f 5f28 7365 6c66 293a 0a20  _iter__(self):. 
+00019b70: 2020 2020 2020 2072 6574 7572 6e20 6974         return it
+00019b80: 6572 2873 656c 662e 6172 6773 290a 0a20  er(self.args).. 
+00019b90: 2020 2064 6566 205f 636f 6d70 6c65 6d65     def _compleme
+00019ba0: 6e74 2873 656c 662c 206f 7468 6572 293a  nt(self, other):
+00019bb0: 0a20 2020 2020 2020 2066 726f 6d20 7379  .        from sy
+00019bc0: 6d70 7920 696d 706f 7274 2052 616e 6765  mpy import Range
+00019bd0: 0a20 2020 2020 2020 2069 6620 6f74 6865  .        if othe
+00019be0: 722e 6973 5f52 616e 6765 3a0a 2020 2020  r.is_Range:.    
+00019bf0: 2020 2020 2020 2020 6e75 6d73 203d 2073          nums = s
+00019c00: 6f72 7465 6428 6d20 666f 7220 6d20 696e  orted(m for m in
+00019c10: 2073 656c 662e 6172 6773 2069 6620 6d2e   self.args if m.
+00019c20: 6973 5f6e 756d 6265 7229 2020 2020 2020  is_number)      
+00019c30: 2020 2020 2020 0a20 2020 2020 2020 2020        .         
+00019c40: 2020 2069 6620 4661 6c73 6520 616e 6420     if False and 
+00019c50: 6e75 6d73 2021 3d20 5b5d 3a0a 2020 2020  nums != []:.    
+00019c60: 2020 2020 2020 2020 2020 2020 7379 6d73              syms
+00019c70: 203d 205b 6d20 666f 7220 6d20 696e 2073   = [m for m in s
+00019c80: 656c 662e 6172 6773 2069 6620 6d2e 6973  elf.args if m.is
+00019c90: 5f53 796d 626f 6c5d 0a20 2020 2020 2020  _Symbol].       
+00019ca0: 2020 2020 2020 2020 2023 2052 6561 6c73           # Reals
+00019cb0: 2063 616e 6e6f 7420 636f 6e74 6169 6e20   cannot contain 
+00019cc0: 656c 656d 656e 7473 206f 7468 6572 2074  elements other t
+00019cd0: 6861 6e20 6e75 6d62 6572 7320 616e 6420  han numbers and 
+00019ce0: 7379 6d62 6f6c 732e 0a0a 2020 2020 2020  symbols...      
+00019cf0: 2020 2020 2020 2020 2020 696e 7465 7276            interv
+00019d00: 616c 7320 3d20 5b5d 2020 2320 4275 696c  als = []  # Buil
+00019d10: 6420 7570 2061 206c 6973 7420 6f66 2069  d up a list of i
+00019d20: 6e74 6572 7661 6c73 2062 6574 7765 656e  ntervals between
+00019d30: 2074 6865 2065 6c65 6d65 6e74 730a 2020   the elements.  
+00019d40: 2020 2020 2020 2020 2020 2020 2020 696e                in
+00019d50: 7465 7276 616c 7320 2b3d 205b 5261 6e67  tervals += [Rang
+00019d60: 6528 532e 4e65 6761 7469 7665 496e 6669  e(S.NegativeInfi
+00019d70: 6e69 7479 2c20 6e75 6d73 5b30 5d29 5d0a  nity, nums[0])].
+00019d80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00019d90: 666f 7220 612c 2062 2069 6e20 7a69 7028  for a, b in zip(
+00019da0: 6e75 6d73 5b3a 2d31 5d2c 206e 756d 735b  nums[:-1], nums[
+00019db0: 313a 5d29 3a0a 2020 2020 2020 2020 2020  1:]):.          
+00019dc0: 2020 2020 2020 2020 2020 696e 7465 7276            interv
+00019dd0: 616c 732e 6170 7065 6e64 2852 616e 6765  als.append(Range
+00019de0: 2861 202b 2031 2c20 6229 2920 2023 2062  (a + 1, b))  # b
+00019df0: 6f74 6820 6f70 656e 0a20 2020 2020 2020  oth open.       
+00019e00: 2020 2020 2020 2020 2069 6e74 6572 7661           interva
+00019e10: 6c73 2e61 7070 656e 6428 5261 6e67 6528  ls.append(Range(
+00019e20: 6e75 6d73 5b2d 315d 202b 2031 2c20 532e  nums[-1] + 1, S.
+00019e30: 496e 6669 6e69 7479 2929 0a0a 2020 2020  Infinity))..    
+00019e40: 2020 2020 2020 2020 2020 2020 6966 2073              if s
+00019e50: 796d 7320 213d 205b 5d3a 0a20 2020 2020  yms != []:.     
+00019e60: 2020 2020 2020 2020 2020 2020 2020 2072                 r
+00019e70: 6574 7572 6e20 436f 6d70 6c65 6d65 6e74  eturn Complement
+00019e80: 2855 6e69 6f6e 282a 696e 7465 7276 616c  (Union(*interval
+00019e90: 732c 2065 7661 6c75 6174 653d 4661 6c73  s, evaluate=Fals
+00019ea0: 6529 2c20 4669 6e69 7465 5365 7428 2a73  e), FiniteSet(*s
+00019eb0: 796d 7329 2c20 6576 616c 7561 7465 3d46  yms), evaluate=F
+00019ec0: 616c 7365 290a 2020 2020 2020 2020 2020  alse).          
+00019ed0: 2020 2020 2020 656c 7365 3a0a 2020 2020        else:.    
+00019ee0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00019ef0: 7265 7475 726e 2055 6e69 6f6e 282a 696e  return Union(*in
+00019f00: 7465 7276 616c 732c 2065 7661 6c75 6174  tervals, evaluat
+00019f10: 653d 4661 6c73 6529 0a20 2020 2020 2020  e=False).       
+00019f20: 2020 2020 2065 6c73 653a 0a0a 2020 2020       else:..    
+00019f30: 2020 2020 2020 2020 2020 2020 666f 7220              for 
+00019f40: 692c 2065 2069 6e20 656e 756d 6572 6174  i, e in enumerat
+00019f50: 6528 7365 6c66 2e61 7267 7329 3a0a 2020  e(self.args):.  
+00019f60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00019f70: 2020 6d2c 204d 203d 206f 7468 6572 2e6d    m, M = other.m
+00019f80: 696e 2829 2c20 6f74 6865 722e 6d61 7828  in(), other.max(
+00019f90: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
+00019fa0: 2020 2020 2020 6966 2065 203d 3d20 4d3a        if e == M:
+00019fb0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00019fc0: 2020 2020 2020 2020 2061 7267 7320 3d20           args = 
+00019fd0: 5b2a 7365 6c66 2e61 7267 735d 0a20 2020  [*self.args].   
+00019fe0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00019ff0: 2020 2020 2064 656c 2061 7267 735b 695d       del args[i]
+0001a000: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0001a010: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
+0001a020: 6f74 6865 722e 636f 7079 2873 746f 703d  other.copy(stop=
+0001a030: 4d2c 2072 6967 6874 5f6f 7065 6e3d 5472  M, right_open=Tr
+0001a040: 7565 2920 2d20 7365 6c66 2e66 756e 6328  ue) - self.func(
+0001a050: 2a61 7267 7329 0a20 2020 2020 2020 2020  *args).         
+0001a060: 2020 2020 2020 2020 2020 2069 6620 6520             if e 
+0001a070: 3d3d 206d 3a0a 2020 2020 2020 2020 2020  == m:.          
+0001a080: 2020 2020 2020 2020 2020 2020 2020 6172                ar
+0001a090: 6773 203d 205b 2a73 656c 662e 6172 6773  gs = [*self.args
+0001a0a0: 5d0a 2020 2020 2020 2020 2020 2020 2020  ].              
+0001a0b0: 2020 2020 2020 2020 2020 6465 6c20 6172            del ar
+0001a0c0: 6773 5b69 5d0a 2020 2020 2020 2020 2020  gs[i].          
+0001a0d0: 2020 2020 2020 2020 2020 2020 2020 7265                re
+0001a0e0: 7475 726e 206f 7468 6572 2e63 6f70 7928  turn other.copy(
+0001a0f0: 7374 6172 743d 6d2c 206c 6566 745f 6f70  start=m, left_op
+0001a100: 656e 3d54 7275 6529 2e73 696d 706c 6966  en=True).simplif
+0001a110: 7928 2920 2d20 7365 6c66 2e66 756e 6328  y() - self.func(
+0001a120: 2a61 7267 7329 0a20 2020 2020 2020 2020  *args).         
+0001a130: 2020 2020 2020 2020 2020 2069 6620 6520             if e 
+0001a140: 3e20 4d20 6f72 2065 203c 206d 3a0a 2020  > M or e < m:.  
+0001a150: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001a160: 2020 2020 2020 6172 6773 203d 205b 2a73        args = [*s
+0001a170: 656c 662e 6172 6773 5d0a 2020 2020 2020  elf.args].      
+0001a180: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001a190: 2020 6465 6c20 6172 6773 5b69 5d0a 2020    del args[i].  
+0001a1a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001a1b0: 2020 2020 2020 7265 7475 726e 206f 7468        return oth
+0001a1c0: 6572 202d 2073 656c 662e 6675 6e63 282a  er - self.func(*
+0001a1d0: 6172 6773 290a 2020 2020 2020 2020 2020  args).          
+0001a1e0: 2020 2020 2020 7265 7475 726e 0a20 2020        return.   
+0001a1f0: 2020 2020 2020 2020 200a 2020 2020 2020           .      
+0001a200: 2020 2020 2020 6966 206f 7468 6572 2e69        if other.i
+0001a210: 735f 696e 7465 6765 723a 0a20 2020 2020  s_integer:.     
+0001a220: 2020 2020 2020 2020 2020 2069 6620 6f74             if ot
+0001a230: 6865 722e 6d69 6e28 2920 696e 2073 656c  her.min() in sel
+0001a240: 663a 200a 2020 2020 2020 2020 2020 2020  f: .            
+0001a250: 2020 2020 2020 2020 7265 7475 726e 206f          return o
+0001a260: 7468 6572 2e63 6f70 7928 7374 6172 743d  ther.copy(start=
+0001a270: 6f74 6865 722e 7374 6172 7420 2b20 3129  other.start + 1)
+0001a280: 202d 2073 656c 662e 6675 6e63 282a 7b2a   - self.func(*{*
+0001a290: 7365 6c66 2e61 7267 737d 202d 207b 6f74  self.args} - {ot
+0001a2a0: 6865 722e 6d69 6e28 297d 2920 2020 2020  her.min()})     
+0001a2b0: 2020 2020 2020 2020 2020 200a 2020 2020             .    
+0001a2c0: 2020 2020 2020 2020 2020 2020 6966 206f              if o
+0001a2d0: 7468 6572 2e6d 6178 2829 2069 6e20 7365  ther.max() in se
+0001a2e0: 6c66 3a20 0a20 2020 2020 2020 2020 2020  lf: .           
+0001a2f0: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
+0001a300: 6f74 6865 722e 636f 7079 2873 746f 703d  other.copy(stop=
+0001a310: 6f74 6865 722e 7374 6f70 202d 2031 2920  other.stop - 1) 
+0001a320: 2d20 7365 6c66 2e66 756e 6328 2a7b 2a73  - self.func(*{*s
+0001a330: 656c 662e 6172 6773 7d20 2d20 7b6f 7468  elf.args} - {oth
+0001a340: 6572 2e6d 6178 2829 7d29 0a20 2020 2020  er.max()}).     
+0001a350: 2020 2065 6c69 6620 6f74 6865 722e 6973     elif other.is
+0001a360: 5f49 6e74 6572 7661 6c3a 0a20 2020 2020  _Interval:.     
+0001a370: 2020 2020 2020 206e 756d 7320 3d20 736f         nums = so
+0001a380: 7274 6564 286d 2066 6f72 206d 2069 6e20  rted(m for m in 
+0001a390: 7365 6c66 2e61 7267 7320 6966 206d 2e69  self.args if m.i
+0001a3a0: 735f 6e75 6d62 6572 290a 2020 2020 2020  s_number).      
+0001a3b0: 2020 2020 2020 6966 206f 7468 6572 2e73        if other.s
+0001a3c0: 7461 7274 2e69 735f 4e65 6761 7469 7665  tart.is_Negative
+0001a3d0: 496e 6669 6e69 7479 2061 6e64 206f 7468  Infinity and oth
+0001a3e0: 6572 2e73 746f 702e 6973 5f49 6e66 696e  er.stop.is_Infin
+0001a3f0: 6974 7920 616e 6420 6e75 6d73 2021 3d20  ity and nums != 
+0001a400: 5b5d 3a0a 2020 2020 2020 2020 2020 2020  []:.            
+0001a410: 2020 2020 6c65 6674 5f6f 7065 6e20 3d20      left_open = 
+0001a420: 6f74 6865 722e 6c65 6674 5f6f 7065 6e0a  other.left_open.
+0001a430: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001a440: 7269 6768 745f 6f70 656e 203d 206f 7468  right_open = oth
+0001a450: 6572 2e72 6967 6874 5f6f 7065 6e0a 2020  er.right_open.  
+0001a460: 2020 2020 2020 2020 2020 2020 2020 7379                sy
+0001a470: 6d73 203d 205b 6d20 666f 7220 6d20 696e  ms = [m for m in
+0001a480: 2073 656c 662e 6172 6773 2069 6620 6d2e   self.args if m.
+0001a490: 6973 5f53 796d 626f 6c5d 0a20 2020 2020  is_Symbol].     
+0001a4a0: 2020 2020 2020 2020 2020 2023 2052 6561             # Rea
+0001a4b0: 6c73 2063 616e 6e6f 7420 636f 6e74 6169  ls cannot contai
+0001a4c0: 6e20 656c 656d 656e 7473 206f 7468 6572  n elements other
+0001a4d0: 2074 6861 6e20 6e75 6d62 6572 7320 616e   than numbers an
+0001a4e0: 6420 7379 6d62 6f6c 732e 0a0a 2020 2020  d symbols...    
+0001a4f0: 2020 2020 2020 2020 2020 2020 696e 7465              inte
+0001a500: 7276 616c 7320 3d20 5b5d 2020 2320 4275  rvals = []  # Bu
+0001a510: 696c 6420 7570 2061 206c 6973 7420 6f66  ild up a list of
+0001a520: 2069 6e74 6572 7661 6c73 2062 6574 7765   intervals betwe
+0001a530: 656e 2074 6865 2065 6c65 6d65 6e74 730a  en the elements.
+0001a540: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001a550: 696e 7465 7276 616c 7320 2b3d 205b 496e  intervals += [In
+0001a560: 7465 7276 616c 2853 2e4e 6567 6174 6976  terval(S.Negativ
+0001a570: 6549 6e66 696e 6974 792c 206e 756d 735b  eInfinity, nums[
+0001a580: 305d 2c20 6c65 6674 5f6f 7065 6e3d 6c65  0], left_open=le
+0001a590: 6674 5f6f 7065 6e2c 2072 6967 6874 5f6f  ft_open, right_o
+0001a5a0: 7065 6e3d 5472 7565 295d 0a20 2020 2020  pen=True)].     
+0001a5b0: 2020 2020 2020 2020 2020 2066 6f72 2061             for a
+0001a5c0: 2c20 6220 696e 207a 6970 286e 756d 735b  , b in zip(nums[
+0001a5d0: 3a2d 315d 2c20 6e75 6d73 5b31 3a5d 293a  :-1], nums[1:]):
+0001a5e0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0001a5f0: 2020 2020 2069 6e74 6572 7661 6c73 2e61       intervals.a
+0001a600: 7070 656e 6428 496e 7465 7276 616c 2861  ppend(Interval(a
+0001a610: 2c20 622c 206c 6566 745f 6f70 656e 3d54  , b, left_open=T
+0001a620: 7275 652c 2072 6967 6874 5f6f 7065 6e3d  rue, right_open=
+0001a630: 5472 7565 2929 2020 2320 626f 7468 206f  True))  # both o
+0001a640: 7065 6e0a 2020 2020 2020 2020 2020 2020  pen.            
+0001a650: 2020 2020 696e 7465 7276 616c 732e 6170      intervals.ap
+0001a660: 7065 6e64 2849 6e74 6572 7661 6c28 6e75  pend(Interval(nu
+0001a670: 6d73 5b2d 315d 2c20 532e 496e 6669 6e69  ms[-1], S.Infini
+0001a680: 7479 2c20 6c65 6674 5f6f 7065 6e3d 5472  ty, left_open=Tr
+0001a690: 7565 2c20 7269 6768 745f 6f70 656e 3d72  ue, right_open=r
+0001a6a0: 6967 6874 5f6f 7065 6e29 290a 0a20 2020  ight_open))..   
+0001a6b0: 2020 2020 2020 2020 2020 2020 2069 6620               if 
+0001a6c0: 7379 6d73 2021 3d20 5b5d 3a0a 2020 2020  syms != []:.    
+0001a6d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001a6e0: 7265 7475 726e 2043 6f6d 706c 656d 656e  return Complemen
+0001a6f0: 7428 556e 696f 6e28 2a69 6e74 6572 7661  t(Union(*interva
+0001a700: 6c73 2c20 6576 616c 7561 7465 3d46 616c  ls, evaluate=Fal
+0001a710: 7365 292c 0a20 2020 2020 2020 2020 2020  se),.           
+0001a720: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001a730: 2046 696e 6974 6553 6574 282a 7379 6d73   FiniteSet(*syms
+0001a740: 292c 2065 7661 6c75 6174 653d 4661 6c73  ), evaluate=Fals
+0001a750: 6529 0a20 2020 2020 2020 2020 2020 2020  e).             
+0001a760: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
+0001a770: 2020 2020 2020 2020 2020 2020 2072 6574               ret
+0001a780: 7572 6e20 556e 696f 6e28 2a69 6e74 6572  urn Union(*inter
+0001a790: 7661 6c73 2c20 6576 616c 7561 7465 3d46  vals, evaluate=F
+0001a7a0: 616c 7365 290a 2020 2020 2020 2020 2020  alse).          
+0001a7b0: 2020 656c 7365 3a0a 0a20 2020 2020 2020    else:..       
+0001a7c0: 2020 2020 2020 2020 2066 6f72 2069 2c20           for i, 
+0001a7d0: 6520 696e 2065 6e75 6d65 7261 7465 2873  e in enumerate(s
+0001a7e0: 656c 662e 6172 6773 293a 0a20 2020 2020  elf.args):.     
+0001a7f0: 2020 2020 2020 2020 2020 2020 2020 206d                 m
+0001a800: 2c20 4d20 3d20 6f74 6865 722e 6d69 6e28  , M = other.min(
+0001a810: 292c 206f 7468 6572 2e6d 6178 2829 0a20  ), other.max(). 
+0001a820: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001a830: 2020 2069 6620 6520 3d3d 204d 3a0a 2020     if e == M:.  
+0001a840: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001a850: 2020 2020 2020 6172 6773 203d 205b 2a73        args = [*s
+0001a860: 656c 662e 6172 6773 5d0a 2020 2020 2020  elf.args].      
+0001a870: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001a880: 2020 6465 6c20 6172 6773 5b69 5d0a 2020    del args[i].  
+0001a890: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001a8a0: 2020 2020 2020 7265 7475 726e 206f 7468        return oth
+0001a8b0: 6572 2e63 6f70 7928 7374 6f70 3d4d 2c20  er.copy(stop=M, 
+0001a8c0: 7269 6768 745f 6f70 656e 3d54 7275 6529  right_open=True)
+0001a8d0: 202d 2073 656c 662e 6675 6e63 282a 6172   - self.func(*ar
+0001a8e0: 6773 290a 2020 2020 2020 2020 2020 2020  gs).            
+0001a8f0: 2020 2020 2020 2020 6966 2065 203d 3d20          if e == 
+0001a900: 6d3a 0a20 2020 2020 2020 2020 2020 2020  m:.             
+0001a910: 2020 2020 2020 2020 2020 2061 7267 7320             args 
+0001a920: 3d20 5b2a 7365 6c66 2e61 7267 735d 0a20  = [*self.args]. 
+0001a930: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001a940: 2020 2020 2020 2064 656c 2061 7267 735b         del args[
+0001a950: 695d 0a20 2020 2020 2020 2020 2020 2020  i].             
+0001a960: 2020 2020 2020 2020 2020 2072 6574 7572             retur
+0001a970: 6e20 6f74 6865 722e 636f 7079 2873 7461  n other.copy(sta
+0001a980: 7274 3d6d 2c20 6c65 6674 5f6f 7065 6e3d  rt=m, left_open=
+0001a990: 5472 7565 292e 7369 6d70 6c69 6679 2829  True).simplify()
+0001a9a0: 202d 2073 656c 662e 6675 6e63 282a 6172   - self.func(*ar
+0001a9b0: 6773 290a 2020 2020 2020 2020 2020 2020  gs).            
+0001a9c0: 2020 2020 2020 2020 6966 2065 203e 204d          if e > M
+0001a9d0: 206f 7220 6520 3c20 6d3a 0a20 2020 2020   or e < m:.     
+0001a9e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001a9f0: 2020 2061 7267 7320 3d20 5b2a 7365 6c66     args = [*self
+0001aa00: 2e61 7267 735d 0a20 2020 2020 2020 2020  .args].         
+0001aa10: 2020 2020 2020 2020 2020 2020 2020 2064                 d
+0001aa20: 656c 2061 7267 735b 695d 0a20 2020 2020  el args[i].     
+0001aa30: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001aa40: 2020 2072 6574 7572 6e20 6f74 6865 7220     return other 
+0001aa50: 2d20 7365 6c66 2e66 756e 6328 2a61 7267  - self.func(*arg
+0001aa60: 7329 0a20 2020 2020 2020 2020 2020 2020  s).             
+0001aa70: 2020 2072 6574 7572 6e0a 2020 2020 2020     return.      
+0001aa80: 2020 2020 2020 0a20 2020 2020 2020 2020        .         
+0001aa90: 2020 2069 6620 6f74 6865 722e 6973 5f69     if other.is_i
+0001aaa0: 6e74 6567 6572 3a0a 2020 2020 2020 2020  nteger:.        
+0001aab0: 2020 2020 2020 2020 6966 206f 7468 6572          if other
+0001aac0: 2e6d 696e 2829 2069 6e20 7365 6c66 3a20  .min() in self: 
+0001aad0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0001aae0: 2020 2020 2072 6574 7572 6e20 6f74 6865       return othe
+0001aaf0: 722e 636f 7079 2873 7461 7274 3d6f 7468  r.copy(start=oth
+0001ab00: 6572 2e73 7461 7274 202b 2031 2920 2d20  er.start + 1) - 
+0001ab10: 7365 6c66 2e66 756e 6328 2a7b 2a73 656c  self.func(*{*sel
+0001ab20: 662e 6172 6773 7d20 2d20 7b6f 7468 6572  f.args} - {other
+0001ab30: 2e6d 696e 2829 7d29 2020 2020 2020 2020  .min()})        
+0001ab40: 2020 2020 2020 2020 0a20 2020 2020 2020          .       
+0001ab50: 2020 2020 2020 2020 2069 6620 6f74 6865           if othe
+0001ab60: 722e 6d61 7828 2920 696e 2073 656c 663a  r.max() in self:
+0001ab70: 200a 2020 2020 2020 2020 2020 2020 2020   .              
+0001ab80: 2020 2020 2020 7265 7475 726e 206f 7468        return oth
+0001ab90: 6572 2e63 6f70 7928 7374 6f70 3d6f 7468  er.copy(stop=oth
+0001aba0: 6572 2e73 746f 7020 2d20 3129 202d 2073  er.stop - 1) - s
+0001abb0: 656c 662e 6675 6e63 282a 7b2a 7365 6c66  elf.func(*{*self
+0001abc0: 2e61 7267 737d 202d 207b 6f74 6865 722e  .args} - {other.
+0001abd0: 6d61 7828 297d 290a 2020 2020 2020 2020  max()}).        
+0001abe0: 2020 2020 0a20 2020 2020 2020 2065 6c69      .        eli
+0001abf0: 6620 6973 696e 7374 616e 6365 286f 7468  f isinstance(oth
+0001ac00: 6572 2c20 4669 6e69 7465 5365 7429 3a0a  er, FiniteSet):.
+0001ac10: 2020 2020 2020 2020 2020 2020 7320 3d20              s = 
+0001ac20: 7365 7428 7365 6c66 2e61 7267 7329 0a20  set(self.args). 
+0001ac30: 2020 2020 2020 2020 2020 205f 7320 3d20             _s = 
+0001ac40: 7365 7428 6f74 6865 722e 6172 6773 290a  set(other.args).
+0001ac50: 2020 2020 2020 2020 2020 2020 0a20 2020              .   
+0001ac60: 2020 2020 2020 2020 2061 7373 6572 7420           assert 
+0001ac70: 7320 616e 6420 5f73 0a20 2020 2020 2020  s and _s.       
+0001ac80: 2020 2020 2069 6e74 6572 7365 6374 696f       intersectio
+0001ac90: 6e20 3d20 7320 2620 5f73 0a23 2020 2020  n = s & _s.#    
+0001aca0: 2020 2020 2020 2020 2073 202d 3d20 696e           s -= in
+0001acb0: 7465 7273 6563 7469 6f6e 0a20 2020 2020  tersection.     
+0001acc0: 2020 2020 2020 205f 7320 2d3d 2069 6e74         _s -= int
+0001acd0: 6572 7365 6374 696f 6e0a 2020 2020 2020  ersection.      
+0001ace0: 2020 2020 2020 0a20 2020 2020 2020 2020        .         
+0001acf0: 2020 2075 6e6b 203d 205b 5d0a 2020 2020     unk = [].    
+0001ad00: 2020 2020 2020 2020 0a20 2020 2020 2020          .       
+0001ad10: 2020 2020 2066 6f72 2069 2069 6e20 733a       for i in s:
+0001ad20: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0001ad30: 2069 6620 6e6f 7420 616c 6c28 4571 7561   if not all(Equa
+0001ad40: 6c28 652c 2069 292e 6973 5f42 6f6f 6c65  l(e, i).is_Boole
+0001ad50: 616e 4661 6c73 6520 666f 7220 6520 696e  anFalse for e in
+0001ad60: 205f 7329 3a0a 2020 2020 2020 2020 2020   _s):.          
+0001ad70: 2020 2020 2020 2020 2020 756e 6b2e 6170            unk.ap
+0001ad80: 7065 6e64 2869 290a 2020 2020 2020 2020  pend(i).        
+0001ad90: 2020 2020 2020 2020 2020 2020 0a20 2020              .   
+0001ada0: 2020 2020 2020 2020 2069 6620 6c65 6e28           if len(
+0001adb0: 756e 6b29 203d 3d20 6c65 6e28 7329 2061  unk) == len(s) a
+0001adc0: 6e64 206e 6f74 2069 6e74 6572 7365 6374  nd not intersect
+0001add0: 696f 6e3a 0a20 2020 2020 2020 2020 2020  ion:.           
+0001ade0: 2020 2020 2072 6574 7572 6e20 2020 2020       return     
+0001adf0: 2020 2020 2020 200a 2020 2020 2020 2020         .        
+0001ae00: 2020 2020 2020 2020 0a20 2020 2020 2020          .       
+0001ae10: 2020 2020 2072 6574 7572 6e20 436f 6d70       return Comp
+0001ae20: 6c65 6d65 6e74 2846 696e 6974 6553 6574  lement(FiniteSet
+0001ae30: 282a 5f73 292c 2046 696e 6974 6553 6574  (*_s), FiniteSet
+0001ae40: 282a 756e 6b29 290a 0a20 2020 2020 2020  (*unk))..       
+0001ae50: 2072 6574 7572 6e20 5365 742e 5f63 6f6d   return Set._com
+0001ae60: 706c 656d 656e 7428 7365 6c66 2c20 6f74  plement(self, ot
+0001ae70: 6865 7229 0a0a 2020 2020 6465 6620 5f63  her)..    def _c
+0001ae80: 6f6e 7461 696e 7328 7365 6c66 2c20 6f74  ontains(self, ot
+0001ae90: 6865 7229 3a0a 2020 2020 2020 2020 2222  her):.        ""
+0001aea0: 220a 2020 2020 2020 2020 5465 7374 7320  ".        Tests 
+0001aeb0: 7768 6574 6865 7220 616e 2065 6c65 6d65  whether an eleme
+0001aec0: 6e74 2c20 6f74 6865 722c 2069 7320 696e  nt, other, is in
+0001aed0: 2074 6865 2073 6574 2e0a 0a20 2020 2020   the set...     
+0001aee0: 2020 2052 656c 6965 7320 6f6e 2050 7974     Relies on Pyt
+0001aef0: 686f 6e27 7320 7365 7420 636c 6173 732e  hon's set class.
+0001af00: 2054 6869 7320 7465 7374 7320 666f 7220   This tests for 
+0001af10: 6f62 6a65 6374 2065 7175 616c 6974 790a  object equality.
+0001af20: 2020 2020 2020 2020 416c 6c20 696e 7075          All inpu
+0001af30: 7473 2061 7265 2073 796d 7069 6669 6564  ts are sympified
+0001af40: 0a0a 2020 2020 2020 2020 4578 616d 706c  ..        Exampl
+0001af50: 6573 0a20 2020 2020 2020 203d 3d3d 3d3d  es.        =====
+0001af60: 3d3d 3d0a 0a20 2020 2020 2020 203e 3e3e  ===..        >>>
+0001af70: 2066 726f 6d20 7379 6d70 7920 696d 706f   from sympy impo
+0001af80: 7274 2046 696e 6974 6553 6574 0a20 2020  rt FiniteSet.   
+0001af90: 2020 2020 203e 3e3e 2031 2069 6e20 4669       >>> 1 in Fi
+0001afa0: 6e69 7465 5365 7428 312c 2032 290a 2020  niteSet(1, 2).  
+0001afb0: 2020 2020 2020 5472 7565 0a20 2020 2020        True.     
+0001afc0: 2020 203e 3e3e 2035 2069 6e20 4669 6e69     >>> 5 in Fini
+0001afd0: 7465 5365 7428 312c 2032 290a 2020 2020  teSet(1, 2).    
+0001afe0: 2020 2020 4661 6c73 650a 0a20 2020 2020      False..     
+0001aff0: 2020 2022 2222 0a23 2020 2020 2020 2020     """.#        
+0001b000: 2072 203d 2053 2e66 616c 7365 0a20 2020   r = S.false.   
+0001b010: 2020 2020 2061 7267 7320 3d20 5b5d 0a20       args = []. 
+0001b020: 2020 2020 2020 2066 6f72 2065 2069 6e20         for e in 
+0001b030: 7365 6c66 2e61 7267 733a 0a20 2020 2020  self.args:.     
+0001b040: 2020 2020 2020 2023 206f 7665 7272 6964         # overrid
+0001b050: 6520 676c 6f62 616c 2065 7661 6c75 6174  e global evaluat
+0001b060: 696f 6e20 736f 2077 6520 6361 6e20 7573  ion so we can us
+0001b070: 6520 4571 2074 6f20 646f 0a20 2020 2020  e Eq to do.     
+0001b080: 2020 2020 2020 2023 2064 6f20 7468 6520         # do the 
+0001b090: 6576 616c 7561 7469 6f6e 0a20 2020 2020  evaluation.     
+0001b0a0: 2020 2020 2020 2074 203d 2045 7128 652c         t = Eq(e,
+0001b0b0: 206f 7468 6572 2c20 6576 616c 7561 7465   other, evaluate
+0001b0c0: 3d54 7275 6529 0a20 2020 2020 2020 2020  =True).         
+0001b0d0: 2020 2069 6620 7420 6973 2053 2e74 7275     if t is S.tru
+0001b0e0: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
+0001b0f0: 2020 2072 6574 7572 6e20 740a 2020 2020     return t.    
+0001b100: 2020 2020 2020 2020 656c 6966 2074 2069          elif t i
+0001b110: 7320 6e6f 7420 532e 6661 6c73 653a 0a20  s not S.false:. 
+0001b120: 2020 2020 2020 2020 2020 2020 2020 2061                 a
+0001b130: 7267 732e 6170 7065 6e64 2874 290a 2320  rgs.append(t).# 
+0001b140: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001b150: 7220 3d20 4e6f 6e65 0a20 2020 2020 2020  r = None.       
+0001b160: 2072 6574 7572 6e20 4f72 282a 6172 6773   return Or(*args
+0001b170: 290a 2320 2020 2020 2020 2020 7265 7475  ).#         retu
+0001b180: 726e 2072 0a0a 2020 2020 4070 726f 7065  rn r..    @prope
+0001b190: 7274 790a 2020 2020 6465 6620 5f62 6f75  rty.    def _bou
+0001b1a0: 6e64 6172 7928 7365 6c66 293a 0a20 2020  ndary(self):.   
+0001b1b0: 2020 2020 2072 6574 7572 6e20 7365 6c66       return self
+0001b1c0: 0a0a 2020 2020 4070 726f 7065 7274 790a  ..    @property.
+0001b1d0: 2020 2020 6465 6620 5f69 6e66 2873 656c      def _inf(sel
+0001b1e0: 6629 3a0a 2020 2020 2020 2020 6672 6f6d  f):.        from
+0001b1f0: 2073 796d 7079 2e66 756e 6374 696f 6e73   sympy.functions
+0001b200: 2e65 6c65 6d65 6e74 6172 792e 6d69 7363  .elementary.misc
+0001b210: 656c 6c61 6e65 6f75 7320 696d 706f 7274  ellaneous import
+0001b220: 204d 696e 0a20 2020 2020 2020 2072 6574   Min.        ret
+0001b230: 7572 6e20 4d69 6e28 2a73 656c 6629 0a0a  urn Min(*self)..
+0001b240: 2020 2020 4070 726f 7065 7274 790a 2020      @property.  
+0001b250: 2020 6465 6620 5f73 7570 2873 656c 6629    def _sup(self)
+0001b260: 3a0a 2020 2020 2020 2020 6672 6f6d 2073  :.        from s
+0001b270: 796d 7079 2e66 756e 6374 696f 6e73 2e65  ympy.functions.e
+0001b280: 6c65 6d65 6e74 6172 792e 6d69 7363 656c  lementary.miscel
+0001b290: 6c61 6e65 6f75 7320 696d 706f 7274 204d  laneous import M
+0001b2a0: 6178 0a20 2020 2020 2020 2072 6574 7572  ax.        retur
+0001b2b0: 6e20 4d61 7828 2a73 656c 6629 0a0a 2020  n Max(*self)..  
+0001b2c0: 2020 4070 726f 7065 7274 790a 2020 2020    @property.    
+0001b2d0: 6465 6620 6d65 6173 7572 6528 7365 6c66  def measure(self
+0001b2e0: 293a 0a20 2020 2020 2020 2072 6574 7572  ):.        retur
+0001b2f0: 6e20 300a 0a20 2020 2064 6566 205f 5f6c  n 0..    def __l
+0001b300: 656e 5f5f 2873 656c 6629 3a0a 2020 2020  en__(self):.    
+0001b310: 2020 2020 7265 7475 726e 206c 656e 2873      return len(s
+0001b320: 656c 662e 6172 6773 290a 0a20 2020 2064  elf.args)..    d
+0001b330: 6566 2061 735f 7265 6c61 7469 6f6e 616c  ef as_relational
+0001b340: 2873 656c 662c 2073 796d 626f 6c29 3a0a  (self, symbol):.
+0001b350: 2020 2020 2020 2020 2222 2252 6577 7269          """Rewri
+0001b360: 7465 2061 2046 696e 6974 6553 6574 2069  te a FiniteSet i
+0001b370: 6e20 7465 726d 7320 6f66 2065 7175 616c  n terms of equal
+0001b380: 6974 6965 7320 616e 6420 6c6f 6769 6320  ities and logic 
+0001b390: 6f70 6572 6174 6f72 732e 2022 2222 0a20  operators. """. 
+0001b3a0: 2020 2020 2020 2066 726f 6d20 7379 6d70         from symp
+0001b3b0: 792e 636f 7265 2e72 656c 6174 696f 6e61  y.core.relationa
+0001b3c0: 6c20 696d 706f 7274 2045 710a 2020 2020  l import Eq.    
+0001b3d0: 2020 2020 7265 7475 726e 204f 7228 2a5b      return Or(*[
+0001b3e0: 4571 2873 796d 626f 6c2c 2065 6c65 6d29  Eq(symbol, elem)
+0001b3f0: 2066 6f72 2065 6c65 6d20 696e 2073 656c   for elem in sel
+0001b400: 665d 290a 0a20 2020 2064 6566 2063 6f6d  f])..    def com
+0001b410: 7061 7265 2873 656c 662c 206f 7468 6572  pare(self, other
+0001b420: 293a 0a20 2020 2020 2020 2072 6574 7572  ):.        retur
+0001b430: 6e20 2868 6173 6828 7365 6c66 2920 2d20  n (hash(self) - 
+0001b440: 6861 7368 286f 7468 6572 2929 0a0a 2020  hash(other))..  
+0001b450: 2020 6465 6620 5f65 7661 6c5f 6576 616c    def _eval_eval
+0001b460: 6628 7365 6c66 2c20 7072 6563 293a 0a20  f(self, prec):. 
+0001b470: 2020 2020 2020 2072 6574 7572 6e20 4669         return Fi
+0001b480: 6e69 7465 5365 7428 2a5b 656c 656d 2e5f  niteSet(*[elem._
+0001b490: 6576 616c 5f65 7661 6c66 2870 7265 6329  eval_evalf(prec)
+0001b4a0: 2066 6f72 2065 6c65 6d20 696e 2073 656c   for elem in sel
+0001b4b0: 665d 290a 0a20 2020 2040 7072 6f70 6572  f])..    @proper
+0001b4c0: 7479 0a20 2020 2064 6566 205f 736f 7274  ty.    def _sort
+0001b4d0: 6564 5f61 7267 7328 7365 6c66 293a 0a20  ed_args(self):. 
+0001b4e0: 2020 2020 2020 2072 6574 7572 6e20 7365         return se
+0001b4f0: 6c66 2e61 7267 730a 0a20 2020 2064 6566  lf.args..    def
+0001b500: 205f 6576 616c 5f70 6f77 6572 7365 7428   _eval_powerset(
+0001b510: 7365 6c66 293a 0a20 2020 2020 2020 2072  self):.        r
+0001b520: 6574 7572 6e20 7365 6c66 2e66 756e 6328  eturn self.func(
+0001b530: 2a5b 7365 6c66 2e66 756e 6328 2a73 2920  *[self.func(*s) 
+0001b540: 666f 7220 7320 696e 2073 7562 7365 7473  for s in subsets
+0001b550: 2873 656c 662e 6172 6773 295d 290a 0a20  (self.args)]).. 
+0001b560: 2020 2064 6566 205f 5f67 655f 5f28 7365     def __ge__(se
+0001b570: 6c66 2c20 6f74 6865 7229 3a0a 2020 2020  lf, other):.    
+0001b580: 2020 2020 6966 206e 6f74 206f 7468 6572      if not other
+0001b590: 2e69 735f 7365 743a 0a20 2020 2020 2020  .is_set:.       
+0001b5a0: 2020 2020 2072 6169 7365 2054 7970 6545       raise TypeE
+0001b5b0: 7272 6f72 2822 496e 7661 6c69 6420 636f  rror("Invalid co
+0001b5c0: 6d70 6172 6973 6f6e 206f 6620 7365 7420  mparison of set 
+0001b5d0: 7769 7468 2025 7322 2025 2066 756e 635f  with %s" % func_
+0001b5e0: 6e61 6d65 286f 7468 6572 2929 0a20 2020  name(other)).   
+0001b5f0: 2020 2020 2072 6574 7572 6e20 6f74 6865       return othe
+0001b600: 722e 6973 5f73 7562 7365 7428 7365 6c66  r.is_subset(self
+0001b610: 290a 0a20 2020 2064 6566 205f 5f67 745f  )..    def __gt_
+0001b620: 5f28 7365 6c66 2c20 6f74 6865 7229 3a0a  _(self, other):.
+0001b630: 2020 2020 2020 2020 6966 206e 6f74 206f          if not o
+0001b640: 7468 6572 2e69 735f 7365 743a 0a20 2020  ther.is_set:.   
+0001b650: 2020 2020 2020 2020 2072 6169 7365 2054           raise T
+0001b660: 7970 6545 7272 6f72 2822 496e 7661 6c69  ypeError("Invali
+0001b670: 6420 636f 6d70 6172 6973 6f6e 206f 6620  d comparison of 
+0001b680: 7365 7420 7769 7468 2025 7322 2025 2066  set with %s" % f
+0001b690: 756e 635f 6e61 6d65 286f 7468 6572 2929  unc_name(other))
+0001b6a0: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
+0001b6b0: 7365 6c66 2e69 735f 7072 6f70 6572 5f73  self.is_proper_s
+0001b6c0: 7570 6572 7365 7428 6f74 6865 7229 0a0a  uperset(other)..
+0001b6d0: 2020 2020 6465 6620 5f5f 6c65 5f5f 2873      def __le__(s
+0001b6e0: 656c 662c 206f 7468 6572 293a 0a20 2020  elf, other):.   
+0001b6f0: 2020 2020 2069 6620 6e6f 7420 6f74 6865       if not othe
+0001b700: 722e 6973 5f73 6574 3a0a 2020 2020 2020  r.is_set:.      
+0001b710: 2020 2020 2020 7261 6973 6520 5479 7065        raise Type
+0001b720: 4572 726f 7228 2249 6e76 616c 6964 2063  Error("Invalid c
+0001b730: 6f6d 7061 7269 736f 6e20 6f66 2073 6574  omparison of set
+0001b740: 2077 6974 6820 2573 2220 2520 6675 6e63   with %s" % func
+0001b750: 5f6e 616d 6528 6f74 6865 7229 290a 2020  _name(other)).  
+0001b760: 2020 2020 2020 7265 7475 726e 2073 656c        return sel
+0001b770: 662e 6973 5f73 7562 7365 7428 6f74 6865  f.is_subset(othe
+0001b780: 7229 0a0a 2020 2020 6465 6620 5f5f 6c74  r)..    def __lt
+0001b790: 5f5f 2873 656c 662c 206f 7468 6572 293a  __(self, other):
+0001b7a0: 0a20 2020 2020 2020 2069 6620 6e6f 7420  .        if not 
+0001b7b0: 6f74 6865 722e 6973 5f73 6574 3a0a 2020  other.is_set:.  
+0001b7c0: 2020 2020 2020 2020 2020 7261 6973 6520            raise 
+0001b7d0: 5479 7065 4572 726f 7228 2249 6e76 616c  TypeError("Inval
+0001b7e0: 6964 2063 6f6d 7061 7269 736f 6e20 6f66  id comparison of
+0001b7f0: 2073 6574 2077 6974 6820 2573 2220 2520   set with %s" % 
+0001b800: 6675 6e63 5f6e 616d 6528 6f74 6865 7229  func_name(other)
+0001b810: 290a 2020 2020 2020 2020 7265 7475 726e  ).        return
+0001b820: 2073 656c 662e 6973 5f70 726f 7065 725f   self.is_proper_
+0001b830: 7375 6273 6574 286f 7468 6572 290a 0a20  subset(other).. 
+0001b840: 2020 2064 6566 205f 6576 616c 5f43 6172     def _eval_Car
+0001b850: 6428 7365 6c66 293a 0a20 2020 2020 2020  d(self):.       
+0001b860: 206c 656e 6774 6820 3d20 6c65 6e28 7365   length = len(se
+0001b870: 6c66 290a 2020 2020 2020 2020 6966 206c  lf).        if l
+0001b880: 656e 6774 6820 3d3d 2031 3a0a 2020 2020  ength == 1:.    
+0001b890: 2020 2020 2020 2020 7265 7475 726e 2053          return S
+0001b8a0: 2e4f 6e65 0a20 2020 2020 2020 2066 726f  .One.        fro
+0001b8b0: 6d20 7379 6d70 792e 6675 6e63 7469 6f6e  m sympy.function
+0001b8c0: 732e 656c 656d 656e 7461 7279 2e70 6965  s.elementary.pie
+0001b8d0: 6365 7769 7365 2069 6d70 6f72 7420 5069  cewise import Pi
+0001b8e0: 6563 6577 6973 650a 2020 2020 2020 2020  ecewise.        
+0001b8f0: 2a20 6265 666f 7265 2c20 6c61 7374 203d  * before, last =
+0001b900: 2073 656c 662e 6172 6773 0a20 2020 2020   self.args.     
+0001b910: 2020 2066 726f 6d20 7379 6d70 7920 696d     from sympy im
+0001b920: 706f 7274 2043 6172 6420 2020 2020 2020  port Card       
+0001b930: 0a20 2020 2020 2020 2062 6566 6f72 6520  .        before 
+0001b940: 3d20 7365 6c66 2e66 756e 6328 2a62 6566  = self.func(*bef
+0001b950: 6f72 6529 0a20 2020 2020 2020 206c 656e  ore).        len
+0001b960: 6774 6820 3d20 4361 7264 2862 6566 6f72  gth = Card(befor
+0001b970: 6529 0a20 2020 2020 2020 2072 6574 7572  e).        retur
+0001b980: 6e20 5069 6563 6577 6973 6528 286c 656e  n Piecewise((len
+0001b990: 6774 682c 2045 6c65 6d65 6e74 286c 6173  gth, Element(las
+0001b9a0: 742c 2062 6566 6f72 6529 2e73 696d 706c  t, before).simpl
+0001b9b0: 6966 7928 2929 2c20 286c 656e 6774 6820  ify()), (length 
+0001b9c0: 2b20 312c 2054 7275 6529 292e 7369 6d70  + 1, True)).simp
+0001b9d0: 6c69 6679 2829 0a0a 2020 2020 6465 6620  lify()..    def 
+0001b9e0: 5f65 7661 6c5f 6973 5f66 696e 6974 6528  _eval_is_finite(
+0001b9f0: 7365 6c66 293a 0a20 2020 2020 2020 2072  self):.        r
+0001ba00: 6574 7572 6e20 6675 7a7a 795f 6574 2861  eturn fuzzy_et(a
+0001ba10: 2e69 735f 6669 6e69 7465 2066 6f72 2061  .is_finite for a
+0001ba20: 2069 6e20 7365 6c66 2e61 7267 7329 0a0a   in self.args)..
+0001ba30: 2020 2020 6465 6620 5f65 7661 6c5f 6973      def _eval_is
+0001ba40: 5f65 7874 656e 6465 645f 696e 7465 6765  _extended_intege
+0001ba50: 7228 7365 6c66 293a 0a20 2020 2020 2020  r(self):.       
+0001ba60: 2072 6574 7572 6e20 6675 7a7a 795f 6574   return fuzzy_et
+0001ba70: 2865 2e69 735f 6578 7465 6e64 6564 5f69  (e.is_extended_i
+0001ba80: 6e74 6567 6572 2066 6f72 2065 2069 6e20  nteger for e in 
+0001ba90: 7365 6c66 2e61 7267 7329 0a20 2020 200a  self.args).    .
+0001baa0: 2020 2020 6465 6620 5f65 7661 6c5f 6973      def _eval_is
+0001bab0: 5f73 7570 6572 5f69 6e74 6567 6572 2873  _super_integer(s
+0001bac0: 656c 6629 3a0a 2020 2020 2020 2020 7265  elf):.        re
+0001bad0: 7475 726e 2066 757a 7a79 5f65 7428 652e  turn fuzzy_et(e.
+0001bae0: 6973 5f73 7570 6572 5f69 6e74 6567 6572  is_super_integer
+0001baf0: 2066 6f72 2065 2069 6e20 7365 6c66 2e61   for e in self.a
+0001bb00: 7267 7329 0a20 2020 200a 2020 2020 6465  rgs).    .    de
+0001bb10: 6620 5f65 7661 6c5f 6973 5f65 7874 656e  f _eval_is_exten
+0001bb20: 6465 645f 7261 7469 6f6e 616c 2873 656c  ded_rational(sel
+0001bb30: 6629 3a0a 2020 2020 2020 2020 7265 7475  f):.        retu
+0001bb40: 726e 2066 757a 7a79 5f65 7428 652e 6973  rn fuzzy_et(e.is
+0001bb50: 5f65 7874 656e 6465 645f 7261 7469 6f6e  _extended_ration
+0001bb60: 616c 2066 6f72 2065 2069 6e20 7365 6c66  al for e in self
+0001bb70: 2e61 7267 7329 0a20 2020 200a 2020 2020  .args).    .    
+0001bb80: 6465 6620 5f65 7661 6c5f 6973 5f73 7570  def _eval_is_sup
+0001bb90: 6572 5f72 6174 696f 6e61 6c28 7365 6c66  er_rational(self
+0001bba0: 293a 0a20 2020 2020 2020 2072 6574 7572  ):.        retur
+0001bbb0: 6e20 6675 7a7a 795f 6574 2865 2e69 735f  n fuzzy_et(e.is_
+0001bbc0: 7375 7065 725f 7261 7469 6f6e 616c 2066  super_rational f
+0001bbd0: 6f72 2065 2069 6e20 7365 6c66 2e61 7267  or e in self.arg
+0001bbe0: 7329 0a0a 2020 2020 6465 6620 5f65 7661  s)..    def _eva
+0001bbf0: 6c5f 6973 5f68 7970 6572 5f72 6174 696f  l_is_hyper_ratio
+0001bc00: 6e61 6c28 7365 6c66 293a 0a20 2020 2020  nal(self):.     
+0001bc10: 2020 2072 6574 7572 6e20 6675 7a7a 795f     return fuzzy_
+0001bc20: 6574 2865 2e69 735f 6879 7065 725f 7261  et(e.is_hyper_ra
+0001bc30: 7469 6f6e 616c 2066 6f72 2065 2069 6e20  tional for e in 
+0001bc40: 7365 6c66 2e61 7267 7329 0a20 2020 200a  self.args).    .
+0001bc50: 2020 2020 6465 6620 5f65 7661 6c5f 6973      def _eval_is
+0001bc60: 5f65 7874 656e 6465 645f 7265 616c 2873  _extended_real(s
+0001bc70: 656c 6629 3a0a 2020 2020 2020 2020 7265  elf):.        re
+0001bc80: 7475 726e 2066 757a 7a79 5f65 7428 652e  turn fuzzy_et(e.
+0001bc90: 6973 5f65 7874 656e 6465 645f 7265 616c  is_extended_real
+0001bca0: 2066 6f72 2065 2069 6e20 7365 6c66 2e61   for e in self.a
+0001bcb0: 7267 7329 200a 0a20 2020 2064 6566 205f  rgs) ..    def _
+0001bcc0: 6576 616c 5f69 735f 6879 7065 725f 7265  eval_is_hyper_re
+0001bcd0: 616c 2873 656c 6629 3a0a 2020 2020 2020  al(self):.      
+0001bce0: 2020 7265 7475 726e 2066 757a 7a79 5f65    return fuzzy_e
+0001bcf0: 7428 652e 6973 5f68 7970 6572 5f72 6561  t(e.is_hyper_rea
+0001bd00: 6c20 666f 7220 6520 696e 2073 656c 662e  l for e in self.
+0001bd10: 6172 6773 290a 2020 2020 0a20 2020 2064  args).    .    d
+0001bd20: 6566 205f 6576 616c 5f69 735f 7375 7065  ef _eval_is_supe
+0001bd30: 725f 7265 616c 2873 656c 6629 3a0a 2020  r_real(self):.  
+0001bd40: 2020 2020 2020 7265 7475 726e 2066 757a        return fuz
+0001bd50: 7a79 5f65 7428 652e 6973 5f73 7570 6572  zy_et(e.is_super
+0001bd60: 5f72 6561 6c20 666f 7220 6520 696e 2073  _real for e in s
+0001bd70: 656c 662e 6172 6773 290a 2020 2020 0a20  elf.args).    . 
+0001bd80: 2020 2064 6566 205f 6576 616c 5f69 735f     def _eval_is_
+0001bd90: 6578 7465 6e64 6564 5f63 6f6d 706c 6578  extended_complex
+0001bda0: 2873 656c 6629 3a0a 2020 2020 2020 2020  (self):.        
+0001bdb0: 7265 7475 726e 2066 757a 7a79 5f65 7428  return fuzzy_et(
+0001bdc0: 652e 6973 5f65 7874 656e 6465 645f 636f  e.is_extended_co
+0001bdd0: 6d70 6c65 7820 666f 7220 6520 696e 2073  mplex for e in s
+0001bde0: 656c 662e 6172 6773 290a 2020 2020 200a  elf.args).     .
+0001bdf0: 2020 2020 6465 6620 5f65 7661 6c5f 6973      def _eval_is
+0001be00: 5f68 7970 6572 5f63 6f6d 706c 6578 2873  _hyper_complex(s
+0001be10: 656c 6629 3a0a 2020 2020 2020 2020 7265  elf):.        re
+0001be20: 7475 726e 2066 757a 7a79 5f65 7428 652e  turn fuzzy_et(e.
+0001be30: 6973 5f68 7970 6572 5f63 6f6d 706c 6578  is_hyper_complex
+0001be40: 2066 6f72 2065 2069 6e20 7365 6c66 2e61   for e in self.a
+0001be50: 7267 7329 0a20 2020 200a 2020 2020 4070  rgs).    .    @p
+0001be60: 726f 7065 7274 790a 2020 2020 6465 6620  roperty.    def 
+0001be70: 6574 7970 6528 7365 6c66 293a 0a20 2020  etype(self):.   
+0001be80: 2020 2020 2064 7479 7065 203d 204e 6f6e       dtype = Non
+0001be90: 650a 2020 2020 2020 2020 666f 7220 6520  e.        for e 
+0001bea0: 696e 2073 656c 663a 0a20 2020 2020 2020  in self:.       
+0001beb0: 2020 2020 205f 6474 7970 6520 3d20 652e       _dtype = e.
+0001bec0: 7479 7065 0a20 2020 2020 2020 2020 2020  type.           
+0001bed0: 2069 6620 6474 7970 6520 6973 204e 6f6e   if dtype is Non
+0001bee0: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
+0001bef0: 2020 2064 7479 7065 203d 205f 6474 7970     dtype = _dtyp
+0001bf00: 650a 2020 2020 2020 2020 2020 2020 2020  e.              
+0001bf10: 2020 636f 6e74 696e 7565 0a20 2020 2020    continue.     
+0001bf20: 2020 2020 2020 2069 6620 6474 7970 6520         if dtype 
+0001bf30: 213d 205f 6474 7970 653a 0a20 2020 2020  != _dtype:.     
+0001bf40: 2020 2020 2020 2020 2020 2069 6620 6474             if dt
+0001bf50: 7970 6520 696e 205f 6474 7970 653a 0a20  ype in _dtype:. 
+0001bf60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001bf70: 2020 2064 7479 7065 203d 205f 6474 7970     dtype = _dtyp
+0001bf80: 650a 2020 2020 2020 2020 2020 2020 2020  e.              
+0001bf90: 2020 656c 6966 205f 6474 7970 6520 696e    elif _dtype in
+0001bfa0: 2064 7479 7065 3a0a 2020 2020 2020 2020   dtype:.        
+0001bfb0: 2020 2020 2020 2020 2020 2020 2e2e 2e0a              ....
+0001bfc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001bfd0: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
+0001bfe0: 2020 2020 2020 2020 2020 7261 6973 6520            raise 
+0001bff0: 4578 6365 7074 696f 6e28 2769 6e63 6f6e  Exception('incon
+0001c000: 7369 7374 656e 7420 6474 7970 6520 6465  sistent dtype de
+0001c010: 7465 6374 6564 3a20 2573 2021 3d20 2573  tected: %s != %s
+0001c020: 2720 2520 2864 7479 7065 2c20 5f64 7479  ' % (dtype, _dty
+0001c030: 7065 2929 0a20 2020 2020 2020 2072 6574  pe)).        ret
+0001c040: 7572 6e20 6474 7970 650a 0a20 2020 2064  urn dtype..    d
+0001c050: 6566 206d 696e 2873 656c 6629 3a0a 2020  ef min(self):.  
+0001c060: 2020 2020 2020 6672 6f6d 2073 796d 7079        from sympy
+0001c070: 2e66 756e 6374 696f 6e73 2e65 6c65 6d65  .functions.eleme
+0001c080: 6e74 6172 792e 6d69 7363 656c 6c61 6e65  ntary.miscellane
+0001c090: 6f75 7320 696d 706f 7274 204d 696e 0a20  ous import Min. 
+0001c0a0: 2020 2020 2020 2072 6574 7572 6e20 4d69         return Mi
+0001c0b0: 6e28 2a73 656c 662e 6172 6773 2920 2020  n(*self.args)   
+0001c0c0: 2020 2020 200a 0a20 2020 2064 6566 206d       ..    def m
+0001c0d0: 6178 2873 656c 6629 3a0a 2020 2020 2020  ax(self):.      
+0001c0e0: 2020 6672 6f6d 2073 796d 7079 2e66 756e    from sympy.fun
+0001c0f0: 6374 696f 6e73 2e65 6c65 6d65 6e74 6172  ctions.elementar
+0001c100: 792e 6d69 7363 656c 6c61 6e65 6f75 7320  y.miscellaneous 
+0001c110: 696d 706f 7274 204d 6178 0a20 2020 2020  import Max.     
+0001c120: 2020 2072 6574 7572 6e20 4d61 7828 2a73     return Max(*s
+0001c130: 656c 662e 6172 6773 2920 2020 2020 2020  elf.args)       
+0001c140: 200a 0a20 2020 2064 6566 205f 5f61 6464   ..    def __add
+0001c150: 5f5f 2873 656c 662c 206f 7468 6572 293a  __(self, other):
+0001c160: 0a20 2020 2020 2020 2069 6620 6f74 6865  .        if othe
+0001c170: 722e 6973 5f73 6574 3a0a 2020 2020 2020  r.is_set:.      
+0001c180: 2020 2020 2020 7265 7475 726e 2055 6e69        return Uni
+0001c190: 6f6e 282a 286f 7468 6572 202b 2061 7267  on(*(other + arg
+0001c1a0: 2066 6f72 2061 7267 2069 6e20 7365 6c66   for arg in self
+0001c1b0: 2e61 7267 7329 290a 2020 2020 2020 2020  .args)).        
+0001c1c0: 7265 7475 726e 2073 656c 662e 6675 6e63  return self.func
+0001c1d0: 282a 2861 7267 202b 206f 7468 6572 2066  (*(arg + other f
+0001c1e0: 6f72 2061 7267 2069 6e20 7365 6c66 2e61  or arg in self.a
+0001c1f0: 7267 7329 290a 0a20 2020 2064 6566 205f  rgs))..    def _
+0001c200: 5f6e 6567 5f5f 2873 656c 6629 3a0a 2020  _neg__(self):.  
+0001c210: 2020 2020 2020 7265 7475 726e 2073 656c        return sel
+0001c220: 662e 6675 6e63 282a 282d 6172 6720 666f  f.func(*(-arg fo
+0001c230: 7220 6172 6720 696e 2073 656c 662e 6172  r arg in self.ar
+0001c240: 6773 2929 0a20 2020 200a 2020 2020 6465  gs)).    .    de
+0001c250: 6620 6861 6e64 6c65 5f66 696e 6974 655f  f handle_finite_
+0001c260: 7365 7473 2873 656c 662c 2075 6e6b 293a  sets(self, unk):
+0001c270: 0a20 2020 2020 2020 2069 6620 6c65 6e28  .        if len(
+0001c280: 756e 6b29 203d 3d20 6c65 6e28 7365 6c66  unk) == len(self
+0001c290: 2920 3d3d 2031 3a0a 2020 2020 2020 2020  ) == 1:.        
+0001c2a0: 2020 2020 7265 7475 726e 2049 6e74 6572      return Inter
+0001c2b0: 7365 6374 696f 6e28 756e 6b2c 2073 656c  section(unk, sel
+0001c2c0: 662c 2065 7661 6c75 6174 653d 4661 6c73  f, evaluate=Fals
+0001c2d0: 6529 0a0a 2020 2020 4063 6163 6865 6974  e)..    @cacheit
+0001c2e0: 0a20 2020 2064 6566 205f 6576 616c 5f64  .    def _eval_d
+0001c2f0: 6f6d 6169 6e5f 6465 6669 6e65 6428 7365  omain_defined(se
+0001c300: 6c66 2c20 782c 202a 2a5f 293a 0a20 2020  lf, x, **_):.   
+0001c310: 2020 2020 2064 6f6d 6169 6e20 3d20 5365       domain = Se
+0001c320: 742e 5f65 7661 6c5f 646f 6d61 696e 5f64  t._eval_domain_d
+0001c330: 6566 696e 6564 2873 656c 662c 2078 2920  efined(self, x) 
+0001c340: 2020 2020 2020 200a 2020 2020 2020 2020         .        
+0001c350: 666f 7220 6172 6720 696e 2073 656c 662e  for arg in self.
+0001c360: 6172 6773 3a0a 2020 2020 2020 2020 2020  args:.          
+0001c370: 2020 646f 6d61 696e 2026 3d20 6172 672e    domain &= arg.
+0001c380: 646f 6d61 696e 5f64 6566 696e 6564 2878  domain_defined(x
+0001c390: 2920 2020 2020 2020 200a 2020 2020 2020  )        .      
+0001c3a0: 2020 7265 7475 726e 2064 6f6d 6169 6e20    return domain 
+0001c3b0: 2020 2020 2020 2020 2020 200a 0a20 2020             ..   
+0001c3c0: 2064 6566 2073 756d 2873 656c 6629 3a0a   def sum(self):.
+0001c3d0: 2020 2020 2020 2020 2320 7265 7475 726e          # return
+0001c3e0: 2074 6865 2073 756d 206f 6620 656c 656d   the sum of elem
+0001c3f0: 656e 7473 2069 6e20 7468 6520 6669 6e69  ents in the fini
+0001c400: 7465 7365 740a 2020 2020 2020 2020 6c65  teset.        le
+0001c410: 6e67 7468 203d 206c 656e 2873 656c 6629  ngth = len(self)
+0001c420: 0a20 2020 2020 2020 2069 6620 6c65 6e67  .        if leng
+0001c430: 7468 203d 3d20 313a 0a20 2020 2020 2020  th == 1:.       
+0001c440: 2020 2020 2072 6574 7572 6e20 7365 6c66       return self
+0001c450: 2e61 7267 0a20 2020 2020 2020 2066 726f  .arg.        fro
+0001c460: 6d20 7379 6d70 792e 6675 6e63 7469 6f6e  m sympy.function
+0001c470: 732e 656c 656d 656e 7461 7279 2e70 6965  s.elementary.pie
+0001c480: 6365 7769 7365 2069 6d70 6f72 7420 5069  cewise import Pi
+0001c490: 6563 6577 6973 650a 2020 2020 2020 2020  ecewise.        
+0001c4a0: 2a20 6265 666f 7265 2c20 6c61 7374 203d  * before, last =
+0001c4b0: 2073 656c 662e 6172 6773 0a20 2020 2020   self.args.     
+0001c4c0: 2020 2062 6566 6f72 6520 3d20 7365 6c66     before = self
+0001c4d0: 2e66 756e 6328 2a62 6566 6f72 6529 0a20  .func(*before). 
+0001c4e0: 2020 2020 2020 2073 756d 5f6f 665f 6265         sum_of_be
+0001c4f0: 666f 7265 203d 2062 6566 6f72 652e 7375  fore = before.su
+0001c500: 6d28 290a 2020 2020 2020 2020 7265 7475  m().        retu
+0001c510: 726e 2050 6965 6365 7769 7365 2828 7375  rn Piecewise((su
+0001c520: 6d5f 6f66 5f62 6566 6f72 652c 2045 6c65  m_of_before, Ele
+0001c530: 6d65 6e74 286c 6173 742c 2062 6566 6f72  ment(last, befor
+0001c540: 6529 2e73 696d 706c 6966 7928 2929 2c20  e).simplify()), 
+0001c550: 2873 756d 5f6f 665f 6265 666f 7265 202b  (sum_of_before +
+0001c560: 206c 6173 742c 2054 7275 6529 292e 7369   last, True)).si
+0001c570: 6d70 6c69 6679 2829 0a0a 2020 2020 4063  mplify()..    @c
+0001c580: 6c61 7373 6d65 7468 6f64 0a20 2020 2064  lassmethod.    d
+0001c590: 6566 2073 696d 706c 6966 795f 4571 7561  ef simplify_Equa
+0001c5a0: 6c28 636c 732c 2073 656c 662c 206c 6873  l(cls, self, lhs
+0001c5b0: 2c20 7268 7329 3a0a 2020 2020 2020 2020  , rhs):.        
+0001c5c0: 2222 220a 2020 2020 2020 2020 7072 6563  """.        prec
+0001c5d0: 6f6e 6469 7469 6f6e 3a20 7365 6c66 2e6c  ondition: self.l
+0001c5e0: 6873 2069 7320 6120 4669 6e69 7465 5365  hs is a FiniteSe
+0001c5f0: 7420 6f62 6a65 6374 210a 2020 2020 2020  t object!.      
+0001c600: 2020 2222 220a 2020 2020 2020 2020 6966    """.        if
+0001c610: 2072 6873 2e69 735f 4669 6e69 7465 5365   rhs.is_FiniteSe
+0001c620: 743a 0a20 2020 2020 2020 2020 2020 2069  t:.            i
+0001c630: 6620 6c65 6e28 6c68 7329 203d 3d20 6c65  f len(lhs) == le
+0001c640: 6e28 7268 7329 203d 3d20 313a 0a20 2020  n(rhs) == 1:.   
+0001c650: 2020 2020 2020 2020 2020 2020 2072 6574               ret
+0001c660: 7572 6e20 7365 6c66 2e66 756e 6328 6c68  urn self.func(lh
+0001c670: 732e 6172 672c 2072 6873 2e61 7267 290a  s.arg, rhs.arg).
+0001c680: 2020 2020 2020 2020 0a20 2020 2040 636c          .    @cl
+0001c690: 6173 736d 6574 686f 640a 2020 2020 6465  assmethod.    de
+0001c6a0: 6620 7369 6d70 6c69 6679 5f45 6c65 6d65  f simplify_Eleme
+0001c6b0: 6e74 2863 6c73 2c20 7365 6c66 2c20 652c  nt(cls, self, e,
+0001c6c0: 2073 293a 0a20 2020 2020 2020 2022 2222   s):.        """
+0001c6d0: 0a20 2020 2020 2020 2070 7265 636f 6e64  .        precond
+0001c6e0: 6974 696f 6e3a 2073 656c 662e 6c68 7320  ition: self.lhs 
+0001c6f0: 6973 2061 2046 696e 6974 6553 6574 206f  is a FiniteSet o
+0001c700: 626a 6563 7421 0a20 2020 2020 2020 2022  bject!.        "
+0001c710: 2222 0a20 2020 2020 2020 2069 6620 6c65  "".        if le
+0001c720: 6e28 7329 203d 3d20 313a 0a20 2020 2020  n(s) == 1:.     
+0001c730: 2020 2020 2020 2079 2c20 2a5f 203d 2073         y, *_ = s
+0001c740: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
+0001c750: 6e6f 7420 652e 5f68 6173 2853 796d 626f  not e._has(Symbo
+0001c760: 6c29 2061 6e64 2079 2e5f 6861 7328 5379  l) and y._has(Sy
+0001c770: 6d62 6f6c 293a 0a20 2020 2020 2020 2020  mbol):.         
+0001c780: 2020 2020 2020 2072 6574 7572 6e20 4571         return Eq
+0001c790: 7561 6c28 792c 2065 290a 2020 2020 2020  ual(y, e).      
+0001c7a0: 2020 2020 2020 7265 7475 726e 2045 7175        return Equ
+0001c7b0: 616c 2865 2c20 7929 0a0a 2020 2020 4063  al(e, y)..    @c
+0001c7c0: 6c61 7373 6d65 7468 6f64 0a20 2020 2064  lassmethod.    d
+0001c7d0: 6566 2073 696d 706c 6966 795f 4e6f 7445  ef simplify_NotE
+0001c7e0: 6c65 6d65 6e74 2863 6c73 2c20 7365 6c66  lement(cls, self
+0001c7f0: 2c20 652c 2073 293a 0a20 2020 2020 2020  , e, s):.       
+0001c800: 2022 2222 0a20 2020 2020 2020 2070 7265   """.        pre
+0001c810: 636f 6e64 6974 696f 6e3a 2073 656c 662e  condition: self.
+0001c820: 6c68 7320 6973 2061 2046 696e 6974 6553  lhs is a FiniteS
+0001c830: 6574 206f 626a 6563 7421 0a20 2020 2020  et object!.     
+0001c840: 2020 2022 2222 0a20 2020 2020 2020 2066     """.        f
+0001c850: 726f 6d20 7379 6d70 7920 696d 706f 7274  rom sympy import
+0001c860: 2055 6e65 7175 616c 0a20 2020 2020 2020   Unequal.       
+0001c870: 2069 6620 6c65 6e28 7329 203d 3d20 313a   if len(s) == 1:
+0001c880: 0a20 2020 2020 2020 2020 2020 2079 2c20  .            y, 
+0001c890: 2a5f 203d 2073 0a20 2020 2020 2020 2020  *_ = s.         
+0001c8a0: 2020 2072 6574 7572 6e20 556e 6571 7561     return Unequa
+0001c8b0: 6c28 652c 2079 290a 2020 2020 2020 2020  l(e, y).        
+0001c8c0: 7265 7475 726e 2041 6e64 282a 2855 6e65  return And(*(Une
+0001c8d0: 7175 616c 2865 2c20 7929 2066 6f72 2079  qual(e, y) for y
+0001c8e0: 2069 6e20 7329 290a 0a20 2020 2064 6566   in s))..    def
+0001c8f0: 205f 6576 616c 5f53 7562 7365 745f 7265   _eval_Subset_re
+0001c900: 7665 7273 6564 2873 656c 662c 206c 6873  versed(self, lhs
+0001c910: 293a 0a20 2020 2020 2020 2069 6620 6c68  ):.        if lh
+0001c920: 732e 6973 5f55 6e69 7665 7273 616c 5365  s.is_UniversalSe
+0001c930: 743a 0a20 2020 2020 2020 2020 2020 2072  t:.            r
+0001c940: 6574 7572 6e20 532e 6661 6c73 650a 2020  eturn S.false.  
+0001c950: 2020 0a0a 6672 6f6d 2073 796d 7079 2e63    ..from sympy.c
+0001c960: 6f72 652e 7379 6d70 6966 7920 696d 706f  ore.sympify impo
+0001c970: 7274 2063 6f6e 7665 7274 6572 0a63 6f6e  rt converter.con
+0001c980: 7665 7274 6572 5b73 6574 5d20 3d20 6c61  verter[set] = la
+0001c990: 6d62 6461 2078 3a20 4669 6e69 7465 5365  mbda x: FiniteSe
+0001c9a0: 7428 2a78 290a 636f 6e76 6572 7465 725b  t(*x).converter[
+0001c9b0: 6672 6f7a 656e 7365 745d 203d 206c 616d  frozenset] = lam
+0001c9c0: 6264 6120 783a 2046 696e 6974 6553 6574  bda x: FiniteSet
+0001c9d0: 282a 7829 0a0a 0a63 6c61 7373 2053 796d  (*x)...class Sym
+0001c9e0: 6d65 7472 6963 4469 6666 6572 656e 6365  metricDifference
+0001c9f0: 2853 6574 293a 0a20 2020 2022 2222 5265  (Set):.    """Re
+0001ca00: 7072 6573 656e 7473 2074 6865 2073 6574  presents the set
+0001ca10: 206f 6620 656c 656d 656e 7473 2077 6869   of elements whi
+0001ca20: 6368 2061 7265 2069 6e20 6569 7468 6572  ch are in either
+0001ca30: 206f 6620 7468 650a 2020 2020 7365 7473   of the.    sets
+0001ca40: 2061 6e64 206e 6f74 2069 6e20 7468 6569   and not in thei
+0001ca50: 7220 696e 7465 7273 6563 7469 6f6e 2e0a  r intersection..
+0001ca60: 0a20 2020 2045 7861 6d70 6c65 730a 2020  .    Examples.  
+0001ca70: 2020 3d3d 3d3d 3d3d 3d3d 0a0a 2020 2020    ========..    
+0001ca80: 3e3e 3e20 6672 6f6d 2073 796d 7079 2069  >>> from sympy i
+0001ca90: 6d70 6f72 7420 5379 6d6d 6574 7269 6344  mport SymmetricD
+0001caa0: 6966 6665 7265 6e63 652c 2046 696e 6974  ifference, Finit
+0001cab0: 6553 6574 0a20 2020 203e 3e3e 2053 796d  eSet.    >>> Sym
+0001cac0: 6d65 7472 6963 4469 6666 6572 656e 6365  metricDifference
+0001cad0: 2846 696e 6974 6553 6574 2831 2c20 322c  (FiniteSet(1, 2,
+0001cae0: 2033 292c 2046 696e 6974 6553 6574 2833   3), FiniteSet(3
+0001caf0: 2c20 342c 2035 2929 0a20 2020 2046 696e  , 4, 5)).    Fin
+0001cb00: 6974 6553 6574 2831 2c20 322c 2034 2c20  iteSet(1, 2, 4, 
+0001cb10: 3529 0a0a 2020 2020 5365 6520 416c 736f  5)..    See Also
+0001cb20: 0a20 2020 203d 3d3d 3d3d 3d3d 3d0a 0a20  .    ========.. 
+0001cb30: 2020 2043 6f6d 706c 656d 656e 742c 2055     Complement, U
+0001cb40: 6e69 6f6e 0a0a 2020 2020 5265 6665 7265  nion..    Refere
+0001cb50: 6e63 6573 0a20 2020 203d 3d3d 3d3d 3d3d  nces.    =======
+0001cb60: 3d3d 3d0a 0a20 2020 202e 2e20 5b31 5d20  ===..    .. [1] 
+0001cb70: 6874 7470 733a 2f2f 656e 2e77 696b 6970  https://en.wikip
+0001cb80: 6564 6961 2e6f 7267 2f77 696b 692f 5379  edia.org/wiki/Sy
+0001cb90: 6d6d 6574 7269 635f 6469 6666 6572 656e  mmetric_differen
+0001cba0: 6365 0a20 2020 2022 2222 0a0a 2020 2020  ce.    """..    
+0001cbb0: 6973 5f53 796d 6d65 7472 6963 4469 6666  is_SymmetricDiff
+0001cbc0: 6572 656e 6365 203d 2054 7275 650a 0a20  erence = True.. 
+0001cbd0: 2020 2064 6566 205f 5f6e 6577 5f5f 2863     def __new__(c
+0001cbe0: 6c73 2c20 612c 2062 2c20 6576 616c 7561  ls, a, b, evalua
+0001cbf0: 7465 3d54 7275 6529 3a0a 2020 2020 2020  te=True):.      
+0001cc00: 2020 6966 2065 7661 6c75 6174 653a 0a20    if evaluate:. 
+0001cc10: 2020 2020 2020 2020 2020 2072 6574 7572             retur
+0001cc20: 6e20 5379 6d6d 6574 7269 6344 6966 6665  n SymmetricDiffe
+0001cc30: 7265 6e63 652e 7265 6475 6365 2861 2c20  rence.reduce(a, 
+0001cc40: 6229 0a0a 2020 2020 2020 2020 7265 7475  b)..        retu
+0001cc50: 726e 2042 6173 6963 2e5f 5f6e 6577 5f5f  rn Basic.__new__
+0001cc60: 2863 6c73 2c20 612c 2062 290a 0a20 2020  (cls, a, b)..   
+0001cc70: 2040 7374 6174 6963 6d65 7468 6f64 0a20   @staticmethod. 
+0001cc80: 2020 2064 6566 2072 6564 7563 6528 412c     def reduce(A,
+0001cc90: 2042 293a 0a20 2020 2020 2020 2072 6573   B):.        res
+0001cca0: 756c 7420 3d20 422e 5f73 796d 6d65 7472  ult = B._symmetr
+0001ccb0: 6963 5f64 6966 6665 7265 6e63 6528 4129  ic_difference(A)
+0001ccc0: 0a20 2020 2020 2020 2069 6620 7265 7375  .        if resu
+0001ccd0: 6c74 2069 7320 6e6f 7420 4e6f 6e65 3a0a  lt is not None:.
+0001cce0: 2020 2020 2020 2020 2020 2020 7265 7475              retu
+0001ccf0: 726e 2072 6573 756c 740a 2020 2020 2020  rn result.      
+0001cd00: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
+0001cd10: 2020 2020 7265 7475 726e 2053 796d 6d65      return Symme
+0001cd20: 7472 6963 4469 6666 6572 656e 6365 2841  tricDifference(A
+0001cd30: 2c20 422c 2065 7661 6c75 6174 653d 4661  , B, evaluate=Fa
+0001cd40: 6c73 6529 0a0a 0a64 6566 2069 6d61 6765  lse)...def image
+0001cd50: 7365 7428 7379 6d2c 2065 7870 722c 2062  set(sym, expr, b
+0001cd60: 6173 6573 6574 293a 0a20 2020 2066 726f  aseset):.    fro
+0001cd70: 6d20 7379 6d70 792e 636f 6e63 7265 7465  m sympy.concrete
+0001cd80: 2e73 6574 7320 696d 706f 7274 2043 7570  .sets import Cup
+0001cd90: 0a20 2020 2069 6620 6261 7365 7365 742e  .    if baseset.
+0001cda0: 6973 5f52 616e 6765 3a0a 2020 2020 2020  is_Range:.      
+0001cdb0: 2020 6c69 6d69 7420 3d20 2873 796d 2c20    limit = (sym, 
+0001cdc0: 6261 7365 7365 742e 6d69 6e28 292c 2062  baseset.min(), b
+0001cdd0: 6173 6573 6574 2e6d 6178 2829 202b 2031  aseset.max() + 1
+0001cde0: 290a 2020 2020 656c 6966 2062 6173 6573  ).    elif bases
+0001cdf0: 6574 2e69 735f 456c 656d 656e 7420 616e  et.is_Element an
+0001ce00: 6420 6261 7365 7365 742e 6c68 7320 3d3d  d baseset.lhs ==
+0001ce10: 2073 796d 3a0a 2020 2020 2020 2020 6c69   sym:.        li
+0001ce20: 6d69 7420 3d20 2873 796d 2c20 6261 7365  mit = (sym, base
+0001ce30: 7365 742e 7268 7329 0a20 2020 2065 6c73  set.rhs).    els
+0001ce40: 653a 0a20 2020 2020 2020 206c 696d 6974  e:.        limit
+0001ce50: 203d 2028 7379 6d2c 2062 6173 6573 6574   = (sym, baseset
+0001ce60: 290a 2020 2020 7265 7475 726e 2043 7570  ).    return Cup
+0001ce70: 287b 6578 7072 7d2c 206c 696d 6974 290a  ({expr}, limit).
+0001ce80: 0a0a 2320 6279 2064 6566 696e 6974 696f  ..# by definitio
+0001ce90: 6e2c 2077 6520 6861 7665 0a23 2043 6f6e  n, we have.# Con
+0001cea0: 6469 7469 6f6e 5365 7428 7661 7269 6162  ditionSet(variab
+0001ceb0: 6c65 2c20 636f 6e64 6974 696f 6e2c 2062  le, condition, b
+0001cec0: 6173 655f 7365 7429 203d 3d20 556e 696f  ase_set) == Unio
+0001ced0: 6e5b 7661 7269 6162 6c65 3a63 6f6e 6469  n[variable:condi
+0001cee0: 7469 6f6e 3a62 6173 655f 7365 745d 287b  tion:base_set]({
+0001cef0: 7661 7269 6162 6c65 7d29 0a64 6566 2063  variable}).def c
+0001cf00: 6f6e 6469 7469 6f6e 7365 7428 2a6c 696d  onditionset(*lim
+0001cf10: 6974 293a 0a20 2020 2066 726f 6d20 7379  it):.    from sy
+0001cf20: 6d70 792e 636f 6e63 7265 7465 2e73 6574  mpy.concrete.set
+0001cf30: 7320 696d 706f 7274 2043 7570 0a20 2020  s import Cup.   
+0001cf40: 2069 6620 6c65 6e28 6c69 6d69 7429 203e   if len(limit) >
+0001cf50: 2032 2061 6e64 2028 6c69 6d69 745b 325d   2 and (limit[2]
+0001cf60: 2069 7320 4e6f 6e65 206f 7220 6c69 6d69   is None or limi
+0001cf70: 745b 325d 2e69 735f 556e 6976 6572 7361  t[2].is_Universa
+0001cf80: 6c53 6574 293a 0a20 2020 2020 2020 206c  lSet):.        l
+0001cf90: 696d 6974 203d 206c 696d 6974 5b3a 325d  imit = limit[:2]
+0001cfa0: 0a20 2020 2076 6172 6961 626c 652c 2063  .    variable, c
+0001cfb0: 6f6e 6469 7469 6f6e 2c20 2a62 6173 655f  ondition, *base_
+0001cfc0: 7365 7420 3d20 6c69 6d69 740a 2020 2020  set = limit.    
+0001cfd0: 6966 2062 6173 655f 7365 743a 0a20 2020  if base_set:.   
+0001cfe0: 2020 2020 2062 6173 655f 7365 7420 3d20       base_set = 
+0001cff0: 6261 7365 5f73 6574 5b30 5d0a 2020 2020  base_set[0].    
+0001d000: 2020 2020 6966 206e 6f74 2062 6173 655f      if not base_
+0001d010: 7365 743a 0a20 2020 2020 2020 2020 2020  set:.           
+0001d020: 2072 6574 7572 6e20 6261 7365 5f73 6574   return base_set
+0001d030: 2020 2020 2020 2020 0a20 2020 2065 6c73          .    els
+0001d040: 653a 0a20 2020 2020 2020 2062 6173 655f  e:.        base_
+0001d050: 7365 7420 3d20 7661 7269 6162 6c65 2e75  set = variable.u
+0001d060: 6e69 7665 7273 616c 5365 740a 2020 2020  niversalSet.    
+0001d070: 2020 200a 2020 2020 6966 2063 6f6e 6469     .    if condi
+0001d080: 7469 6f6e 3a0a 2020 2020 2020 2020 7265  tion:.        re
+0001d090: 7475 726e 2062 6173 655f 7365 7420 2020  turn base_set   
+0001d0a0: 2020 2020 200a 2020 2020 6966 2063 6f6e       .    if con
+0001d0b0: 6469 7469 6f6e 2e69 735f 426f 6f6c 6561  dition.is_Boolea
+0001d0c0: 6e46 616c 7365 3a0a 2020 2020 2020 2020  nFalse:.        
+0001d0d0: 7265 7475 726e 2076 6172 6961 626c 652e  return variable.
+0001d0e0: 656d 7074 7953 6574 0a0a 2020 2020 7265  emptySet..    re
+0001d0f0: 7475 726e 2043 7570 287b 7661 7269 6162  turn Cup({variab
+0001d100: 6c65 7d2c 206c 696d 6974 290a 0a0a 6465  le}, limit)...de
+0001d110: 6620 5f69 6d61 6765 7365 7428 2a61 7267  f _imageset(*arg
+0001d120: 7329 3a0a 2020 2020 7222 2222 0a20 2020  s):.    r""".   
+0001d130: 2052 6574 7572 6e20 616e 2069 6d61 6765   Return an image
+0001d140: 206f 6620 7468 6520 7365 7420 756e 6465   of the set unde
+0001d150: 7220 7472 616e 7366 6f72 6d61 7469 6f6e  r transformation
+0001d160: 2060 6066 6060 2e0a 0a20 2020 2049 6620   ``f``...    If 
+0001d170: 7468 6973 2066 756e 6374 696f 6e20 6361  this function ca
+0001d180: 6e27 7420 636f 6d70 7574 6520 7468 6520  n't compute the 
+0001d190: 696d 6167 652c 2069 7420 7265 7475 726e  image, it return
+0001d1a0: 7320 616e 0a20 2020 2075 6e65 7661 6c75  s an.    unevalu
+0001d1b0: 6174 6564 2049 6d61 6765 5365 7420 6f62  ated ImageSet ob
+0001d1c0: 6a65 6374 2e0a 0a20 2020 202e 2e20 6d61  ject...    .. ma
+0001d1d0: 7468 3a3a 0a20 2020 2020 2020 207b 2066  th::.        { f
+0001d1e0: 2878 2920 7c20 7820 5c69 6e20 7365 6c66  (x) | x \in self
+0001d1f0: 207d 0a0a 2020 2020 4578 616d 706c 6573   }..    Examples
+0001d200: 0a20 2020 203d 3d3d 3d3d 3d3d 3d0a 0a20  .    ========.. 
+0001d210: 2020 203e 3e3e 2066 726f 6d20 7379 6d70     >>> from symp
+0001d220: 7920 696d 706f 7274 2053 2c20 496e 7465  y import S, Inte
+0001d230: 7276 616c 2c20 5379 6d62 6f6c 2c20 696d  rval, Symbol, im
+0001d240: 6167 6573 6574 2c20 7369 6e2c 204c 616d  ageset, sin, Lam
+0001d250: 6264 610a 2020 2020 3e3e 3e20 6672 6f6d  bda.    >>> from
+0001d260: 2073 796d 7079 2e61 6263 2069 6d70 6f72   sympy.abc impor
+0001d270: 7420 782c 2079 0a0a 2020 2020 3e3e 3e20  t x, y..    >>> 
+0001d280: 696d 6167 6573 6574 2878 2c20 322a 782c  imageset(x, 2*x,
+0001d290: 2049 6e74 6572 7661 6c28 302c 2032 2929   Interval(0, 2))
+0001d2a0: 0a20 2020 2049 6e74 6572 7661 6c28 302c  .    Interval(0,
+0001d2b0: 2034 290a 0a20 2020 203e 3e3e 2069 6d61   4)..    >>> ima
+0001d2c0: 6765 7365 7428 6c61 6d62 6461 2078 3a20  geset(lambda x: 
+0001d2d0: 322a 782c 2049 6e74 6572 7661 6c28 302c  2*x, Interval(0,
+0001d2e0: 2032 2929 0a20 2020 2049 6e74 6572 7661   2)).    Interva
+0001d2f0: 6c28 302c 2034 290a 0a20 2020 203e 3e3e  l(0, 4)..    >>>
+0001d300: 2069 6d61 6765 7365 7428 4c61 6d62 6461   imageset(Lambda
+0001d310: 2878 2c20 7369 6e28 7829 292c 2049 6e74  (x, sin(x)), Int
+0001d320: 6572 7661 6c28 2d32 2c20 3129 290a 2020  erval(-2, 1)).  
+0001d330: 2020 496d 6167 6553 6574 284c 616d 6264    ImageSet(Lambd
+0001d340: 6128 782c 2073 696e 2878 2929 2c20 496e  a(x, sin(x)), In
+0001d350: 7465 7276 616c 282d 322c 2031 2929 0a0a  terval(-2, 1))..
+0001d360: 2020 2020 3e3e 3e20 696d 6167 6573 6574      >>> imageset
+0001d370: 2873 696e 2c20 496e 7465 7276 616c 282d  (sin, Interval(-
+0001d380: 322c 2031 2929 0a20 2020 2049 6d61 6765  2, 1)).    Image
+0001d390: 5365 7428 4c61 6d62 6461 2878 2c20 7369  Set(Lambda(x, si
+0001d3a0: 6e28 7829 292c 2049 6e74 6572 7661 6c28  n(x)), Interval(
+0001d3b0: 2d32 2c20 3129 290a 2020 2020 3e3e 3e20  -2, 1)).    >>> 
+0001d3c0: 696d 6167 6573 6574 286c 616d 6264 6120  imageset(lambda 
+0001d3d0: 793a 2078 202b 2079 2c20 496e 7465 7276  y: x + y, Interv
+0001d3e0: 616c 282d 322c 2031 2929 0a20 2020 2049  al(-2, 1)).    I
+0001d3f0: 6d61 6765 5365 7428 4c61 6d62 6461 2879  mageSet(Lambda(y
+0001d400: 2c20 7820 2b20 7929 2c20 496e 7465 7276  , x + y), Interv
+0001d410: 616c 282d 322c 2031 2929 0a0a 2020 2020  al(-2, 1))..    
+0001d420: 4578 7072 6573 7369 6f6e 7320 6170 706c  Expressions appl
+0001d430: 6965 6420 746f 2074 6865 2073 6574 206f  ied to the set o
+0001d440: 6620 496e 7465 6765 7273 2061 7265 2073  f Integers are s
+0001d450: 696d 706c 6966 6965 640a 2020 2020 746f  implified.    to
+0001d460: 2073 686f 7720 6173 2066 6577 206e 6567   show as few neg
+0001d470: 6174 6976 6573 2061 7320 706f 7373 6962  atives as possib
+0001d480: 6c65 2061 6e64 206c 696e 6561 7220 6578  le and linear ex
+0001d490: 7072 6573 7369 6f6e 730a 2020 2020 6172  pressions.    ar
+0001d4a0: 6520 636f 6e76 6572 7465 6420 746f 2061  e converted to a
+0001d4b0: 2063 616e 6f6e 6963 616c 2066 6f72 6d2e   canonical form.
+0001d4c0: 2049 6620 7468 6973 2069 7320 6e6f 7420   If this is not 
+0001d4d0: 6465 7369 7261 626c 650a 2020 2020 7468  desirable.    th
+0001d4e0: 656e 2074 6865 2075 6e65 7661 6c75 6174  en the unevaluat
+0001d4f0: 6564 2049 6d61 6765 5365 7420 7368 6f75  ed ImageSet shou
+0001d500: 6c64 2062 6520 7573 6564 2e0a 0a20 2020  ld be used...   
+0001d510: 203e 3e3e 2069 6d61 6765 7365 7428 782c   >>> imageset(x,
+0001d520: 202d 322a 7820 2b20 352c 2053 2e49 6e74   -2*x + 5, S.Int
+0001d530: 6567 6572 7329 0a20 2020 2049 6d61 6765  egers).    Image
+0001d540: 5365 7428 4c61 6d62 6461 2878 2c20 322a  Set(Lambda(x, 2*
+0001d550: 7820 2b20 3129 2c20 496e 7465 6765 7273  x + 1), Integers
+0001d560: 290a 0a20 2020 2053 6565 2041 6c73 6f0a  )..    See Also.
+0001d570: 2020 2020 3d3d 3d3d 3d3d 3d3d 0a0a 2020      ========..  
+0001d580: 2020 7379 6d70 792e 7365 7473 2e66 616e    sympy.sets.fan
+0001d590: 6379 7365 7473 2e49 6d61 6765 5365 740a  cysets.ImageSet.
+0001d5a0: 0a20 2020 2022 2222 0a20 2020 2066 726f  .    """.    fro
+0001d5b0: 6d20 7379 6d70 792e 636f 7265 2069 6d70  m sympy.core imp
+0001d5c0: 6f72 7420 4c61 6d62 6461 0a20 2020 2066  ort Lambda.    f
+0001d5d0: 726f 6d20 7379 6d70 792e 7365 7473 2e66  rom sympy.sets.f
+0001d5e0: 616e 6379 7365 7473 2069 6d70 6f72 7420  ancysets import 
+0001d5f0: 496d 6167 6553 6574 0a20 2020 2066 726f  ImageSet.    fro
+0001d600: 6d20 7379 6d70 792e 7365 7473 2e73 6574  m sympy.sets.set
+0001d610: 6578 7072 2069 6d70 6f72 7420 7365 745f  expr import set_
+0001d620: 6675 6e63 7469 6f6e 0a0a 2020 2020 6966  function..    if
+0001d630: 206c 656e 2861 7267 7329 203c 2032 3a0a   len(args) < 2:.
+0001d640: 2020 2020 2020 2020 7261 6973 6520 5661          raise Va
+0001d650: 6c75 6545 7272 6f72 2827 696d 6167 6573  lueError('images
+0001d660: 6574 2065 7870 6563 7473 2061 7420 6c65  et expects at le
+0001d670: 6173 7420 3220 6172 6773 2c20 676f 743a  ast 2 args, got:
+0001d680: 2025 7327 2025 206c 656e 2861 7267 7329   %s' % len(args)
+0001d690: 290a 0a20 2020 2066 726f 6d20 7379 6d70  )..    from symp
+0001d6a0: 792e 7465 6e73 6f72 2e69 6e64 6578 6564  y.tensor.indexed
+0001d6b0: 2069 6d70 6f72 7420 536c 6963 6564 0a20   import Sliced. 
+0001d6c0: 2020 2069 6620 6973 696e 7374 616e 6365     if isinstance
+0001d6d0: 2861 7267 735b 305d 2c20 2853 796d 626f  (args[0], (Symbo
+0001d6e0: 6c2c 2074 7570 6c65 2c20 536c 6963 6564  l, tuple, Sliced
+0001d6f0: 2929 2061 6e64 206c 656e 2861 7267 7329  )) and len(args)
+0001d700: 203e 2032 3a0a 2020 2020 2020 2020 6620   > 2:.        f 
+0001d710: 3d20 4c61 6d62 6461 2861 7267 735b 305d  = Lambda(args[0]
+0001d720: 2c20 6172 6773 5b31 5d29 0a20 2020 2020  , args[1]).     
+0001d730: 2020 2073 6574 5f6c 6973 7420 3d20 6172     set_list = ar
+0001d740: 6773 5b32 3a5d 0a20 2020 2065 6c73 653a  gs[2:].    else:
+0001d750: 0a20 2020 2020 2020 2066 203d 2061 7267  .        f = arg
+0001d760: 735b 305d 0a20 2020 2020 2020 2073 6574  s[0].        set
+0001d770: 5f6c 6973 7420 3d20 6172 6773 5b31 3a5d  _list = args[1:]
+0001d780: 0a0a 2020 2020 6966 2069 7369 6e73 7461  ..    if isinsta
+0001d790: 6e63 6528 662c 204c 616d 6264 6129 3a0a  nce(f, Lambda):.
+0001d7a0: 2020 2020 2020 2020 7061 7373 0a20 2020          pass.   
+0001d7b0: 2065 6c69 6620 6361 6c6c 6162 6c65 2866   elif callable(f
+0001d7c0: 293a 0a20 2020 2020 2020 206e 6172 6773  ):.        nargs
+0001d7d0: 203d 2067 6574 6174 7472 2866 2c20 276e   = getattr(f, 'n
+0001d7e0: 6172 6773 272c 207b 7d29 0a20 2020 2020  args', {}).     
+0001d7f0: 2020 2069 6620 6e61 7267 733a 0a20 2020     if nargs:.   
+0001d800: 2020 2020 2020 2020 2069 6620 6c65 6e28           if len(
+0001d810: 6e61 7267 7329 2021 3d20 313a 0a20 2020  nargs) != 1:.   
+0001d820: 2020 2020 2020 2020 2020 2020 2072 6169               rai
+0001d830: 7365 204e 6f74 496d 706c 656d 656e 7465  se NotImplemente
+0001d840: 6428 6669 6c6c 6465 6465 6e74 2827 2727  d(filldedent('''
+0001d850: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0001d860: 2020 2020 2054 6869 7320 6675 6e63 7469       This functi
+0001d870: 6f6e 2063 616e 2074 616b 6520 6d6f 7265  on can take more
+0001d880: 2074 6861 6e20 3120 6172 670a 2020 2020   than 1 arg.    
+0001d890: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001d8a0: 6275 7420 7468 6520 706f 7465 6e74 6961  but the potentia
+0001d8b0: 6c6c 7920 636f 6d70 6c69 6361 7465 6420  lly complicated 
+0001d8c0: 7365 7420 696e 7075 740a 2020 2020 2020  set input.      
+0001d8d0: 2020 2020 2020 2020 2020 2020 2020 6861                ha
+0001d8e0: 7320 6e6f 7420 6265 656e 2061 6e61 6c79  s not been analy
+0001d8f0: 7a65 6420 6174 2074 6869 7320 706f 696e  zed at this poin
+0001d900: 7420 746f 0a20 2020 2020 2020 2020 2020  t to.           
+0001d910: 2020 2020 2020 2020 206b 6e6f 7720 6974           know it
+0001d920: 7320 6469 6d65 6e73 696f 6e73 2e20 544f  s dimensions. TO
+0001d930: 444f 0a20 2020 2020 2020 2020 2020 2020  DO.             
+0001d940: 2020 2020 2020 2027 2727 2929 0a20 2020         ''')).   
+0001d950: 2020 2020 2020 2020 204e 203d 206e 6172           N = nar
+0001d960: 6773 2e61 7267 735b 305d 0a20 2020 2020  gs.args[0].     
+0001d970: 2020 2020 2020 2069 6620 4e20 3d3d 2031         if N == 1
+0001d980: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+0001d990: 2020 7320 3d20 2778 270a 2020 2020 2020    s = 'x'.      
+0001d9a0: 2020 2020 2020 656c 7365 3a0a 2020 2020        else:.    
+0001d9b0: 2020 2020 2020 2020 2020 2020 7320 3d20              s = 
+0001d9c0: 5b53 796d 626f 6c28 2778 2569 2720 2520  [Symbol('x%i' % 
+0001d9d0: 6929 2066 6f72 2069 2069 6e20 7261 6e67  i) for i in rang
+0001d9e0: 6528 312c 204e 202b 2031 295d 0a20 2020  e(1, N + 1)].   
+0001d9f0: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
+0001da00: 2020 2020 2020 2073 203d 2069 6e73 7065         s = inspe
+0001da10: 6374 2e73 6967 6e61 7475 7265 2866 292e  ct.signature(f).
+0001da20: 7061 7261 6d65 7465 7273 0a0a 2020 2020  parameters..    
+0001da30: 2020 2020 6465 7870 7220 3d20 5f73 796d      dexpr = _sym
+0001da40: 7069 6679 2866 282a 5b44 756d 6d79 2829  pify(f(*[Dummy()
+0001da50: 2066 6f72 2069 2069 6e20 735d 2929 0a20   for i in s])). 
+0001da60: 2020 2020 2020 2076 6172 203d 205b 5f75         var = [_u
+0001da70: 6e69 7175 656c 795f 6e61 6d65 645f 7379  niquely_named_sy
+0001da80: 6d62 6f6c 2853 796d 626f 6c28 6929 2c20  mbol(Symbol(i), 
+0001da90: 6465 7870 7229 2066 6f72 2069 2069 6e20  dexpr) for i in 
+0001daa0: 735d 0a20 2020 2020 2020 2065 7870 7220  s].        expr 
+0001dab0: 3d20 6628 2a76 6172 290a 2020 2020 2020  = f(*var).      
+0001dac0: 2020 6620 3d20 4c61 6d62 6461 2876 6172    f = Lambda(var
+0001dad0: 2c20 6578 7072 290a 2020 2020 656c 7365  , expr).    else
+0001dae0: 3a0a 2020 2020 2020 2020 7261 6973 6520  :.        raise 
+0001daf0: 5479 7065 4572 726f 7228 6669 6c6c 6465  TypeError(fillde
+0001db00: 6465 6e74 2827 2727 0a20 2020 2020 2020  dent('''.       
+0001db10: 2020 2020 2065 7870 6563 7469 6e67 206c       expecting l
+0001db20: 616d 6264 612c 204c 616d 6264 610a 2020  ambda, Lambda.  
+0001db30: 2020 2020 2020 2020 2020 6e6f 7420 5c27            not \'
+0001db40: 2573 5c27 2e27 2727 2025 2066 756e 635f  %s\'.''' % func_
+0001db50: 6e61 6d65 2866 2929 290a 0a20 2020 2069  name(f)))..    i
+0001db60: 6620 616e 7928 6e6f 7420 732e 6973 5f73  f any(not s.is_s
+0001db70: 6574 2066 6f72 2073 2069 6e20 7365 745f  et for s in set_
+0001db80: 6c69 7374 293a 0a20 2020 2020 2020 206e  list):.        n
+0001db90: 616d 6520 3d20 5b66 756e 635f 6e61 6d65  ame = [func_name
+0001dba0: 2873 2920 666f 7220 7320 696e 2073 6574  (s) for s in set
+0001dbb0: 5f6c 6973 745d 0a20 2020 2020 2020 2072  _list].        r
+0001dbc0: 6169 7365 2056 616c 7565 4572 726f 7228  aise ValueError(
+0001dbd0: 2761 7267 756d 656e 7473 2061 6674 6572  'arguments after
+0001dbe0: 206d 6170 7069 6e67 2073 686f 756c 6420   mapping should 
+0001dbf0: 6265 2073 6574 732c 206e 6f74 2025 7327  be sets, not %s'
+0001dc00: 2025 206e 616d 6529 0a0a 2020 2020 6966   % name)..    if
+0001dc10: 206c 656e 2873 6574 5f6c 6973 7429 203d   len(set_list) =
+0001dc20: 3d20 313a 0a20 2020 2020 2020 2073 6574  = 1:.        set
+0001dc30: 203d 2073 6574 5f6c 6973 745b 305d 0a20   = set_list[0]. 
+0001dc40: 2020 2020 2020 2074 7279 3a0a 2020 2020         try:.    
+0001dc50: 2020 2020 2020 2020 2320 5479 7065 4572          # TypeEr
+0001dc60: 726f 7220 6966 2061 7267 2063 6f75 6e74  ror if arg count
+0001dc70: 2021 3d20 7365 7420 6469 6d65 6e73 696f   != set dimensio
+0001dc80: 6e73 0a20 2020 2020 2020 2020 2020 2072  ns.            r
+0001dc90: 203d 2073 6574 5f66 756e 6374 696f 6e28   = set_function(
+0001dca0: 662c 2073 6574 290a 2020 2020 2020 2020  f, set).        
+0001dcb0: 2020 2020 6966 2072 2069 7320 4e6f 6e65      if r is None
+0001dcc0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+0001dcd0: 2020 7261 6973 6520 5479 7065 4572 726f    raise TypeErro
+0001dce0: 720a 2020 2020 2020 2020 2020 2020 6966  r.            if
+0001dcf0: 206e 6f74 2072 3a0a 2020 2020 2020 2020   not r:.        
+0001dd00: 2020 2020 2020 2020 7265 7475 726e 2072          return r
+0001dd10: 0a20 2020 2020 2020 2065 7863 6570 7420  .        except 
+0001dd20: 5479 7065 4572 726f 723a 0a20 2020 2020  TypeError:.     
+0001dd30: 2020 2020 2020 2072 203d 2049 6d61 6765         r = Image
+0001dd40: 5365 7428 662c 2073 6574 290a 2020 2020  Set(f, set).    
+0001dd50: 2020 2020 6966 2069 7369 6e73 7461 6e63      if isinstanc
+0001dd60: 6528 722c 2049 6d61 6765 5365 7429 3a0a  e(r, ImageSet):.
+0001dd70: 2020 2020 2020 2020 2020 2020 662c 2073              f, s
+0001dd80: 6574 203d 2072 2e61 7267 730a 0a20 2020  et = r.args..   
+0001dd90: 2020 2020 2069 6620 662e 7661 7269 6162       if f.variab
+0001dda0: 6c65 7320 3d3d 2066 2e65 7870 723a 0a20  les == f.expr:. 
+0001ddb0: 2020 2020 2020 2020 2020 2072 6574 7572             retur
+0001ddc0: 6e20 7365 740a 0a20 2020 2020 2020 2069  n set..        i
+0001ddd0: 6620 6973 696e 7374 616e 6365 2873 6574  f isinstance(set
+0001dde0: 2c20 496d 6167 6553 6574 293a 0a20 2020  , ImageSet):.   
+0001ddf0: 2020 2020 2020 2020 2069 6620 6c65 6e28           if len(
+0001de00: 7365 742e 6c61 6d64 612e 7661 7269 6162  set.lamda.variab
+0001de10: 6c65 7329 203d 3d20 3120 616e 6420 6c65  les) == 1 and le
+0001de20: 6e28 662e 7661 7269 6162 6c65 7329 203d  n(f.variables) =
+0001de30: 3d20 313a 0a20 2020 2020 2020 2020 2020  = 1:.           
+0001de40: 2020 2020 2072 6574 7572 6e20 696d 6167       return imag
+0001de50: 6573 6574 284c 616d 6264 6128 7365 742e  eset(Lambda(set.
+0001de60: 6c61 6d64 612e 7661 7269 6162 6c65 735b  lamda.variables[
+0001de70: 305d 2c0a 2020 2020 2020 2020 2020 2020  0],.            
+0001de80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001de90: 2020 2020 2020 2020 2020 2066 2e65 7870             f.exp
+0001dea0: 722e 7375 6273 2866 2e76 6172 6961 626c  r.subs(f.variabl
+0001deb0: 6573 5b30 5d2c 2073 6574 2e6c 616d 6461  es[0], set.lamda
+0001dec0: 2e65 7870 7229 292c 0a20 2020 2020 2020  .expr)),.       
+0001ded0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001dee0: 2020 2020 2020 2020 2073 6574 2e62 6173           set.bas
+0001def0: 655f 7365 7429 0a0a 2020 2020 2020 2020  e_set)..        
+0001df00: 6966 2072 2069 7320 6e6f 7420 4e6f 6e65  if r is not None
+0001df10: 3a0a 2020 2020 2020 2020 2020 2020 7265  :.            re
+0001df20: 7475 726e 2072 0a0a 2020 2020 7265 7475  turn r..    retu
+0001df30: 726e 2049 6d61 6765 5365 7428 662c 202a  rn ImageSet(f, *
+0001df40: 7365 745f 6c69 7374 290a 0a0a 6465 6620  set_list)...def 
+0001df50: 6973 5f66 756e 6374 696f 6e5f 696e 7665  is_function_inve
+0001df60: 7274 6962 6c65 5f69 6e5f 7365 7428 6675  rtible_in_set(fu
+0001df70: 6e63 2c20 7365 7476 293a 0a20 2020 2022  nc, setv):.    "
+0001df80: 2222 0a20 2020 2043 6865 636b 7320 7768  "".    Checks wh
+0001df90: 6574 6865 7220 6675 6e63 7469 6f6e 2060  ether function `
+0001dfa0: 6066 756e 6360 6020 6973 2069 6e76 6572  `func`` is inver
+0001dfb0: 7469 626c 6520 7768 656e 2074 6865 2064  tible when the d
+0001dfc0: 6f6d 6169 6e20 6973 0a20 2020 2072 6573  omain is.    res
+0001dfd0: 7472 6963 7465 6420 746f 2073 6574 2060  tricted to set `
+0001dfe0: 6073 6574 7660 602e 0a20 2020 2022 2222  `setv``..    """
+0001dff0: 0a20 2020 2066 726f 6d20 7379 6d70 7920  .    from sympy 
+0001e000: 696d 706f 7274 2065 7870 2c20 6c6f 670a  import exp, log.
+0001e010: 2020 2020 2320 4675 6e63 7469 6f6e 7320      # Functions 
+0001e020: 6b6e 6f77 6e20 746f 2061 6c77 6179 7320  known to always 
+0001e030: 6265 2069 6e76 6572 7469 626c 653a 0a20  be invertible:. 
+0001e040: 2020 2069 6620 6675 6e63 2069 6e20 2865     if func in (e
+0001e050: 7870 2c20 6c6f 6729 3a0a 2020 2020 2020  xp, log):.      
+0001e060: 2020 7265 7475 726e 2054 7275 650a 2020    return True.  
+0001e070: 2020 7520 3d20 4475 6d6d 7928 2275 2229    u = Dummy("u")
+0001e080: 0a20 2020 2066 6469 6666 203d 2066 756e  .    fdiff = fun
+0001e090: 6328 7529 2e64 6966 6628 7529 0a20 2020  c(u).diff(u).   
+0001e0a0: 2023 206d 6f6e 6f74 6f6e 6f75 7320 6675   # monotonous fu
+0001e0b0: 6e63 7469 6f6e 733a 0a20 2020 2023 2054  nctions:.    # T
+0001e0c0: 4f44 4f3a 2063 6865 636b 2073 7562 7365  ODO: check subse
+0001e0d0: 7473 2028 6066 756e 6360 2069 6e20 6073  ts (`func` in `s
+0001e0e0: 6574 7660 290a 2020 2020 6966 2028 6664  etv`).    if (fd
+0001e0f0: 6966 6620 3e20 3029 203d 3d20 5472 7565  iff > 0) == True
+0001e100: 206f 7220 2866 6469 6666 203c 2030 2920   or (fdiff < 0) 
+0001e110: 3d3d 2054 7275 653a 0a20 2020 2020 2020  == True:.       
+0001e120: 2072 6574 7572 6e20 5472 7565 0a20 2020   return True.   
+0001e130: 2023 2054 4f44 4f3a 2073 7570 706f 7274   # TODO: support
+0001e140: 206d 6f72 650a 2020 2020 7265 7475 726e   more.    return
+0001e150: 204e 6f6e 650a 0a0a 6465 6620 7369 6d70   None...def simp
+0001e160: 6c69 6679 5f75 6e69 6f6e 2861 7267 7329  lify_union(args)
+0001e170: 3a0a 2020 2020 2222 220a 2020 2020 5369  :.    """.    Si
+0001e180: 6d70 6c69 6679 2061 203a 636c 6173 733a  mplify a :class:
+0001e190: 6055 6e69 6f6e 6020 7573 696e 6720 6b6e  `Union` using kn
+0001e1a0: 6f77 6e20 7275 6c65 730a 0a20 2020 2057  own rules..    W
+0001e1b0: 6520 6669 7273 7420 7374 6172 7420 7769  e first start wi
+0001e1c0: 7468 2067 6c6f 6261 6c20 7275 6c65 7320  th global rules 
+0001e1d0: 6c69 6b65 2027 4d65 7267 6520 616c 6c20  like 'Merge all 
+0001e1e0: 4669 6e69 7465 5365 7473 270a 0a20 2020  FiniteSets'..   
+0001e1f0: 2054 6865 6e20 7765 2069 7465 7261 7465   Then we iterate
+0001e200: 2074 6872 6f75 6768 2061 6c6c 2070 6169   through all pai
+0001e210: 7273 2061 6e64 2061 736b 2074 6865 2063  rs and ask the c
+0001e220: 6f6e 7374 6974 7565 6e74 2073 6574 7320  onstituent sets 
+0001e230: 6966 2074 6865 790a 2020 2020 6361 6e20  if they.    can 
+0001e240: 7369 6d70 6c69 6679 2074 6865 6d73 656c  simplify themsel
+0001e250: 7665 7320 7769 7468 2061 6e79 206f 7468  ves with any oth
+0001e260: 6572 2063 6f6e 7374 6974 7565 6e74 2e20  er constituent. 
+0001e270: 2054 6869 7320 7072 6f63 6573 7320 6465   This process de
+0001e280: 7065 6e64 730a 2020 2020 6f6e 2060 6075  pends.    on ``u
+0001e290: 6e69 6f6e 5f73 6574 7328 612c 2062 2960  nion_sets(a, b)`
+0001e2a0: 6020 6675 6e63 7469 6f6e 732e 0a20 2020  ` functions..   
+0001e2b0: 2022 2222 0a23 2020 2020 2066 726f 6d20   """.#     from 
+0001e2c0: 7379 6d70 792e 7365 7473 2e68 616e 646c  sympy.sets.handl
+0001e2d0: 6572 732e 756e 696f 6e20 696d 706f 7274  ers.union import
+0001e2e0: 2075 6e69 6f6e 5f73 6574 730a 0a20 2020   union_sets..   
+0001e2f0: 2023 203d 3d3d 3d3d 2047 6c6f 6261 6c20   # ===== Global 
+0001e300: 5275 6c65 7320 3d3d 3d3d 3d0a 2020 2020  Rules =====.    
+0001e310: 6966 206e 6f74 2061 7267 733a 0a20 2020  if not args:.   
+0001e320: 2020 2020 2072 6574 7572 6e20 456d 7074       return Empt
+0001e330: 7953 6574 2829 0a0a 2020 2020 666f 7220  ySet()..    for 
+0001e340: 6172 6720 696e 2061 7267 733a 0a20 2020  arg in args:.   
+0001e350: 2020 2020 2069 6620 6e6f 7420 6172 672e       if not arg.
+0001e360: 6973 5f73 6574 3a0a 2020 2020 2020 2020  is_set:.        
+0001e370: 2020 2020 7261 6973 6520 5479 7065 4572      raise TypeEr
+0001e380: 726f 7228 2249 6e70 7574 2061 7267 7320  ror("Input args 
+0001e390: 746f 2055 6e69 6f6e 206d 7573 7420 6265  to Union must be
+0001e3a0: 2053 6574 7322 290a 0a20 2020 2023 204d   Sets")..    # M
+0001e3b0: 6572 6765 2061 6c6c 2066 696e 6974 6520  erge all finite 
+0001e3c0: 7365 7473 0a20 2020 2066 696e 6974 655f  sets.    finite_
+0001e3d0: 7365 7473 203d 205b 7820 666f 7220 7820  sets = [x for x 
+0001e3e0: 696e 2061 7267 7320 6966 2078 2e69 735f  in args if x.is_
+0001e3f0: 4669 6e69 7465 5365 745d 0a20 2020 2069  FiniteSet].    i
+0001e400: 6620 6c65 6e28 6669 6e69 7465 5f73 6574  f len(finite_set
+0001e410: 7329 203e 2031 3a0a 2020 2020 2020 2020  s) > 1:.        
+0001e420: 6172 6773 203d 205b 7820 666f 7220 7820  args = [x for x 
+0001e430: 696e 2061 7267 7320 6966 206e 6f74 2078  in args if not x
+0001e440: 2e69 735f 4669 6e69 7465 5365 745d 2020  .is_FiniteSet]  
+0001e450: 2020 2020 2020 0a20 2020 2020 2020 2061        .        a
+0001e460: 203d 205b 7820 666f 7220 7320 696e 2066   = [x for s in f
+0001e470: 696e 6974 655f 7365 7473 2066 6f72 2078  inite_sets for x
+0001e480: 2069 6e20 735d 0a20 2020 2020 2020 2069   in s].        i
+0001e490: 6620 613a 0a20 2020 2020 2020 2020 2020  f a:.           
+0001e4a0: 2066 726f 6d20 7379 6d70 7920 696d 706f   from sympy impo
+0001e4b0: 7274 2046 696e 6974 6553 6574 0a20 2020  rt FiniteSet.   
+0001e4c0: 2020 2020 2020 2020 2061 7267 732e 6170           args.ap
+0001e4d0: 7065 6e64 2846 696e 6974 6553 6574 282a  pend(FiniteSet(*
+0001e4e0: 6129 290a 2020 2020 2020 2020 656c 6966  a)).        elif
+0001e4f0: 206e 6f74 2061 7267 733a 0a20 2020 2020   not args:.     
+0001e500: 2020 2020 2020 2061 7267 7320 3d20 6669         args = fi
+0001e510: 6e69 7465 5f73 6574 735b 3a31 5d20 2020  nite_sets[:1]   
+0001e520: 2020 2020 2020 2020 200a 0a20 2020 2023           ..    #
+0001e530: 203d 3d3d 3d3d 2050 6169 722d 7769 7365   ===== Pair-wise
+0001e540: 2052 756c 6573 203d 3d3d 3d3d 0a20 2020   Rules =====.   
+0001e550: 2023 2048 6572 6520 7765 2064 6570 656e   # Here we depen
+0001e560: 6420 6f6e 2072 756c 6573 2062 7569 6c74  d on rules built
+0001e570: 2069 6e74 6f20 7468 6520 636f 6e73 7469   into the consti
+0001e580: 7475 656e 7420 7365 7473 0a20 2020 2061  tuent sets.    a
+0001e590: 7267 7320 3d20 7365 7428 6172 6773 290a  rgs = set(args).
+0001e5a0: 2020 2020 6e65 775f 6172 6773 203d 2054      new_args = T
+0001e5b0: 7275 650a 2020 2020 7768 696c 6520 6e65  rue.    while ne
+0001e5c0: 775f 6172 6773 3a0a 2020 2020 2020 2020  w_args:.        
+0001e5d0: 666f 7220 7320 696e 2061 7267 733a 0a20  for s in args:. 
+0001e5e0: 2020 2020 2020 2020 2020 206e 6577 5f61             new_a
+0001e5f0: 7267 7320 3d20 4661 6c73 650a 2020 2020  rgs = False.    
+0001e600: 2020 2020 2020 2020 666f 7220 7420 696e          for t in
+0001e610: 2061 7267 7320 2d20 7365 7428 2873 2c29   args - set((s,)
+0001e620: 293a 0a20 2020 2020 2020 2020 2020 2020  ):.             
+0001e630: 2020 206e 6577 5f73 6574 203d 2073 2e75     new_set = s.u
+0001e640: 6e69 6f6e 5f73 6574 7328 7429 0a20 2020  nion_sets(t).   
+0001e650: 2020 2020 2020 2020 2020 2020 2023 2054               # T
+0001e660: 6869 7320 7265 7475 726e 7320 4e6f 6e65  his returns None
+0001e670: 2069 6620 7320 646f 6573 206e 6f74 206b   if s does not k
+0001e680: 6e6f 7720 686f 7720 746f 2069 6e74 6572  now how to inter
+0001e690: 7365 6374 0a20 2020 2020 2020 2020 2020  sect.           
+0001e6a0: 2020 2020 2023 2077 6974 6820 742e 2052       # with t. R
+0001e6b0: 6574 7572 6e73 2074 6865 206e 6577 6c79  eturns the newly
+0001e6c0: 2069 6e74 6572 7365 6374 6564 2073 6574   intersected set
+0001e6d0: 206f 7468 6572 7769 7365 0a20 2020 2020   otherwise.     
+0001e6e0: 2020 2020 2020 2020 2020 2069 6620 6e65             if ne
+0001e6f0: 775f 7365 7420 6973 206e 6f74 204e 6f6e  w_set is not Non
+0001e700: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
+0001e710: 2020 2020 2020 2069 6620 6e6f 7420 6973         if not is
+0001e720: 696e 7374 616e 6365 286e 6577 5f73 6574  instance(new_set
+0001e730: 2c20 7365 7429 3a0a 2020 2020 2020 2020  , set):.        
+0001e740: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001e750: 6e65 775f 7365 7420 3d20 7365 7428 286e  new_set = set((n
+0001e760: 6577 5f73 6574 2c29 290a 2020 2020 2020  ew_set,)).      
+0001e770: 2020 2020 2020 2020 2020 2020 2020 6e65                ne
+0001e780: 775f 6172 6773 203d 2028 6172 6773 202d  w_args = (args -
+0001e790: 2073 6574 2828 732c 2074 2929 292e 756e   set((s, t))).un
+0001e7a0: 696f 6e28 6e65 775f 7365 7429 0a20 2020  ion(new_set).   
+0001e7b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001e7c0: 2062 7265 616b 0a20 2020 2020 2020 2020   break.         
+0001e7d0: 2020 2069 6620 6e65 775f 6172 6773 3a0a     if new_args:.
+0001e7e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001e7f0: 6172 6773 203d 206e 6577 5f61 7267 730a  args = new_args.
+0001e800: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001e810: 6272 6561 6b0a 0a20 2020 2069 6620 6c65  break..    if le
+0001e820: 6e28 6172 6773 2920 3d3d 2031 3a0a 2020  n(args) == 1:.  
+0001e830: 2020 2020 2020 7265 7475 726e 2061 7267        return arg
+0001e840: 732e 706f 7028 290a 2020 2020 656c 7365  s.pop().    else
+0001e850: 3a0a 2020 2020 2020 2020 7265 7475 726e  :.        return
+0001e860: 2055 6e69 6f6e 282a 6172 6773 2c20 6576   Union(*args, ev
+0001e870: 616c 7561 7465 3d46 616c 7365 290a 0a0a  aluate=False)...
+0001e880: 6465 6620 7369 6d70 6c69 6679 5f69 6e74  def simplify_int
+0001e890: 6572 7365 6374 696f 6e28 6172 6773 293a  ersection(args):
+0001e8a0: 0a20 2020 2022 2222 0a20 2020 2053 696d  .    """.    Sim
+0001e8b0: 706c 6966 7920 616e 2069 6e74 6572 7365  plify an interse
+0001e8c0: 6374 696f 6e20 7573 696e 6720 6b6e 6f77  ction using know
+0001e8d0: 6e20 7275 6c65 730a 0a20 2020 2057 6520  n rules..    We 
+0001e8e0: 6669 7273 7420 7374 6172 7420 7769 7468  first start with
+0001e8f0: 2067 6c6f 6261 6c20 7275 6c65 7320 6c69   global rules li
+0001e900: 6b65 0a20 2020 2027 6966 2061 6e79 2065  ke.    'if any e
+0001e910: 6d70 7479 2073 6574 7320 7265 7475 726e  mpty sets return
+0001e920: 2065 6d70 7479 2073 6574 2720 616e 6420   empty set' and 
+0001e930: 2764 6973 7472 6962 7574 6520 616e 7920  'distribute any 
+0001e940: 756e 696f 6e73 270a 0a20 2020 2054 6865  unions'..    The
+0001e950: 6e20 7765 2069 7465 7261 7465 2074 6872  n we iterate thr
+0001e960: 6f75 6768 2061 6c6c 2070 6169 7273 2061  ough all pairs a
+0001e970: 6e64 2061 736b 2074 6865 2063 6f6e 7374  nd ask the const
+0001e980: 6974 7565 6e74 2073 6574 7320 6966 2074  ituent sets if t
+0001e990: 6865 790a 2020 2020 6361 6e20 7369 6d70  hey.    can simp
+0001e9a0: 6c69 6679 2074 6865 6d73 656c 7665 7320  lify themselves 
+0001e9b0: 7769 7468 2061 6e79 206f 7468 6572 2063  with any other c
+0001e9c0: 6f6e 7374 6974 7565 6e74 0a20 2020 2022  onstituent.    "
+0001e9d0: 2222 0a0a 2020 2020 2320 3d3d 3d3d 3d20  ""..    # ===== 
+0001e9e0: 476c 6f62 616c 2052 756c 6573 203d 3d3d  Global Rules ===
+0001e9f0: 3d3d 0a20 2020 2069 6620 6e6f 7420 6172  ==.    if not ar
+0001ea00: 6773 3a0a 2020 2020 2020 2020 7072 696e  gs:.        prin
+0001ea10: 7428 2777 6172 6e69 6e67 3a20 556e 6976  t('warning: Univ
+0001ea20: 6572 7361 6c53 6574 2077 6974 686f 7574  ersalSet without
+0001ea30: 2065 7479 7065 2069 7320 7072 6f68 6962   etype is prohib
+0001ea40: 6974 6564 2127 290a 2020 2020 2020 2020  ited!').        
+0001ea50: 7265 7475 726e 2055 6e69 7665 7273 616c  return Universal
+0001ea60: 5365 7428 290a 2020 2020 2320 4966 2061  Set().    # If a
+0001ea70: 6e79 2045 6d70 7479 5365 7473 2072 6574  ny EmptySets ret
+0001ea80: 7572 6e20 456d 7074 7953 6574 0a20 2020  urn EmptySet.   
+0001ea90: 2066 6f72 2073 2069 6e20 6172 6773 3a0a   for s in args:.
+0001eaa0: 2020 2020 2020 2020 6966 206e 6f74 2073          if not s
+0001eab0: 2e69 735f 7365 743a 0a20 2020 2020 2020  .is_set:.       
+0001eac0: 2020 2020 2072 6169 7365 2054 7970 6545       raise TypeE
+0001ead0: 7272 6f72 2822 496e 7075 7420 6172 6773  rror("Input args
+0001eae0: 2074 6f20 556e 696f 6e20 6d75 7374 2062   to Union must b
+0001eaf0: 6520 5365 7473 2229 0a20 2020 2020 2020  e Sets").       
+0001eb00: 200a 2020 2020 2020 2020 6966 2073 2e69   .        if s.i
+0001eb10: 735f 456d 7074 7953 6574 3a0a 2020 2020  s_EmptySet:.    
+0001eb20: 2020 2020 2020 2020 7265 7475 726e 2073          return s
+0001eb30: 0a20 2020 2023 2048 616e 646c 6520 4669  .    # Handle Fi
+0001eb40: 6e69 7465 2073 6574 730a 2020 2020 7276  nite sets.    rv
+0001eb50: 203d 2049 6e74 6572 7365 6374 696f 6e2e   = Intersection.
+0001eb60: 5f68 616e 646c 655f 6669 6e69 7465 5f73  _handle_finite_s
+0001eb70: 6574 7328 6172 6773 290a 0a20 2020 2069  ets(args)..    i
+0001eb80: 6620 7276 2069 7320 6e6f 7420 4e6f 6e65  f rv is not None
+0001eb90: 3a0a 2020 2020 2020 2020 7265 7475 726e  :.        return
+0001eba0: 2072 760a 0a20 2020 2023 2049 6620 616e   rv..    # If an
+0001ebb0: 7920 6f66 2074 6865 2073 6574 7320 6172  y of the sets ar
+0001ebc0: 6520 756e 696f 6e73 2c20 7265 7475 726e  e unions, return
+0001ebd0: 2061 2055 6e69 6f6e 206f 6620 496e 7465   a Union of Inte
+0001ebe0: 7273 6563 7469 6f6e 730a 2020 2020 666f  rsections.    fo
+0001ebf0: 7220 7320 696e 2061 7267 733a 0a20 2020  r s in args:.   
+0001ec00: 2020 2020 2069 6620 732e 6973 5f55 6e69       if s.is_Uni
+0001ec10: 6f6e 3a0a 2020 2020 2020 2020 2020 2020  on:.            
+0001ec20: 6f74 6865 725f 7365 7473 203d 2073 6574  other_sets = set
+0001ec30: 2861 7267 7329 202d 2073 6574 2828 732c  (args) - set((s,
+0001ec40: 2929 0a20 2020 2020 2020 2020 2020 2069  )).            i
+0001ec50: 6620 6c65 6e28 6f74 6865 725f 7365 7473  f len(other_sets
+0001ec60: 2920 3e20 303a 0a20 2020 2020 2020 2020  ) > 0:.         
+0001ec70: 2020 2020 2020 206f 7468 6572 203d 2049         other = I
+0001ec80: 6e74 6572 7365 6374 696f 6e28 2a6f 7468  ntersection(*oth
+0001ec90: 6572 5f73 6574 7329 0a20 2020 2020 2020  er_sets).       
+0001eca0: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
+0001ecb0: 556e 696f 6e28 2a28 496e 7465 7273 6563  Union(*(Intersec
+0001ecc0: 7469 6f6e 2861 7267 2c20 6f74 6865 7229  tion(arg, other)
+0001ecd0: 2066 6f72 2061 7267 2069 6e20 732e 6172   for arg in s.ar
+0001ece0: 6773 2929 0a20 2020 2020 2020 2020 2020  gs)).           
+0001ecf0: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
+0001ed00: 2020 2020 2020 2072 6574 7572 6e20 556e         return Un
+0001ed10: 696f 6e28 2a5b 6172 6720 666f 7220 6172  ion(*[arg for ar
+0001ed20: 6720 696e 2073 2e61 7267 735d 290a 0a20  g in s.args]).. 
+0001ed30: 2020 2066 6f72 2073 2069 6e20 6172 6773     for s in args
+0001ed40: 3a0a 2020 2020 2020 2020 6966 2073 2e69  :.        if s.i
+0001ed50: 735f 436f 6d70 6c65 6d65 6e74 3a0a 2020  s_Complement:.  
+0001ed60: 2020 2020 2020 2020 2020 6172 6773 2e72            args.r
+0001ed70: 656d 6f76 6528 7329 0a20 2020 2020 2020  emove(s).       
+0001ed80: 2020 2020 206f 7468 6572 5f73 6574 7320       other_sets 
+0001ed90: 3d20 6172 6773 202b 205b 732e 6172 6773  = args + [s.args
+0001eda0: 5b30 5d5d 0a20 2020 2020 2020 2020 2020  [0]].           
+0001edb0: 2072 6574 7572 6e20 436f 6d70 6c65 6d65   return Compleme
+0001edc0: 6e74 2849 6e74 6572 7365 6374 696f 6e28  nt(Intersection(
+0001edd0: 2a6f 7468 6572 5f73 6574 7329 2c20 732e  *other_sets), s.
+0001ede0: 6172 6773 5b31 5d29 0a0a 0a0a 2020 2020  args[1])....    
+0001edf0: 2320 4174 2074 6869 7320 7374 6167 6520  # At this stage 
+0001ee00: 7765 2061 7265 2067 7561 7261 6e74 6565  we are guarantee
+0001ee10: 6420 6e6f 7420 746f 2068 6176 6520 616e  d not to have an
+0001ee20: 790a 2020 2020 2320 456d 7074 7953 6574  y.    # EmptySet
+0001ee30: 732c 2046 696e 6974 6553 6574 732c 206f  s, FiniteSets, o
+0001ee40: 7220 556e 696f 6e73 2069 6e20 7468 6520  r Unions in the 
+0001ee50: 696e 7465 7273 6563 7469 6f6e 0a0a 2020  intersection..  
+0001ee60: 2020 2320 3d3d 3d3d 3d20 5061 6972 2d77    # ===== Pair-w
+0001ee70: 6973 6520 5275 6c65 7320 3d3d 3d3d 3d0a  ise Rules =====.
+0001ee80: 2020 2020 2320 4865 7265 2077 6520 6465      # Here we de
+0001ee90: 7065 6e64 206f 6e20 7275 6c65 7320 6275  pend on rules bu
+0001eea0: 696c 7420 696e 746f 2074 6865 2063 6f6e  ilt into the con
+0001eeb0: 7374 6974 7565 6e74 2073 6574 730a 2020  stituent sets.  
+0001eec0: 2020 6172 6773 203d 2073 6574 2861 7267    args = set(arg
+0001eed0: 7329 0a20 2020 206e 6577 5f61 7267 7320  s).    new_args 
+0001eee0: 3d20 5472 7565 0a20 2020 2077 6869 6c65  = True.    while
+0001eef0: 206e 6577 5f61 7267 733a 0a20 2020 2020   new_args:.     
+0001ef00: 2020 2066 6f72 2073 2069 6e20 6172 6773     for s in args
+0001ef10: 3a0a 2020 2020 2020 2020 2020 2020 6e65  :.            ne
+0001ef20: 775f 6172 6773 203d 2046 616c 7365 0a20  w_args = False. 
+0001ef30: 2020 2020 2020 2020 2020 2066 6f72 2074             for t
+0001ef40: 2069 6e20 6172 6773 202d 2073 6574 2828   in args - set((
+0001ef50: 732c 2929 3a0a 2020 2020 2020 2020 2020  s,)):.          
+0001ef60: 2020 2020 2020 6e65 775f 7365 7420 3d20        new_set = 
+0001ef70: 732e 696e 7465 7273 6563 7469 6f6e 5f73  s.intersection_s
+0001ef80: 6574 7328 7429 0a20 2020 2020 2020 2020  ets(t).         
+0001ef90: 2020 2020 2020 2023 2054 6869 7320 7265         # This re
+0001efa0: 7475 726e 7320 4e6f 6e65 2069 6620 7320  turns None if s 
+0001efb0: 646f 6573 206e 6f74 206b 6e6f 7720 686f  does not know ho
+0001efc0: 7720 746f 2069 6e74 6572 7365 6374 0a20  w to intersect. 
+0001efd0: 2020 2020 2020 2020 2020 2020 2020 2023                 #
+0001efe0: 2077 6974 6820 742e 2052 6574 7572 6e73   with t. Returns
+0001eff0: 2074 6865 206e 6577 6c79 2069 6e74 6572   the newly inter
+0001f000: 7365 6374 6564 2073 6574 206f 7468 6572  sected set other
+0001f010: 7769 7365 0a0a 2020 2020 2020 2020 2020  wise..          
+0001f020: 2020 2020 2020 6966 206e 6577 5f73 6574        if new_set
+0001f030: 2069 7320 6e6f 7420 4e6f 6e65 3a0a 2020   is not None:.  
+0001f040: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001f050: 2020 6e65 775f 6172 6773 203d 2028 6172    new_args = (ar
+0001f060: 6773 202d 2073 6574 2828 732c 2074 2929  gs - set((s, t))
+0001f070: 292e 756e 696f 6e28 7365 7428 286e 6577  ).union(set((new
+0001f080: 5f73 6574 2c29 2929 0a20 2020 2020 2020  _set,))).       
+0001f090: 2020 2020 2020 2020 2020 2020 2062 7265               bre
+0001f0a0: 616b 0a20 2020 2020 2020 2020 2020 2069  ak.            i
+0001f0b0: 6620 6e65 775f 6172 6773 3a0a 2020 2020  f new_args:.    
+0001f0c0: 2020 2020 2020 2020 2020 2020 6172 6773              args
+0001f0d0: 203d 206e 6577 5f61 7267 730a 2020 2020   = new_args.    
+0001f0e0: 2020 2020 2020 2020 2020 2020 6272 6561              brea
+0001f0f0: 6b0a 0a20 2020 2069 6620 6c65 6e28 6172  k..    if len(ar
+0001f100: 6773 2920 3d3d 2031 3a0a 2020 2020 2020  gs) == 1:.      
+0001f110: 2020 7265 7475 726e 2061 7267 732e 706f    return args.po
+0001f120: 7028 290a 2020 2020 656c 7365 3a0a 2020  p().    else:.  
+0001f130: 2020 2020 2020 7265 7475 726e 2049 6e74        return Int
+0001f140: 6572 7365 6374 696f 6e28 2a61 7267 732c  ersection(*args,
+0001f150: 2065 7661 6c75 6174 653d 4661 6c73 6529   evaluate=False)
+0001f160: 0a0a 0a64 6566 205f 6861 6e64 6c65 5f66  ...def _handle_f
+0001f170: 696e 6974 655f 7365 7473 286f 702c 2078  inite_sets(op, x
+0001f180: 2c20 792c 2063 6f6d 6d75 7461 7469 7665  , y, commutative
+0001f190: 293a 0a20 2020 2023 2048 616e 646c 6520  ):.    # Handle 
+0001f1a0: 6669 6e69 7465 2073 6574 733a 0a20 2020  finite sets:.   
+0001f1b0: 2066 726f 6d20 7379 6d70 7920 696d 706f   from sympy impo
+0001f1c0: 7274 2046 696e 6974 6553 6574 0a20 2020  rt FiniteSet.   
+0001f1d0: 2066 735f 6172 6773 2c20 6f74 6865 7220   fs_args, other 
+0001f1e0: 3d20 7369 6674 285b 782c 2079 5d2c 206c  = sift([x, y], l
+0001f1f0: 616d 6264 6120 783a 2069 7369 6e73 7461  ambda x: isinsta
+0001f200: 6e63 6528 782c 2046 696e 6974 6553 6574  nce(x, FiniteSet
+0001f210: 292c 2062 696e 6172 793d 5472 7565 290a  ), binary=True).
+0001f220: 2020 2020 6966 206c 656e 2866 735f 6172      if len(fs_ar
+0001f230: 6773 2920 3d3d 2032 3a0a 2020 2020 2020  gs) == 2:.      
+0001f240: 2020 7265 7475 726e 2046 696e 6974 6553    return FiniteS
+0001f250: 6574 282a 5b6f 7028 692c 206a 2920 666f  et(*[op(i, j) fo
+0001f260: 7220 6920 696e 2066 735f 6172 6773 5b30  r i in fs_args[0
+0001f270: 5d20 666f 7220 6a20 696e 2066 735f 6172  ] for j in fs_ar
+0001f280: 6773 5b31 5d5d 290a 2020 2020 656c 6966  gs[1]]).    elif
+0001f290: 206c 656e 2866 735f 6172 6773 2920 3d3d   len(fs_args) ==
+0001f2a0: 2031 3a0a 2020 2020 2020 2020 7365 7473   1:.        sets
+0001f2b0: 203d 205b 5f61 7070 6c79 5f6f 7065 7261   = [_apply_opera
+0001f2c0: 7469 6f6e 286f 702c 206f 7468 6572 5b30  tion(op, other[0
+0001f2d0: 5d2c 2069 2c20 636f 6d6d 7574 6174 6976  ], i, commutativ
+0001f2e0: 6529 2066 6f72 2069 2069 6e20 6673 5f61  e) for i in fs_a
+0001f2f0: 7267 735b 305d 5d0a 2020 2020 2020 2020  rgs[0]].        
+0001f300: 7265 7475 726e 2055 6e69 6f6e 282a 7365  return Union(*se
+0001f310: 7473 290a 2020 2020 656c 7365 3a0a 2020  ts).    else:.  
+0001f320: 2020 2020 2020 7265 7475 726e 204e 6f6e        return Non
+0001f330: 650a 0a0a 6465 6620 5f61 7070 6c79 5f6f  e...def _apply_o
+0001f340: 7065 7261 7469 6f6e 286f 702c 2078 2c20  peration(op, x, 
+0001f350: 792c 2063 6f6d 6d75 7461 7469 7665 293a  y, commutative):
+0001f360: 0a20 2020 2066 726f 6d20 7379 6d70 792e  .    from sympy.
+0001f370: 7365 7473 2069 6d70 6f72 7420 496d 6167  sets import Imag
+0001f380: 6553 6574 0a20 2020 2066 726f 6d20 7379  eSet.    from sy
+0001f390: 6d70 7920 696d 706f 7274 2073 796d 626f  mpy import symbo
+0001f3a0: 6c73 2c20 4c61 6d62 6461 0a20 2020 2064  ls, Lambda.    d
+0001f3b0: 203d 2044 756d 6d79 2827 6427 290a 0a20   = Dummy('d').. 
+0001f3c0: 2020 206f 7574 203d 205f 6861 6e64 6c65     out = _handle
+0001f3d0: 5f66 696e 6974 655f 7365 7473 286f 702c  _finite_sets(op,
+0001f3e0: 2078 2c20 792c 2063 6f6d 6d75 7461 7469   x, y, commutati
+0001f3f0: 7665 290a 2020 2020 6966 206f 7574 2069  ve).    if out i
+0001f400: 7320 4e6f 6e65 3a0a 2020 2020 2020 2020  s None:.        
+0001f410: 6f75 7420 3d20 6f70 2878 2c20 7929 0a0a  out = op(x, y)..
+0001f420: 2020 2020 6966 206f 7574 2069 7320 4e6f      if out is No
+0001f430: 6e65 2061 6e64 2063 6f6d 6d75 7461 7469  ne and commutati
+0001f440: 7665 3a0a 2020 2020 2020 2020 6f75 7420  ve:.        out 
+0001f450: 3d20 6f70 2879 2c20 7829 0a20 2020 2069  = op(y, x).    i
+0001f460: 6620 6f75 7420 6973 204e 6f6e 653a 0a20  f out is None:. 
+0001f470: 2020 2020 2020 205f 782c 205f 7920 3d20         _x, _y = 
+0001f480: 7379 6d62 6f6c 7328 2278 2079 2229 0a20  symbols("x y"). 
+0001f490: 2020 2020 2020 2069 6620 782e 6973 5f73         if x.is_s
+0001f4a0: 6574 2061 6e64 206e 6f74 2079 2e69 735f  et and not y.is_
+0001f4b0: 7365 743a 0a20 2020 2020 2020 2020 2020  set:.           
+0001f4c0: 206f 7574 203d 2049 6d61 6765 5365 7428   out = ImageSet(
+0001f4d0: 4c61 6d62 6461 2864 2c20 6f70 2864 2c20  Lambda(d, op(d, 
+0001f4e0: 7929 292c 2078 292e 646f 6974 2829 0a20  y)), x).doit(). 
+0001f4f0: 2020 2020 2020 2065 6c69 6620 6e6f 7420         elif not 
+0001f500: 782e 6973 5f73 6574 2061 6e64 2079 2e69  x.is_set and y.i
+0001f510: 735f 7365 743a 0a20 2020 2020 2020 2020  s_set:.         
+0001f520: 2020 206f 7574 203d 2049 6d61 6765 5365     out = ImageSe
+0001f530: 7428 4c61 6d62 6461 2864 2c20 6f70 2878  t(Lambda(d, op(x
+0001f540: 2c20 6429 292c 2079 292e 646f 6974 2829  , d)), y).doit()
+0001f550: 0a20 2020 2020 2020 2065 6c73 653a 0a20  .        else:. 
+0001f560: 2020 2020 2020 2020 2020 206f 7574 203d             out =
+0001f570: 2049 6d61 6765 5365 7428 4c61 6d62 6461   ImageSet(Lambda
+0001f580: 2828 5f78 2c20 5f79 292c 206f 7028 5f78  ((_x, _y), op(_x
+0001f590: 2c20 5f79 2929 2c20 782c 2079 290a 2020  , _y)), x, y).  
+0001f5a0: 2020 7265 7475 726e 206f 7574 0a0a 0a64    return out...d
+0001f5b0: 6566 2073 6574 5f61 6464 2878 2c20 7929  ef set_add(x, y)
+0001f5c0: 3a0a 2020 2020 6672 6f6d 2073 796d 7079  :.    from sympy
+0001f5d0: 2e73 6574 732e 6861 6e64 6c65 7273 2e61  .sets.handlers.a
+0001f5e0: 6464 2069 6d70 6f72 7420 5f73 6574 5f61  dd import _set_a
+0001f5f0: 6464 0a20 2020 2072 6574 7572 6e20 5f61  dd.    return _a
+0001f600: 7070 6c79 5f6f 7065 7261 7469 6f6e 285f  pply_operation(_
+0001f610: 7365 745f 6164 642c 2078 2c20 792c 2063  set_add, x, y, c
+0001f620: 6f6d 6d75 7461 7469 7665 3d54 7275 6529  ommutative=True)
+0001f630: 0a0a 0a64 6566 2073 6574 5f73 7562 2878  ...def set_sub(x
+0001f640: 2c20 7929 3a0a 2020 2020 6672 6f6d 2073  , y):.    from s
+0001f650: 796d 7079 2e73 6574 732e 6861 6e64 6c65  ympy.sets.handle
+0001f660: 7273 2e61 6464 2069 6d70 6f72 7420 5f73  rs.add import _s
+0001f670: 6574 5f73 7562 0a20 2020 2072 6574 7572  et_sub.    retur
+0001f680: 6e20 5f61 7070 6c79 5f6f 7065 7261 7469  n _apply_operati
+0001f690: 6f6e 285f 7365 745f 7375 622c 2078 2c20  on(_set_sub, x, 
+0001f6a0: 792c 2063 6f6d 6d75 7461 7469 7665 3d46  y, commutative=F
+0001f6b0: 616c 7365 290a 0a0a 6465 6620 7365 745f  alse)...def set_
+0001f6c0: 6d75 6c28 782c 2079 293a 0a20 2020 2066  mul(x, y):.    f
+0001f6d0: 726f 6d20 7379 6d70 792e 7365 7473 2e68  rom sympy.sets.h
+0001f6e0: 616e 646c 6572 732e 6d75 6c20 696d 706f  andlers.mul impo
+0001f6f0: 7274 205f 7365 745f 6d75 6c0a 2020 2020  rt _set_mul.    
+0001f700: 7265 7475 726e 205f 6170 706c 795f 6f70  return _apply_op
+0001f710: 6572 6174 696f 6e28 5f73 6574 5f6d 756c  eration(_set_mul
+0001f720: 2c20 782c 2079 2c20 636f 6d6d 7574 6174  , x, y, commutat
+0001f730: 6976 653d 5472 7565 290a 0a0a 6465 6620  ive=True)...def 
+0001f740: 7365 745f 6469 7628 782c 2079 293a 0a20  set_div(x, y):. 
+0001f750: 2020 2066 726f 6d20 7379 6d70 792e 7365     from sympy.se
+0001f760: 7473 2e68 616e 646c 6572 732e 6d75 6c20  ts.handlers.mul 
+0001f770: 696d 706f 7274 205f 7365 745f 6469 760a  import _set_div.
+0001f780: 2020 2020 7265 7475 726e 205f 6170 706c      return _appl
+0001f790: 795f 6f70 6572 6174 696f 6e28 5f73 6574  y_operation(_set
+0001f7a0: 5f64 6976 2c20 782c 2079 2c20 636f 6d6d  _div, x, y, comm
+0001f7b0: 7574 6174 6976 653d 4661 6c73 6529 0a0a  utative=False)..
+0001f7c0: 0a64 6566 2073 6574 5f70 6f77 2878 2c20  .def set_pow(x, 
+0001f7d0: 7929 3a0a 2020 2020 6672 6f6d 2073 796d  y):.    from sym
+0001f7e0: 7079 2e73 6574 732e 6861 6e64 6c65 7273  py.sets.handlers
+0001f7f0: 2e70 6f77 6572 2069 6d70 6f72 7420 5f73  .power import _s
+0001f800: 6574 5f70 6f77 0a20 2020 2072 6574 7572  et_pow.    retur
+0001f810: 6e20 5f61 7070 6c79 5f6f 7065 7261 7469  n _apply_operati
+0001f820: 6f6e 285f 7365 745f 706f 772c 2078 2c20  on(_set_pow, x, 
+0001f830: 792c 2063 6f6d 6d75 7461 7469 7665 3d46  y, commutative=F
+0001f840: 616c 7365 290a 0a0a 6465 6620 7365 745f  alse)...def set_
+0001f850: 6675 6e63 7469 6f6e 2866 2c20 7829 3a0a  function(f, x):.
+0001f860: 2020 2020 6672 6f6d 2073 796d 7079 2e73      from sympy.s
+0001f870: 6574 732e 6861 6e64 6c65 7273 2e66 756e  ets.handlers.fun
+0001f880: 6374 696f 6e73 2069 6d70 6f72 7420 5f73  ctions import _s
+0001f890: 6574 5f66 756e 6374 696f 6e0a 2020 2020  et_function.    
+0001f8a0: 7265 7475 726e 205f 7365 745f 6675 6e63  return _set_func
+0001f8b0: 7469 6f6e 2866 2c20 7829 0a              tion(f, x).
```

### Comparing `sympy.keras-1.0.21/sympy/sets/subset.py` & `sympy.keras-1.0.4/sympy/sets/subset.py`

 * *Files 1% similar despite different names*

```diff
@@ -19,30 +19,30 @@
             _args = args
         return BinaryCondition.eval(cls, *args, **assumptions)
 
     def simplify(self, deep=False):
         if self.lhs.is_FiniteSet:
             eqs = []
             for e in self.lhs.args:
-                from sympy import Element
+                from sympy import Element                
                 eqs.append(Element(e, self.rhs))
             return And(*eqs)
 
         return self
 
     def _sympystr(self, p):
 #                 \N{SUBSET OF}
         return '%s \N{SUBSET OF OR EQUAL TO} %s' % tuple(p._print(x) for x in self.args)
     
     def _latex(self, printer):
         return r'%s \subset %s' % tuple(printer._print(x) for x in self.args)
 
     def _pretty(self, p):
         from sympy.printing.pretty.stringpict import prettyForm, stringPict
-        from sympy.printing.string import sstr
+        from sympy.printing.str import sstr
         
         var, s = self.args
         if p._use_unicode:
             el = u" \N{SUBSET OF OR EQUAL TO} "
             return prettyForm(*stringPict.next(p._print(var),
                                                el, p._print(s)), binding=8)
         else:
@@ -60,15 +60,15 @@
             return S.true
         ret = rhs._eval_Subset_reversed(lhs)
         if ret is not None:
             return ret
 
         ret = lhs._eval_Subset(rhs)
         if ret is not None:
-            return ret
+            return ret        
                 
     def as_set(self):
         return self
 
     @property
     def set(self):
         return self.args[1]
@@ -149,15 +149,15 @@
 
     @classmethod
     def simplify_ForAll(cls, self, function, *limits):
         if function.lhs.is_FiniteSet:
             function, S = function.lhs, function.rhs
             res = self.simplify_int_limits(function)
             if res:
-                function, limits = res
+                function, limits = res            
                 function = Subset(function, S).simplify()
                 return self.func(function, *limits).simplify()
 
 
 class NotSubset(BinaryCondition):
     """
     Asserts that A is a subset of the set S
@@ -180,24 +180,24 @@
         if self.lhs.is_FiniteSet and len(self.lhs) == 1:
             from sympy import NotElement
             return NotElement(self.lhs.arg, self.rhs).simplify()            
              
         return self
 
     def _sympystr(self, p):
-        #  NEITHER A SUBSET OF NOR EQUAL TO
+        #  NEITHER A SUBSET OF NOR EQUAL TO      
 #         \N{SUBSET OF WITH NOT EQUAL TO}
         return '%s \N{NOT A SUBSET OF} %s' % tuple(p._print(x) for x in self.args)
 
     def _latex(self, printer):
         return r'%s \not\subset %s' % tuple(printer._print(x) for x in self.args)
 
     def _pretty(self, p):
         from sympy.printing.pretty.stringpict import prettyForm, stringPict
-        from sympy.printing.string import sstr
+        from sympy.printing.str import sstr
         
         var, s = self.args
         if p._use_unicode:
             el = u" \N{NOT A SUBSET OF} "
             return prettyForm(*stringPict.next(p._print(var),
                                                el, p._print(s)), binding=8)
         else:
@@ -308,29 +308,29 @@
             
         return BinaryCondition.__and__(self, other)
     
     def simplify(self, deep=False):
         if self.rhs.is_FiniteSet:
             eqs = []
             for e in self.rhs.args:
-                from sympy import Element
+                from sympy import Element                
                 eqs.append(Element(e, self.lhs))
             return And(*eqs)
         return self
 
     def _sympystr(self, p):
 #         \N{SUPERSET OF}
         return '%s \N{SUPERSET OF OR EQUAL TO} %s' % tuple(p._print(x) for x in self.args)
 
     def _latex(self, printer):
         return r'%s\supset %s' % tuple(printer._print(x) for x in self.args)
 
     def _pretty(self, p):
         from sympy.printing.pretty.stringpict import prettyForm, stringPict
-        from sympy.printing.string import sstr
+        from sympy.printing.str import sstr
         
         var, s = self.args
         if p._use_unicode:
             el = u" \N{SUPERSET OF OR EQUAL TO} "
             return prettyForm(*stringPict.next(p._print(var),
                                                el, p._print(s)), binding=8)
         else:
@@ -417,15 +417,15 @@
         return '%s \N{NOT A SUPERSET OF} %s' % tuple(p._print(x) for x in self.args)
 
     def _latex(self, printer):
         return r'%s\not\supset %s' % tuple(printer._print(x) for x in self.args)
 
     def _pretty(self, p):
         from sympy.printing.pretty.stringpict import prettyForm, stringPict
-        from sympy.printing.string import sstr
+        from sympy.printing.str import sstr
         
         var, s = self.args
         if p._use_unicode:
             el = u" \N{NOT A SUPERSET OF} "
             return prettyForm(*stringPict.next(p._print(var),
                                                el, p._print(s)), binding=8)
         else:
```

### Comparing `sympy.keras-1.0.21/sympy/simplify/__init__.py` & `sympy.keras-1.0.4/sympy/simplify/__init__.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/simplify/combsimp.py` & `sympy.keras-1.0.4/sympy/simplify/combsimp.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/simplify/cse_main.py` & `sympy.keras-1.0.4/sympy/simplify/cse_main.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/simplify/cse_opts.py` & `sympy.keras-1.0.4/sympy/simplify/cse_opts.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/simplify/epathtools.py` & `sympy.keras-1.0.4/sympy/simplify/epathtools.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/simplify/fu.py` & `sympy.keras-1.0.4/sympy/simplify/fu.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/simplify/gammasimp.py` & `sympy.keras-1.0.4/sympy/simplify/gammasimp.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/simplify/hyperexpand.py` & `sympy.keras-1.0.4/sympy/simplify/hyperexpand.py`

 * *Files 0% similar despite different names*

```diff
@@ -248,30 +248,31 @@
         return besseli(a, x) + besselj(a, x)
 
     def fm(a, z):
         return besseli(a, x) - besselj(a, x)
 
     # TODO branching
     addb([], [S.Half, a, a + S.Half],
-         Matrix((fp(2*a - 1, z), fm(2*a, z)*z**(S(1)/4),
-                 fm(2*a - 1, z)*sqrt(z), fp(2*a, z)*z**(S(3)/4)))
+         Matrix([fp(2*a - 1, z), fm(2*a, z)*z**(S(1)/4),
+                 fm(2*a - 1, z)*sqrt(z), fp(2*a, z)*z**(S(3)/4)])
          * 2**(-2*a)*gamma(2*a)*z**((1 - 2*a)/4),
          Matrix([[1, 0, 0, 0]]),
          Matrix([[0, 1, 0, 0],
                  [0, S(1)/2 - a, 1, 0],
                  [0, 0, S(1)/2, 1],
                  [z, 0, 0, 1 - a]]))
     x = 2*(4*z)**(S(1)/4)*exp_polar(I*pi/4)
     addb([], [a, a + S.Half, 2*a],
-         Matrix((besselj(2*a - 1, x)*besseli(2*a - 1, x),
+         (2*sqrt(polar_lift(-1)*z))**(1 - 2*a)*gamma(2*a)**2 *
+         Matrix([besselj(2*a - 1, x)*besseli(2*a - 1, x),
                  x*(besseli(2*a, x)*besselj(2*a - 1, x)
                     - besseli(2*a - 1, x)*besselj(2*a, x)),
                  x**2*besseli(2*a, x)*besselj(2*a, x),
                  x**3*(besseli(2*a, x)*besselj(2*a - 1, x)
-                       + besseli(2*a - 1, x)*besselj(2*a, x)))) * (2*sqrt(polar_lift(-1)*z))**(1 - 2*a)*gamma(2*a)**2,
+                       + besseli(2*a - 1, x)*besselj(2*a, x))]),
          Matrix([[1, 0, 0, 0]]),
          Matrix([[0, S(1)/4, 0, 0],
                  [0, (1 - 2*a)/2, -S(1)/2, 0],
                  [0, 0, 1 - 2*a, S(1)/4],
                  [-32*z, 0, 0, 1 - a]]))
 
     # 1F2
@@ -281,18 +282,19 @@
                  *besseli(a - S(3)/2, sqrt(z)),
                  z**(S(3)/2 - a)*besseli(a - S(3)/2, sqrt(z))**2]),
          Matrix([[-gamma(a + S.Half)**2/4**(S.Half - a),
                  2*gamma(a - S.Half)*gamma(a + S.Half)/4**(1 - a),
                  0]]),
          Matrix([[1 - 2*a, 1, 0], [z/2, S.Half - a, S.Half], [0, z, 0]]))
     addb([S.Half], [b, 2 - b],
-         Matrix((besseli(1 - b, sqrt(z))*besseli(b - 1, sqrt(z)),
+         pi*(1 - b)/sin(pi*b)*
+         Matrix([besseli(1 - b, sqrt(z))*besseli(b - 1, sqrt(z)),
                  sqrt(z)*(besseli(-b, sqrt(z))*besseli(b - 1, sqrt(z))
                           + besseli(1 - b, sqrt(z))*besseli(b, sqrt(z))),
-                 besseli(-b, sqrt(z))*besseli(b, sqrt(z)))) * pi*(1 - b)/sin(pi*b),
+                 besseli(-b, sqrt(z))*besseli(b, sqrt(z))]),
          Matrix([[1, 0, 0]]),
          Matrix([[b - 1, S(1)/2, 0],
                  [z, 0, z],
                  [0, S(1)/2, -b]]))
     addb([S(1)/2], [S(3)/2, S(3)/2],
          Matrix([Shi(2*sqrt(z))/2/sqrt(z), sinh(2*sqrt(z))/2/sqrt(z),
                  cosh(2*sqrt(z))]),
@@ -336,18 +338,19 @@
                  [ 0,       z,      S(1)/2]]))
 
     # 2F3
     # XXX with this five-parameter formula is pretty slow with the current
     #     Formula.find_instantiations (creates 2!*3!*3**(2+3) ~ 3000
     #     instantiations ... But it's not too bad.
     addb([a, a + S.Half], [2*a, b, 2*a - b + 1],
-         Matrix((besseli(b - 1, sqrt(z))*besseli(2*a - b, sqrt(z)),
+         gamma(b)*gamma(2*a - b + 1) * (sqrt(z)/2)**(1 - 2*a) *
+         Matrix([besseli(b - 1, sqrt(z))*besseli(2*a - b, sqrt(z)),
                  sqrt(z)*besseli(b, sqrt(z))*besseli(2*a - b, sqrt(z)),
                  sqrt(z)*besseli(b - 1, sqrt(z))*besseli(2*a - b + 1, sqrt(z)),
-                 besseli(b, sqrt(z))*besseli(2*a - b + 1, sqrt(z)))) * gamma(b)*gamma(2*a - b + 1) * (sqrt(z)/2)**(1 - 2*a),
+                 besseli(b, sqrt(z))*besseli(2*a - b + 1, sqrt(z))]),
          Matrix([[1, 0, 0, 0]]),
          Matrix([[0, S(1)/2, S(1)/2, 0],
                  [z/2, 1 - b, 0, z/2],
                  [z/2, 0, b - 2*a, z/2],
                  [0, S(1)/2, S(1)/2, -2*a]]))
     # (C/f above comment about eulergamma in the basis).
     addb([1, 1], [2, 2, S(3)/2],
@@ -367,15 +370,15 @@
     # Basic rule
     # add([1, 1, a], [2, 2, a+1], (a/(z*(a-1)**2)) *
     #     (1 - (-z)**(1-a) * (gamma(a) - uppergamma(a,-z))
     #      - (a-1) * (EulerGamma + uppergamma(0,-z) + log(-z))
     #      - exp(z)))
     # Manually tuned rule
     addb([1, 1, a], [2, 2, a+1],
-         Matrix([a*(log(-z) + expint(1, -z) + S.EulerGamma)/(z*(a**2 - 2*a + 1)),
+         Matrix([a*(log(-z) + expint(1, -z) + EulerGamma)/(z*(a**2 - 2*a + 1)),
                  a*(-z)**(-a)*(gamma(a) - uppergamma(a, -z))/(a - 1)**2,
                  a*exp(z)/(a**2 - 2*a + 1),
                  a/(z*(a**2 - 2*a + 1))]),
          Matrix([[1-a, 1, -1/z, 1]]),
          Matrix([[-1,0,-1/z,1],
                  [0,-a,1,0],
                  [0,0,z,0],
@@ -701,19 +704,15 @@
         for _ in range(n):
             b.append(self.z*b[-1].diff(self.z))
 
         self.B = Matrix(b)
         self.C = Matrix([[1] + [0]*n])
 
         m = eye(n)
-        if m.is_Matrix:
-            m = m.col_insert(0, zeros(n, 1))
-        else:
-            m = Matrix((zeros(n, 1), m))
-            
+        m = m.col_insert(0, zeros(n, 1))
         l = poly.all_coeffs()[1:]
         l.reverse()
         self.M = m.row_insert(n, -Matrix([l])/poly.all_coeffs()[0])
 
     def __init__(self, func, z, res, symbols, B=None, C=None, M=None):
         z = sympify(z)
         res = sympify(res)
@@ -730,18 +729,15 @@
         #      (for prettier answers) to compute a basis only *after*
         #      instantiation
         if res is not None:
             self._compute_basis(res)
 
     @property
     def closed_form(self):
-        expr = self.C*self.B
-        if expr.shape:
-            return expr[0]
-        return expr
+        return (self.C*self.B)[0]
 
     def find_instantiations(self, func):
         """
         Find substitutions of the free symbols that match ``func``.
 
         Return the substitution dictionaries as a list. Note that the returned
         instantiations need not actually match, or be valid!
@@ -1976,26 +1972,20 @@
 
     def carryout_plan(f, ops):
         C = apply_operators(f.C.subs(f.z, z0), ops,
                             make_derivative_operator(f.M.subs(f.z, z0), z0))
         from sympy import eye
         C = apply_operators(C, ops0,
                             make_derivative_operator(f.M.subs(f.z, z0)
-                                         + prem*eye(f.M.shape[0] if f.M.shape else 1), z0))
+                                         + prem*eye(f.M.shape[0]), z0))
 
         if premult == 1:
-            if C.shape:
-                C = C.applyfunc(make_simp(z0))
-            else:
-                C = make_simp(z0)(C)
+            C = C.applyfunc(make_simp(z0))
         r = C*f.B.subs(f.z, z0)*premult
-        if r.shape:
-            res = r[0].subs(z0, z)
-        else:
-            res = r.subs(z0, z)
+        res = r[0].subs(z0, z)
         if rewrite:
             res = res.rewrite(rewrite)
         return res
 
     # TODO
     # The following would be possible:
     # *) PFD Duplication (see Kelly Roach's paper)
```

### Comparing `sympy.keras-1.0.21/sympy/simplify/powsimp.py` & `sympy.keras-1.0.4/sympy/simplify/powsimp.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/simplify/radsimp.py` & `sympy.keras-1.0.4/sympy/simplify/radsimp.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/simplify/ratsimp.py` & `sympy.keras-1.0.4/sympy/simplify/ratsimp.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/simplify/simplify.py` & `sympy.keras-1.0.4/sympy/simplify/simplify.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/simplify/sqrtdenest.py` & `sympy.keras-1.0.4/sympy/simplify/sqrtdenest.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/simplify/traversaltools.py` & `sympy.keras-1.0.4/sympy/simplify/traversaltools.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/simplify/trigsimp.py` & `sympy.keras-1.0.4/sympy/simplify/trigsimp.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/solvers/__init__.py` & `sympy.keras-1.0.4/sympy/solvers/__init__.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/solvers/bivariate.py` & `sympy.keras-1.0.4/sympy/solvers/bivariate.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/solvers/decompogen.py` & `sympy.keras-1.0.4/sympy/solvers/decompogen.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/solvers/deutils.py` & `sympy.keras-1.0.4/sympy/solvers/deutils.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/solvers/diophantine/diophantine.py` & `sympy.keras-1.0.4/sympy/solvers/diophantine/diophantine.py`

 * *Files 1% similar despite different names*

```diff
@@ -25,14 +25,19 @@
 from sympy.polys.polytools import Poly, factor_list
 from sympy.simplify.simplify import signsimp
 from sympy.solvers.solveset import solveset_real
 from sympy.utilities import default_sort_key, numbered_symbols
 from sympy.utilities.misc import filldedent
 
 
+
+# these are imported with 'from sympy.solvers.diophantine import *
+__all__ = ['diophantine', 'classify_diop']
+
+
 class DiophantineSolutionSet(set):
     """
     Container for a set of solutions to a particular diophantine equation.
 
     The base representation is a set of tuples representing each of the solutions.
 
     Parameters
```

### Comparing `sympy.keras-1.0.21/sympy/solvers/inequalities.py` & `sympy.keras-1.0.4/sympy/solvers/inequalities.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/solvers/ode/ode.py` & `sympy.keras-1.0.4/sympy/solvers/ode/ode.py`

 * *Files 0% similar despite different names*

```diff
@@ -3754,16 +3754,16 @@
     Matches any differential equation that can be rewritten with a smaller
     order. Only derivatives of ``func`` alone, wrt a single variable,
     are considered, and only in them should ``func`` appear.
     """
     # ODE only handles functions of 1 variable so this affirms that state
     assert len(func.args) == 1
     x = func.args[0]
-    vc = [d.limits[0] for d in eq.atoms(Derivative)
-          if d.expr == func and len(d.limits) == 1]
+    vc = [d.variable_count[0] for d in eq.atoms(Derivative)
+          if d.expr == func and len(d.variable_count) == 1]
     ords = [c for v, c in vc if v == x]
     if len(ords) < 2:
         return
     smallest = min(ords)
     # make sure func does not appear outside of derivatives
     D = Dummy()
     if eq.subs(func.diff(x, smallest), D).has(func):
```

### Comparing `sympy.keras-1.0.21/sympy/solvers/ode/single.py` & `sympy.keras-1.0.4/sympy/solvers/ode/single.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/solvers/ode/subscheck.py` & `sympy.keras-1.0.4/sympy/solvers/ode/subscheck.py`

 * *Files 0% similar despite different names*

```diff
@@ -35,15 +35,15 @@
     ... 1/(x*(z + 1/x)))
     x*(-1/(x**2*(z + 1/x)) + 1/(x**3*(z + 1/x)**2)) + 1/(x*(z + 1/x))
     ...- 1/(x**2*(z + 1/x)**2)
     """
     reps= {func: new}
     for d in eq.atoms(Derivative):
         if d.expr == func:
-            reps[d] = new.diff(*d.limits)
+            reps[d] = new.diff(*d.variable_count)
         else:
             reps[d] = d.xreplace({func: new}).doit(deep=False)
     return eq.xreplace(reps)
 
 
 def checkodesol(ode, sol, func=None, order='auto', solve_for_func=True):
     r"""
```

### Comparing `sympy.keras-1.0.21/sympy/solvers/ode/systems.py` & `sympy.keras-1.0.4/sympy/solvers/ode/systems.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/solvers/pde.py` & `sympy.keras-1.0.4/sympy/solvers/pde.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/solvers/polysys.py` & `sympy.keras-1.0.4/sympy/solvers/polysys.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/solvers/recurr.py` & `sympy.keras-1.0.4/sympy/solvers/recurr.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/solvers/solvers.py` & `sympy.keras-1.0.4/sympy/solvers/solvers.py`

 * *Files 0% similar despite different names*

```diff
@@ -1805,15 +1805,15 @@
             if n == 1:
                 poly, *_ = polys
                 for monom, coeff in polys[0].terms():
                     try:
                         j = monom.index(1)
                         matrix[j] = coeff
                     except ValueError:
-                        matrix[m] = -coeff
+                        matrix[m] = -coeff                
             else:                
                 for i, poly in enumerate(polys):
                     for monom, coeff in poly.terms():
                         try:
                             j = monom.index(1)
                             matrix[i, j] = coeff
                         except ValueError:
```

### Comparing `sympy.keras-1.0.21/sympy/solvers/solveset.py` & `sympy.keras-1.0.4/sympy/solvers/solveset.py`

 * *Files 1% similar despite different names*

```diff
@@ -662,15 +662,15 @@
             else:
                 result = ConditionSet(symbol, Eq(f, 0), domain)
     else:
         poly = Poly(f)
         if poly is None:
             result = ConditionSet(symbol, Eq(f, 0), domain)
         gens = [g for g in poly.gens if g.has(symbol)]
-        from sympy.sets.sets import conditionset
+
         if len(gens) == 1:
             poly = Poly(poly, gens[0])
             gen = poly.gen
             deg = poly.degree()
             poly = Poly(poly.as_expr(), poly.gen, composite=True)
             poly_solns = FiniteSet(*roots(poly, cubics=True, quartics=True,
                                           quintics=True).keys())
@@ -681,17 +681,17 @@
             if gen != symbol:
                 y = Dummy('y')
                 inverter = invert_real if domain.is_subset(Reals) else invert_complex
                 lhs, rhs_s = inverter(gen, y, symbol)
                 if lhs == symbol:
                     result = Union(*[rhs_s.subs(y, s) for s in poly_solns])
                 else:
-                    result = conditionset(symbol, Eq(f, 0), domain)
+                    result = ConditionSet(symbol, Eq(f, 0), domain)
         else:
-            result = conditionset(symbol, Eq(f, 0), domain)
+            result = ConditionSet(symbol, Eq(f, 0), domain)
 
     if result is not None:
         if isinstance(result, FiniteSet):
             # this is to simplify solutions like -sqrt(-I) to sqrt(2)/2
             # - sqrt(2)*I/2. We are not expanding for solution with symbols
             # or undefined functions because that makes the solution more complicated.
             # For example, expand_complex(a) returns re(a) + I*im(a)
```

### Comparing `sympy.keras-1.0.21/sympy/stats/compound_rv.py` & `sympy.keras-1.0.4/sympy/stats/compound_rv.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,9 +1,9 @@
 from sympy import Basic, Sum, Dummy, Lambda, Integral
-from sympy.stats.rv import (NamedArgsMixin, _symbol_converter,
+from sympy.stats.rv import (NamedArgsMixin, random_symbols, _symbol_converter,
                         PSpace, RandomSymbol, is_random)
 from sympy.stats.crv import ContinuousDistribution, SingleContinuousPSpace
 from sympy.stats.drv import DiscreteDistribution, SingleDiscretePSpace
 from sympy.stats.frv import SingleFiniteDistribution, SingleFinitePSpace
 from sympy.stats.crv_types import ContinuousDistributionHandmade
 from sympy.stats.drv_types import DiscreteDistributionHandmade
 from sympy.stats.frv_types import FiniteDistributionHandmade
@@ -209,11 +209,11 @@
     @classmethod
     def _compound_check(self, dist):
         """
         Checks if the given distribution contains random parameters.
         """
         randoms = []
         for arg in dist.args:
-            randoms.extend(arg.random_symbols)
+            randoms.extend(random_symbols(arg))
         if len(randoms) == 0:
             return False
         return True
```

### Comparing `sympy.keras-1.0.21/sympy/stats/crv.py` & `sympy.keras-1.0.4/sympy/stats/crv.py`

 * *Files 1% similar despite different names*

```diff
@@ -16,15 +16,15 @@
 from sympy.functions.special.delta_functions import DiracDelta
 from sympy.polys.polyerrors import PolynomialError
 from sympy.solvers.solveset import solveset
 from sympy.solvers.inequalities import reduce_rational_inequalities
 from sympy.core.sympify import _sympify
 from sympy.external import import_module
 from sympy.stats.rv import (RandomDomain, SingleDomain, ConditionalDomain, is_random,
-        ProductDomain, PSpace, SinglePSpace, NamedArgsMixin,
+        ProductDomain, PSpace, SinglePSpace, random_symbols, NamedArgsMixin,
     Distribution)
 
 
 class ContinuousDomain(RandomDomain):
     """
     A domain with continuous support
 
@@ -378,39 +378,39 @@
         """ Expectation of expression over distribution """
         if evaluate:
             try:
                 p = poly(expr, var)
                 t = Dummy('t', real=True)
                 mgf = self._moment_generating_function(t)
                 if mgf is None:
-                    return integrate(expr * self(var), (var, self.set), **kwargs)
+                    return integrate(expr * self.pdf(var), (var, self.set), **kwargs)
                 deg = p.degree()
                 taylor = poly(series(mgf, t, 0, deg + 1).removeO(), t)
                 result = 0
                 for k in range(deg + 1):
                     result += p.coeff_monomial(var ** k) * taylor.coeff_monomial(t ** k) * factorial(k)
                 return result
             except PolynomialError:
-                return integrate(expr * self(var), (var, self.set), **kwargs)
+                return integrate(expr * self.pdf(var), (var, self.set), **kwargs)
         else:
             if space is not None:
                 from sympy import Probability, Equal
                 return Integral(expr * Probability(Equal(space.value, var)), (var, self.set), **kwargs)            
-            return Integral(expr * self(var), (var, self.set), **kwargs)
+            return Integral(expr * self.pdf(var), (var, self.set), **kwargs)
 
     @cacheit
     def compute_quantile(self, **kwargs):
         """ Compute the Quantile from the PDF
 
         Returns a Lambda
         """
         x, p = symbols('x, p', real=True, cls=Dummy)
         left_bound = self.set.start
 
-        pdf = self(x)
+        pdf = self.pdf(x)
         cdf = integrate(pdf, (x, left_bound, x), **kwargs)
         quantile = solveset(cdf - p, x, self.set)
         return Lambda(p, Piecewise((quantile, (p >= 0) & (p <= 1)), (nan, True)))
 
     def _quantile(self, x):
         return None
 
@@ -543,15 +543,15 @@
             # return S.Zero if `domain` is empty set
             s = domain.set
             if s.is_EmptySet or s.is_FiniteSet:
                 if cond_inv:
                     return S.One
                 if pdf: 
                     if len(s) == 1:
-                        x, = s
+                        [x] = s             
                         return pdf(x)
                     else:
                         assert condition.is_Equal
                         y = condition.rhs
                         fy = sum(pdf(g) * abs(g.diff(y)) for g in s)
                         return fy
                     
@@ -577,15 +577,15 @@
                 dens = ContinuousDistributionHandmade(dens, set=self.domain.set)
             # Turn problem into univariate case
             space = SingleContinuousPSpace(z, dens)
             result = space.probability(condition.__class__(space.value, comp))
             return result if not cond_inv else S.One - result
 
     def where(self, condition):
-        rvs = frozenset(condition.random_symbols)
+        rvs = frozenset(random_symbols(condition))
         if not (len(rvs) == 1 and rvs.issubset(self.values)):
             raise NotImplementedError("Multiple continuous random variables not supported")
         rv = tuple(rvs)[0]
         interval = reduce_rational_inequalities_wrap(condition, rv)
         interval = interval.intersect(self.domain.set)
         from sympy import pspace
         return SingleContinuousDomain(pspace(rv).symbol, interval)
@@ -694,15 +694,15 @@
         else:
             return ContinuousPSpace.compute_quantile(self, expr, **kwargs)
 
 
 def _reduce_inequalities(conditions, var, **kwargs):
     try:
         return reduce_rational_inequalities(conditions, var, **kwargs)
-    except (PolynomialError, AssertionError):
+    except PolynomialError:
         raise ValueError("Reduction of condition failed %s\n" % conditions[0])
 
 
 def reduce_rational_inequalities_wrap(condition, var):
     if condition.is_Relational:
         return _reduce_inequalities([[condition]], var, relational=False)
     if isinstance(condition, Or):
```

### Comparing `sympy.keras-1.0.21/sympy/stats/crv_types.py` & `sympy.keras-1.0.4/sympy/stats/crv_types.py`

 * *Files 2% similar despite different names*

```diff
@@ -50,26 +50,82 @@
 UniformSum
 VonMises
 Wald
 Weibull
 WignerSemicircle
 """
 
+
+
 from sympy import beta as beta_fn
 from sympy import cos, sin, tan, atan, exp, besseli, besselj, besselk
 from sympy import (log, sqrt, pi, S, Dummy, Interval, sympify, gamma, sign,
                    Piecewise, And, Eq, binomial, factorial, Sum, floor, Abs,
                    Lambda, Basic, lowergamma, erf, erfc, erfi, erfinv, I, asin,
                    hyper, uppergamma, sinh, Ne, expint, Rational, integrate)
 from sympy.matrices import MatrixBase, MatrixExpr
 from sympy.stats.crv import SingleContinuousPSpace, SingleContinuousDistribution
 from sympy.stats.rv import _value_check, is_random
 
 oo = S.Infinity
 
+__all__ = ['ContinuousRV',
+'Arcsin',
+'Benini',
+'Beta',
+'BetaNoncentral',
+'BetaPrime',
+'BoundedPareto',
+'Cauchy',
+'Chi',
+'ChiNoncentral',
+'ChiSquared',
+'Dagum',
+'Erlang',
+'ExGaussian',
+'Exponential',
+'ExponentialPower',
+'FDistribution',
+'FisherZ',
+'Frechet',
+'Gamma',
+'GammaInverse',
+'Gompertz',
+'Gumbel',
+'Kumaraswamy',
+'Laplace',
+'Levy',
+'Logistic',
+'LogLogistic',
+'LogNormal',
+'Lomax',
+'Maxwell',
+'Moyal',
+'Nakagami',
+'Normal',
+'GaussianInverse',
+'Pareto',
+'PowerFunction',
+'QuadraticU',
+'RaisedCosine',
+'Rayleigh',
+'Reciprocal',
+'StudentT',
+'ShiftedGompertz',
+'Trapezoidal',
+'Triangular',
+'Uniform',
+'UniformSum',
+'VonMises',
+'Wald',
+'Weibull',
+'WignerSemicircle',
+]
+
+
 @is_random.register(MatrixBase)
 def _(x):
     return any([is_random(i) for i in x])
 
 def rv(symbol, cls, args):
     args = list(map(sympify, args))
     dist = cls(*args)
@@ -850,15 +906,15 @@
     @staticmethod
     def check(k):
         _value_check(k > 0, "Number of degrees of freedom (k) must be positive.")
         _value_check(k.is_integer, "Number of degrees of freedom (k) must be an integer.")
 
     domain = set = Interval(0, oo)
 
-    def __call__(self, x):
+    def pdf(self, x):
         k = self.k
         return 1/(2**(k/2)*gamma(k/2))*x**(k/2 - 1)*exp(-x/2)
 
     def _cdf(self, x):
         k = self.k
         return Piecewise(
                 (S.One/gamma(k/2)*lowergamma(k/2, x/2), x >= 0),
@@ -867,17 +923,14 @@
 
     def _characteristic_function(self, t):
         return (1 - 2*I*t)**(-self.k/2)
 
     def  _moment_generating_function(self, t):
         return (1 - 2*t)**(-self.k/2)
 
-    def _latex(self, p):
-        return r'\mathcal{X}^2%s' % p._print(self.args)
-
     
 def ChiSquared(name, k):
     r"""
     Create a continuous random variable with a Chi-squared distribution.
 
     The density of the Chi-squared distribution is given by
 
@@ -2790,50 +2843,40 @@
     return rv(name, NakagamiDistribution, (mu, omega))
 
 #-------------------------------------------------------------------------------
 # Normal distribution ----------------------------------------------------------
 
 
 class NormalDistribution(SingleContinuousDistribution):
-    _argnames = ('mean', 'sigma')
+    _argnames = ('mean', 'std')
     
     @staticmethod
-    def check(mean, sigma):
-        _value_check(sigma > 0, "Standard deviation must be positive")
+    def check(mean, std):
+        _value_check(std > 0, "Standard deviation must be positive")
 
-    def __call__(self, x):
-        sigma = self.sigma
-        mean = self.mean
-        if sigma.shape:
-            D, = mean.shape
-            return exp(-((x - mean) @ (sigma ^ -1) @ (x - mean)) / 2) / (sqrt((2 * pi) ** D * sigma.det()))
-        else:
-            return exp(-(x - mean) ** 2 / (2 * sigma)) / (sqrt(2 * pi * sigma))
+    def pdf(self, x):
+        return exp(-(x - self.mean)**2 / (2*self.std**2)) / (sqrt(2*pi)*self.std)
 
     def _cdf(self, x):
-        mean, sigma = self.mean, self.sigma
-        return erf(sqrt(2) * (-mean + x) / (2 * sqrt(sigma))) / 2 + S.Half
+        mean, std = self.mean, self.std
+        return erf(sqrt(2)*(-mean + x)/(2*std))/2 + S.Half
 
     def _characteristic_function(self, t):
-        mean, sigma = self.mean, self.sigma
-        return exp(I * mean * t - sigma * t ** 2 / 2)
+        mean, std = self.mean, self.std
+        return exp(I*mean*t - std**2*t**2/2)
 
     def _moment_generating_function(self, t):
-        mean, sigma = self.mean, self.sigma
-        return exp(mean * t + sigma * t ** 2 / 2)
+        mean, std = self.mean, self.std
+        return exp(mean*t + std**2*t**2/2)
 
     def _quantile(self, p):
-        mean, sigma = self.mean, self.sigma
-        return mean + sqrt(2 * sigma) * erfinv(2 * p - 1)
-
-    def _latex(self, p):
-        return r'\mathcal{N}%s' % p._print(self.args)
-
+        mean, std = self.mean, self.std
+        return mean + std*sqrt(2)*erfinv(2*p - 1)
 
-def Normal(name, mean, sigma):
+def Normal(name, mean, std):
     r"""
     Create a continuous random variable with a Normal distribution.
 
     The density of the Normal distribution is given by
 
     .. math::
         f(x) := \frac{1}{\sigma\sqrt{2\pi}} e^{ -\frac{(x-\mu)^2}{2\sigma^2} }
@@ -2909,18 +2952,18 @@
 
     .. [1] https://en.wikipedia.org/wiki/Normal_distribution
     .. [2] http://mathworld.wolfram.com/NormalDistributionFunction.html
 
     """
 
     if isinstance(mean, (list, MatrixBase, MatrixExpr)) and\
-        isinstance(sigma, (list, MatrixBase, MatrixExpr)):
+        isinstance(std, (list, MatrixBase, MatrixExpr)):
         from sympy.stats.joint_rv_types import MultivariateNormal
-        return MultivariateNormal(name, mean, sigma)
-    return rv(name, NormalDistribution, (mean, sigma))
+        return MultivariateNormal(name, mean, std)
+    return rv(name, NormalDistribution, (mean, std))
 
 
 #-------------------------------------------------------------------------------
 # Inverse Gaussian distribution ----------------------------------------------------------
 
 
 class GaussianInverseDistribution(SingleContinuousDistribution):
@@ -4275,22 +4318,34 @@
 
     return rv(name, WignerSemicircleDistribution, (R,))
 
 
 # an AbstractContinuousDistribution is a Continuous Distribution whose true probability density function is unevaluated!
 # we only know its expression composed of other known random variables;
 class AbstractContinuousDistribution(SingleContinuousDistribution):
-    def __new__(cls, *args):
-        return Basic.__new__(cls, *args)
+#     _argnames = ['expression', 'set']
+
+#     def __new__(cls, expression):
+#         expression = sympify(expression)
+#         if expression >= 0:
+#             st = Interval(0, oo)
+#         else:
+#             st = Interval(-oo, oo)
+#
+#         args = [expression, st]
+#
+#         obj = Basic.__new__(cls, *args)
+#
+#         return obj
 
     @property
     def expression(self):
         return self.args[0]
 
-    def __cal__(self, x):
+    def pdf(self, x):
         from sympy.stats.rv import PDF
         return PDF(self.expression)(x)
 
     @property
     def set(self):
         if self.expression >= 0:
             return Interval(0, oo)
```

### Comparing `sympy.keras-1.0.21/sympy/stats/drv.py` & `sympy.keras-1.0.4/sympy/stats/drv.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 from sympy import (Basic, sympify, symbols, Dummy, Lambda, summation,
                    Piecewise, S, cacheit, Sum, exp, I, Ne, Eq, poly,
                    series, factorial, And, lambdify)
 
 from sympy.polys.polyerrors import PolynomialError
 from sympy.stats.crv import reduce_rational_inequalities_wrap
 from sympy.stats.rv import (NamedArgsMixin, SinglePSpace, SingleDomain,
-                            PSpace, ConditionalDomain, RandomDomain,
+                            random_symbols, PSpace, ConditionalDomain, RandomDomain,
                             ProductDomain, Distribution)
 from sympy.stats.symbolic_probability import Probability
 from sympy.sets.fancysets import Range, FiniteSet
 from sympy.sets.sets import Union
 from sympy.sets.contains import Element
 from sympy.utilities import filldedent
 from sympy.core.sympify import _sympify
@@ -266,15 +266,38 @@
                 return quantile
         return self.compute_quantile(**kwargs)(x)
 
     def expectation(self, expr, var, evaluate=True, **kwargs):
         """ Expectation of expression over distribution """
         # TODO: support discrete sets with non integer stepsizes
 
-        return Sum[var:self.domain.min(): self.domain.max() + 1](expr * self(var)).doit(evaluate=evaluate)
+        return Sum[var:self.domain.min(): self.domain.max() + 1](expr * self.pdf(var)).doit(evaluate=evaluate)
+        if evaluate:
+            return Sum[var:self.domain.min(): self.domain.max() + 1](expr * self.pdf(var)).doit()
+            try:
+                p = poly(expr, var)
+
+                t = Dummy('t', real=True)
+
+                mgf = self.moment_generating_function(t)
+                deg = p.degree()
+                taylor = poly(series(mgf, t, 0, deg + 1).removeO(), t)
+                result = 0
+                for k in range(deg + 1):
+                    result += p.coeff_monomial(var ** k) * taylor.coeff_monomial(t ** k) * factorial(k)
+
+                return result
+
+            except PolynomialError:
+                return summation(expr * self.pdf(var),
+                                 (var, self.set.inf, self.set.sup), **kwargs)
+
+        else:
+            return Sum(expr * self.pdf(var),
+                         (var, self.set.inf, self.set.sup), **kwargs)
 
     def __call__(self, *args):
         return self.pdf(*args)
 
 
 class DiscreteDomain(RandomDomain):
     """
@@ -326,15 +349,15 @@
         return {self.symbol: self.value}
 
     @property
     def pdf(self):
         return self.density(*self.symbols)
 
     def where(self, condition):
-        rvs = condition.random_symbols
+        rvs = random_symbols(condition)
         assert all(r in self.values for r in rvs)
         if len(rvs) > 1:
             raise NotImplementedError(filldedent('''Multivariate discrete
             random variables are not yet supported.'''))
         conditional_domain = reduce_rational_inequalities_wrap(condition,
             rvs[0])
         conditional_domain = conditional_domain.intersect(self.domain.set)
```

### Comparing `sympy.keras-1.0.21/sympy/stats/drv_types.py` & `sympy.keras-1.0.4/sympy/stats/drv_types.py`

 * *Files 0% similar despite different names*

```diff
@@ -17,14 +17,24 @@
                    Lambda)
 from sympy.stats.drv import SingleDiscreteDistribution, SingleDiscretePSpace
 from sympy.stats.rv import _value_check, is_random
 from sympy.sets.sets import Interval
 from sympy.core.numbers import oo
 from sympy.sets import PositiveIntegers, NonnegativeIntegers, Integers
 
+__all__ = ['Geometric',
+'Hermite',
+'Logarithmic',
+'NegativeBinomial',
+'Poisson',
+'Skellam',
+'YuleSimon',
+'Zeta'
+]
+
 
 def rv(symbol, cls, *args):
     args = list(map(sympify, args))
     dist = cls(*args)
     dist.check(*args)
     pspace = SingleDiscretePSpace(symbol, dist)
     if any(is_random(arg) for arg in args):
@@ -483,15 +493,15 @@
         _value_check((n.is_integer, n.is_nonnegative),
                     "'n' must be nonnegative integer.")
         _value_check((p <= 1, p >= 0),
                     "p should be in range [0, 1].")
 
     @property
     def domain(self):
-        from sympy import Range
+        from sympy import Range  
         return Range(self.n + 1) 
 
     set = domain
     
     def pdf(self, k):
         return binomial(self.n, k) * self.p ** k * (1 - self.p) ** (self.n - k)
 
@@ -568,15 +578,15 @@
 
     @property
     def low(self):
         return S.One
 
     @property
     def set(self):    
-        from sympy import Range
+        from sympy import Range    
         return Range(1, self.sides + 1)
 
     domain = set
     
     def pdf(self, x):
         x = sympify(x)
         cond = (x >= 1) & (x <= self.sides)
@@ -828,15 +838,15 @@
 #             return SingleDiscreteDistribution.__new__(expr)
 #         return SingleDiscreteDistribution.__new__(cls, expr, domain)
 
     @property
     def expression(self):
         return self.args[0]
 
-    def __call__(self, x):
+    def pdf(self, x):
         from sympy.stats.rv import PDF
         if len(self.args) > 1:
             return self.expression(x)
         return PDF(self.expression)(x)
 
     @property
     def domain(self):
```

### Comparing `sympy.keras-1.0.21/sympy/stats/error_prop.py` & `sympy.keras-1.0.4/sympy/stats/error_prop.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/stats/frv.py` & `sympy.keras-1.0.4/sympy/stats/frv.py`

 * *Files 2% similar despite different names*

```diff
@@ -14,15 +14,15 @@
                    Sum, Intersection, S)
 from sympy.core.containers import Dict
 from sympy.core.logic import Logic
 from sympy.core.relational import Relational
 from sympy.core.sympify import _sympify
 from sympy.sets.sets import FiniteSet
 from sympy.stats.rv import (RandomDomain, ProductDomain, ConditionalDomain,
-                            PSpace, IndependentProductPSpace, SinglePSpace,
+                            PSpace, IndependentProductPSpace, SinglePSpace, random_symbols,
                             sumsets, rv_subs, NamedArgsMixin)
 from sympy.external import import_module
 
 
 class FiniteDensity(dict):
     """
     A domain with Finite Density.
@@ -243,15 +243,15 @@
         elem = sympify(elem)
         density = self._density
         if isinstance(list(density.keys())[0], FiniteSet):
             return density.get(elem, S.Zero)
         return density.get(tuple(elem)[0][1], S.Zero)
 
     def where(self, condition):
-        assert all(r.symbol in self.symbols for r in condition.random_symbols)
+        assert all(r.symbol in self.symbols for r in random_symbols(condition))
         return ConditionalFiniteDomain(self.domain, condition)
 
     def compute_density(self, expr):
         expr = rv_subs(expr, self.values)
         d = FiniteDensity()
         for elem in self.domain:
             val = expr.xreplace(dict(elem))
@@ -313,15 +313,15 @@
         p = Dummy('p', real=True)
         set = ((nan, (p < 0) | (p > 1)),)
         for key, value in cdf.items():
             set = set + ((key, p <= value), )
         return Lambda(p, Piecewise(*set))
 
     def probability(self, condition):
-        cond_symbols = frozenset(rs.symbol for rs in condition.random_symbols)
+        cond_symbols = frozenset(rs.symbol for rs in random_symbols(condition))
         cond = rv_subs(condition)
         if not cond_symbols.issubset(self.symbols):
             raise ValueError("Cannot compare foreign random symbols, %s"
                              %(str(cond_symbols - self.symbols)))
         if isinstance(condition, Relational) and \
             (not cond.free_symbols.issubset(self.domain.free_symbols)):
             rv = condition.lhs if isinstance(condition.rhs, Symbol) else condition.rhs
@@ -500,15 +500,15 @@
             "with symbolic dimension because the bounds of searching the required "
             "value is undetermined.")
         expr = rv_subs(expr, self.values)
         return FinitePSpace(self.domain, self.distribution).compute_quantile(expr)
 
     def compute_density(self, expr):
         if self._is_symbolic:
-            rv = expr.random_symbols[0]
+            rv = list(random_symbols(expr))[0]
             k = Dummy('k', integer=True)
             cond = True if not isinstance(expr, (Relational, Logic)) \
                      else expr.subs(rv, k)
             return Lambda(k,
             Piecewise((self.pmf(k), And(k >= self.args[1].low,
             k <= self.args[1].high, cond)), (S.Zero, True)))
         expr = rv_subs(expr, self.values)
@@ -521,15 +521,15 @@
             ki = Dummy('ki')
             return Lambda(k, Sum(d(ki), (ki, self.args[1].low, k)))
         expr = rv_subs(expr, self.values)
         return FinitePSpace(self.domain, self.distribution).compute_cdf(expr)
 
     def compute_expectation(self, expr, rvs=None, **kwargs):
         if self._is_symbolic:
-            rv = expr.random_symbols[0]
+            rv = random_symbols(expr)[0]
             k = Dummy('k', integer=True)
             expr = expr.subs(rv, k)
             cond = True if not isinstance(expr, (Relational, Logic)) \
                     else expr
             func = self.pmf(k) * k if cond != True else self.pmf(k) * expr
             return Sum(Piecewise((func, cond), (S.Zero, True)),
                 (k, self.distribution.low, self.distribution.high)).doit()
```

### Comparing `sympy.keras-1.0.21/sympy/stats/frv_types.py` & `sympy.keras-1.0.4/sympy/stats/frv_types.py`

 * *Files 1% similar despite different names*

```diff
@@ -20,14 +20,25 @@
                    Symbol, Lambda, Piecewise, Or, Gt, Lt, Ge, Le, Element)
 from sympy import beta as beta_fn
 from sympy.stats.frv import (SingleFiniteDistribution,
                              SingleFinitePSpace)
 from sympy.stats.rv import _value_check, PDF, is_random
 
 
+__all__ = ['FiniteRV',
+'DiscreteUniform',
+'Die',
+'Bernoulli',
+'Coin',
+'Binomial',
+'BetaBinomial',
+'Hypergeometric',
+'Rademacher'
+]
+
 def rv(name, cls, *args):
     args = list(map(sympify, args))
     dist = cls(*args)
     dist.check(*args)
     pspace = SingleFinitePSpace(name, dist)
     if any(is_random(arg) for arg in args):
         from sympy.stats.compound_rv import CompoundPSpace, CompoundDistribution
```

### Comparing `sympy.keras-1.0.21/sympy/stats/joint_rv.py` & `sympy.keras-1.0.4/sympy/stats/joint_rv.py`

 * *Files 2% similar despite different names*

```diff
@@ -17,18 +17,19 @@
 from sympy.core.compatibility import iterable
 from sympy.core.containers import Tuple
 from sympy.integrals.integrals import Integral, integrate
 from sympy.matrices import ImmutableMatrix, matrix2numpy, list2numpy
 from sympy.stats.crv import SingleContinuousDistribution, SingleContinuousPSpace
 from sympy.stats.drv import SingleDiscreteDistribution, SingleDiscretePSpace
 from sympy.stats.rv import (ProductPSpace, NamedArgsMixin,
-                            ProductDomain, RandomSymbol, SingleDomain, _symbol_converter)
+                            ProductDomain, RandomSymbol, random_symbols, SingleDomain, _symbol_converter)
 from sympy.utilities.misc import filldedent
 from sympy.external import import_module
 
+# __all__ = ['marginal_distribution']
 
 class JointPSpace(ProductPSpace):
     """
     Represents a joint probability space. Represented using symbols for
     each component and a distribution.
     """
     def __new__(cls, sym, dist):
@@ -67,15 +68,15 @@
     @property
     def pdf(self):
         sym = [Indexed(self.symbol, i) for i in range(self.component_count)]
         return self.distribution(*sym)
 
     @property
     def domain(self):
-        rvs = self.distribution.random_symbols
+        rvs = random_symbols(self.distribution)
         if not rvs:
             return SingleDomain(self.symbol, self.distribution.set)
         return ProductDomain(*[rv.pspace.domain for rv in rvs])
 
     def component_domain(self, index):
         return self.set.args[index]
 
@@ -108,15 +109,15 @@
             return expr
         expr = expr*self.pdf
         for rv in rvs:
             if isinstance(rv, Indexed):
                 expr = expr.xreplace({rv: Indexed(str(rv.base), rv.args[1])})
             elif isinstance(rv, RandomSymbol):
                 expr = expr.xreplace({rv: rv.symbol})
-        if self.value in expr.random_symbols:
+        if self.value in random_symbols(expr):
             raise NotImplementedError(filldedent('''
             Expectations of expression with unindexed joint random symbols
             cannot be calculated yet.'''))
         limits = tuple((Indexed(str(rv.base),rv.args[1]),
             self.distribution.set.args[rv.args[1]]) for rv in syms)
         return Integral(expr, *limits)
 
@@ -318,15 +319,15 @@
         if len(rvs) == 1 and iterable(rvs[0]):
             rvs = tuple(rvs[0])
         if not all([isinstance(rv, (Indexed, RandomSymbol))] for rv in rvs):
             raise ValueError(filldedent('''Marginal distribution can be
              intitialised only in terms of random variables or indexed random
              variables'''))
         rvs = Tuple.fromiter(rv for rv in rvs)
-        if not isinstance(dist, JointDistribution) and len(dist.random_symbols) == 0:
+        if not isinstance(dist, JointDistribution) and len(random_symbols(dist)) == 0:
             return dist
         return Basic.__new__(cls, dist, rvs)
 
     def check(self):
         pass
 
     @property
@@ -337,15 +338,15 @@
     @property
     def symbols(self):
         rvs = self.args[1]
         return {rv.pspace.symbol for rv in rvs}
 
     def pdf(self, *x):
         expr, rvs = self.args[0], self.args[1]
-        marginalise_out = [i for i in expr.random_symbols if i not in rvs]
+        marginalise_out = [i for i in random_symbols(expr) if i not in rvs]
         if isinstance(expr, JointDistribution):
             count = len(expr.domain.args)
             x = Dummy('x', real=True, finite=True)
             syms = tuple(Indexed(x, i) for i in count)
             expr = expr.pdf(syms)
         else:
             syms = tuple(rv.pspace.symbol if isinstance(rv, RandomSymbol) else rv.args[0] for rv in rvs)
```

### Comparing `sympy.keras-1.0.21/sympy/stats/joint_rv_types.py` & `sympy.keras-1.0.4/sympy/stats/joint_rv_types.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,15 +1,29 @@
 from sympy import (sympify, S, pi, sqrt, exp, Lambda, Indexed, besselk, gamma, Interval,
                    Range, factorial, Mul, Integer,
                    Add, rf, Eq, Piecewise, ones, Symbol, Pow, Rational, Sum,
                    Intersection, Matrix, symbols, Product, IndexedBase)
 from sympy.matrices import ImmutableMatrix, MatrixSymbol
 from sympy.matrices.expressions.determinant import det
 from sympy.stats.joint_rv import JointDistribution, JointPSpace, MarginalDistribution
-from sympy.stats.rv import _value_check
+from sympy.stats.rv import _value_check, random_symbols
+
+__all__ = ['JointRV',
+'MultivariateNormal',
+'MultivariateLaplace',
+'Dirichlet',
+'GeneralizedMultivariateLogGamma',
+'GeneralizedMultivariateLogGammaOmega',
+'Multinomial',
+'MultivariateBeta',
+'MultivariateEwens',
+'MultivariateT',
+'NegativeMultinomial',
+'NormalGamma'
+]
 
 def multivariate_rv(cls, sym, *args):
     args = list(map(sympify, args))
     dist = cls(*args)
     args = dist.args
     dist.check(*args)
     return JointPSpace(sym, dist).value
@@ -97,15 +111,15 @@
     syms = list(i for i in pdf.free_symbols if isinstance(i, Indexed)
         and i.base == IndexedBase(symbol))
     syms = tuple(sorted(syms, key = lambda index: index.args[1]))
     _set = Reals**len(syms)
     pdf = Lambda(syms, pdf)
     dist = JointDistributionHandmade(pdf, _set)
     jrv = JointPSpace(symbol, dist).value
-    rvs = pdf.random_symbols
+    rvs = random_symbols(pdf)
     if len(rvs) != 0:
         dist = MarginalDistribution(dist, (jrv,))
         return JointPSpace(symbol, dist).value
     return jrv
 
 #-------------------------------------------------------------------------------
 # Multivariate Normal distribution ---------------------------------------------
```

### Comparing `sympy.keras-1.0.21/sympy/stats/matrix_distributions.py` & `sympy.keras-1.0.4/sympy/stats/matrix_distributions.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/stats/random_matrix.py` & `sympy.keras-1.0.4/sympy/stats/random_matrix.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/stats/random_matrix_models.py` & `sympy.keras-1.0.4/sympy/stats/random_matrix_models.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,15 +1,28 @@
 from sympy import (Basic, exp, pi, Lambda, Trace, S, MatrixSymbol, Integral,
                    gamma, Product, Dummy, Sum, Abs, IndexedBase, I)
 from sympy.core.sympify import _sympify
-from sympy.stats.rv import _symbol_converter, RandomMatrixSymbol, is_random
+from sympy.stats.rv import _symbol_converter, PDF, RandomMatrixSymbol, is_random
 from sympy.stats.joint_rv_types import JointDistributionHandmade
 from sympy.stats.random_matrix import RandomMatrixPSpace
 from sympy.tensor.array import ArrayComprehension
 
+__all__ = [
+    'CircularEnsemble',
+    'CircularUnitaryEnsemble',
+    'CircularOrthogonalEnsemble',
+    'CircularSymplecticEnsemble',
+    'GaussianEnsemble',
+    'GaussianUnitaryEnsemble',
+    'GaussianOrthogonalEnsemble',
+    'GaussianSymplecticEnsemble',
+    'joint_eigen_distribution',
+    'JointEigenDistribution',
+    'level_spacing_distribution'
+]
 
 @is_random.register(RandomMatrixSymbol)
 def _(x):
     return True
 
 
 class RandomMatrixEnsembleModel(Basic):
```

### Comparing `sympy.keras-1.0.21/sympy/stats/rv.py` & `sympy.keras-1.0.4/sympy/stats/rv.py`

 * *Files 3% similar despite different names*

```diff
@@ -132,14 +132,16 @@
     ========
 
     sympy.stats.crv.ConditionalContinuousDomain
     sympy.stats.frv.ConditionalFiniteDomain
     """
 
     def __new__(cls, fulldomain, condition):
+#         condition = condition.xreplace({rs: rs.symbol
+#             for rs in random_symbols(condition)})
         return Basic.__new__(cls, fulldomain, condition)
 
     @property
     def symbols(self):
         return self.fulldomain.symbols
 
     @property
@@ -263,26 +265,14 @@
     def distribution(self):
         return self.args[1]
 
     @property
     def pdf(self):
         return self.distribution.pdf(self.symbol)
 
-    @cacheit
-    def sort_key(self, order=None):
-        def inner_key(arg):
-            if isinstance(arg, Basic):
-                return arg.sort_key(order)
-            else:
-                return arg
-
-        args = self._sorted_args
-        args = len(args), tuple(arg if arg is None else arg.class_key() for arg in args), tuple(inner_key(arg) for arg in args)
-        return self.class_key(), args, S.One.sort_key(), S.One
-
 
 class RandomSymbol(Expr):
     """
     Random Symbols represent ProbabilitySpaces in SymPy Expressions
     In principle they can take on any value that their symbol can take on
     within the associated PSpace with probability determined by the PSpace
     Density.
@@ -438,19 +428,28 @@
 #         for space in spaces:
 #             for value in space.values:
 #                 rs_space_dict[value] = space
 
         symbols = set().union(*[sp.symbols for sp in spaces])
 
         # Overlapping symbols
+        from sympy.stats.joint_rv import MarginalDistribution
+        from sympy.stats.compound_rv import CompoundDistribution
+        if len(symbols) < sum(len(space.symbols) for space in spaces if not
+         isinstance(space.distribution, (
+            CompoundDistribution, MarginalDistribution))):
+            raise ValueError("Overlapping Random Variables")
+
         if all(space.is_Finite for space in spaces):
             from sympy.stats.frv import ProductFinitePSpace
             cls = ProductFinitePSpace
 
-        return Basic.__new__(cls, *FiniteSet(*spaces))
+        obj = Basic.__new__(cls, *FiniteSet(*spaces))
+
+        return obj
 
     @property
     def pdf(self):
         p = Mul(*[space.pdf for space in self.spaces])
         return p.subs({rv: rv.symbol for rv in self.values})
 
     @property
@@ -503,15 +502,15 @@
             condition = Eq(condition.args[0], condition.args[1])
             cond_inv = True
         elif isinstance(condition, And):  # they are independent
             return Mul(*[self.probability(arg) for arg in condition.args])
         elif isinstance(condition, Or):  # they are independent
             return Add(*[self.probability(arg) for arg in condition.args])
         expr = condition.lhs - condition.rhs
-        rvs = expr.random_symbols
+        rvs = random_symbols(expr)
         dens = self.compute_density(expr)
         if any([pspace(rv).is_Continuous for rv in rvs]):
             from sympy.stats.crv import SingleContinuousPSpace
             from sympy.stats.crv_types import ContinuousDistributionHandmade
             if expr in self.values:
                 # Marginalize all other random symbols out of the density
                 randomsymbols = tuple(set(self.values) - frozenset([expr]))
@@ -528,35 +527,35 @@
             dens = DiscreteDistributionHandmade(dens)
             z = Dummy('z', integer=True)
             space = SingleDiscretePSpace(z, dens)
             result = space.probability(condition.__class__(space.value, 0))
         return result if not cond_inv else S.One - result
 
     def compute_density(self, expr, **kwargs):
-        rvs = expr.random_symbols
+        rvs = random_symbols(expr)
         
         reps = self.values2symbols()
         for var in rvs: 
             expr = expr._subs(var, reps[var])
 
-        assert not expr.random_symbols
+        assert not random_symbols(expr)
 
         if any(pspace(rv).is_Continuous for rv in rvs):
             z = Dummy('z', real=True)
             expr = self.compute_expectation(DiracDelta(expr - z), **kwargs)
         else:
             z = Dummy('z', integer=True)
             expr = self.compute_expectation(KroneckerDelta(expr, z), **kwargs)
         return Lambda(z, expr)
 
     def compute_cdf(self, expr, **kwargs):
         raise ValueError("CDF not well defined on multivariate expressions")
 
     def conditional_space(self, condition, normalize=True, **kwargs):
-        rvs = condition.random_symbols
+        rvs = random_symbols(condition)
         condition = condition.xreplace({rv: rv.symbol for rv in self.values})
         if any([pspace(rv).is_Continuous for rv in rvs]):
             from sympy.stats.crv import (ConditionalContinuousDomain,
                 ContinuousPSpace)
             space = ContinuousPSpace
             domain = ConditionalContinuousDomain(self.domain, condition)
         elif any([pspace(rv).is_Discrete for rv in rvs]):
@@ -646,14 +645,38 @@
         # All subevents passed
         return True
 
     def as_boolean(self):
         return And(*[domain.as_boolean() for domain in self.domains])
 
 
+def random_symbols(expr):
+    
+    """
+    Returns all RandomSymbols within a SymPy Expression.
+    """
+
+    def preorder_traversal(self):
+        if isinstance(self, Basic): 
+            if self.is_symbol:
+                if self.is_random:
+                    yield self
+            elif self.is_PDF:
+                ...
+            else:
+                if hasattr(self, '_argset'):
+                    args = self._argset
+                else:
+                    args = self.args
+    
+                for arg in args:
+                    yield from preorder_traversal(arg)
+                       
+    return [*preorder_traversal(expr)]
+
 
 def contain_random_symbols(expr):
     """
     Returns all RandomSymbols within a SymPy Expression.
     """
     from sympy.core.basic import preorder_traversal
     for ex in preorder_traversal(expr):
@@ -689,15 +712,15 @@
         if expr.is_integer:
             from sympy.stats.drv import SingleDiscretePSpace
             return SingleDiscretePSpace(expr)
         else:
             from sympy.stats.crv import SingleContinuousPSpace
             return SingleContinuousPSpace(expr)
 
-    rvs = expr.random_symbols
+    rvs = random_symbols(expr)
     if not rvs:
         raise ValueError("Expression containing Random Variable expected, not %s" % (expr))
     # If only one space present
     pspaces = {pspace(rv) for rv in rvs}
     if len(pspaces) == 1:
         ps, *_ = pspaces
         return ps
@@ -781,14 +804,41 @@
     if not condition.is_random or pspace_independent(expr, condition):
         return expr
 
 #     if isinstance(condition, RandomSymbol):
     if condition.is_symbol:
         condition = Eq(condition, pspace(condition).symbol)
 
+#     condsymbols = random_symbols(condition)
+#     if condition.is_Equal and len(condsymbols) == 1 and not isinstance(pspace(expr).domain, ConditionalDomain):
+#         rv = tuple(condsymbols)[0]
+# 
+#         results = solveset(condition, rv)
+#         if isinstance(results, Intersection) and Reals in results.args:
+#             results = list(results.args[1])
+# 
+#         sums = 0
+#         for res in results:
+#             temp = expr.subs(rv, res)
+#             if temp == True:
+#                 return True
+#             if temp != False:
+#                 # XXX: This seems nonsensical but preserves existing behaviour
+#                 # after the change that Relational is no longer a subclass of
+#                 # Expr. Here expr is sometimes Relational and sometimes Expr
+#                 # but we are trying to add them with +=. This needs to be
+#                 # fixed somehow.
+#                 if sums == 0 and isinstance(expr, Relational):
+#                     sums = expr.subs(rv, res)
+#                 else:
+#                     sums += expr.subs(rv, res)
+#         if sums == 0:
+#             return False
+#         return sums
+
     # Get full probability space of both the expression and the condition
     fullspace = pspace(Tuple(expr, condition))
     # Build new space given the condition
     if fullspace.distribution:
         symbols2values = fullspace.conditional_space(condition, **kwargs)
         # Dictionary to swap out RandomSymbols in expr with new RandomSymbols
         # That point to the new conditional space
@@ -909,15 +959,15 @@
         expr, condition = self.expr, self.condition
 
         if isinstance(expr, SingleFiniteDistribution):
             return expr.dict
         if condition is not None:
             # Recompute on new conditional expr
             expr = given(expr, condition, **kwargs)
-        if not expr.random_symbols:
+        if not random_symbols(expr):
             x = Symbol('x', real=True)
             return Lambda(x, DiracDelta(x - expr))
         ps = pspace(expr)
         if expr.is_Symbol or expr.is_Indexed:
             if isinstance(ps, (SinglePSpace, JointPSpace, MatrixPSpace)) and \
                 hasattr(ps, 'distribution'):
                 return ps.distribution
@@ -1520,33 +1570,33 @@
 
     pspace_independent(a, b) implies independent(a, b)
     independent(a, b) does not imply pspace_independent(a, b)
     """
     pspace_a = pspace(a)
     pspace_b = pspace(b)
     if pspace_a.distribution is None or pspace_b.distribution is None:
-        return
+        return 
     a_symbols = set(pspace_a.symbols)
     b_symbols = set(pspace_b.symbols)
 
-    if len(set(a.random_symbols).intersection(b.random_symbols)) != 0:
+    if len(set(random_symbols(a)).intersection(random_symbols(b))) != 0:
         return False
 
     if len(a_symbols.intersection(b_symbols)) == 0:
         return True
 
 
 def rv_subs(expr, symbols=None):
     """
     Given a random expression replace all random variables with their symbols.
 
     If symbols keyword is given restrict the swap to only the symbols listed.
     """
     if symbols is None:
-        symbols = expr.random_symbols
+        symbols = random_symbols(expr)
     if not symbols:
         return expr
     swapdict = {rv: rv.symbol for rv in symbols}
     return expr.subs(swapdict)
 
 
 class NamedArgsMixin:
@@ -1708,14 +1758,12 @@
 class Distribution(Basic):
 
     def __call__(self, *args):
         return self.pdf(*args)
     
     @property
     def type(self):
-        return dtype.distribution
+        return dtype.distribution   
 
     def _latex(self, p):
         name = self.func.__name__[:-len('Distribution')]
         return name + p._print(self.args)
-    
-    is_distribution = True
```

### Comparing `sympy.keras-1.0.21/sympy/stats/rv_interface.py` & `sympy.keras-1.0.4/sympy/stats/rv_interface.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,16 +1,24 @@
 from sympy.sets import FiniteSet
 from sympy import (sqrt, log, exp, FallingFactorial, Rational, Eq, Dummy,
                 piecewise_fold, solveset, Integral)
 from .rv import (probability, expectation, density, where, given, pspace, cdf, PSpace,
-                 characteristic_function, sample, sample_iter, independent, dependent,
+                 characteristic_function, sample, sample_iter, random_symbols, independent, dependent,
                  sampling_density, moment_generating_function, quantile, is_random,
                  sample_stochastic_process)
 
 
+__all__ = ['P', 'E', 'H', 'density', 'where', 'given', 'sample', 'cdf',
+        'characteristic_function', 'pspace', 'sample_iter', 'variance', 'std',
+        'skewness', 'kurtosis', 'covariance', 'dependent', 'entropy', 'median',
+        'independent', 'random_symbols', 'correlation', 'factorial_moment',
+        'moment', 'cmoment', 'sampling_density', 'moment_generating_function',
+        'smoment', 'quantile', 'sample_stochastic_process']
+
+
 
 def moment(X, n, c=0, condition=None, *, evaluate=True, **kwargs):
     """
     Return the nth moment of a random expression about c.
 
     .. math::
         moment(X, c, n) = E((X-c)^{n})
```

### Comparing `sympy.keras-1.0.21/sympy/stats/stochastic_process.py` & `sympy.keras-1.0.4/sympy/stats/stochastic_process.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/stats/stochastic_process_types.py` & `sympy.keras-1.0.4/sympy/stats/stochastic_process_types.py`

 * *Files 0% similar despite different names*

```diff
@@ -11,26 +11,40 @@
                    Ge, Piecewise, Symbol, NonSquareMatrixError, EmptySet,
                    ceiling, MatrixBase)
 from sympy.core.relational import Relational
 from sympy.logic.boolalg import Boolean
 from sympy.utilities.exceptions import SymPyDeprecationWarning
 from sympy.stats.joint_rv import JointDistribution
 from sympy.stats.joint_rv_types import JointDistributionHandmade
-from sympy.stats.rv import (RandomIndexedSymbol, RandomSymbol,
+from sympy.stats.rv import (RandomIndexedSymbol, random_symbols, RandomSymbol,
                             _symbol_converter, _value_check, pspace, given,
                            dependent, is_random, sample_iter)
 from sympy.stats.stochastic_process import StochasticPSpace
 from sympy.stats.symbolic_probability import Probability, Expectation
 from sympy.stats.frv_types import Bernoulli, BernoulliDistribution, FiniteRV
 from sympy.stats.drv_types import Poisson, PoissonDistribution
 from sympy.stats.crv_types import Normal, NormalDistribution, Gamma, GammaDistribution
 from sympy.core.sympify import _sympify, sympify
 from sympy.sets import NonnegativeIntegers
 from sympy.sets.fancysets import Reals
 
+__all__ = [
+    'StochasticProcess',
+    'DiscreteTimeStochasticProcess',
+    'DiscreteMarkovChain',
+    'TransitionMatrixOf',
+    'StochasticStateSpaceOf',
+    'GeneratorMatrixOf',
+    'ContinuousMarkovChain',
+    'BernoulliProcess',
+    'PoissonProcess',
+    'WienerProcess',
+    'GammaProcess'
+]
+
 
 @is_random.register(Indexed)
 def _(x):
     return is_random(x.base)
 
 @is_random.register(RandomIndexedSymbol)  # type: ignore
 def _(x):
@@ -647,15 +661,15 @@
 
         check, mat, state_index, condition = \
             self._preprocess(condition, evaluate)
 
         if check:
             return Expectation(expr, condition)
 
-        rvs = expr.random_symbols
+        rvs = random_symbols(expr)
         if isinstance(expr, Expr) and isinstance(condition, Eq) \
             and len(rvs) == 1:
             # handle queries similar to E(f(X[i]), Eq(X[i-m], <some-state>))
             condition=self.replace_with_index(condition)
             state_index=self.replace_with_index(state_index)
             rv = list(rvs)[0]
             lhsg, rhsg = condition.lhs, condition.rhs
@@ -1160,23 +1174,23 @@
             Condition for which expectation has to be computed. Must
             contain a RandomIndexedSymbol of the process.
         condition: Relational, Logic
             The given conditions under which computations should be done.
 
         """
 
-        rvs_expr = expr.random_symbols
+        rvs_expr = random_symbols(expr)
         if len(rvs_expr) != 0:
             swapdict_expr = {}
             for rv in rvs_expr:
                 if isinstance(rv, RandomIndexedSymbol):
                     newrv = rv.pspace.process.simple_rv(rv) # substitute with equivalent simple rv
                     swapdict_expr[rv] = newrv
             expr = expr.subs(swapdict_expr)
-        rvs_cond = condition.random_symbols
+        rvs_cond = random_symbols(condition)
         if len(rvs_cond)!=0:
             swapdict_cond = {}
             for rv in rvs_cond:
                 if isinstance(rv, RandomIndexedSymbol):
                     newrv = rv.pspace.process.simple_rv(rv)
                     swapdict_cond[rv] = newrv
             condition = condition.subs(swapdict_cond)
@@ -1235,15 +1249,15 @@
 
         Probability of the condition.
 
         """
         new_condition, new_givencondition = self._rvindexed_subs(condition, given_condition)
 
         if isinstance(new_givencondition, RandomSymbol):
-            condrv = new_condition.random_symbols
+            condrv = random_symbols(new_condition)
             if len(condrv) == 1 and condrv[0] == new_givencondition:
                 return BernoulliDistribution(self._probability(new_condition), 0, 1)
 
             if any([dependent(rv, new_givencondition) for rv in condrv]):
                 return Probability(new_condition, new_givencondition)
             else:
                 return self._probability(new_condition)
```

### Comparing `sympy.keras-1.0.21/sympy/stats/symbolic_multivariate_probability.py` & `sympy.keras-1.0.4/sympy/stats/symbolic_multivariate_probability.py`

 * *Files 2% similar despite different names*

```diff
@@ -3,15 +3,15 @@
 from sympy import (MatrixExpr, Expr, ShapeError, ZeroMatrix,
                     Add, Mul, MatMul, S, expand as _expand)
 from sympy.stats.rv import RandomSymbol, is_random
 from sympy.core.sympify import _sympify
 from sympy.stats.symbolic_probability import Variance, Covariance, Expectation
 
 
-class ExpectationMatrix(MatrixExpr):
+class ExpectationMatrix(Expectation, MatrixExpr):
     """
     Expectation of a random matrix expression.
 
     Examples
     ========
 
     >>> from sympy.stats import ExpectationMatrix, Normal
@@ -101,16 +101,15 @@
             if len(nonrv) == 0:
                 return self
             return Mul.fromiter(nonrv)*Expectation(Mul.fromiter(rv),
                     condition=condition)*Mul.fromiter(postnon)
 
         return self
 
-
-class VarianceMatrix(MatrixExpr):
+class VarianceMatrix(Variance, MatrixExpr):
     """
     Variance of a random matrix probability expression. Also known as
     Covariance matrix, auto-covariance matrix, dispersion matrix,
     or variance-covariance matrix
 
     Examples
     ========
@@ -189,16 +188,15 @@
                 return self
             return Mul.fromiter(nonrv)*Variance(Mul.fromiter(rv),
                             condition)*(Mul.fromiter(nonrv)).transpose()
 
         # this expression contains a RandomSymbol somehow:
         return self
 
-
-class CrossCovarianceMatrix(MatrixExpr):
+class CrossCovarianceMatrix(Covariance, MatrixExpr):
     """
     Covariance of a random matrix probability expression.
 
     Examples
     ========
 
     >>> from sympy.stats import CrossCovarianceMatrix
```

### Comparing `sympy.keras-1.0.21/sympy/stats/symbolic_probability.py` & `sympy.keras-1.0.4/sympy/sets/fancysets.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,1925 +1,1882 @@
-import itertools
-
-from sympy import (Expr, Add, Mul, S, Integral, Eq, Sum, Symbol,
-                    expand as _expand, Not)
-from sympy.core.compatibility import default_sort_key
-from sympy.core.parameters import global_parameters
-from sympy.core.sympify import _sympify
-from sympy.core.relational import Equal, Unequal
-from sympy.logic.boolalg import BinaryCondition, And
-from sympy.stats import variance, covariance, rv
-from sympy.stats.rv import (RandomSymbol, pspace, dependent,
-                            given, sampling_E, RandomIndexedSymbol, is_random,
-                            PSpace, sampling_P)
-from sympy.concrete.expr_with_limits import ExprWithLimits
+from sympy.core.basic import Basic
+from sympy.core.expr import Expr
+from sympy.core.singleton import S, Singleton
+from sympy.core.symbol import Dummy, symbols, dtype
+from sympy.core.sympify import _sympify, sympify, converter
+from sympy.logic.boolalg import And
+from sympy.sets.sets import Set, Interval, Union, FiniteSet
+from sympy.utilities.misc import filldedent
+from sympy.core.logic import fuzzy_or, fuzzy_and
+from sympy.sets.sets import ProductSet
 from sympy.core.cache import cacheit
-from sympy.core.expr import AtomicExpr
-from sympy.core.containers import Tuple
-from _collections import defaultdict
-import std
-from sympy.core.logic import fuzzy_et
-
 
-@is_random.register(Expr)
-def _(x):
-    atoms = x.free_symbols
-    if len(atoms) == 1 and x in atoms:
-        return False
-    return any([is_random(i) for i in atoms])
+Reals = Interval(S.NegativeInfinity, S.Infinity)
+ExtendedReals = Interval(S.NegativeInfinity, S.Infinity, left_open=False, right_open=False)
 
 
-@is_random.register(RandomSymbol)  # type: ignore
-def _(x):
-    return True
+class ImageSet(Set):
+    """
+    Image of a set under a mathematical function. The transformation
+    must be given as a Lambda function which has as many arguments
+    as the elements of the set upon which it operates, e.g. 1 argument
+    when acting on the set of integers or 2 arguments when acting on
+    a complex region.
 
+    This function is not normally called directly, but is called
+    from `imageset`.
 
-class Distributed(BinaryCondition):
-    """
-    Asserts that x is a random expression/symbol under the distribution S
-    """
 
-    def __new__(cls, x, s, **assumptions):
-        return BinaryCondition.eval(cls, x, s, **assumptions)
+    Examples
+    ========
 
-    def subs(self, *args, **kwargs):
-        if len(args) == 1:
-            eq, *_ = args
-            if eq.is_Equal:
-                args = eq.args
-                return self.func(self.lhs._subs(*args, **kwargs).simplify(), self.rhs._subs(*args, **kwargs).simplify(), equivalent=[self, eq]).simplify()
-            if isinstance(eq, dict):
-                return self
-            if eq.is_Quantifier:
-                return self.bfn(self.subs, eq)
-        return BinaryCondition.subs(self, *args, **kwargs)
+    >>> from sympy import Symbol, S, pi, Dummy, Lambda
+    >>> from sympy.sets.sets import FiniteSet, Interval
+    >>> from sympy.sets.fancysets import ImageSet
+
+    >>> x = Symbol('x')
+    >>> N = S.Naturals
+    >>> squares = ImageSet(Lambda(x, x**2), N) # {x**2 for x in N}
+    >>> 4 in squares
+    True
+    >>> 5 in squares
+    False
+
+    >>> FiniteSet(0, 1, 2, 3, 4, 5, 6, 7, 9, 10).intersect(squares)
+    {1, 4, 9}
+
+    >>> square_iterable = iter(squares)
+    >>> for i in range(4):
+    ...     next(square_iterable)
+    1
+    4
+    9
+    16
+
+    If you want to get value for `x` = 2, 1/2 etc. (Please check whether the
+    `x` value is in `base_set` or not before passing it as args)
+
+    >>> squares.lamda(2)
+    4
+    >>> squares.lamda(S(1)/2)
+    1/4
+
+    >>> n = Dummy('n')
+    >>> solutions = ImageSet(Lambda(n, n*pi), S.Integers) # solutions of sin(x) = 0
+    >>> dom = Interval(-1, 1)
+    >>> dom.intersect(solutions)
+    {0}
 
-    def _latex(self, p):
-        return r"%s\ {\color{blue}{\sim}}\ %s" % tuple(p._print(a) for a in self.args)
+    See Also
+    ========
 
-    def _sympystr(self, p):
-        return r"%s ~ %s" % tuple(p._print(a) for a in self.args)
+    sympy.sets.sets.imageset
+    """
 
-    @classmethod
-    def eval(cls, x, s):
-        if not s.is_distribution:
-            raise TypeError('expecting Distribution, not %s' % s)
-
-        ret = s.contains(x)
-        if not isinstance(ret, Distributed) and ret in (S.true, S.false):
-            return ret
+    def __new__(cls, flambda, *sets):
+        from sympy.core.function import Lambda
+        if not isinstance(flambda, Lambda):
+            raise ValueError('first argument must be a Lambda')
+        if flambda is S.IdentityFunction and len(sets) == 1:
+            return sets[0]
+        if not flambda.expr.free_symbols or not flambda.expr.args:
+            return FiniteSet(flambda.expr)
 
-    def simplify(self, *_, **__):
-        return self
+        return Basic.__new__(cls, flambda, *sets)
 
-    
-class NotDistributed(BinaryCondition):
-    """
-    Asserts that x is not a random expression/symbol under the distribution S
-    """
+    lamda = property(lambda self: self.args[0])
 
-    invert_type = Distributed
-    
-    def __new__(cls, x, s, **assumptions):
-        return BinaryCondition.eval(cls, x, s, **assumptions)
+    @property
+    def base_set(self): 
+        return ProductSet(self.args[1:])
     
-    def subs(self, *args, **kwargs):
-        if len(args) == 1:
-            eq, *_ = args
-            if eq.is_Equal:
-                args = eq.args
-                return self.func(self.lhs._subs(*args, **kwargs).simplify(), self.rhs._subs(*args, **kwargs).simplify(), equivalent=[self, eq]).simplify()
-            if isinstance(eq, dict):
-                return self
-            if eq.is_Quantifier:
-                return self.bfn(self.subs, eq)
-        return BinaryCondition.subs(self, *args, **kwargs)
+    @property
+    def etype(self):
+        return self.lamda.expr.type
 
     def _latex(self, p):
-        return r"%s\ {\color{blue}{\nsim}}\ %s" % tuple(p._print(a) for a in self.args)
+        from sympy.sets.conditionset import ConditionSet
+        if isinstance(self.base_set, ConditionSet) and self.lamda.variables == self.base_set.variable:
+            return r"\left\{%s \left| %s \right. \right\}" % (p._print(self.lamda.expr), p._print(self.base_set.condition))
+
+        from sympy.core.containers import Tuple
+        if isinstance(self.lamda.variables, Tuple):
+            sets = self.args[1:]
+            varsets = [r"%s \in %s" % (p._print(var), p._print(setv)) for var, setv in zip(self.lamda.variables, sets)]
+    #         return r"\left\{%s\; |\; %s\right\}" % (self._print(s.lamda.expr), ', '.join(varsets))
+            return r"\left\{%s \left| %s \right. \right\}" % (p._print(self.lamda.expr), ', '.join(varsets))
+
+        var = self.lamda.variables
+        setv = self.base_set
+        varsets = r"%s \in %s" % (p._print(var), p._print(setv))
+        return r"\left\{%s \left| %s \right. \right\}" % (p._print(self.lamda.expr), varsets)
 
-    def _sympystr(self, p):
-        return r"%s !~ %s" % tuple(p._print(a) for a in self.args)
+    def __iter__(self):
+        already_seen = set()
+        for i in self.base_set:
+            val = self.lamda(i)
+            if val in already_seen:
+                continue
+            else:
+                already_seen.add(val)
+                yield val
 
-    @classmethod
-    def eval(cls, x, s):
-        if not s.is_distribution:
-            raise TypeError('expecting Set, not %s' % s)
+    def _is_multivariate(self):
+        return len(self.lamda.variables) > 1
 
-    def simplify(self, *_, **__):
-        return self
+    def _contains(self, other):
+        from sympy.matrices import Matrix
+        from sympy.solvers.solveset import solveset, linsolve
+        from sympy.solvers.solvers import solve
+        from sympy.utilities.iterables import is_sequence, iterable, cartes
+        from sympy.core.function import Lambda
+        L = self.lamda
+        if is_sequence(other):
+            if not is_sequence(L.expr):
+                return S.false
+            if len(L.expr) != len(other):
+                raise ValueError(filldedent('''
+    Dimensions of other and output of Lambda are different.'''))
+        elif iterable(other):
+                raise ValueError(filldedent('''
+    `other` should be an ordered object like a Tuple.'''))
+
+        solns = None
+        if self._is_multivariate():
+            if not is_sequence(L.expr):
+                # exprs -> (numer, denom) and check again
+                # XXX this is a bad idea -- make the user
+                # remap self to desired form
+                return other.as_numer_denom() in self.func(
+                    Lambda(L.variables, L.expr.as_numer_denom()), self.base_set)
+            eqs = [expr - val for val, expr in zip(other, L.expr)]
+            variables = L.variables
+            free = set(variables)
+            if all(i.is_number for i in list(Matrix(eqs).jacobian(variables))):
+                solns = list(linsolve([e - val for e, val in
+                zip(L.expr, other)], variables))
+            else:
+                try:
+                    syms = [e.free_symbols & free for e in eqs]
+                    solns = {}
+                    for i, (e, s, v) in enumerate(zip(eqs, syms, other)):
+                        if not s:
+                            if e != v:
+                                return S.false
+                            solns[vars[i]] = [v]
+                            continue
+                        elif len(s) == 1:
+                            sy = s.pop()
+                            sol = solveset(e, sy)
+                            if sol.is_EmptySet:
+                                return S.false
+                            elif isinstance(sol, FiniteSet):
+                                solns[sy] = list(sol)
+                            else:
+                                raise NotImplementedError
+                        else:
+                            # if there is more than 1 symbol from
+                            # variables in expr than this is a
+                            # coupled system
+                            raise NotImplementedError
+                    solns = cartes(*[solns[s] for s in variables])
+                except NotImplementedError:
+                    solns = solve([e - val for e, val in
+                        zip(L.expr, other)], variables, set=True)
+                    if solns:
+                        _v, solns = solns
+                        # watch for infinite solutions like solving
+                        # for x, y and getting (x, 0), (0, y), (0, 0)
+                        solns = [i for i in solns if not any(
+                            s in i for s in variables)]
+        else:
+            x = L.variables[0]
+            if isinstance(L.expr, Expr):
+                # scalar -> scalar mapping
+                solnsSet = solveset(L.expr - other, x)
+                if solnsSet.is_FiniteSet:
+                    solns = list(solnsSet)
+                else:
+                    msgset = solnsSet
+            else:
+                # scalar -> vector
+                for e, o in zip(L.expr, other):
+                    solns = solveset(e - o, x)
+                    if solns.is_EmptySet:
+                        return S.false
+                    for soln in solns:
+                        try:
+                            if soln in self.base_set:
+                                break  # check next pair
+                        except TypeError:
+                            if self.base_set.contains(soln.evalf()):
+                                break
+                    else:
+                        return S.false  # never broke so there was no True
+                return S.true
+
+        if solns is None:
+            raise NotImplementedError(filldedent('''
+            Determining whether %s contains %s has not
+            been implemented.''' % (msgset, other)))
+        for soln in solns:
+            try:
+                if soln in self.base_set:
+                    return S.true
+            except TypeError:
+                return self.base_set.contains(soln.evalf())
+        return S.false
 
+    @property
+    def is_iterable(self):
+        return self.base_set.is_iterable
+
+    def doit(self, **kwargs):
+        from sympy.sets.setexpr import SetExpr
+        f = self.lamda
+        base_set = self.base_set
+        return SetExpr(base_set)._eval_func(f).set
 
-Distributed.invert_type = NotDistributed
 
-class Conditioned(Expr):
+class Range(Set):
     """
-    Symbolic expression for the conditional randomal variables.
+    Represents a range of integers. Can be called as Range(stop),
+    Range(start, stop), or Range(start, stop, step); when step is
+    not given it defaults to 1.
+
+    `Range(stop)` is the same as `Range(0, stop, 1)` and the stop value
+    (just as for Python ranges) is not included in the Range values.
     """
-    is_random = True
-    
-    lhs = property(lambda self: self.args[0])
-    rhs = property(lambda self: self.args[1])
-    
-    @cacheit
-    def _eval_domain_defined(self, x, **_):        
-        return self.lhs.domain_defined(x) & self.rhs.domain_defined(x)            
 
-    def simplify_condition_on_random_variable(self):
-        condition = self.lhs.simplify_condition_on_random_variable()
-        if condition is self.lhs:
-            return self
-        return self.func(condition, self.rhs)
-    
-    def __bool__(self):
-        if self.is_bool:
+    def structurally_equal(self, other):
+        if not isinstance(other, self.func) or len(self.args) != len(other.args):
             return False
+        if self.left_open != other.left_open or self.right_open != other.right_open or self.is_integer != other.is_integer:
+            return False
+        for x, y in zip(self.args[:3], other.args[:3]):
+            if not x.structurally_equal(y):
+                return False
         return True
 
-    def __new__(cls, prob, given, evaluate=True):
-        if prob.is_BooleanAtom:
-            return prob
-
-        assert prob.is_random, prob
-        assert given.is_random, given
+    def simplify(self, deep=False):
+        if deep:
+            hit = False
+            args = [*self.args]
+            for i, arg in enumerate(self.args[:3]): 
+                _arg = arg.simplify(deep=deep)                
+
+                if _arg != arg:
+                    hit = True
+                args[i] = _arg
+            if hit:
+                return self.func(*args).simplify()
         
-        prob = _sympify(prob)
-        given = _sympify(given)
-        if prob.is_Conditioned:
-            return Expr.__new__(cls, prob.lhs, prob.rhs & given)
-        if prob.is_And:
-            if given.is_And:
-                if given._argset & prob._argset:
-                    prob = prob.func(*prob._argset - given._argset)
-            else:
-                if given in prob._argset:
-                    prob = prob.func(*prob._argset - {given})
-                elif given.is_Equal:
-                    lhs, rhs = given.args
-                    if rhs.is_Surrogate:
-                        _given = Equal(lhs, rhs.arg.var, evaluate=False)
-                        if _given in prob._argset:
-                            prob = prob.func(*prob._argset - {_given})
-                        
-        return Expr.__new__(cls, prob, given)
-
-    def doit(self, **hints):
-        return given(self.lhs, self.rhs)
+        if self.is_integer:
+            if self.left_open:
+                return self.copy(start=self.start + 1, left_open=False)
+        return self
 
     @property
-    def dtype(self):        
-        return self.lhs.dtype
+    def is_UniversalSet(self):
+        return self.start.is_NegativeInfinity and self.stop.is_Infinity
     
-    @cacheit
-    def _eval_shape(self):
-        return self.lhs.shape
+    def intersection_sets(self, b):
+        if not (b.is_Interval or b.is_Range):
+            if self.is_UniversalSet:
+                return b
+            return
+        # handle (-oo, oo)
+        if self.is_UniversalSet:
+            if b.is_Interval:
+                return b.copy(integer=True)
+            return b
+
+        # We can't intersect [0,3] with [x,6] -- we don't know if x>0 or x<0
+        if not self._is_comparable(b):
+            from sympy import Min, Max
+            integer = b.is_integer
+            if integer:
+                a_start = self.start
+                b_start = b.start
+                if self.step == b.step:
+                    step = self.step
+                elif b.step.is_One:
+                    if b_start.is_finite:
+                        b_start += (a_start - b_start) % self.step
+                    step = self.step
+                elif self.step.is_One:
+                    if a_start.is_finite:
+                        a_start += (b_start - a_start) % b.step
+                    step = b.step
+                else:
+                    return
+                start = Max(a_start, b_start)
     
-    def _latex(self, p):
-        # return r"%s \middle \vert %s" % (p._print(self.lhs), p._print(self.rhs))
-        return r"%s \mathrel{\bigg|} %s" % (p._print(self.lhs), p._print(self.rhs))
-
-    def _eval_is_real(self):
-        return self.lhs.is_real
+                a_end = self.stop
+                b_end = b.stop
     
-    def _eval_is_complex(self):
-        return self.lhs.is_complex
-
-    def _eval_is_integer(self):
-        return self.lhs.is_integer
+                stop = Min(a_end, b_end)
+                return Range(start, stop, step=step)
+                        
+            else:
+                if b.left_open:
+                    if self.start <= b.start:
+                        start = b.start
+                        left_open = True
+                    elif self.start > b.start:
+                        start = self.start
+                        left_open = False
+                    else:
+                        return
+                else:
+                    start = Max(self.start, b.start)
+                    left_open = False
+                    
+                if b.right_open: 
+                    stop = Min(self.stop, b.stop)
+                    right_open = True                            
+                else:
+                    if self.stop > b.stop:
+                        stop = b.stop
+                        right_open = False
+                    elif self.stop <= b.stop:
+#                                 [a, b), [a, b']
+                        stop = self.stop
+                        right_open = True
+                    else: 
+                        return                            
+                            
+                return Range(start, stop, left_open=left_open, right_open=right_open)
 
-    def _eval_is_finite(self):
-        return self.lhs.is_finite
+        empty = False
 
-    def _eval_is_extended_negative(self):
-        return self.lhs.is_extended_negative
+        if self.start <= b.stop and b.start <= self.stop:
+            # Get topology right.
+            if self.start < b.start:
+                start = b.start
+                left_open = b.left_open
+            elif self.start > b.start:
+                start = self.start
+                left_open = self.left_open
+            else:
+                start = self.start
+                left_open = self.left_open or b.left_open
 
-    def _eval_is_extended_positive(self):
-        return self.lhs.is_extended_positive
+            if self.stop < b.stop:
+                stop = self.stop
+                right_open = self.right_open
+            elif self.stop > b.stop:
+                stop = b.stop
+                right_open = b.right_open
+            else:
+                stop = self.stop
+                right_open = self.right_open or b.right_open
 
-    @property
-    def is_bool(self):
-        return self.lhs.is_bool
+            if stop - start == 0 and (left_open or right_open):
+                empty = True
+        else:
+            empty = True
 
-    def domain_definition(self):
-        return Unequal(Probability(self.rhs), 0)
-        
-    def invert(self):
-        return self.func(self.lhs.invert(), self.rhs)
-        
-    def as_boolean(self):
-        if not self.is_bool:
-            return self.func(self.lhs.as_boolean(), self.rhs)
+        if empty:
+            return self.etype.emptySet
+
+        return self.func(start, stop, left_open=left_open, right_open=right_open)
+
+    def _union_sets(self, b):
+        from sympy import Min, Max
+        if self.max() in b: 
+            return b.copy(start=Min(self.min(), b.min()), left_open=False, integer=True)
+        elif self.min() in b:
+            return b.copy(stop=Max(self.max(), b.max()), right_open=False, integer=True)
+        elif self in b:
+            return b
+        elif b in self:
+            return self
 
-    def yield_random_symbols(self):
-        yield from self.lhs.yield_random_symbols()
+    def union_sets(self, b):
+        from sympy.functions.elementary.miscellaneous import Min, Max
+        if b.is_Range:
+            if self._is_comparable(b):
+                # Non-overlapping intervals
+                stop = Min(self.stop, b.stop)
+                start = Max(self.start, b.start)
+                if (stop < start or
+                   (stop == start and (stop not in self and stop not in b))):
+                    return 
+                else:
+                    start = Min(self.start, b.start)
+                    stop = Max(self.stop, b.stop)
 
-    def simplify(self, deep=False):
-        lhs, rhs = self.args
-        if lhs.is_And:
-            _argset = lhs._argset
-            if rhs in _argset:
-                lhs = And(*{*_argset} - {rhs})
-                return self.func(lhs, rhs, evaluate=False)
-            
-            elif rhs.is_Equal:
-                x, x_var = rhs.args
-                if x_var.is_Surrogate:
-                    rhs = Equal(x, x_var.arg.var, evaluate=False)
-                    if rhs in _argset:
-                        lhs = And(*{*_argset} - {rhs})
-                        return self.func(lhs, rhs, evaluate=False)
+                    left_open = ((self.start != start or self.left_open) and
+                                 (b.start != start or b.left_open))
+                    right_open = ((self.stop != stop or self.right_open) and
+                                  (b.stop != stop or b.right_open))
+                    return self.func(start, stop, left_open=left_open, right_open=right_open)
+            else:
+                if b.left_open:
+                    if self.stop == b.start:
+                        return self.func(self.start, b.stop, left_open=self.left_open, right_open=b.right_open) - FiniteSet(b.start)
+                else:
+                    if self.stop == b.start - 1:
+                        if b.start <= b.stop: 
+                            return self.func(self.start, b.stop, left_open=self.left_open, right_open=b.right_open) - FiniteSet(self.stop)
+                    if self.stop == b.start:
+                        if self.stop >= self.start and b.stop >= b.start:
+                            return self.copy(stop=b.stop)
                     
-        return Expr.simplify(self, deep)
+                return self._union_sets(b)
+            
+        if b.is_Interval:
+            if self._is_comparable(b): 
+                # Non-overlapping intervals
+                stop = Min(self.stop, b.stop)
+                start = Max(self.start, b.start)
+                if (stop < start or
+                   (stop == start and (stop not in self and stop not in b))):
+                    return 
+                else:
+                    start = Min(self.start, b.start)
+                    stop = Max(self.stop, b.stop)
 
-    def _try_to_substitute(self, other, new):
-        if not other.is_Conditioned:
-            return
-        
-        if self.lhs != other.lhs:
-            return
+                    left_open = ((self.start != start or self.left_open) and
+                                 (b.start != start or b.left_open))
+                    right_open = ((self.stop != stop or self.right_open) and
+                                  (b.stop != stop or b.right_open))
+                    return self.func(start, stop, left_open=left_open, right_open=right_open)
+            else:
+                if b.left_open:
+                    if self.stop == b.start:
+                        return self.func(self.start, b.stop, left_open=self.left_open, right_open=b.right_open) - FiniteSet(b.start)
+                else:
+                    if self.stop == b.start - 1:
+                        if b.start <= b.stop: 
+                            return self.func(self.start, b.stop, left_open=self.left_open, right_open=b.right_open) - FiniteSet(self.stop)
+                    if self.stop == b.start:
+                        return self.copy(stop=b.stop, right_open=b.right_open)
+                    
+                return self._union_sets(b)
+            
+        if b.is_UniversalSet:
+            return b
+        if b.is_Complement:
+            U, A = b.args             
+            if (U.is_Range or U.is_Interval) and not A & self:
+                combined = self | U
+                if combined.is_Range or combined.is_Interval:
+                    return combined - A 
+
+        # If I have open end points and these endpoints are contained in b
+        # But only in case, when endpoints are finite. Because
+        # interval does not contain oo or -oo.
+        open_left_in_b_and_finite = (self.left_open and
+                                         sympify(b.contains(self.start)) is S.true and
+                                         self.start.is_finite)
+        open_right_in_b_and_finite = (self.right_open and
+                                          sympify(b.contains(self.stop)) is S.true and
+                                          self.stop.is_finite)
+        if open_left_in_b_and_finite or open_right_in_b_and_finite:
+            # Fill in my end points and return
+            left_open = self.left_open and self.start not in b
+            right_open = self.right_open and self.stop not in b            
+            new_a = self.copy(left_open=left_open, right_open=right_open)
+            return set((new_a, b))
+        
+        drapeau = False
+        stop = self.stop
+        right_open = self.right_open
+        if right_open:
+            if stop in b:
+                drapeau = True
+                right_open = False
+        else: 
+            if stop + 1 in b:
+                drapeau = True
+                stop += 1                                   
+
+        start = self.start
+        left_open = self.left_open
+        if left_open:
+            if start in b:
+                drapeau = True
+                left_open = False
+        else: 
+            if start - 1 in b:
+                drapeau = True
+                start -= 1                                    
+
+        if drapeau:
+            new_a = self.func(start + 1 if left_open else start, stop if right_open else stop + 1)
+            return set((new_a, b))
         
-        rhs = self.rhs
-        _rhs = other.rhs
-        if rhs.is_And and _rhs.is_And:
-            rhs = rhs.args
-            _rhs = _rhs.args
-            if len(rhs) == len(_rhs):
-                conds = []
-                for eq, _eq in zip(rhs, _rhs):
-                    if new := eq._try_to_substitute(_eq, new):
-                        ...
-                    else:
-                        return
+        if self.is_UniversalSet:
+            return self
 
-                return new
+    def __new__(cls, start=None, stop=None, step=None, **kwargs):
+        if stop is None:
+            if start is None:
+                if kwargs.get('positive'):
+                    stop = S.Infinity
+                    start = S.One
+                elif kwargs.get('nonnegative'):
+                    start = S.Zero
+                    stop = S.Infinity
+                elif kwargs.get('negative'):
+                    start = S.NegativeInfinity
+                    stop = S.Zero
+                    kwargs['right_open'] = True
+                elif kwargs.get('nonpositive'):
+                    start = S.NegativeInfinity
+                    stop = S.Zero
+                else:
+                    start = S.NegativeInfinity
+                    stop = S.Infinity
+                    
+                if kwargs.get('odd'):
+                    return cls(start, stop, left_open=start.is_NegativeInfinity, right_open=True).retain_odd()
+                elif kwargs.get('even'):
+                    return cls(start, stop, left_open=start.is_NegativeInfinity, right_open=True).retain_even()
+            else:
+                stop = _sympify(start)
+                start = S.Zero
+        else:
+            start = _sympify(start)
+            stop = _sympify(stop)
             
-        elif rhs.is_Equal and _rhs.is_Equal:
-            if new := rhs._try_to_substitute(_rhs, new):
-                return new
-    
-    def _subs(self, old, new, **hints):
-        if _new := self._try_to_substitute(old, new):
-            return _new
+        if 'left_open' in kwargs:
+            left_open = kwargs['left_open']
+        else:
+            # by default, infinite interval start points are open.
+            if start.is_NegativeInfinity:
+                left_open = True
+            else:
+                left_open = False
+                
+        if 'right_open' in kwargs:
+            right_open = kwargs['right_open']
+        else:
+            # by default, stop points are open.
+            right_open = True
+                
         
-        return Expr._subs(self, old, new)
-
-    def __iter__(self):
-        raise TypeError
-    
-    def __getitem__(self, indices, **kw_args):
-        lhs, rhs = self.args
-        return self.func(lhs[indices], rhs, evaluate=False)
-
-    @cacheit
-    def sort_key(self, order=None):
-        args = self.args
-        args = tuple(arg.sort_key(order=order) for arg in args)
-        args = len(args), tuple(arg.class_key() for arg in self.args), args
-        return self.class_key(), args, S.One.sort_key(order=order), S.One
+        if stop == start:
+            if left_open or right_open:
+                return S.Zero.emptySet
+            else:
+                if start.is_Infinity or start.is_NegativeInfinity:
+                    return start.emptySet                
+                return FiniteSet(stop)
+
+        if left_open:
+            if start.is_finite:
+                if not start.is_integer:
+                    start = start.floor().simplify()
+                    
+                start += 1
+                left_open = False
+        else:
+            if start.is_finite and not start.is_integer: 
+                start = start.ceiling().simplify()                
+            
+        if right_open: 
+            if stop.is_finite and not stop.is_integer:
+                stop = stop.ceiling().simplify()
+            
+            if start == stop - 1:
+                return FiniteSet(start)                
+                
+        else:
+            if stop.is_finite and not stop.is_integer:
+                stop = stop.floor().simplify()
 
-    @classmethod
-    def class_key(cls):
-        """Nice order of classes. """
-        return 6, 0, cls.__name__
+            if left_open:
+                if start == stop - 1:
+                    return FiniteSet(stop)
+            else:
+                if start == stop:
+                    return FiniteSet(stop)
+            
+            if stop.is_finite:
+                right_open = True
+                stop += 1
+                
+        # evaluate if possible
+        if right_open and stop <= start or not right_open and stop < start:
+            return S.Zero.emptySet
+            
+        if step is not None and step != 1:
+            args = start, stop, _sympify(step)
+        else:
+            args = start, stop
+            
+        self = Basic.__new__(cls, *args)
+        self.left_open = bool(left_open)
+        self.right_open = bool(right_open)
+        return self        
 
+    def element_symbol(self, excludes=set()):
+        return self.generate_var(excludes, **self.etype.dict)
 
-class Surrogate(AtomicExpr):
-    is_symbol = True
-    is_comparable = False
-    
-    def __new__(cls, symbol):
-        obj = Expr.__new__(cls, symbol)
-        return obj
-    
     @property
-    def var(self):
-        return self.arg.var
-    
-    @property
-    def dtype(self):
-        return self.arg.dtype
-    
-    @cacheit
-    def _eval_shape(self):
-        return self.arg.shape
-    
-    def __contains__(self, other):
-        return other in self.symbol
-    
-    def __iter__(self):
-        raise TypeError
-      
-    def __getitem__(self, indices):
-        return Surrogate(self.arg.__getitem__(indices))
-    
-    def _sympystr(self, p): 
-        return self.arg._sympystr(p)
-    
-    def _latex(self, p):
-        return self.arg._latex(p, color='magenta')
-    
-    def _eval_is_extended_positive(self):
-        return self.arg.is_extended_positive
-    
-    def _eval_is_extended_negative(self):
-        return self.arg.is_extended_negative
-    
-    def _eval_is_nonzero(self):
-        return self.arg.is_nonzero
-    
-    def _eval_is_zero(self):
-        return self.arg.is_zero
-    
-    def _eval_is_finite(self):
-        return self.arg.is_finite
-    
-    def _eval_is_extended_integer(self):
-        return self.arg.is_extended_integer
-    
-    def _eval_is_super_integer(self):
-        return self.arg.is_super_integer
-    
-    def _eval_is_extended_rational(self):
-        return self.arg.is_extended_rational
-    
-    def _eval_is_hyper_rational(self):
-        return self.arg.is_hyper_rational
-    
-    def _eval_is_super_rational(self):
-        return self.arg.is_super_rational
-    
-    def _eval_is_extended_real(self):
-        return self.arg.is_real
-    
-    def _eval_is_hyper_real(self):
-        return self.arg.is_hyper_real
-    
-    def _eval_is_super_real(self):
-        return self.arg.is_super_real
-    
-    def _eval_is_extended_complex(self):
-        return self.arg.is_extended_complex
-    
-    def _eval_is_hyper_complex(self):
-        return self.arg.is_hyper_complex
-    
-    def _eval_is_algebraic(self):
-        return self.arg.is_algebraic
-    
-    def _eval_is_hermitian(self):
-        return self.arg.is_hermitian
-    
-    def _eval_is_imaginary(self):
-        return self.arg.is_imaginary
-    
-    def _eval_is_random(self):
-        return self.arg.is_random
-    
+    def size(self):
+        if self.left_open:
+            start = self.start + 1
+        else:
+            start = self.start
+        if self.right_open:
+            stop = self.stop
+        else:
+            stop = self.stop + 1
+        return stop - start
+
     @property
-    def distribution(self):
-        return self.arg.distribution
+    def start(self):
+        """
+        The left end point of 'self'.
 
-    def as_boolean(self):
-        from sympy import Equal
-        return Equal(self.arg, self, evaluate=False)
-
-    def __and__(self, other):
-        """Overloading for & operator"""
-        if other.is_random:
-            if not other.is_bool:
-                other = other.as_boolean()
-            return self.as_boolean() & other
+        This property takes the same value as the 'inf' property.
 
-        return super(Surrogate, self).__and__(other)
+        Examples
+        ========
 
-    def copy(self, **kwargs):
-        return self.arg.copy(**kwargs)
+        >>> from sympy import Interval
+        >>> Interval(0, 1).start
+        0
 
+        """
+        return self._args[0]
 
-# when X is a discrete random variable, define P(X) = P(X=x), which is necessarily nomore than 1, Sum[X](P(X)) = 1
-# when X is a continuous random variable, define P(X) = P(X=x) = PDF(X)(x) which is possibly greater than 1, Integral[X](P(X)) = 1
-class Probability(Expr):
-    """
-    Symbolic expression for the probability.
+    _inf = left = start
 
-    Examples
-    ========
+    @classmethod
+    def open(cls, a, b):
+        """Return an interval including neither boundary."""
+        return cls(a, b, True, True)
+
+    @classmethod
+    def Lopen(cls, a, b):
+        """Return an interval not including the left boundary."""
+        return cls(a, b, True, False)
+
+    @classmethod
+    def Ropen(cls, a, b):
+        """Return an interval not including the right boundary."""
+        return cls(a, b, False, True)
 
-    >>> from sympy.stats import Probability, Normal
-    >>> from sympy import Integral
-    >>> X = Normal("X", 0, 1)
-    >>> prob = Probability(X > 1)
-    >>> prob
-    Probability(X > 1)
-
-    Integral representation:
+    @property
+    def stop(self):
+        """
+        The right end point of 'self'.
 
-    >>> prob.rewrite(Integral)
-    Integral(sqrt(2)*exp(-_z**2/2)/(2*sqrt(pi)), (_z, 1, oo))
+        This property takes the same value as the 'sup' property.
 
-    Evaluation of the integral:
+        Examples
+        ========
 
-    >>> prob.evaluate_integral()
-    sqrt(2)*(-sqrt(2)*sqrt(pi)*erf(sqrt(2)/2) + sqrt(2)*sqrt(pi))/(4*sqrt(pi))
-    """
-    is_extended_negative = False
-    is_extended_real = True
-    is_finite = True
-    
-    @cacheit
-    def _eval_domain_defined(self, x, **_):        
-        return self.arg.domain_defined(x)            
+        >>> from sympy import Interval
+        >>> Interval(0, 1).stop
+        1
 
-    def marginalize(self, given, *rest):
-        assert given.is_symbol and given.is_random
-        prob = self.func.marginalize_condition(self.arg, given)
-        if rest:
-            prob = prob.marginalize(*rest)
-            
-        return prob
-                
-    @classmethod
-    def marginalize_condition(cls, condition, given):        
-        if condition.is_And:
-            expr = []
-            hit = False
-            for eq in condition.args:
-                if eq.is_Equal:
-                    lhs, rhs = eq.args
-                    if lhs.is_symbol and pspace(lhs).symbol == rhs:
-                        if lhs._has(given):
-                            if lhs == given:
-                                hit = True
-                                continue
-                            
-                            if given.is_Indexed:               
-                                start = given.indices[0]
-                                stop = start + 1
-                            elif given.is_Sliced:
-                                start, stop = given.index
-                            else:
-                                expr.append(eq)
-                                continue
-                                                                                                  
-                            lhs = lhs.split(slice(start, stop))
-                            if not lhs.is_BlockMatrix:
-                                hit = True
-                            else:
-                                rhs = rhs.split(slice(start, stop))                                
-                                for lhs, rhs in zip(lhs.args, rhs.args):
-                                    eq = Equal(lhs, rhs)
-                                    if lhs == given:
-                                        hit = True
-                                    else:
-                                        expr.append(eq)
-                            continue
-                expr.append(eq)
-            if hit:
-                return cls(And(*expr))
-        elif condition.is_Conditioned:
-            self = cls(condition.lhs).marginalize(given)
-            return self.func(self.arg, given=condition.rhs)
-        elif condition.is_Equal:
-            if given.is_Sliced:
-                start, stop = given.index
-                lhs, rhs = condition.lhs.split(slice(start, stop)), condition.rhs.split(slice(start, stop))
-                assert lhs.is_BlockMatrix and rhs.is_BlockMatrix
-                condition = And(*(condition.func(l, r) for l, r in zip(lhs.args, rhs.args)))
-            elif given.is_Indexed:                
-                condition = condition.split([slice(*index) for index in given.indices])
-            if condition.is_And:
-                return cls.marginalize_condition(condition, given)
-            
-    @property
-    def dtype(self):
-        from sympy.core.symbol import dtype
-        return dtype.real
+        """
+        return self._args[1]
     
-    def __new__(cls, *prob, given=None, evaluate=False): 
-        booleans = []
-        limits = []
-        for arg in prob:
-            if isinstance(arg, (tuple, Tuple)):
-                limits.append(Tuple(*arg))
-                continue
-            
-            if arg.is_BooleanTrue:
-                continue
+    @property
+    def step(self):
+        if len(self._args) == 3:
+            return self._args[2]
+        return S.One
+
+    _sup = right = stop
+
+#     trying to evaluate other \ self
+    def _complement(self, other):
+        if other == Reals:
+            return
+        
+        from sympy.sets import Integers
+        if other == Integers and self.step.is_One:
+            start, stop = S.NegativeInfinity, self.start
+            if self.left_open:
+                stop += 1
+            a = Range(start, stop)
             
-            if arg.is_BooleanFalse:
-                return S.Zero
+            start, stop = self.stop, S.Infinity
+            if not self.right_open:
+                start += 1    
+            b = Range(start, stop)
             
-            assert arg.is_random
-            if arg.is_symbol:
-                booleans.append(Equal(arg, pspace(arg).symbol))
-            elif arg.is_Conditioned:
-                lhs, rhs = arg.args
-                if lhs.is_symbol:
-                    if lhs.is_Surrogate:
-                        booleans.append(arg.func(Equal(lhs.arg, lhs), rhs))
-                    else:
-                        booleans.append(arg.func(Equal(lhs, pspace(lhs).symbol), rhs))
-                else:
-                    booleans.append(arg)
-            else:
-                assert arg.is_Boolean, type(arg)
-                booleans.append(arg)
+            return a | b
 
-        if not booleans:
-            return S.One
+        if other.is_FiniteSet:
+            nums = [m for m in other.args if m.is_number]
+            if nums == []:
+                return
 
-        expr = And(*booleans)
-        if given is not None:
-            expr = rv.given(expr, given)
-
-        vars = [v for v in expr.random_symbols if not v.is_Surrogate]
-        std.deleteIndices(limits, lambda limits, i : cls.is_redundant(limits, i, vars))
-
-        return Expr.__new__(cls, expr, *limits)
-
-    @classmethod
-    def is_redundant(cls, limits, i, vars):
-        limit = limits[i]
-        if len(limit) > 1:
-            x, w = limit
-            if x.has(*vars):
-                if x.is_Indexed or x.is_Sliced:
-                    if not any(i.is_random for i in x.indices):
-                        limits[i] = Tuple(x.base, w)
-            else:
-                return True
-        
-    def doit(self, **hints):
-        condition = self.args[0]
-        given_condition = None
-        numsamples = hints.get('numsamples', False)
-        for_rewrite = not hints.get('for_rewrite', False)
-
-        if isinstance(condition, Not):
-            return S.One - self.func(condition.args[0], given_condition, evaluate=for_rewrite).doit(**hints)
-
-        if condition.has(RandomIndexedSymbol):
-            return pspace(condition).probability(condition, given_condition, evaluate=for_rewrite)
-
-        if isinstance(given_condition, RandomSymbol):
-            condrv = condition.random_symbols
-            if len(condrv) == 1 and condrv[0] == given_condition:
-                from sympy.stats.frv_types import BernoulliDistribution
-                return BernoulliDistribution(self.func(condition).doit(**hints), 0, 1)
-            if any([dependent(rv, given_condition) for rv in condrv]):
-                return Probability(condition, given_condition)
-            else:
-                return Probability(condition).doit()
+        return Set._complement(self, other)
 
-        if given_condition is not None and not given_condition.is_Relational:
-            raise ValueError("%s is not a relational or combination of relationals" % (given_condition))
+    @property
+    def _boundary(self):
+        finite_points = [p for p in (self.start, self.stop) if abs(p) != S.Infinity]
+        return FiniteSet(*finite_points)
+
+    def _contains(self, other):
+        if not isinstance(other, Expr) or (
+                other is S.Infinity or
+                other is S.NegativeInfinity or
+                other is S.NaN or
+                other is S.ComplexInfinity) or other.is_extended_real == False:
+            return S.false
+
+        if self.start is S.NegativeInfinity and self.stop is S.Infinity:
+            if not other.is_extended_real is None:
+                if other.is_integer:
+                    return S.true
+                return
 
-        if given_condition == False or condition is S.false:
-            return S.Zero
+        if other.is_extended_real == False:
+            return S.false
         
-        if not condition.is_Relational:
-            return self
+        if other.is_extended_real is None:
+            return
         
-        if condition is S.true:
-            return S.One
+        if self.left_open:
+            expr = other > self.start
+        else:
+            expr = other >= self.start
 
-        if numsamples:
-            return sampling_P(condition, given_condition, numsamples=numsamples)
-        if given_condition is not None:  # If there is a condition
-            # Recompute on new conditional expr
-            return Probability(given(condition, given_condition)).doit()
-
-        # Otherwise pass work off to the ProbabilitySpace
-        ps = pspace(condition)
-        if ps  == PSpace():
-            return Probability(condition, given_condition)
-
-        try:
-            return ps.probability(condition).simplify()
-        except:
-            return self
+        if self.right_open:
+            expr = And(expr, other < self.stop)
+            
+            if self.step != 1:
+                from sympy import Equal
+                expr &= Equal((other - self.start) % self.step, 0)
+        else:
+            expr = And(expr, other <= self.stop)
 
-    def _eval_rewrite_as_Integral(self, arg, condition=None, **kwargs):
-        return self.func(arg, condition=condition).doit(for_rewrite=True)
+        return _sympify(expr)
 
-    _eval_rewrite_as_Sum = _eval_rewrite_as_Integral
+    @property
+    def _measure(self):
+        return self.stop - self.start
 
-    def evaluate_integral(self):
-        return self.rewrite(Integral).doit()
+    def doit(self, deep=False, **_):
+        if deep:
+            return self.copy(start=self.start.doit(), stop=self.stop.doit())
+        m = self.min()
+        if m.is_Integer:
+            M = self.max()
+            if M.is_Integer: 
+                from sympy import FiniteSet
+                return FiniteSet(*range(m, M + 1))
+        return self
 
-    def normalize_limits(self, limits):
-        for i, limit in enumerate(limits):
-            if len(limit) > 1:
-                limits[i] = (limit[-1],)
-        return limits
+    def to_mpi(self, prec=53):
+        return mpi(mpf(self.start._eval_evalf(prec)), mpf(self.stop._eval_evalf(prec)))
 
-    @cacheit
-    def _eval_is_pdf(self):
-        expr = self.arg
-        random_symbols = {v for v in expr.random_symbols if not v.is_Surrogate}
-
-        if expr.is_Conditioned:
-            expr = expr.lhs
-
-        conds = expr.args if expr.is_And else [expr]
-        if all(cond.is_Equal for cond in conds): 
-            for cond in conds:
-                lhs, rhs = cond.args
-                if not lhs.is_integer and lhs.is_symbol and any(v.index_contains(lhs) for v in random_symbols):
-                    return True
-                
-                if not rhs.is_integer:
-                    return True
-        
-    @property
-    def is_pdf(self):
-        return self._eval_is_pdf()
+    def _eval_evalf(self, prec):
+        return Interval(self.left._eval_evalf(prec), self.right._eval_evalf(prec),
+                        left_open=self.left_open, right_open=self.right_open)
+
+    def _is_comparable(self, other):
+        is_comparable = self.start.is_comparable
+        is_comparable &= self.stop.is_comparable
+        is_comparable &= other.start.is_comparable
+        is_comparable &= other.stop.is_comparable
 
-    def _latex(self, p):
-        expr, *limits = self.args
-        symbol_P = 'p' if self.is_pdf else 'P'
-        if limits:
-            limits = self.normalize_limits(limits)
-            return r'\mathbb{%s}_{%s}\left(%s\right)' % (
-                symbol_P,
-                ','.join([p._print(s) for s, *_ in limits]), 
-                expr._latex(p))
-        else:
-            return r'\mathbb{%s}\left(%s\right)' % (symbol_P, expr._latex(p))
-
-    def _sympystr(self, p):
-        expr, *limits = self.args
-        if limits:
-            limits = self.normalize_limits(limits)
-            return 'P[%s](%s)' % (','.join([p._print(s) for s, *_ in limits]), p._print(expr))
-        else:
-            return 'P(%s)' % p._print(expr)
+        return is_comparable
 
-    def domain_definition(self):        
-        return self.arg.domain_definition()
-    
-    def _subs(self, old, new, **hints):
-        if old.is_Conditioned and not old.lhs.is_bool or new.is_Conditioned and not new.lhs.is_bool:
-            old = old.as_boolean()
-            new = new.as_boolean()
-            
-        else:
-            random_symbols = self.args[0].random_symbols
-            if old in random_symbols:
-                if not old.is_Surrogate:
-                    old = old.surrogate
-                    if old in random_symbols:
-                        if new.is_random:
-                            new = new.surrogate
-                    else:
-                        return self
+    @property
+    def is_left_unbounded(self):
+        """Return ``True`` if the left endpoint is negative infinity. """
+        return self.left is S.NegativeInfinity or self.left == Float("-inf")
 
-        return Expr._subs(self, old, new, **hints)
+    @property
+    def is_right_unbounded(self):
+        """Return ``True`` if the right endpoint is positive infinity. """
+        return self.right is S.Infinity or self.right == Float("+inf")
+
+    def as_relational(self, x):
+        """Rewrite an interval in terms of inequalities and logic operators."""
+        x = sympify(x)
+        if self.right_open:
+            right = x < self.stop
+        else:
+            right = x <= self.stop
+        if self.left_open:
+            left = self.start < x
+        else:
+            left = self.start <= x
+        return And(left, right)
+
+    def _eval_Eq(self, other):
+        if not other.is_Range:
+            if other.is_FiniteSet:
+                if other.is_EmptySet and self.start < self.stop:
+                    return S.false
+                return
+            elif other.is_set:
+                return
+            return S.false
+        from sympy import Equal 
+        return And(Equal(self.left, other.left), Equal(self.right, other.right))
 
-    @classmethod
-    def simplify_Equal(cls, self, lhs, rhs):
-        """
-        precondition: self.lhs is a Probability object!
-        """
-        if lhs.is_Probability and len(lhs.args) == 1 and rhs.is_Probability and len(rhs.args) == 1:
-            lhs = self.lhs.arg.simplify_condition_on_random_variable()
-            if lhs is not self.lhs.arg:
-                rhs = self.rhs.arg.simplify_condition_on_random_variable()
-                if rhs is not self.rhs.arg:
-                    return self.func(lhs, rhs)
+    @cacheit
+    def _eval_free_symbols(self):
+        return set().union(*[a.free_symbols for a in self.args[:2]])
 
-    def yield_random_symbols(self):
-        expr, *limits = self.args
-        
-        if expr.is_Conditioned:
-            lhs, rhs = expr.args
-            for v in lhs.yield_random_symbols():
-                if v.is_Surrogate:
-                    yield v.arg
-
-            for v in rhs.yield_random_symbols():
-                if v.is_Surrogate:
-                    yield v.arg
-        else:
-            for v in expr.yield_random_symbols():
-                if v.is_Surrogate:
-                    yield v.arg
-
-        for x, *ab in limits:
-            for w in ab:
-                yield from w.yield_random_symbols()
-
-    def _eval_is_random(self):
-        expr = self.arg
-        if expr.is_Conditioned:
-            expr, given = expr.args
+    def max(self):
+        if self.right_open:
+            return self.stop - 1
+        return self.stop
+
+    def min(self):
+        if self.left_open:
+            return self.start + 1
+        return self.start
+
+    def __neg__(self):
+        assert self.right_open
+        assert not self.left_open        
+        return self.func(-self.stop + 1, -self.start + 1)
+    
+    def _eval_right_open(self, other):
+        if self.stop.is_infinite:
+            if other.stop.is_infinite:
+                return self.right_open and other.right_open
+            else:
+                return self.right_open
         else:
-            given = None
-            
-        for v in expr.random_symbols:
-            if v.is_Surrogate:
+            if other.stop.is_infinite:
+                return other.right_open
+            else:
                 return True
+    
+    def _eval_left_open(self, other):
+        if self.start.is_infinite:
+            if other.start.is_infinite:
+                return self.left_open and other.left_open
+            else:
+                return self.left_open
+        else:
+            if other.start.is_infinite:
+                return other.left_open
+            else:
+                return False
             
-        if given is not None:
-            for v in given.random_symbols:
-                if v.is_Surrogate:
-                    return True
-
-    def __le__(self, other):
-        if not self.is_pdf and other >= 1:
-            return S.true
-
-        return Expr.__le__(self, other)
-
-    def __lt__(self, other):
-        if not self.is_pdf and other > 1:
-            return S.true
-
-        return Expr.__le__(self, other)
-
-    @classmethod
-    def class_key(cls):
-        """Nice order of classes. """
-        return 5, 50, cls.__name__
-
+    def __add__(self, other):
+        other = sympify(other)
+        if other.is_Range:
+            start = self.start
+            stop = self.stop
+            
+            start += other.start
+            stop += other.stop - 1
+            
+            right_open = self._eval_right_open(other)               
+            left_open = self._eval_left_open(other)
+            
+            return self.func(start, stop, left_open=left_open, right_open=right_open)
+        
+        if other.is_Interval:
+            start = self.min()
+            stop = self.max()
+            
+            start += other.start
+            stop += other.stop
+            left_open, right_open = other.left_open, other.right_open                    
+            return Interval(start, stop, left_open=left_open, right_open=right_open)
+        
+        if other.is_ComplexRegion:
+            productset = other.args[0].args
+            return other.func((self + productset[0]) @ productset[1])
+        
+        if other.is_FiniteSet:
+            start, stop = self.start, self.stop
+            start += other.min()
+            stop += other.max()
+                        
+            if other.is_integer: 
+                return self.func(start, stop)
+            else: 
+                stop -= 1
+                return Interval(start, stop)
+        if other.is_CartesianSpace:
+            return other.func(self + other.space, *other.space_shape)
+        
+        if not other.is_set:
+            start = self.start + other
+            stop = self.stop + other
+            if self.step.is_One:
+                return self.func(start, stop)
+            else:
+                return self.func(start, stop, step=self.step)
 
-class Expectation(ExprWithLimits):
-    """
-    Symbolic expression for the expectation.
+        return Set.__add__(self, other)
 
-    Examples
-    ========
+    def __mul__(self, k):
+        if isinstance(k, Expr):
+            a, b = self.args
+            start = self.start * k
+            stop = self.stop * k
+            if k.is_integer:
+                if k > 0:
+                    return self.func(a * k, b * k - k + 1)
+                if k < 0:
+                    return self.func(b * k - k, a * k + 1)
+                if k == 0:
+                    return FiniteSet(0)
+                
+                return self.func(S.NegativeInfinity, S.Infinity)
+            else:
+                if k > 0:
+                    return Interval(a * k, b * k - k)
+                if k < 0:
+                    return Interval(b * k - k, a * k)
+                if k == 0:
+                    return FiniteSet(0)
+                
+                return Interval(S.NegativeInfinity, S.Infinity)
 
-    >>> from sympy.stats import Expectation, Normal, Probability, Poisson
-    >>> from sympy import symbols, Integral, Sum
-    >>> mu = symbols("mu")
-    >>> sigma = symbols("sigma", positive=True)
-    >>> X = Normal("X", mu, sigma)
-    >>> Expectation(X)
-    Expectation(X)
-    >>> Expectation(X).evaluate_integral().simplify()
-    mu
-
-    To get the integral expression of the expectation:
-
-    >>> Expectation(X).rewrite(Integral)
-    Integral(sqrt(2)*X*exp(-(X - mu)**2/(2*sigma**2))/(2*sqrt(pi)*sigma), (X, -oo, oo))
-
-    The same integral expression, in more abstract terms:
-
-    >>> Expectation(X).rewrite(Probability)
-    Integral(x*Probability(Eq(X, x)), (x, -oo, oo))
-
-    To get the Summation expression of the expectation for discrete random variables:
-
-    >>> lamda = symbols('lamda', positive=True)
-    >>> Z = Poisson('Z', lamda)
-    >>> Expectation(Z).rewrite(Sum)
-    Sum(Z*lamda**Z*exp(-lamda)/factorial(Z), (Z, 0, oo))
-
-    This class is aware of some properties of the expectation:
-
-    >>> from sympy.abc import a
-    >>> Expectation(a*X)
-    Expectation(a*X)
-    >>> Y = Normal("Y", 1, 2)
-    >>> Expectation(X + Y)
-    Expectation(X + Y)
-
-    To expand the ``Expectation`` into its expression, use ``expand()``:
-
-    >>> Expectation(X + Y).expand()
-    Expectation(X) + Expectation(Y)
-    >>> Expectation(a*X + Y).expand()
-    a*Expectation(X) + Expectation(Y)
-    >>> Expectation(a*X + Y)
-    Expectation(a*X + Y)
-    >>> Expectation((X + Y)*(X - Y)).expand()
-    Expectation(X**2) - Expectation(Y**2)
-
-    To evaluate the ``Expectation``, use ``doit()``:
-
-    >>> Expectation(X + Y).doit()
-    mu + 1
-    >>> Expectation(X + Expectation(Y + Expectation(2*X))).doit()
-    3*mu + 1
-
-    To prevent evaluating nested ``Expectation``, use ``doit(deep=False)``
-
-    >>> Expectation(X + Expectation(Y)).doit(deep=False)
-    mu + Expectation(Expectation(Y))
-    >>> Expectation(X + Expectation(Y + Expectation(2*X))).doit(deep=False)
-    mu + Expectation(Expectation(Y + Expectation(2*X)))
+        return Set.__mul__(self, k)
 
-    """
+    def cos(self):
+        from sympy.core.numbers import epsilon
+        start, stop = self.args
+        if self.right_open:
+            stop -= epsilon
 
-    def __new__(cls, expr, *limits, **kwargs):
-        # only the last limit can be the weight limit
-        expr = _sympify(expr)
-        if not expr.is_random:
-            return cls.constant_expr(expr)
-        
-        weights = []
-        
-        def deleteIndices(limit):
-            nonlocal weights
-            x, *ab = limit
-            if not x.is_random:
-                weights += [x, *ab]
-                return True
+        from sympy import cos, floor
 
-        if (ret := std.deleteIndices(limits, deleteIndices)) is not None:
-            limits = ret
-                
-        random_symbols = expr.random_symbols
-        if limits:
-            varsAltered = defaultdict(set)
-            for x, *ab in limits:
-                if ab or not x.shape:
-                    continue
-
-                for xk in random_symbols:
-                    if not xk.is_Indexed:
-                        continue
-                     
-                    if xk.base == x:
-                        varsAltered[x].add((xk,))
-                    elif x.is_Sliced and x.base == xk.base:
-                        if len(x.args) <= len(xk.args):
-                            for (start, stop), k in zip(x.indices, xk.indices):
-                                if start <= k < stop:
-                                    varsAltered[x].add((xk,))
-                
-            if varsAltered:
-                limits = [*limits]
-                for x, xks in varsAltered.items():
-                    i = std.indexFor(limits, lambda limit: limit[0] == x)
-                    std.splice(limits, i, 1, *xks)
-
-        else:
-            limits = [(x,) for x in random_symbols]
-            
-        if weights:
-            limits.append(tuple(weights))
-
-        if (given := kwargs.get('given')) is not None:
-            if given.is_symbol:
-                given = given.as_boolean()
-
-            expr = Conditioned(expr, given)
-
-        if expr.is_Conditioned:
-            given = expr.rhs
-            vars_given = set()
-            if given.is_Equal:
-                vars_given.add(given.lhs)
-
-            elif given.is_And:
-                for eq in given.args:
-                    if eq.is_Equal:
-                        vars_given.add(eq.lhs)
-                
-            def delete_vars_given(limit):
-                v, *ab = limit
-                return not ab and v in vars_given
-            
-            if (ret := std.deleteIndices(limits, delete_vars_given)) is not None:
-                limits = ret
-                                
-        return ExprWithLimits.__new__(cls, expr, *limits)
+        n = floor(start / S.Pi)
 
-    @classmethod
-    def constant_expr(cls, expr):
-        return expr
+        m = floor(stop / S.Pi)
 
-    @classmethod
-    def unnest(cls, expr, limits, symbols, **assumptions):
-        if not limits and symbols:
-            return expr.copy(**assumptions)
-        return Expr.__new__(cls, expr, *limits, **assumptions)
+        if n.is_even:
+            if n == m:
+                return self.func(cos(self.stop), cos(start),
+                                 left_open=self.right_open,
+                                 right_open=self.left_open,
+                                 integer=self.is_integer)
+        elif n.is_odd:
+            if n == m:
+                return self.copy(start=cos(start), stop=cos(self.stop))
 
-    def _eval_is_complex(self):
-        return True
+        return self.func(-1, 1)
 
-    def _has_weights(self):
-        return not self.args[-1][0].is_random
+    def acos(self):
+        from sympy import acos
 
-    @property
-    def limits(self):
-        return self.args[1:-1] if self._has_weights() else self.args[1:]
-    
-    @property
-    def weights(self):
-        return self.args[-1] if self._has_weights() else Tuple()
+        start, stop = self.args
 
-    @property
-    def expr(self):
-        return self.args[0]
+        return self.func(acos(stop), acos(start), left_open=self.right_open, right_open=self.left_open, integer=self.is_integer)
 
-    @property
-    def dtype(self):
-        return self.expr.dtype
+    def __truediv__(self, other):
+        if self.is_integer:
+            if other.is_One:
+                return self
+            if other.is_NegativeOne: 
+                return self.func(self.stop / other, self.start / other,
+                                 left_open=self.right_open, right_open=self.left_open, integer=self.is_integer)
+        else:
+            if other.is_extended_positive: 
+                return self.copy(start=self.start / other, stop=self.stop / other)
+            if other.is_extended_negative: 
+                return self.func(self.stop / other, self.start / other,
+                                 left_open=self.right_open, right_open=self.left_open, integer=self.is_integer)
 
     @cacheit
-    def _eval_shape(self):
-        return self.expr.shape
-
-    def expand(self, **hints):
-        expr = self.args[0]
-
-        if not is_random(expr):
-            return expr
+    def _has(self, pattern):
+        return self.start._has(pattern) or self.stop._has(pattern)
 
-        if isinstance(expr, Add):
-            return Add.fromiter(Expectation(a).expand() for a in expr.args)
-
-        expand_expr = _expand(expr)
-        if isinstance(expand_expr, Add):
-            return Add.fromiter(Expectation(a).expand() for a in expand_expr.args)
-
-        elif isinstance(expr, Mul):
-            rv = []
-            nonrv = []
-            for a in expr.args:
-                if is_random(a):
-                    rv.append(a)
-                else:
-                    nonrv.append(a)
-            return Mul.fromiter(nonrv) * Expectation(Mul.fromiter(rv))
+    def copy(self, **kwargs):
+        if 'start' not in kwargs:
+            start = self.start
+        else:
+            start = kwargs['start']
+            
+        if 'stop' not in kwargs:
+            stop = self.stop
+        else:
+            stop = kwargs['stop']
+            
+        if 'left_open' not in kwargs:
+            left_open = self.left_open
+        else:
+            left_open = kwargs['left_open']
 
+        if 'right_open' not in kwargs:
+            right_open = self.right_open
+        else:
+            right_open = kwargs['right_open']
+            
+        if left_open:
+            start += 1
+        if not right_open:
+            stop += 1
+        return self.func(start, stop)
+
+    def retain_odd(self):
+        i = self.generate_var(integer=True)
+        from sympy import Cup
+        return Cup[i:self]((2 * i + 1).set)
+        
+    def retain_even(self):
+        i = self.generate_var(integer=True)        
+        from sympy import Cup
+        return Cup[i:self]((2 * i).set)
+        
+    def _subs(self, old, new, **hints):
+        assert old != new
+        if self == old:
+            return new
+        
+        hit = False
+        [*args] = self.args
+        for i, arg in enumerate(args):
+            if not hasattr(arg, '_eval_subs'):
+                continue
+            arg = arg._subs(old, new, **hints)
+            if arg != args[i]:
+                hit = True
+                args[i] = arg
+        if hit:
+            return self.func(*args, **self.kwargs)
         return self
 
-    def doit(self, **hints):
-        if self.limits:
-            function = self.expr
-            for limit in self.limits:
-                x, distribution = limit
-                _x = x.copy(distribution=distribution)
-                expr = function._subs(x, _x)
-                if expr.is_Conditioned:
-                    expr = expr.doit()
-                if not expr.is_random:  # expr isn't random?
-                    return expr
-                ps = pspace(expr)
-                if ps == PSpace():
-                    return self.func(expr)
-                # Otherwise case is simple, pass work off to the ProbabilitySpace
-                function = ps.compute_expectation(expr, evaluate=True)
-                if hasattr(function, 'doit'):
-                    function = function.doit(**hints)
-            return function
-        else:
-            deep = hints.get('deep', True)
-            expr = self.args[0]
-            numsamples = hints.get('numsamples', False)
-            for_rewrite = not hints.get('for_rewrite', False)
-    
-            if deep:
-                expr = expr.doit(**hints)
-    
-            if not expr.is_random or isinstance(expr, Expectation):  # expr isn't random?
-                return expr
-            if numsamples:  # Computing by monte carlo sampling?
-                evalf = hints.get('evalf', True)
-                return sampling_E(expr, numsamples=numsamples, evalf=evalf)
-    
-            if expr.has(RandomIndexedSymbol):
-                return pspace(expr).compute_expectation(expr)
-    
-            # A few known statements for efficiency
-    
-            if expr.is_Add:  # We know that E is Linear
-                return Add(*[self.func(arg).doit(**hints)
-                        if not isinstance(arg, Expectation) else self.func(arg)
-                             for arg in expr.args])
-            if expr.is_Mul:
-                if expr.atoms(Expectation):
-                    return expr
-    
-            ps = pspace(expr)
-            if ps == PSpace():
-                return self.func(expr)
-            # Otherwise case is simple, pass work off to the ProbabilitySpace
-            result = ps.compute_expectation(expr, evaluate=for_rewrite)
-            if hasattr(result, 'doit') and for_rewrite:
-                return result.doit(**hints)
-            else:
-                return result
-
-    def _eval_rewrite_as_Probability(self, arg, condition=None, **kwargs):
-        rvs = arg.atoms(RandomSymbol)
-        if len(rvs) > 1:
-            raise NotImplementedError()
-        if len(rvs) == 0:
-            return arg
-
-        rv = rvs.pop()
-        if rv.pspace is None:
-            raise ValueError("Probability space not known")
-
-        symbol = rv.symbol
-        if symbol.name[0].isupper():
-            symbol = Symbol(symbol.name.lower())
-        else :
-            symbol = Symbol(symbol.name + "_1")
-
-        if rv.pspace.is_Continuous:
-            return Integral(arg.replace(rv, symbol) * Probability(Eq(rv, symbol), condition), (symbol, rv.pspace.domain.set.inf, rv.pspace.domain.set.sup))
-        else:
-            if rv.pspace.is_Finite:
-                raise NotImplementedError
-            else:
-                return Sum(arg.replace(rv, symbol) * Probability(Eq(rv, symbol), condition), (symbol, rv.pspace.domain.set.inf, rv.pspace.set.sup))
-
-    def _eval_rewrite_as_Integral(self, arg, condition=None, **kwargs):
-        return self.func(arg, condition=condition).doit(deep=False, for_rewrite=True)
+    @property
+    def etype(self):
+        return dtype.integer
 
-    _eval_rewrite_as_Sum = _eval_rewrite_as_Integral  # For discrete this will be Sum
+    def _pretty(self, p): 
+        if self.start == self.stop:
+            return p._print_seq(self.args[:1], '{', '}')
 
-    def evaluate_integral(self):
-        return self.rewrite(Integral).doit()
+        else:
+            left = '['
+            right = ')'
 
-    evaluate_sum = evaluate_integral
+            return p._print_seq(self.args[:2], left, right, delimiter=';')
 
-    def _latex(self, p):
-        tex = r'\mathop{\mathbb{E}}'
-        limits = self.limits
-
-        if weights := self.weights:
-            weights_str = ','.join([p._print(w) for w in weights])
-            def _format_ineq(limit):
-                if len(limit) == 1:
-                    return r"%s \sim %s" % (p._print(limit[0]), weights_str)
-                x, cond = limit
-                return r"%s \sim %s \mid %s" % (p._print(x), p._print(cond), weights_str)
-        else:
-            def _format_ineq(limit):
-                if len(limit) == 1:
-                    return p._print(limit[0])
-                x, cond = limit
-                return r"%s \sim %s" % (p._print(x), p._print(cond))
-
-        if not limits:
-            tex += ' '  
-        elif len(limits) == 1:
-            limit = limits[0]
-            if len(limit) == 1:
-                x, = limit
-                if weights:
-                    tex += r"_{%s \sim %s} " % (p._print(x), weights_str)
-                else:
-                    if self.scope_variables - {x}:
-                        tex += r"_{%s} " % p._print(x)
-            else:
-                tex += r"\limits_{%s} " % _format_ineq(limit)
+    def _sympystr(self, _): 
+        if self.step.is_One:
+            return '{left_open}{start}{sep} {stop}{right_open}'.format(**{'start': self.start, 'stop': self.stop, 'sep': ';',
+                             'left_open': '(' if self.left_open else '[',
+                             'right_open': ')' if self.right_open else ']'})
         else:
-            if all(len(limit) == 1 for limit in limits):
-                vars = [limit[0] for limit in limits]
-                if self.scope_variables - {*vars} or {*self.yield_random_symbols_from_expr()} - self.scope_variables:
-                    tex += r"_{%s} " % str.join(', ', [p._print(v) for v in vars])
-            else:
-                tex += r"\limits_{\begin{subarray}{c}%s\end{subarray}} " % str.join('\\\\', [_format_ineq(l) for l in limits])
-
-        tex += r"\left(%s\right)" % p._print(self.expr)
-        return tex
-
-    def _sympystr(self, p):
-        if weights := self.weights:
-            weights_str = ','.join([p._print(w) for w in weights])
-            def _format_ineq(limit):
-                if len(limit) == 1:
-                    return r"%s ~ %s" % (p._print(limit[0]), weights_str)
-                x, cond = limit
-                return r"%s ~ %s | %s" % (p._print(x), p._print(cond), weights_str)
-        else:
-            def _format_ineq(limit):
-                if len(limit) == 1:
-                    return p._print(limit[0])
-                x, cond = limit
-                return r"%s ~ %s" % (p._print(x), p._print(cond))
+            return 'Range(%s, %s, %s)' % (self.start, self.stop, self.step)
 
-        return 'E[%s](%s)' % (','.join([_format_ineq(limit) for limit in self.limits]), p._print(self.expr))
+    def handle_finite_sets(self, unk):
+        if all(arg.domain in self for arg in unk.args):
+            return unk
 
-    def _eval_is_random(self):
-        expr = self.expr
-        
-        variables_set = self.variables_set
-        if any(not any(V.index_contains(v) for V in variables_set) for v in expr.random_symbols): 
-            return True
-                
-        if expr.is_Conditioned:
-            for v in expr.rhs.yield_random_symbols():
-                if v.is_Surrogate:
-                    return True
+    def _hashable_content(self):
+        """Return a tuple of information about self that can be used to
+        compute the hash. If a class defines additional attributes,
+        like ``name`` in Symbol, then this method should be updated
+        accordingly to return such relevant attributes.
+
+        Defining more than _hashable_content is necessary if __eq__ has
+        been defined by a class. See note about this in Basic.__eq__."""
+
+        return self._args + (self.left_open, self.right_open)
 
     def _eval_is_finite(self):
-        return self.expr.is_finite
+        return (self.start.is_finite or self.left_open) and (self.stop.is_finite or self.right_open)
     
     def _eval_is_extended_integer(self):
-        return self.expr.is_extended_integer
+        return True
+        
+    def _eval_is_super_integer(self):
+        return True
     
-    def _eval_is_extended_real(self):
-        return self.expr.is_extended_real
-
-    def _eval_is_extended_complex(self):
-        return self.expr.is_extended_complex
-
-    def _eval_is_extended_positive(self):
-        return self.expr.is_extended_positive
-
-    def _eval_is_extended_negative(self):
-        return self.expr.is_extended_negative
+    def _eval_is_extended_rational(self):
+        return True        
 
-    def _if_new_has_variables(self, old, new):
-        return set()
+    def _eval_is_hyper_rational(self):
+        return True
+            
+    def _eval_is_super_rational(self):
+        return True
     
-    def simplify(self, deep=False):
-        [*limits] = self.limits
-        expr = self.expr
-        if expr.is_Conditioned:
-            expr, given = expr.args
-        else:
-            given = None
-            
-        def needDelete(limit):
-            x, *ab = limit
-            return not expr._has(x)
-
-        if std.deleteIndices(limits, needDelete) is not None:
-            if limits:
-                for limit in self.limits:
-                    x, *ab = limit
-                    if ab and x.is_random and not expr._has(x):
-                        limits.append(limit)
-                if weights := self.weights:
-                    limits.append(weights)
+    def _eval_is_extended_real(self):
+        return True        
 
-            if limits:
-                self = self.func(expr, *limits, given=given, evaluate=False)
-            else:
-                return expr
+    def _eval_is_hyper_real(self):
+        return True
             
-        random_symbols = expr.random_symbols
-        
-        varMapping = defaultdict(list)
-        for x, *ab in self.limits:
-            for v in random_symbols:
-                if x != v and x.index_contains(v):
-                    varMapping[x].append((v, *ab))
-                    
-        if varMapping:
-            for x, s in varMapping.items():
-                if len(s) == 1:
-                    s, = s
-                    i = self.variables.index(x)
-                    limits[i] = s
-                
-            self = self.func(expr, *limits, *self.weights, given=given, evaluate=False)
-
-        return ExprWithLimits.simplify(self, deep)
-
-    def yield_random_symbols_from_expr(self):
-        expr = self.expr
-        if expr.is_Conditioned:
-            yield from expr.lhs.yield_random_symbols()
-        else:
-            yield from expr.yield_random_symbols()
-
-    def yield_random_symbols_from_given(self):
-        expr = self.expr
-        if expr.is_Conditioned:
-            for v in expr.rhs.yield_random_symbols():
-                if v.is_Surrogate:
-                    yield v.arg
-
-    def yield_random_symbols(self):
-        variables = self.variables
-        for v in self.yield_random_symbols_from_expr():
-            if not any(V.index_contains(v) for V in variables):
-                yield v
-
-        yield from self.yield_random_symbols_from_given()
-
-        for x, *ab in self.limits:
-            for v in ab:
-                yield from v.yield_random_symbols()
-
-    def _has_random_symbols(self, pattern):
-        if pattern.is_random:
-            expr = self.expr
-            if expr.is_Conditioned:
-                for surrogate in expr.rhs.finditer(Surrogate):
-                    if surrogate._has(pattern):
-                        return True
-        else:
-            for surrogate in self.finditer(Surrogate):
-                if surrogate.arg.var._has(pattern):
-                    return True
-        
-    def _has_indexed(self, pattern):
-        if self._has_random_symbols(pattern):
+    def _eval_is_super_real(self):
+        return True
+   
+    def _eval_is_extended_negative(self):
+        if self.min().is_extended_nonnegative:
+            return False
+        if self.max().is_extended_negative:
             return True
-        return ExprWithLimits._has_indexed(self, pattern)
 
-    def _has_symbol(self, pattern):
-        if self._has_random_symbols(pattern):
-            return True
-        return ExprWithLimits._has_symbol(self, pattern)
-    
-    def _has_sliced(self, pattern):
-        if self._has_random_symbols(pattern):
+    def _eval_is_extended_positive(self):
+        if self.max().is_extended_nonpositive:
+            return False
+        if self.min().is_extended_positive:
             return True
-        return ExprWithLimits._has_sliced(self, pattern)
-    
-    def __iter__(self):
-        raise TypeError
-    
-    def __getitem__(self, indices, **kw_args):
-        return self.func(self.expr[indices], *self.limits, *self.weights)
 
-    @property
-    def limits_weights(self):
-        limits_weights = []
-        for v, *cond in self.limits:
-            if len(cond) == 1:
-                weight, = cond
-                if not weight.is_Distribution:
-                    if not v.is_Symbol:
-                        v = v.base
-                    limits_weights.append((v, *cond))
-        return limits_weights
-
-    def domain_definition(self):
-        expr = self.expr
-        if expr.is_Conditioned:
-            limits_weighted = self.limits_weights
-            limits_weighted = filter(lambda limit: expr.rhs._has(limit[0]), limits_weighted)
-            cond = Unequal(Probability(expr.rhs, *limits_weighted), 0)
-            if cond.has(*self.scope_variables):
-                return S.true
-        else:
-            cond = expr.domain_definition()
-            if cond.has(*self.variables):
-                return S.true
-
-        return cond
+    def _eval_is_extended_complex(self):
+        return True        
 
-    @cacheit
-    def _eval_scope_variables(self):
-        expr = self.expr
-        if expr.is_Conditioned:
-            expr, given = expr.args
-            vars_given = {v for v in given.random_symbols if not v.is_Surrogate}
-        else:
-            vars_given = set()
-        
-        from sympy.tensor.indexed import index_intersect, index_complement
-        random_variables = index_intersect(expr.random_symbols, self.variables)
-        return index_complement(random_variables, vars_given)
+    def _eval_is_hyper_complex(self):
+        return True
 
-    @property
-    def scope_variables(self):
-        return self._eval_scope_variables()
+    def _eval_is_algebraic(self):
+        return True        
 
-    def structurally_equal(self, other):
-        if other.func != self.func or len(self.args) != len(other.args):
-            return False
-        
-        if not self.expr.structurally_equal(other.expr):
+    def _eval_is_zero(self):
+        if self.min().is_extended_positive:
             return False
-        
-        if not self.weights.structurally_equal(other.weights):
+        if self.max().is_extended_negative:
             return False
 
-        limits = self.limits
-        _limits = other.limits
-        if len(limits) != len(_limits):
-            return False
-         
-        occupied = [None] * len(limits)
-        j = -1
-        size = len(_limits)
-        for limit in limits:
-            for _ in range(size):
-                j = (j + 1) % size
-                if occupied[j]:
-                    continue
-
-                _limit = _limits[j]
-                if limit.structurally_equal(_limit):
-                    occupied[j] = True
-                    break
+    def inverse(self):
+        return
+
+    def _latex(self, p):
+        if self.step.is_One:
+            if self.start.is_NegativeInfinity:
+                if self.stop.is_Infinity:
+                    if self.left_open and self.right_open: 
+                        return r"\mathbb{Z}"
+                elif self.stop.is_NegativeOne:
+                    if self.left_open and not self.right_open:
+                        return r"\mathbb{Z}^-"
+                                        
+            elif self.stop.is_Infinity:
+                if self.start.is_One:
+                    if not self.left_open and self.right_open:
+                        return r"\mathbb{Z}^+"
+            
+            if self.left_open:
+                left = '('
             else:
-                return False
+                left = '['
+    
+            if self.right_open:
+                right = ')'
+            else:
+                right = ']'
+    
+            return r"\left%s%s; %s\right%s" % (left, p._print(self.start), p._print(self.stop), right)
+        else:
+            return r"Range\left(%s, %s, %s\right)" % (p._print(self.start), p._print(self.stop), p._print(self.step))
 
-        return True
+    @classmethod
+    def simplify_Element(cls, self, e, s):
+        if s.is_integer and e.is_Add:
+            if not s.left_open or s.right_open:
+                if S.NegativeOne in e.args:
+                    s += S.One
+                    e += S.One
+                    return self.func(e, s, evaluate=False)
+                    
+            if s.left_open or not s.right_open:
+                if S.One in e.args:
+                    s -= S.One
+                    e -= S.One
+                    return self.func(e, s, evaluate=False)
+                
+        if e.is_integer == s.is_integer: 
+            if s.start is S.NegativeInfinity:
+                from sympy import Less, LessEqual
+                func = Less if s.right_open else LessEqual
+                if e.is_extended_real:
+                    return func(e, s.stop)
+                return
+            if s.stop is S.Infinity:
+                from sympy import Greater, GreaterEqual
+                func = Greater if s.left_open else GreaterEqual
+                if e.is_extended_real:
+                    return func(e, s.start).simplify()
+                return
+            complement = e.domain - s
+            if complement.is_FiniteSet:
+                return self.invert_type(e, complement).simplify()                
+            
+    @classmethod
+    def simplify_NotElement(cls, self, e, s):
+        if s.is_Range and e.is_Add:
+            if S.NegativeOne in e.args:
+                s += S.One
+                e += S.One
+                return self.func(e, s, evaluate=False).simplify()
+                    
+            if S.One in e.args: 
+                s += S.NegativeOne
+                e -= S.One
+                return self.func(e, s, evaluate=False).simplify()
 
-# precondition, self and other are structurally equal!
-    def _dummy_eq(self, other):
-        if other.func != self.func or len(self.args) != len(other.args):
-            return False
-        
-        if not self.expr._dummy_eq(other.expr):
-            return False
+    def _eval_Subset(self, rhs):
+        if rhs.is_UniversalSet:
+            return S.true
+        if rhs.is_Range:
+            if self.left_open == rhs.left_open:
+                if rhs.start == self.start:
+                    if self.right_open == rhs.right_open:
+                        if self.stop <= rhs.stop:
+                            return S.true
+            if self.right_open == rhs.right_open:
+                if rhs.stop == self.stop:
+                    if self.left_open == rhs.left_open:
+                        if self.start >= rhs.start:
+                            return S.true               
+
+        if rhs.is_Interval:
+            if not rhs.left_open:
+                if rhs.start == self.start:
+                    if self.right_open == rhs.right_open:
+                        if self.stop <= rhs.stop:
+                            return S.true
+            if rhs.right_open:
+                if rhs.stop == self.stop:
+                    if self.left_open == rhs.left_open:
+                        if self.start >= rhs.start:
+                            return S.true
+            else:
+                if rhs.stop == self.stop - 1:
+                    if rhs.left_open:
+                        if rhs.start.is_NegativeInfinity:
+                            return S.true
+                    else:
+                        if self.start >= rhs.start:
+                            return S.true                
+                                               
+    @property
+    def kwargs(self):
+        return {'left_open': self.left_open, 'right_open': self.right_open}
+                 
+    def _eval_Card(self):
+        from sympy import Piecewise
+        if self.step == 1:
+            return Piecewise((self.stop - self.start, self.stop >= self.start), (0, True))
+        else:
+            from sympy.functions.elementary.integers import Ceiling
+            return Piecewise((Ceiling((self.stop - self.start) / self.step), self.stop >= self.start), (0, True))
+
+
+    def delete_from_domain(self, x):
+        if self.step._has(x):
+            return self.etype.universalSet
         
-        if not self.weights._dummy_eq(other.weights):
-            return False
+        if self.start._has(x):
+            self = self.copy(start=S.NegativeInfinity)
+                    
+        if self.stop._has(x):
+            self = self.copy(stop=S.Infinity)
+            
+        return self
 
-        limits = self.limits
-        _limits = other.limits
-        if len(limits) != len(_limits):
-            return False
-         
-        occupied = [None] * len(limits)
-        j = -1
-        size = len(_limits)
-        for limit in limits:
-            for _ in range(size):
-                j = (j + 1) % size
-                if occupied[j]:
-                    continue
-
-                _limit = _limits[j]
-                if limit._dummy_eq(_limit):
-                    occupied[j] = True
-                    break
-            else:
-                return False
+converter[range] = Range
 
-        return True
-    
 
-class Variance(ExprWithLimits):
+def normalize_theta_set(theta):
     """
-    Symbolic expression for the variance.
+    Normalize a Real Set `theta` in the Interval [0, 2*pi). It returns
+    a normalized value of theta in the Set. For Interval, a maximum of
+    one cycle [0, 2*pi], is returned i.e. for theta equal to [0, 10*pi],
+    returned normalized value would be [0, 2*pi). As of now intervals
+    with end points as non-multiples of `pi` is not supported.
+
+    Raises
+    ======
+
+    NotImplementedError
+        The algorithms for Normalizing theta Set are not yet
+        implemented.
+    ValueError
+        The input is not valid, i.e. the input is not a real set.
+    RuntimeError
+        It is a bug, please report to the github issue tracker.
 
     Examples
     ========
 
-    >>> from sympy import symbols, Integral
-    >>> from sympy.stats import Normal, Expectation, Variance, Probability
-    >>> mu = symbols("mu", positive=True)
-    >>> sigma = symbols("sigma", positive=True)
-    >>> X = Normal("X", mu, sigma)
-    >>> Variance(X)
-    Variance(X)
-    >>> Variance(X).evaluate_integral()
-    sigma**2
-
-    Integral representation of the underlying calculations:
-
-    >>> Variance(X).rewrite(Integral)
-    Integral(sqrt(2)*(X - Integral(sqrt(2)*X*exp(-(X - mu)**2/(2*sigma**2))/(2*sqrt(pi)*sigma), (X, -oo, oo)))**2*exp(-(X - mu)**2/(2*sigma**2))/(2*sqrt(pi)*sigma), (X, -oo, oo))
-
-    Integral representation, without expanding the PDF:
-
-    >>> Variance(X).rewrite(Probability)
-    -Integral(x*Probability(Eq(X, x)), (x, -oo, oo))**2 + Integral(x**2*Probability(Eq(X, x)), (x, -oo, oo))
-
-    Rewrite the variance in terms of the expectation
-
-    >>> Variance(X).rewrite(Expectation)
-    -Expectation(X)**2 + Expectation(X**2)
-
-    Some transformations based on the properties of the variance may happen:
-
-    >>> from sympy.abc import a
-    >>> Y = Normal("Y", 0, 1)
-    >>> Variance(a*X)
-    Variance(a*X)
-
-    To expand the variance in its expression, use ``expand()``:
-
-    >>> Variance(a*X).expand()
-    a**2*Variance(X)
-    >>> Variance(X + Y)
-    Variance(X + Y)
-    >>> Variance(X + Y).expand()
-    2*Covariance(X, Y) + Variance(X) + Variance(Y)
+    >>> from sympy.sets.fancysets import normalize_theta_set
+    >>> from sympy import Interval, FiniteSet, pi
+    >>> normalize_theta_set(Interval(9*pi/2, 5*pi))
+    Interval(pi/2, pi)
+    >>> normalize_theta_set(Interval(-3*pi/2, pi/2))
+    Interval.Ropen(0, 2*pi)
+    >>> normalize_theta_set(Interval(-pi/2, pi/2))
+    Union(Interval(0, pi/2), Interval.Ropen(3*pi/2, 2*pi))
+    >>> normalize_theta_set(Interval(-4*pi, 3*pi))
+    Interval.Ropen(0, 2*pi)
+    >>> normalize_theta_set(Interval(-3*pi/2, -pi/2))
+    Interval(pi/2, 3*pi/2)
+    >>> normalize_theta_set(FiniteSet(0, pi, 3*pi))
+    {0, pi}
 
     """
+    from sympy.functions.elementary.trigonometric import _pi_coeff as coeff
 
-    __new__ = Expectation.__new__
-    
-    @classmethod
-    def constant_expr(cls, expr):
-        from sympy import ZeroMatrix
-        return ZeroMatrix(*expr.shape)
-
-    def expand(self, **hints):
-        arg = self.args[0]
-        condition = self._condition
+    if theta.is_Range or theta.is_Interval:
+        interval_len = theta.measure
+        # one complete circle
+        if interval_len >= 2 * S.Pi:
+            if interval_len == 2 * S.Pi and theta.left_open and theta.right_open:
+                k = coeff(theta.start)
+                return Union(Interval(0, k * S.Pi, left_open=False, right_open=True),
+                        Interval(k * S.Pi, 2 * S.Pi, left_open=True, right_open=True))
+            return Interval(0, 2 * S.Pi, left_open=False, right_open=True)
+
+        k_start, k_end = coeff(theta.start), coeff(theta.stop)
+
+        if k_start is None or k_end is None:
+            raise NotImplementedError("Normalizing theta without pi as coefficient is "
+                                    "not yet implemented")
+        new_start = k_start * S.Pi
+        new_end = k_end * S.Pi
+
+        if new_start > new_end:
+            return Union(Interval(S.Zero, new_end, left_open=False, right_open=theta.right_open),
+                         Interval(new_start, 2 * S.Pi, left_open=theta.left_open, right_open=True))
+        else:
+            return Interval(new_start, new_end, left_open=theta.left_open, right_open=theta.right_open)
+
+    elif theta.is_FiniteSet:
+        new_theta = []
+        for element in theta:
+            k = coeff(element)
+            if k is None:
+                raise NotImplementedError('Normalizing theta without pi as '
+                                          'coefficient, is not Implemented.')
+            else:
+                new_theta.append(k * S.Pi)
+        return FiniteSet(*new_theta)
 
-        if not is_random(arg):
-            return S.Zero
+    elif theta.is_Union:
+        return Union(*[normalize_theta_set(interval) for interval in theta.args])
 
-        if isinstance(arg, RandomSymbol):
-            return self
-        elif isinstance(arg, Add):
-            rv = []
-            for a in arg.args:
-                if is_random(a):
-                    rv.append(a)
-            variances = Add(*map(lambda xv: Variance(xv, condition).expand(), rv))
-            map_to_covar = lambda x: 2 * Covariance(*x, condition=condition).expand()
-            covariances = Add(*map(map_to_covar, itertools.combinations(rv, 2)))
-            return variances + covariances
-        elif isinstance(arg, Mul):
-            nonrv = []
-            rv = []
-            for a in arg.args:
-                if is_random(a):
-                    rv.append(a)
-                else:
-                    nonrv.append(a ** 2)
-            if len(rv) == 0:
-                return S.Zero
-            return Mul.fromiter(nonrv) * Variance(Mul.fromiter(rv), condition)
+    elif theta.is_subset(Reals):
+        raise NotImplementedError("Normalizing theta when, it is of type %s is not "
+                                  "implemented" % type(theta))
+    else:
+        raise ValueError(" %s is not a real set" % (theta))
 
-        # this expression contains a RandomSymbol somehow:
-        return self
 
-    def _eval_rewrite_as_Expectation(self, arg, condition=None, **kwargs):
-            e1 = Expectation(arg ** 2, condition)
-            e2 = Expectation(arg, condition) ** 2
-            return e1 - e2
+class ComplexRegion(Set):
+    """
+    Represents the Set of all Complex Numbers. It can represent a
+    region of Complex Plane in both the standard forms Polar and
+    Rectangular coordinates.
+
+    * Polar Form
+      Input is in the form of the ProductSet or Union of ProductSets
+      of the intervals of r and theta, & use the flag polar=True.
+
+    Z = {z in C | z = r*[cos(theta) + I*sin(theta)], r in [r], theta in [theta]}
+
+    * Rectangular Form
+      Input is in the form of the ProductSet or Union of ProductSets
+      of interval of x and y the of the Complex numbers in a Plane.
+      Default input type is in rectangular form.
 
-    def _eval_rewrite_as_Probability(self, arg, condition=None, **kwargs):
-        return self.rewrite(Expectation).rewrite(Probability)
+    Z = {z in C | z = x + I*y, x in [Re(z)], y in [Im(z)]}
 
-    def _eval_rewrite_as_Integral(self, arg, condition=None, **kwargs):
-        return variance(self.args[0], self._condition, evaluate=False)
+    Examples
+    ========
 
-    _eval_rewrite_as_Sum = _eval_rewrite_as_Integral
+    >>> from sympy.sets.fancysets import ComplexRegion
+    >>> from sympy.sets import Interval
+    >>> from sympy import S, I, Union
+    >>> a = Interval(2, 3)
+    >>> b = Interval(4, 6)
+    >>> c = Interval(1, 8)
+    >>> c1 = ComplexRegion(a*b)  # Rectangular Form
+    >>> c1
+    CartesianComplexRegion(ProductSet(Interval(2, 3), Interval(4, 6)))
+
+    * c1 represents the rectangular region in complex plane
+      surrounded by the coordinates (2, 4), (3, 4), (3, 6) and
+      (2, 6), of the four vertices.
+
+    >>> c2 = ComplexRegion(Union(a*b, b*c))
+    >>> c2
+    CartesianComplexRegion(Union(ProductSet(Interval(2, 3), Interval(4, 6)), ProductSet(Interval(4, 6), Interval(1, 8))))
+
+    * c2 represents the Union of two rectangular regions in complex
+      plane. One of them surrounded by the coordinates of c1 and
+      other surrounded by the coordinates (4, 1), (6, 1), (6, 8) and
+      (4, 8).
+
+    >>> 2.5 + 4.5*I in c1
+    True
+    >>> 2.5 + 6.5*I in c1
+    False
+
+    >>> r = Interval(0, 1)
+    >>> theta = Interval(0, 2*S.Pi)
+    >>> c2 = ComplexRegion(r*theta, polar=True)  # Polar Form
+    >>> c2  # unit Disk
+    PolarComplexRegion(ProductSet(Interval(0, 1), Interval.Ropen(0, 2*pi)))
+
+    * c2 represents the region in complex plane inside the
+      Unit Disk centered at the origin.
+
+    >>> 0.5 + 0.5*I in c2
+    True
+    >>> 1 + 2*I in c2
+    False
+
+    >>> unit_disk = ComplexRegion(Interval(0, 1)*Interval(0, 2*S.Pi), polar=True)
+    >>> upper_half_unit_disk = ComplexRegion(Interval(0, 1)*Interval(0, S.Pi), polar=True)
+    >>> intersection = unit_disk.intersect(upper_half_unit_disk)
+    >>> intersection
+    PolarComplexRegion(ProductSet(Interval(0, 1), Interval(0, pi)))
+    >>> intersection == upper_half_unit_disk
+    True
 
-    def evaluate_integral(self):
-        return self.rewrite(Integral).doit()
+    See Also
+    ========
 
-    def _latex(self, p):
-        tex = r'\mathop{\mathbb{Var}}'
-        limits = self.limits
-        
-        def _format_ineq(limit):
-            if len(limit) == 1:
-                return p._print(limit[0])
-            x, cond = limit
-            return r"%s \sim %s" % (p._print(x), p._print(cond))
-        
-        if not limits:
-            tex += ' '  
-        elif len(limits) == 1:
-            limit = limits[0]
-            if len(limit) == 1:
-                x, = limit
-                if {*self.expr.random_symbols} - {x}:
-                    tex += r"_{%s} " % p._print(x)
-            else:
-                tex += r"\limits_{%s} " % _format_ineq(limit)
-        else:
-            if all(len(limit) == 1 for limit in limits):
-                vars = [limit[0] for limit in limits]
-                if {*self.expr.random_symbols} - {*vars}:
-                    tex += r"_{%s} " % str.join(', ', [p._print(v) for v in vars])
-            else:
-                tex += r"\limits_{\begin{subarray}{c}%s\end{subarray}} " % str.join('\\\\', [_format_ineq(l) for l in limits])
-
-        tex += r"\left(%s\right)" % p._print(self.expr)
-        return tex
-
-    def _sympystr(self, p):
-        expr, *limits = self.args
-        if limits:
-            def _format_ineq(limit):
-                if len(limit) == 1:
-                    return p._print(limit[0])
-                x, cond = limit
-                return r"%s ~ %s" % (p._print(x), p._print(cond))
-            
-            return 'Var[%s](%s)' % (','.join([_format_ineq(limit) for limit in limits]), p._print(expr))
-        else:
-            return 'Var(%s)' % p._print(expr)
-
-    def _eval_shape(self):
-        shape = self.expr.shape
-        if not shape:
-            return ()
-        
-        if len(shape) == 1:
-            return shape * 2
-        
-        return *shape[:-1], shape[-2]
+    CartesianComplexRegion
+    PolarComplexRegion
+    Complexes
 
-    yield_random_symbols = Expectation.yield_random_symbols
-    yield_random_symbols_from_expr = Expectation.yield_random_symbols_from_expr
-    yield_random_symbols_from_given = Expectation.yield_random_symbols_from_given
-    
-    scope_variables = Expectation.scope_variables
-    
-    _eval_scope_variables = Expectation._eval_scope_variables
-    _eval_is_random = Expectation._eval_is_random
+    """
 
-    @classmethod
-    def is_identity(cls, expr):
-        ...
+    def union_sets(self, b):
+        if b.is_EmptySet:
+            return
+        
+        if b.is_subset(Reals):
+            # treat a subset of reals as a complex region
+            b = ComplexRegion.from_real(b)
+
+        if b.is_ComplexRegion:
+            # a in rectangular form
+            if (not self.polar) and (not b.polar):
+                return ComplexRegion(Union(self.sets, b.sets))
+            # a in polar form
+            elif self.polar and b.polar:
+                return ComplexRegion(Union(self.sets, b.sets), polar=True)
+        return None
+
+    def __new__(cls, sets, polar=False):
+        if polar is False:
+            return CartesianComplexRegion(sets)
+        elif polar is True:
+            return PolarComplexRegion(sets)
+        else:
+            raise ValueError("polar should be either True or False")
 
+    @property
+    def sets(self):
+        """
+        Return raw input sets to the self.
 
-class KL(Expr):
-    """
-    Symbolic expression for the Kullback-Leibler divergence.
-    """
+        Examples
+        ========
 
-    def __new__(cls, lhs, rhs, **kwargs):
-        assert lhs.is_Probability and rhs.is_Probability
-        if lhs == rhs:
-            return S.Zero
-        return Expr.__new__(cls, lhs, rhs)
+        >>> from sympy import Interval, ComplexRegion, Union
+        >>> a = Interval(2, 3)
+        >>> b = Interval(4, 5)
+        >>> c = Interval(1, 7)
+        >>> C1 = ComplexRegion(a*b)
+        >>> C1.sets
+        ProductSet(Interval(2, 3), Interval(4, 5))
+        >>> C2 = ComplexRegion(Union(a*b, b*c))
+        >>> C2.sets
+        Union(ProductSet(Interval(2, 3), Interval(4, 5)), ProductSet(Interval(4, 5), Interval(1, 7)))
 
-    def _latex(self, p):
-        tex = r'\mathop{\mathbb{KL}}'
-        lhs, rhs = self.args
-        limits = []
-        
-        def _format_ineq(limit):
-            if len(limit) == 1:
-                return p._print(limit[0])
-            x, cond = limit
-            return r"%s \sim %s" % (p._print(x), p._print(cond))
-        
-        if not limits:
-            tex += ' '  
-        elif len(limits) == 1:
-            limit = limits[0]
-            if len(limit) == 1:
-                x, = limit
-                if {*self.expr.random_symbols} - {x}:
-                    tex += r"_{%s} " % p._print(x)
-            else:
-                tex += r"\limits_{%s} " % _format_ineq(limit)
-        else:
-            if all(len(limit) == 1 for limit in limits):
-                vars = [limit[0] for limit in limits]
-                if {*self.expr.random_symbols} - {*vars}:
-                    tex += r"_{%s} " % str.join(', ', [p._print(v) for v in vars])
-            else:
-                tex += r"\limits_{\begin{subarray}{c}%s\end{subarray}} " % str.join('\\\\', [_format_ineq(l) for l in limits])
-        #\bigg/
-        tex += r"\left(%s\middle/%s\right)" % (p._print(lhs), p._print(rhs))
-        return tex
+        """
+        return self.args[0]
 
     @property
-    def shape(self):
-        return ()
-    
-    @property
-    def dtype(self):
-        from sympy import dtype
-        return dtype.real
+    def psets(self):
+        """
+        Return a tuple of sets (ProductSets) input of the self.
 
-    def _eval_is_extended_nonnegative(self):
-        return True
+        Examples
+        ========
 
-    def _sympystr(self, p):
-        lhs, rhs = self.args
-        limits = []
-
-        if limits:
-            def _format_ineq(limit):
-                if len(limit) == 1:
-                    return p._print(limit[0])
-                x, cond = limit
-                return r"%s ~ %s" % (p._print(x), p._print(cond))
-            
-            return 'KL[%s](%s, %s)' % (','.join([_format_ineq(limit) for limit in limits]), p._print(lhs), p._print(rhs))
+        >>> from sympy import Interval, ComplexRegion, Union
+        >>> a = Interval(2, 3)
+        >>> b = Interval(4, 5)
+        >>> c = Interval(1, 7)
+        >>> C1 = ComplexRegion(a*b)
+        >>> C1.psets
+        (ProductSet(Interval(2, 3), Interval(4, 5)),)
+        >>> C2 = ComplexRegion(Union(a*b, b*c))
+        >>> C2.psets
+        (ProductSet(Interval(2, 3), Interval(4, 5)), ProductSet(Interval(4, 5), Interval(1, 7)))
+
+        """
+        if self.sets.is_ProductSet:
+            psets = ()
+            psets = psets + (self.sets,)
         else:
-            return 'KL(%s, %s)' % (p._print(lhs), p._print(rhs))
+            psets = self.sets.args
+        return psets
 
-    def _eval_is_random(self):
-        return any(arg.is_random for arg in self.args)
+    @property
+    def a_interval(self):
+        """
+        Return the union of intervals of `x` when, self is in
+        rectangular form, or the union of intervals of `r` when
+        self is in polar form.
+
+        Examples
+        ========
+
+        >>> from sympy import Interval, ComplexRegion, Union
+        >>> a = Interval(2, 3)
+        >>> b = Interval(4, 5)
+        >>> c = Interval(1, 7)
+        >>> C1 = ComplexRegion(a*b)
+        >>> C1.a_interval
+        Interval(2, 3)
+        >>> C2 = ComplexRegion(Union(a*b, b*c))
+        >>> C2.a_interval
+        Union(Interval(2, 3), Interval(4, 5))
 
-    def _eval_is_finite(self):
-        lhs, rhs = self.args
-        from sympy import Log
-        return Log(lhs / rhs).is_finite
+        """
+        a_interval = []
+        for element in self.psets:
+            a_interval.append(element.args[0])
 
+        a_interval = Union(*a_interval)
+        return a_interval
 
-class Covariance(Expr):
-    """
-    Symbolic expression for the covariance.
+    @property
+    def b_interval(self):
+        """
+        Return the union of intervals of `y` when, self is in
+        rectangular form, or the union of intervals of `theta`
+        when self is in polar form.
+
+        Examples
+        ========
+
+        >>> from sympy import Interval, ComplexRegion, Union
+        >>> a = Interval(2, 3)
+        >>> b = Interval(4, 5)
+        >>> c = Interval(1, 7)
+        >>> C1 = ComplexRegion(a*b)
+        >>> C1.b_interval
+        Interval(4, 5)
+        >>> C2 = ComplexRegion(Union(a*b, b*c))
+        >>> C2.b_interval
+        Interval(1, 7)
 
-    Examples
-    ========
+        """
+        b_interval = []
+        for element in self.psets:
+            b_interval.append(element.args[1])
 
-    >>> from sympy.stats import Covariance
-    >>> from sympy.stats import Normal
-    >>> X = Normal("X", 3, 2)
-    >>> Y = Normal("Y", 0, 1)
-    >>> Z = Normal("Z", 0, 1)
-    >>> W = Normal("W", 0, 1)
-    >>> cexpr = Covariance(X, Y)
-    >>> cexpr
-    Covariance(X, Y)
-
-    Evaluate the covariance, `X` and `Y` are independent,
-    therefore zero is the result:
-
-    >>> cexpr.evaluate_integral()
-    0
-
-    Rewrite the covariance expression in terms of expectations:
-
-    >>> from sympy.stats import Expectation
-    >>> cexpr.rewrite(Expectation)
-    Expectation(X*Y) - Expectation(X)*Expectation(Y)
-
-    In order to expand the argument, use ``expand()``:
-
-    >>> from sympy.abc import a, b, c, d
-    >>> Covariance(a*X + b*Y, c*Z + d*W)
-    Covariance(a*X + b*Y, c*Z + d*W)
-    >>> Covariance(a*X + b*Y, c*Z + d*W).expand()
-    a*c*Covariance(X, Z) + a*d*Covariance(W, X) + b*c*Covariance(Y, Z) + b*d*Covariance(W, Y)
-
-    This class is aware of some properties of the covariance:
-
-    >>> Covariance(X, X).expand()
-    Variance(X)
-    >>> Covariance(a*X, b*Y).expand()
-    a*b*Covariance(X, Y)
-    """
+        b_interval = Union(*b_interval)
+        return b_interval
 
-    def __new__(cls, lhs, rhs, **kwargs):
-        if (given := kwargs.get('given')) is not None:
-            if given.is_symbol:
-                given = given.as_boolean()
+    @property
+    def _measure(self):
+        """
+        The measure of self.sets.
 
-            lhs = Conditioned(lhs, given)
-            rhs = Conditioned(rhs, given)
+        Examples
+        ========
 
-        return Expr.__new__(cls, lhs, rhs)
+        >>> from sympy import Interval, ComplexRegion, S
+        >>> a, b = Interval(2, 5), Interval(4, 8)
+        >>> c = Interval(0, 2*S.Pi)
+        >>> c1 = ComplexRegion(a*b)
+        >>> c1.measure
+        12
+        >>> c2 = ComplexRegion(a*c, polar=True)
+        >>> c2.measure
+        6*pi
 
-    def expand(self, **hints):
-        arg1 = self.args[0]
-        arg2 = self.args[1]
-        condition = self._condition
+        """
+        return self.sets._measure
 
-        if arg1 == arg2:
-            return Variance(arg1, condition).expand()
+    @classmethod
+    def from_real(cls, sets):
+        """
+        Converts given subset of real numbers to a complex region.
 
-        if not is_random(arg1):
-            return S.Zero
-        if not is_random(arg2):
-            return S.Zero
+        Examples
+        ========
 
-        arg1, arg2 = sorted([arg1, arg2], key=default_sort_key)
+        >>> from sympy import Interval, ComplexRegion
+        >>> unit = Interval(0,1)
+        >>> ComplexRegion.from_real(unit)
+        CartesianComplexRegion(ProductSet(Interval(0, 1), FiniteSet(0)))
 
-        if isinstance(arg1, RandomSymbol) and isinstance(arg2, RandomSymbol):
-            return Covariance(arg1, arg2, condition)
+        """
+        if not sets.is_subset(S.Reals):
+            raise ValueError("sets must be a subset of the real line")
 
-        coeff_rv_list1 = self._expand_single_argument(arg1.expand())
-        coeff_rv_list2 = self._expand_single_argument(arg2.expand())
+        return CartesianComplexRegion(sets * FiniteSet(0))
 
-        addends = [a * b * Covariance(*sorted([r1, r2], key=default_sort_key), condition=condition)
-                   for (a, r1) in coeff_rv_list1 for (b, r2) in coeff_rv_list2]
-        return Add.fromiter(addends)
+    def _contains(self, other):
+        from sympy.functions import arg, Abs
+        from sympy.core.containers import Tuple
+        other = sympify(other)
+        isTuple = isinstance(other, Tuple)
+        if isTuple and len(other) != 2:
+            raise ValueError('expecting Tuple of length 2')
+
+        # If the other is not an Expression, and neither a Tuple
+        if not isinstance(other, Expr) and not isinstance(other, Tuple):
+            return S.false
+        # self in rectangular form
+        if not self.polar:
+            re, im = other if isTuple else other.as_real_imag()
+            return fuzzy_or(fuzzy_and([
+                pset.args[0]._contains(re),
+                pset.args[1]._contains(im)])
+                for pset in self.psets)
+
+        # self in polar form
+        elif self.polar:
+            if other.is_zero:
+                # ignore undefined complex argument
+                return fuzzy_or(pset.args[0]._contains(S.Zero)
+                    for pset in self.psets)
+            if isTuple:
+                r, theta = other
+            else:
+                r, theta = Abs(other), arg(other)
+            if theta.is_real and theta.is_number:
+                # angles in psets are normalized to [0, 2pi)
+                theta %= 2 * S.Pi
+                return fuzzy_or(fuzzy_and([
+                    pset.args[0]._contains(r),
+                    pset.args[1]._contains(theta)])
+                    for pset in self.psets)
 
-    @classmethod
-    def _expand_single_argument(cls, expr):
-        # return (coefficient, random_symbol) pairs:
-        if isinstance(expr, RandomSymbol):
-            return [(S.One, expr)]
-        elif isinstance(expr, Add):
-            outval = []
-            for a in expr.args:
-                if isinstance(a, Mul):
-                    outval.append(cls._get_mul_nonrv_rv_tuple(a))
-                elif is_random(a):
-                    outval.append((S.One, a))
-
-            return outval
-        elif isinstance(expr, Mul):
-            return [cls._get_mul_nonrv_rv_tuple(expr)]
-        elif is_random(expr):
-            return [(S.One, expr)]
 
-    @classmethod
-    def _get_mul_nonrv_rv_tuple(cls, m):
-        rv = []
-        nonrv = []
-        for a in m.args:
-            if is_random(a):
-                rv.append(a)
-            else:
-                nonrv.append(a)
-        return (Mul.fromiter(nonrv), Mul.fromiter(rv))
+class CartesianComplexRegion(ComplexRegion):
+    """
+    Set representing a square region of the complex plane.
 
-    def _eval_rewrite_as_Expectation(self, arg1, arg2, condition=None, **kwargs):
-        e1 = Expectation(arg1 * arg2, condition)
-        e2 = Expectation(arg1, condition) * Expectation(arg2, condition)
-        return e1 - e2
+    Z = {z in C | z = x + I*y, x in [Re(z)], y in [Im(z)]}
 
-    def _eval_rewrite_as_Probability(self, arg1, arg2, condition=None, **kwargs):
-        return self.rewrite(Expectation).rewrite(Probability)
+    Examples
+    ========
 
-    def _eval_rewrite_as_Integral(self, arg1, arg2, condition=None, **kwargs):
-        return covariance(self.args[0], self.args[1], self._condition, evaluate=False)
+    >>> from sympy.sets.fancysets import ComplexRegion
+    >>> from sympy.sets.sets import Interval
+    >>> from sympy import I
+    >>> region = ComplexRegion(Interval(1, 3) * Interval(4, 6))
+    >>> 2 + 5*I in region
+    True
+    >>> 5*I in region
+    False
 
-    _eval_rewrite_as_Sum = _eval_rewrite_as_Integral
+    See also
+    ========
 
-    def evaluate_integral(self):
-        return self.rewrite(Integral).doit()
+    ComplexRegion
+    PolarComplexRegion
+    Complexes
+    """
 
-    @property
-    def given(self):
-        lhs, rhs = self.args
-        if lhs.is_Conditioned and rhs.is_Conditioned:
-            return lhs.rhs
+    polar = False
+    variables = symbols('x, y', cls=Dummy)
 
-    def _latex(self, p):
-        lhs, rhs = self.args
-        tex = r'\mathbb{Cov}'
-        given = self.given
-        if given is None:
-            tex += r"\left(%s,%s\right)" % (p._print(lhs), p._print(rhs))
-        else:
-            lhs = lhs.lhs
-            rhs = rhs.lhs
-            tex += r"\left(%s,%s \mathrel{\bigg|} %s\right)" % (p._print(lhs), p._print(rhs), p._print(given))
-        return tex
-
-    def _sympystr(self, p):
-        lhs, rhs = self.args
-        return 'Cov(%s, %s)' % (p._print(lhs), p._print(rhs))
-
-    @property
-    def dtype(self):
-        lhs, rhs = self.args
-        if lhs.dtype in rhs.dtype:
-            return rhs.dtype
-        return lhs.dtype
-    
-    def _eval_shape(self):
-        lhs, rhs = self.args
-        lhs_shape = lhs.shape
-        if lhs_shape:
-            *batch_size, size = lhs_shape
-            rhs_shape = rhs.shape
-            if len(rhs_shape) > 1:
-                return (*batch_size, rhs_shape[-2])
-            elif batch_size:
-                return batch_size
-            else:
-                return (*lhs_shape, *rhs_shape)
-        else:
-            return () 
+    def __new__(cls, sets):
 
-    def _eval_is_finite(self):
-        return fuzzy_et(arg.is_finite for arg in self.args)
-    
-    def _eval_is_extended_integer(self):
-        return fuzzy_et(arg.is_extended_integer for arg in self.args)
-    
-    def _eval_is_extended_real(self):
-        return fuzzy_et(arg.is_extended_real for arg in self.args)
+        if sets == S.Reals @ S.Reals:
+            return S.Complexes
 
-    def _eval_is_extended_complex(self):
-        return fuzzy_et(arg.is_extended_complex for arg in self.args)
-    
-    def _eval_is_random(self):
-        lhs, rhs = self.args
-        if lhs.is_Conditioned and rhs.is_Conditioned:
-            if lhs.rhs == rhs.rhs:
-                given = lhs.rhs
-                for v in given.random_symbols:
-                    if v.is_Surrogate:
-                        return True
-
-    def yield_random_symbols(self):
-        lhs, rhs = self.args
-        if lhs.is_Conditioned and rhs.is_Conditioned:
-            if lhs.rhs == rhs.rhs:
-                given = lhs.rhs
-                for v in given.random_symbols:
-                    if v.is_Surrogate:
-                        yield v.arg
-        
-    @cacheit
-    def _eval_domain_defined(self, x, **_):
-        lhs, rhs = self.args        
-        return lhs.domain_defined(x) & rhs.domain_defined(x)
+        if all(_a.is_FiniteSet for _a in sets.args) and (len(sets.args) == 2):
 
+            # ** ProductSet of FiniteSets in the Complex Plane. **
+            # For Cases like ComplexRegion({2, 4}*{3}), It
+            # would return {2 + 3*I, 4 + 3*I}
 
-class Moment(Expr):
+            # FIXME: This should probably be handled with something like:
+            # return ImageSet(Lambda((x, y), x+I*y), sets).rewrite(FiniteSet)
+            complex_num = []
+            for x in sets.args[0]:
+                for y in sets.args[1]:
+                    complex_num.append(x + S.ImaginaryUnit * y)
+            return FiniteSet(*complex_num)
+        else:
+            return Set.__new__(cls, sets)
+
+    @property
+    def expr(self):
+        x, y = self.variables
+        return x + S.ImaginaryUnit * y
+
+
+class PolarComplexRegion(ComplexRegion):
     """
-    Symbolic class for Moment
+    Set representing a polar region of the complex plane.
+
+    Z = {z in C | z = r*[cos(theta) + I*sin(theta)], r in [r], theta in [theta]}
 
     Examples
     ========
 
-    >>> from sympy import Symbol, Integral
-    >>> from sympy.stats import Normal, Expectation, Probability, Moment
-    >>> mu = Symbol('mu', real=True)
-    >>> sigma = Symbol('sigma', positive=True)
-    >>> X = Normal('X', mu, sigma)
-    >>> M = Moment(X, 3, 1)
+    >>> from sympy.sets.fancysets import ComplexRegion, Interval
+    >>> from sympy import oo, pi, I
+    >>> rset = Interval(0, oo)
+    >>> thetaset = Interval(0, pi)
+    >>> upper_half_plane = ComplexRegion(rset * thetaset, polar=True)
+    >>> 1 + I in upper_half_plane
+    True
+    >>> 1 - I in upper_half_plane
+    False
 
-    To evaluate the result of Moment use `doit`:
+    See also
+    ========
 
-    >>> M.doit()
-    mu**3 - 3*mu**2 + 3*mu*sigma**2 + 3*mu - 3*sigma**2 - 1
+    ComplexRegion
+    CartesianComplexRegion
+    Complexes
 
-    Rewrite the Moment expression in terms of Expectation:
+    """
 
-    >>> M.rewrite(Expectation)
-    Expectation((X - 1)**3)
+    polar = True
+    variables = symbols('r, theta', cls=Dummy)
 
-    Rewrite the Moment expression in terms of Probability:
+    def __new__(cls, sets):
 
-    >>> M.rewrite(Probability)
-    Integral((x - 1)**3*Probability(Eq(X, x)), (x, -oo, oo))
+        new_sets = []
+        # sets is Union of ProductSets
+        if not sets.is_ProductSet:
+            for k in sets.args:
+                new_sets.append(k)
+        # sets is ProductSets
+        else:
+            new_sets.append(sets)
+        # Normalize input theta
+        for k, v in enumerate(new_sets):
+            new_sets[k] = ProductSet(v.args[0],
+                                     normalize_theta_set(v.args[1]))
+        sets = Union(*new_sets)
+        return Set.__new__(cls, sets)
 
-    Rewrite the Moment expression in terms of Integral:
+    @property
+    def expr(self):
+        from sympy.functions.elementary.trigonometric import sin, cos
+        r, theta = self.variables
+        return r * (cos(theta) + S.ImaginaryUnit * sin(theta))
 
-    >>> M.rewrite(Integral)
-    Integral(sqrt(2)*(X - 1)**3*exp(-(X - mu)**2/(2*sigma**2))/(2*sqrt(pi)*sigma), (X, -oo, oo))
 
+class Complexes(CartesianComplexRegion, metaclass=Singleton):
     """
+    The Set of all complex numbers
 
-    def __new__(cls, X, n, c=0, condition=None, **kwargs):
-        X = _sympify(X)
-        n = _sympify(n)
-        c = _sympify(c)
-        if condition is not None:
-            condition = _sympify(condition)
-        return Expr.__new__(cls, X, n, c, condition)
-
-    def doit(self, **hints):
-        if not is_random(self.args[0]):
-            return self.args[0]
-        return self.rewrite(Expectation).doit(**hints)
-
-    def _eval_rewrite_as_Expectation(self, X, n, c=0, condition=None, **kwargs):
-        return Expectation((X - c) ** n, condition)
+    Examples
+    ========
 
-    def _eval_rewrite_as_Probability(self, X, n, c=0, condition=None, **kwargs):
-        return self.rewrite(Expectation).rewrite(Probability)
+    >>> from sympy import S, I
+    >>> S.Complexes
+    Complexes
+    >>> 1 + I in S.Complexes
+    True
 
-    def _eval_rewrite_as_Integral(self, X, n, c=0, condition=None, **kwargs):
-        return self.rewrite(Expectation).rewrite(Integral)
+    See also
+    ========
 
+    Reals
+    ComplexRegion
+	"""
+    
+    is_UniversalSet = True
+    
+    def __new__(cls):
+        return Set.__new__(cls, ProductSet(Reals, Reals))
 
-class CentralMoment(Expr):
-    """
-    Symbolic class Central Moment
+    def __str__(self):
+        return "S.Complexes"
 
-    Examples
-    ========
+    def _latex(self, p):
+        return r"\mathbb{C}"
 
-    >>> from sympy import Symbol, Integral
-    >>> from sympy.stats import Normal, Expectation, Probability, CentralMoment
-    >>> mu = Symbol('mu', real=True)
-    >>> sigma = Symbol('sigma', positive=True)
-    >>> X = Normal('X', mu, sigma)
-    >>> CM = CentralMoment(X, 4)
+    def __repr__(self):
+        return "S.Complexes"
 
-    To evaluate the result of CentralMoment use `doit`:
+    def __add__(self, other):
+        if not other.shape and other.is_complex:
+            return self
+        if other.is_set:
+            return self
+            
+        raise Exception("could not add %s, %s" % (self, other))
+
+    def __matmul__(self, other):
+        if other.is_set:
+            return ProductSet(self, other)
+        
+        raise Exception("could not multiply %s, %s" % (self, other))
+
+    def __mul__(self, other):
+        if other.is_set:
+            return ProductSet(self, other)
+        if other.is_complex:
+            return S.Complexes
+        raise Exception("could not multiply %s, %s" % (self, other))
 
-    >>> CM.doit().simplify()
-    3*sigma**4
+    @property
+    def etype(self):
+        return dtype.complex
 
-    Rewrite the CentralMoment expression in terms of Expectation:
+    def _contains(self, other):
+        if other.is_complex:
+            return True
 
-    >>> CM.rewrite(Expectation)
-    Expectation((X - Expectation(X))**4)
+        
+class ExtendedComplexes(CartesianComplexRegion, metaclass=Singleton):
+    
+    is_UniversalSet = True
+    
+    def __new__(cls):
+        return Set.__new__(cls, ProductSet(ExtendedReals, ExtendedReals))
+    
+    def __str__(self):
+        return "S.ExtendedComplexes"
 
-    Rewrite the CentralMoment expression in terms of Probability:
+    def _latex(self, p):
+        return r"\mathbb{*C}"
 
-    >>> CM.rewrite(Probability)
-    Integral((x - Integral(x*Probability(True), (x, -oo, oo)))**4*Probability(Eq(X, x)), (x, -oo, oo))
+    def __repr__(self):
+        return "S.ExtendedComplexes"
 
-    Rewrite the CentralMoment expression in terms of Integral:
+    def __add__(self, other):
+        return self
 
-    >>> CM.rewrite(Integral)
-    Integral(sqrt(2)*(X - Integral(sqrt(2)*X*exp(-(X - mu)**2/(2*sigma**2))/(2*sqrt(pi)*sigma), (X, -oo, oo)))**4*exp(-(X - mu)**2/(2*sigma**2))/(2*sqrt(pi)*sigma), (X, -oo, oo))
+    def __matmul__(self, other):
+        if other.is_set:
+            return ProductSet(self, other)
+        
+        raise Exception("could not multiply %s, %s" % (self, other))
+
+    def __mul__(self, other):
+        if other.is_set:
+            return ProductSet(self, other)
+        return self
 
-    """
+    @property
+    def etype(self):
+        return dtype.extended_complex
 
-    def __new__(cls, X, n, condition=None, **kwargs):
-        X = _sympify(X)
-        n = _sympify(n)
-        if condition is not None:
-            condition = _sympify(condition)
-        return Expr.__new__(cls, X, n, condition)
-
-    def doit(self, **hints):
-        if not is_random(self.args[0]):
-            return self.args[0]
-        return self.rewrite(Expectation).doit(**hints)
-
-    def _eval_rewrite_as_Expectation(self, X, n, condition=None, **kwargs):
-        mu = Expectation(X, condition, **kwargs)
-        return Moment(X, n, mu, condition, **kwargs).rewrite(Expectation)
+    def _contains(self, other):
+        if other.is_extended_complex:
+            return True
 
-    def _eval_rewrite_as_Probability(self, X, n, condition=None, **kwargs):
-        return self.rewrite(Expectation).rewrite(Probability)
 
-    def _eval_rewrite_as_Integral(self, X, n, condition=None, **kwargs):
-        return self.rewrite(Expectation).rewrite(Integral)
+def arange(*args):
+    from sympy.concrete.expr_with_limits import Lamda
+    args = [*map(sympify, args)]
+    if len(args) == 1:
+        [size] = args
+        i = size.generate_var(integer=True, var='i')
+        return Lamda[i:size](i)
+    
+    if len(args) == 2:
+        start, stop = args
+        i = stop.generate_var(integer=True, var='i', excludes=start.free_symbols)
+        return Lamda[i:stop - start](i + start)
+    
+    if len(args) == 3:
+        start, stop, step = args
+        i = stop.generate_var(integer=True, var='i', excludes=start.free_symbols | step.free_symbols)
+        from sympy.functions.elementary.integers import Ceiling
+        return Lamda[i: Ceiling((stop - start) / step)](i * step + start)
```

### Comparing `sympy.keras-1.0.21/sympy/strategies/__init__.py` & `sympy.keras-1.0.4/sympy/strategies/__init__.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/strategies/branch/core.py` & `sympy.keras-1.0.4/sympy/strategies/branch/core.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/strategies/branch/traverse.py` & `sympy.keras-1.0.4/sympy/strategies/branch/traverse.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/strategies/core.py` & `sympy.keras-1.0.4/sympy/strategies/core.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/strategies/rl.py` & `sympy.keras-1.0.4/sympy/strategies/rl.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/strategies/tools.py` & `sympy.keras-1.0.4/sympy/strategies/tools.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/strategies/traverse.py` & `sympy.keras-1.0.4/sympy/strategies/traverse.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/strategies/tree.py` & `sympy.keras-1.0.4/sympy/strategies/tree.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/tensor/array/__init__.py` & `sympy.keras-1.0.4/sympy/tensor/array/__init__.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/tensor/array/array_comprehension.py` & `sympy.keras-1.0.4/sympy/tensor/array/array_comprehension.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/tensor/array/arrayop.py` & `sympy.keras-1.0.4/sympy/tensor/array/arrayop.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/tensor/array/dense_ndim_array.py` & `sympy.keras-1.0.4/sympy/tensor/array/dense_ndim_array.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/tensor/array/ndim_array.py` & `sympy.keras-1.0.4/sympy/tensor/array/ndim_array.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/tensor/array/sparse_ndim_array.py` & `sympy.keras-1.0.4/sympy/tensor/array/sparse_ndim_array.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/tensor/functions.py` & `sympy.keras-1.0.4/sympy/tensor/functions.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/tensor/index_methods.py` & `sympy.keras-1.0.4/sympy/tensor/index_methods.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/tensor/indexed.py` & `sympy.keras-1.0.4/sympy/tensor/indexed.py`

 * *Files 17% similar despite different names*

```diff
@@ -127,20 +127,17 @@
 
     >>> A = IndexedBase('A')
     >>> Indexed('A', i, j) == A[i, j]
     True
 
     """
     is_commutative = True
+    is_symbol = True
     is_Atom = True
 
-    @property
-    def is_symbol(self):
-        return self.base.is_symbol
-    
     @classmethod
     def class_key(cls):
         return 3, 0, cls.__name__
 
     def __iter__(self):
         raise TypeError
 
@@ -149,71 +146,55 @@
             if isinstance(indices[-1], slice):
                 value, *slices = value.of(Sliced)
                 
                 size = len(slices)
                 for i in range(size):
                     start, stop = slices[i].of(Tuple)
                     index = indices[i - size]
-                    assert index.start == start
+                    assert index.start == start 
                     assert index.stop == stop
                     
                 indices = indices[:-size]
                 self[indices] = value
             else:
                 args = value.of(Indexed)
                 assert self == args[0]
                 assert args[1:] == indices
         else:
             if isinstance(indices, slice):
                 base, sliced = value.of(Sliced)
                 start, stop = sliced.of(Tuple)
-                assert indices.start == start
+                assert indices.start == start 
                 assert indices.stop == stop
                 
                 assert self == base
 
             else:
                 base, index = value.of(Indexed)
                 assert self == base
                 assert index == indices
 
     def __getitem__(self, indices, **kw_args):
         if (indices := self.simplify_indices(indices)) is None:
             return self
         
         if isinstance(indices, tuple):
-            for pivot, index in enumerate(indices):
-                if isinstance(index, Tuple):
-                    break
-            else:
-                pivot += 1
-                
-            indices, slices = indices[:pivot], indices[pivot:]
-            if slices:
-                if indices:
-                    return self[indices][slices]
-                
-                for pivot, index in enumerate(slices):
-                    if not isinstance(index, Tuple):
-                        break
-                else:
-                    pivot += 1
-                    
-                slices, indices = slices[:pivot], slices[pivot:]
-                if indices:
-                    index, *indices = indices
-                    self = SlicedIndexed(self, *slices, index)
+            if len(indices) >= 2 and isinstance(indices[0], Tuple):
+                for i in range(1, len(indices)):
+                    if isinstance(indices[i], Tuple):
+                        continue
+                    self = SlicedIndexed(self, *indices[:i], indices[i])
+                    indices = indices[i + 1:]
                     if indices:
                         self = self[indices]
                     return self
+                    
+                return Sliced(self, *indices)
                 
-                return Sliced(self, *slices)
-            
-            indices = self.indices + indices
-            
+            indices = self.indices + tuple(indices)
         elif isinstance(indices, Tuple):
             start, stop, step = indices.slice_args
             if start is None:
                 start = 0
                 
             if stop is None:
                 stop = self.shape[0]
@@ -388,43 +369,34 @@
                 ranges.append(None)
         return ranges
 
     def _sympystr(self, p):
         indices = list(map(p.doprint, self.indices))
         return "%s[%s]" % (p.doprint(self.base), ", ".join(indices))
 
-    def _latex(self, p, **kwargs):
+    def _latex(self, p):
         shape = self.base.shape
-        exp = None
-        if self.base.is_Symbol:
-            import re
-            if m := re.match("(\w+)\^([\w-]+)", self.base.name):
-                tex_base, exp = m.groups()
-
-        if exp is None:
-            tex_base = self.base._latex(p, **kwargs)
-
+        tex_base = p._print(self.base)
+        if self.is_random:
+            tex_base = r'{\color{red} {%s}}' % tex_base
         indices = [*self.indices]
         
         for i, index in enumerate(indices):
             length = shape[i]
             if index.is_Add:
                 if length in index.args:
                     negative_index = index - length
                     if negative_index.is_extended_negative:
                         indices[i] = negative_index
                  
-        if exp is None:
-            return '{%s}_{%s}' % (tex_base, ','.join(map(p._print, indices)))
-        
-        return '{%s}_{%s}^{%s}' % (tex_base, ','.join(map(p._print, indices)), exp)
+        return '{' + tex_base + '}' + '_{%s}' % ','.join(map(p._print, indices))
 
     @cacheit
     def _eval_free_symbols(self):
-        base = self.base
+        base = self.base        
         indices_free_symbols = {fs for i in self.indices for fs in i.free_symbols}
         base_free_symbols = indices_free_symbols | base.free_symbols
         if 'definition' in base._assumptions or base.is_AppliedUndef:
             ...
         else: 
             base_free_symbols.add(self)
         return base_free_symbols
@@ -558,45 +530,42 @@
             
             if len(self_indices) > len(old_indices):
                 old_indices = [*old_indices]  # make a copy first
                 shape = self.base.shape
                 while len(self_indices) > len(old_indices): 
                     old_indices.append((0, shape[len(old_indices)]))
 #             elif len(self_indices) < len(old_indices):
-                # could not substitute for an index with fewer args than that of a slice
+                # could not substitute for an index with fewer args than that of a slice                                                        
                     
             indices = []
-            
-            from sympy import Range
             for k, (start, stop) in zip(self_indices, old_indices):
-                if Range(start, stop).conditionally_contains(k):
+                if k >= start and k < stop:
                     indices.append(k - start)
                 else: 
                     break
             else: 
                 return new[tuple(indices)]
-
         return Expr._subs_sliced(self, old, new, **hints)
 
     def _eval_is_random(self):
-        return any(arg.is_random for arg in self.args)
+        return self.base.is_random
 
     @property
     def distribution(self):
         distribution = self.base.distribution
         if distribution is not None:
             return distribution
                          
         definition = self.definition
         if definition is not None: 
             if self.is_integer:
                 from sympy.stats.drv_types import AbstractDiscreteDistribution
                 return AbstractDiscreteDistribution(definition.function)
             else: 
-                from sympy.stats.crv_types import AbstractContinuousDistribution
+                from sympy.stats.crv_types import AbstractContinuousDistribution                
                 return AbstractContinuousDistribution(definition) 
 
     @property
     def dtype(self):
         return self.base.dtype
 
     @cacheit
@@ -615,15 +584,15 @@
                     return x.domain & domain
                 
         if not self.base.is_AppliedUndef:
             definition = self.definition
             if definition is not None:
                 return definition.domain_defined(x)
             
-        domain = x.domain
+        domain = x.domain          
          
         for index in self.indices:
             domain &= index.domain_defined(x)
         return domain
 
     @property
     def definition(self):
@@ -664,18 +633,18 @@
     def copy(self, **kwargs):
         return self.base.copy(**kwargs)[self.indices]
 
     def equality_defined(self):
         from sympy import Equal
         return Equal(self, self.definition, evaluate=False)
 
-    def _eval_determinant(self, **kwargs):
+    def _eval_determinant(self):
         definition = self.definition
         if definition is not None:
-            return definition._eval_determinant(**kwargs)
+            return definition._eval_determinant()
 
     def generate_int_limit(self, *args, **kwargs):
         definition = self.definition
         if definition is not None:
             return definition.generate_int_limit(*args, **kwargs) 
         return Expr.generate_int_limit(self, *args, **kwargs)
       
@@ -691,16 +660,15 @@
 
     @property
     def domain(self): 
         if self.is_set:
             return self.universalSet
         definition = self.defun()
         if definition is not None:
-            if self is not definition:
-                return definition.domain
+            return definition.domain
         
         from sympy import Interval, Range
         domain = self.base.domain_assumed
         if domain is None:
             
             assumptions = self.base.assumptions0
             integer = assumptions.pop('integer', None)
@@ -732,15 +700,19 @@
     @property
     def is_given(self): 
         return self.base.is_given
 #         if self.base.is_given:
 #             return True
 #         return all(index.is_given for index in self.indices)
 
-    as_boolean = Symbol.as_boolean
+    def as_boolean(self):
+        if self.is_random:
+            from sympy import Equal
+            from sympy.stats.rv import pspace
+            return Equal(self, pspace(self).symbol)
 
     def condition_set(self):
         definition = self.definition
         if definition is None:
             return
         return definition.condition_set()
 
@@ -764,38 +736,28 @@
         if cls.is_IndexedOperator and cls.func.is_Symbol:
             return self.of(Indexed[(Symbol,) + cls.args])
         return Expr.of(self, cls)
  
     of_simple_poly = Symbol.of_simple_poly
     
     monotonicity = Symbol.monotonicity
-        
-    def enlarge_indices(self, limits, expr=None):
+    
+    def enlarge_indices(self, limits):
         base, *indices = self.args
         
         indices_transformed = [*indices]
         hit = False
-        for limit in limits:
-            i, *ab = limit
-            if not i.is_integer:
-                continue
-
-            if len(ab) == 2 and not ab[1].is_set:
-                if args := enlarge_indices(limit, indices_transformed):
-                    t, args = args
-                    indices_transformed[t] = args
-                    hit = True
-
-            elif not ab and expr is not None:
-                domain = expr.domain_defined(i)
-                if domain.is_Range:
-                    if args := enlarge_indices((i, *domain.args), indices_transformed):
-                        t, args = args
-                        indices_transformed[t] = args
-                        hit = True
+        for i, *ab in limits:
+            if i in indices:
+                index = indices.index(i)
+                if len(ab) == 2:
+                    a, b = ab
+                    if b.is_integer:
+                        indices_transformed[index] = Tuple(a, b)
+                        hit = True 
                 
         if hit:
             return base[tuple(indices_transformed)]
         
         return self
                                 
     def _eval_torch(self):
@@ -896,18 +858,16 @@
                                 if len(ab) == 2:
                                     zero, shape = ab
                                     assert zero.is_zero
                                     step = 1
                                 else:
                                     [domain] = ab
                                     zero, shape, step = domain.args
-                            else:
-                                shape = self.shape[0]
-
-                            return expr.base[indices[:i] + (slice(start, shape + start, step),) + indices[i + 1:]]
+                                    
+                                return expr.base[indices[:i] + (slice(start, shape + start, step),) + indices[i + 1:]]
                             
                         elif step:
                             _, *ab = self.limits[0]
                             if ab:
                                 if len(ab) == 2:
                                     zero, shape = ab
                                     assert zero.is_zero
@@ -947,132 +907,15 @@
                 i += 1
                 
             if hit:
                 return expr.base[indices]
                 
         return self
         
-    @property
-    def var(self):
-        assert self.base.is_random
-        assert not any(index.is_random for index in self.indices)
-        return self.base.var[self.indices]
-
-    @property
-    def surrogate(self):
-        assert self.base.is_random
-        assert not any(index.is_random for index in self.indices)
-        return self.base.surrogate[self.indices]
-
-    def __and__(self, other):
-        """Overloading for & operator"""
-        if self.is_random and other.is_random:
-            if not other.is_bool:
-                other = other.as_boolean()
-            return self.as_boolean() & other
         
-        return super(Indexed, self).__and__(other)
-
-# performing other.indices in self.indices
-    def index_contains(self, other):
-        if other.is_Sliced or other.is_SlicedIndexed:
-            return self.index_contains(other.base)
-
-        if other.is_Indexed:
-            if self.base != other.base:
-                return
-            return indices_contains_indices(self.indices, other.indices)
-
-# performing indices intersection
-    def index_intersect(self, other):
-        if other.is_Sliced or other.is_SlicedIndexed:
-            if self.index_contains(other.base):
-                return other
-            return
-
-        if other.is_Indexed:
-            if self.base != other.base:
-                return
-            
-            if indices_contains_indices(self.indices, other.indices):
-                return other
-
-            if indices_contains_indices(other.indices, self.indices):
-                return self
-
-# performing indices complement
-    def index_complement(self, other):
-        if other.is_Sliced or other.is_SlicedIndexed:
-            if other.index_contains(self):
-                return
-            else:
-                return self
-
-        if other.is_Indexed:
-            if self.base == other.base:
-                if indices_contains_indices(self.indices, other.indices):
-                    return
-
-        return self
-
-    @property
-    def is_bounded(self):
-        self = self.base
-        if self.is_Symbol:
-            if 'domain' in self._assumptions:
-                return True
-            
-            if  'positive' in self._assumptions:
-                return True
-            if  'negative' in self._assumptions:
-                return True
-            if  'nonpositive' in self._assumptions:
-                return True
-            if  'nonnegative' in self._assumptions:
-                return True
-            if  'odd' in self._assumptions:
-                return True
-            if  'even' in self._assumptions:
-                return True
-            if  'prime' in self._assumptions:
-                return True
-
-    @property
-    def domain_bounded(self):
-        base = self.base
-        if base.is_Symbol: 
-            from sympy import CartesianSpace
-            from sympy import Interval, oo, Range
-            if 'domain' in base._assumptions:
-                domain = base._assumptions['domain']
-            elif base.is_positive:
-                if base.is_integer:
-                    domain = Range(1, oo)
-                else:
-                    domain = Interval(0, oo, left_open=True)
-            elif base.is_negative:
-                if base.is_integer:
-                    domain = Range(-oo, 0)
-                else:
-                    domain = Interval(-oo, 0, right_open=True)
-            elif base.is_nonpositive:
-                if base.is_integer:
-                    domain = Range(-oo, 1)
-                else:
-                    domain = Interval(-oo, 0)
-            elif base.is_nonnegative:
-                if base.is_integer:
-                    domain = Range(oo)
-                else:
-                    domain = Interval(0, oo)
-            else:
-                return
-            
-            return CartesianSpace(domain, *self.shape)
-
 class Sliced(Expr):
     """Represents a mathematical object with Slices,
     in the form of x[start0:stop0, ..., start1:stop1]
     """
     is_symbol = True
     is_Atom = True
 
@@ -1093,15 +936,15 @@
                          
         definition = self.definition
         if definition is not None: 
             if self.is_integer:
                 from sympy.stats.drv_types import AbstractDiscreteDistribution
                 return AbstractDiscreteDistribution(definition.function)
             else: 
-                from sympy.stats.crv_types import AbstractContinuousDistribution
+                from sympy.stats.crv_types import AbstractContinuousDistribution                
                 return AbstractContinuousDistribution(definition) 
 
     @property
     def definition(self):
         return self.defun()
 
     @cacheit
@@ -1116,15 +959,15 @@
     @property
     def domain_assumed(self):
         return self.base.domain_assumed
 
     @property
     def domain(self): 
         if self.dtype.is_set:
-            return self.universalSet
+            return self.universalSet    
 
         from sympy import Interval, Range
         domain = self.base.domain_assumed
         if domain is None:
             assumptions = self.base.assumptions0
             integer = assumptions.pop('integer', None)
             if integer:
@@ -1144,160 +987,25 @@
     def structurally_equal(self, other):
         if other.is_symbol:
             return self.shape == other.shape
         return False
 
 # performing other.indices in self.indices
     def index_contains(self, other):
-        if other.is_Indexed:
-            if self.base != other.base: 
-                return
-
-            slices = self.indices
-            _indices = other.indices
-            if len(_indices) < len(slices):
-                return
-            
-            return slices_contains_indices(slices, _indices)
-
-        if other.is_Sliced:
-            base = self.base
-            _base = other.base
-            if base == _base: 
-                slices = self.indices
-                _slices = other.indices
-                if len(_slices) < len(slices):
-                    return
-        
-                return slices_contains_slices(slices, _slices)
-            
-            elif _base.is_Indexed and _base.base == base:
-                slices = self.indices
-                _indices, _slices = other.indices_slices()
-                
-                if len(_indices) + len(_slices) < len(slices):
-                    return
-                
-                if not slices_contains_indices(slices, _indices):
-                    return
-                
-                if len(_indices) >= len(slices):
-                    return True
-                
-                return slices_contains_slices(slices[len(_indices):], _slices)
-
-        if other.is_SlicedIndexed:
-            if self.base != other.base: 
-                return
-            
-            slices = self.indices
-            _slices, _indices = other.slices_indices
-            if len(_slices) + len(_indices) < len(self.indices):
-                return
-    
-            if not slices_contains_slices(slices, _slices):
-                return
-            
-            if len(_slices) >= len(slices):
-                return True
-            
-            return slices_contains_indices(slices, _indices)
-
-    def index_complement(self, other):
         if not (other.is_Indexed or other.is_Sliced) or self.base != other.base: 
-            return self
+            return False
         
         if len(other.indices) != len(self.indices):
-            return self
+            return False
 
-        indices = []
-        from sympy import Range, FiniteSet
         if other.is_Sliced:
-            indices = []
-            for (start, stop), (_start, _stop) in zip(self.indices, other.indices):
-                if start == _start and stop >= _stop:
-                    indices.append(Range(_stop, stop))
-                else:
-                    indices.append(Range(start, stop) - Range(_start, _stop))
+            return all(_start >= start and _stop <= stop for (start, stop), (_start, _stop) in zip(self.indices, other.indices)) 
         else:
-            indices = [Range(start, stop) - FiniteSet(index) for (start, stop), index in zip(self.indices, other.indices)]
-
-        for i, index in enumerate(indices): 
-            if index.is_Range:
-                indices[i] = slice(index.start, index.stop)
-            elif index.is_FiniteSet:
-                indices[i] = next(iter(index))
-            else:
-                return self
-
-        return self.base[tuple(indices)]
+            return all(index >= start and index < stop for (start, stop), index in zip(self.indices, other.indices))
 
-# performing indices intersection
-    def index_intersect(self, other):
-        if other.is_Indexed:
-            if self.base != other.base: 
-                return
-
-            slices = self.indices
-            _indices = other.indices
-            if len(_indices) < len(slices):
-                return
-            
-            if slices_contains_indices(slices, _indices):
-                return other
-
-            return
-
-        if other.is_Sliced:
-            base = self.base
-            _base = other.base
-            if base == _base: 
-                slices = self.indices
-                _slices = other.indices
-                if len(_slices) >= len(slices):
-                    if slices_contains_slices(slices, _slices):
-                        return other
-                else:
-                    if slices_contains_slices(_slices, slices):
-                        return self
-            
-            elif _base.is_Indexed and _base.base == base:
-                slices = self.indices
-                _indices, _slices = other.indices_slices()
-                
-                if len(_indices) + len(_slices) < len(slices):
-                    return
-                
-                if not slices_contains_indices(slices, _indices):
-                    return
-                
-                if len(_indices) >= len(slices):
-                    return other
-                
-                if slices_contains_slices(slices[len(_indices):], _slices):
-                    return other
-
-        if other.is_SlicedIndexed:
-            if self.base != other.base: 
-                return
-            
-            slices = self.indices
-            _slices, _indices = other.slices_indices
-            if len(_slices) + len(_indices) < len(self.indices):
-                return
-    
-            if not slices_contains_slices(slices, _slices):
-                return
-            
-            if len(_slices) >= len(slices):
-                return other
-            
-            if slices_contains_indices(slices, _indices):
-                return other
-        
     def cup_finiteset(self, var=None):
         from sympy.concrete.sets import Cup
         i = self.generate_var(integer=True, var=var)
         return Cup({self.base[i]}, (i, *self.index))
 
     @cacheit
     def __new__(cls, base, *indices, **kw_args):
@@ -1314,16 +1022,15 @@
             if stop is None:
                 stop = base.shape[i]
             elif stop < 0:
                 stop = base.shape[i] + stop
             else: 
                 stop = sympify(stop)
                 
-            if start == stop:
-                raise Exception('empty slices')
+            assert start != stop, "%s != %s" % (start, stop)
             
             if step is None:
                 step = S.One
                 
             if step == 1:
                 indices[i] = Tuple(start, stop)
             else:
@@ -1414,41 +1121,39 @@
         return self_indices
             
     def get_parallel_indices(self, start, indices):
         [*self_indices] = self.indices[start: start + len(indices)]
         for i, (self_index, index) in enumerate(zip(self_indices, indices)):
             self_indices[i] = self_index[0] + index
             
-        if len(indices) > len(self_indices):
-            self_indices.extend(indices[len(self_indices):])
         return self_indices
     
     def __setitem__(self, indices, value):
         if isinstance(indices, tuple):
             if isinstance(indices[-1], slice):
                 value, *slices = value.of(Sliced)
                 
                 size = len(slices)
                 for i in range(size):
                     start, stop = slices[i].of(Tuple)
                     index = indices[i - size]
-                    assert index.start == start
+                    assert index.start == start 
                     assert index.stop == stop
                     
                 indices = indices[:-size]
                 self[indices] = value
             else:
                 args = value.of(Indexed)
                 assert self == args[0]
                 assert args[1:] == indices
         else:
             if isinstance(indices, slice):
                 base, sliced = value.of(Sliced)
                 start, stop = sliced.of(Tuple)
-                assert indices.start == start
+                assert indices.start == start 
                 assert indices.stop == stop
                 
                 assert self == base
 
             else:
                 base, index = value.of(Indexed)
                 assert self == base
@@ -1469,15 +1174,15 @@
                         index *= step
                     base = base[start + index]
                     
                 return self.func(base, *self.indices[len(indices):])
             else:
                 
                 for pivot, index in enumerate(indices):
-                    if not isinstance(index, Tuple):
+                    if not isinstance(index, Tuple):                        
                         break
                 else:
                     pivot += 1
 
                 # former must be a tuple of slices;
                 former = indices[:pivot]
                 if len(former) > len(self.indices):
@@ -1546,16 +1251,16 @@
                     if size.is_Ceiling:
                         stop = size.arg * step + start
                         
                     return self.base[start:stop:step]
                 else:
                     raise "unimplemented cases"
         else:
-            (start, stop), *slices = self.indices
-            return self.base[tuple([indices + start] + slices)]
+            start, stop = self.index
+            return self.base[indices + start]
 
     def _eval_derivative(self, wrt):
         from sympy.tensor.array.ndim_array import NDimArray
         from sympy.functions.special.tensor_functions import KroneckerDelta
         
         if isinstance(wrt, Indexed) and wrt.base == self.base:
             if len(self.indices) != len(wrt.indices):
@@ -1668,40 +1373,22 @@
         if base.is_Indexed:
             base, *indices = base.args
             indices = [p._print(index) for index in indices] + [*self.index_generator(p)]
         else:
             indices = self.index_generator(p)            
         return "%s[%s]" % (p.doprint(base), ', '.join(indices))
 
-    def _latex(self, p, **kwargs):
-        base = self.base
-        exp = None
-        import re
-        if base.is_Indexed:
-            if base.base.is_Symbol:
-                if m := re.match("(\w+)\^([\w-]+)", base.base.name):
-                    tex_base, exp = m.groups()
-                
-            indices = [p._print(index) for index in base.indices]
+    def _latex(self, p):
+        if self.base.is_Indexed:
+            indices = [p._print(index) for index in self.base.indices]
             indices += [*self.index_generator(p)]
-            if exp is None:
-                tex = '{%s}_{%s}' % (base.base._latex(p, **kwargs), ', '.join(indices))
-            else:
-                tex = '{%s}_{%s}^{%s}' % (tex_base, ', '.join(indices), exp)
+            
+            tex = '{%s}_{%s}' % (p._print(self.base.base), ', '.join(indices))        
         else:
-            if base.is_Symbol:
-                if m := re.match("(\w+)\^([\w-]+)", base.name):
-                    tex_base, exp = m.groups()
-
-            if exp is None:
-                tex_base = base._latex(p, **kwargs)
-                tex = '{%s}_{%s}' % (tex_base, ', '.join(self.index_generator(p)))
-            else:
-                tex = '{%s}_{%s}^{%s}' % (tex_base, ', '.join(self.index_generator(p)), exp)
-                
+            tex = '{%s}_{%s}' % (p._print(self.base), ', '.join(self.index_generator(p)))
         return tex
 
     @cacheit
     def _eval_free_symbols(self):
         base_free_symbols = self.base.free_symbols
         indices_free_symbols = {fs for i in self.indices for fs in i.free_symbols}
         if base_free_symbols:
@@ -1716,15 +1403,15 @@
     # return expr._has(self)
     def has_match(self, expr):
         if expr.is_Indexed and expr.base == self.base:
             if len(expr.indices) == 1:
                 index, *_ = expr.indices
                 start, stop = self.index
                 if index < start or index >= stop:
-                    return False
+                    return False 
 # it is possible for them to be equal!
                 return True
         if expr.is_Sliced:
             if expr.base == self.base:
                 for _index, index in zip(expr.indices, self.indices):
                     index_start, index_stop, index_step = _index.slice_args
                     start, stop, step = index.slice_args
@@ -1817,32 +1504,37 @@
     def _eval_is_finite(self):
         return self.base.is_finite
 
     def _eval_is_zero(self):
         return self.base.is_zero
 
     def _eval_is_random(self):
-        return any(arg.is_random for arg in self.args)
+        return self.base.is_random
     
     @property
     def is_given(self): 
         return self.base.is_given
 
-    as_boolean = Symbol.as_boolean
+    def as_boolean(self):
+        if self.is_random:
+            from sympy import Equal
+            from sympy.stats.rv import pspace
+            return Equal(self, pspace(self).symbol)
 
     @cacheit
     def _eval_domain_defined(self, x, allow_empty=False, **_):
         domain = self.base.domain_defined(x)
         start, stop, step = self.index.slice_args
             
         if allow_empty:
-            domain &= x.domain_conditioned(stop - start >= 0)
+            domain &= x.domain_conditioned(start <= stop)
         else:
-            domain &= x.domain_conditioned(stop - start > 0)
+            domain &= x.domain_conditioned(start < stop)
         return domain
+            
 
     def domain_definition(self):
         base = self.base
         
         from sympy.logic.boolalg import And
         eqs = []
         for i, sliced in enumerate(self.indices):
@@ -1929,15 +1621,15 @@
         return indexed
                 
     @property
     def domain_bounded(self):
         base = self.base
         if base.is_Symbol: 
             from sympy import CartesianSpace
-            from sympy import Interval, oo, Range
+            from sympy import Interval, oo, Range 
             if 'domain' in base._assumptions:
                 domain = base._assumptions['domain']
             elif base.is_positive:
                 if base.is_integer:
                     domain = Range(1, oo)
                 else:
                     domain = Interval(0, oo, left_open=True)
@@ -1963,14 +1655,16 @@
 
     @property
     def is_bounded(self):
         self = self.base
         if self.is_Symbol:
             if 'domain' in self._assumptions:
                 return True
+#             if 'shape' in self._assumptions:
+#                 return False
             
             if  'positive' in self._assumptions:
                 return True
             if  'negative' in self._assumptions:
                 return True
             if  'nonpositive' in self._assumptions:
                 return True
@@ -1985,48 +1679,23 @@
 
     @property
     def unbounded(self):
         if self.is_bounded:
             return self.copy(domain=None)
         return self
 
-    def enlarge_indices(self, limits, expr=None):
+    def enlarge_indices(self, limits):
         base, *indices = self.args
         if base.is_Indexed:
             base = base.enlarge_indices(limits)
             if base.is_Sliced:
                 base, *new_indices = base.args
                 indices = new_indices + indices
                 return Sliced(base, *indices)
-            return self
-        
-        indices_transformed = [*indices]
-        hit = False
-        for limit in limits:
-            i, *ab = limit
-            if not i.is_integer:
-                continue
-
-            if len(ab) == 2 and not ab[1].is_set:
-                if args := enlarge_indices(limit, indices):
-                    t, args = args
-                    indices_transformed[t] = args
-                    hit = True
-
-            elif not ab and expr is not None:
-                domain = expr.domain_defined(i)
-                if domain.is_Range:
-                    if args := enlarge_indices((i, *domain.args), indices):
-                        t, args = args
-                        indices_transformed[t] = args
-                        hit = True
-                
-        if hit:
-            return base[tuple(indices_transformed)]
-        
+            
         return self
 
     def _eval_torch(self):
         base, *indices = self.args
         base = base.torch
         indices = [slice(*[None if arg is None else arg.torch for arg in index.args]) for index in indices]
         return base[indices]
@@ -2046,62 +1715,14 @@
                         if b.is_integer:
                             if not limits:
                                 if not any(s._has(var) for s in slices):
                                     return Sliced(base, Tuple(a, b), *slices)
             
         return self
     
-    @property
-    def var(self):
-        assert self.base.is_random
-        assert not any(index.is_random for index in self.indices)
-        return self.base.var[self.indices]
-    
-    @property
-    def surrogate(self):
-        assert self.base.is_random
-        assert not any(index.is_random for index in self.indices)
-        return self.base.surrogate[self.indices]
-
-    def __and__(self, other):
-        """Overloading for & operator"""
-        if self.is_random and other.is_random:
-            if not other.is_bool:
-                other = other.as_boolean()
-            return self.as_boolean() & other
-        
-        return super(Sliced, self).__and__(other)
-
-    def catch_exception(self, old, new):
-        base, *slices = self.args
-        for a, b in slices:
-            if a._subs(old, new) == b._subs(old, new):
-                return True
-
-    def indices_slices(self):
-        base, *slices = self.args
-        return base.indices, slices
-
-    def indexOf(self, indexed):
-        if indexed.is_Indexed:
-            if indexed.base == self.base:
-                indices = indexed.indices
-                slices = self.indices
-                if len(indices) < len(slices):
-                    indices = (i - start for i, (start, stop) in zip(indices, slices[:len(indices)]))
-                    return tuple(indices) + slices[len(indices):]
-                
-                elif len(indices) > len(slices):
-                    indices_former = (i - start for i, (start, stop) in zip(indices[:len(slices)], slices))
-                    return tuple(indices_former) + indices[len(slices):]
-                
-                else:
-                    indices = (i - start for i, (start, stop) in zip(indices, slices))
-                    return tuple(indices)
-                
 
 class SlicedIndexed(Expr):
     """Represents a mathematical object with Slices and indices both.
     in the form of x[start0:stop0, ..., start1:stop1, index0,..., index1]
 
     """
     is_symbol = True
@@ -2141,15 +1762,15 @@
                          
         definition = self.definition
         if definition is not None: 
             if self.is_integer:
                 from sympy.stats.drv_types import AbstractDiscreteDistribution
                 return AbstractDiscreteDistribution(definition.function)
             else: 
-                from sympy.stats.crv_types import AbstractContinuousDistribution
+                from sympy.stats.crv_types import AbstractContinuousDistribution                
                 return AbstractContinuousDistribution(definition) 
 
     def definition(self):
         return self.defun()
 
     @cacheit
     def defun(self):
@@ -2163,23 +1784,23 @@
     @property
     def domain_assumed(self):
         return self.base.domain_assumed
 
     @property
     def domain(self): 
         if self.dtype.is_set:
-            return self.universalSet
+            return self.universalSet    
 
         from sympy import Interval, Range, CartesianSpace
         domain = self.base.domain_assumed
         if domain is None:
-            assumptions = self.base.assumptions0
+            assumptions = self.base.assumptions0            
             integer = assumptions.pop('integer', self.base.is_integer)
             domain = (Range if integer else Interval)(**assumptions)
-
+            
         shape = self.shape
         if not shape:
             return domain
         return CartesianSpace(domain, *shape)
 
     def _dummy_eq(self, other):
         return self == other
@@ -2187,194 +1808,27 @@
     def structurally_equal(self, other):
         if other.is_symbol:
             return self.shape == other.shape
         return False
 
     # performing other in self
     def index_contains(self, other):
-        if other.is_Indexed:
-            if self.base != other.base: 
-                return
-            
-            slices, indices = self.slices_indices()
-            _indices = other.indices
-            if len(_indices) < len(slices) + len(indices):
-                return
-    
-            if not slices_contains_indices(slices, _indices):
-                return
-            
-            return indices_contains_indices(indices, _indices)
-
-        if other.is_Sliced:
-            base = self.base
-            _base = other.base
-            if base == _base:
-                return
-
-            elif _base.is_Indexed and _base.base == base:
-                slices, indices = self.slices_indices()
-                _indices = _base.indices
-                
-                if len(_indices) <= len(slices):
-                    return
-                
-                if not slices_contains_indices(slices, _indices):
-                    return
-                
-                return indices_contains_indices(indices, _indices[len(slices):])
-
-        if other.is_SlicedIndexed:
-            if self.base != other.base: 
-                return
-            
-            slices, indices = self.slices_indices()
-            _slices, _indices = other.slices_indices()
-            if len(_slices) > len(slices):
-                return
-            
-            if not slices_contains_slices(slices, _slices):
-                return
-            
-            if len(_slices) + len(_indices) < len(slices) + len(indices):
-                return
-                
-            if len(_slices) < len(slices):
-                if not slices_contains_indices(slices[len(_slices):], indices):
-                    return
-            
-                return indices_contains_indices(indices, _indices[len(slices) - len(_slices):])
-            else:
-                return indices_contains_indices(indices, _indices)
-
-    # performing other in self
-    def index_intersect(self, other):
-        if other.is_Indexed:
-            if self.base != other.base: 
-                return
-            
-            slices, indices = self.slices_indices()
-            _indices = other.indices
-            if len(_indices) < len(slices) + len(indices):
-                return
-    
-            if not slices_contains_indices(slices, _indices):
-                return
-            
-            if indices_contains_indices(indices, _indices):
-                return other
-
-        if other.is_Sliced:
-            base = self.base
-            _base = other.base
-            if base == _base:
-                return
-
-            elif _base.is_Indexed and _base.base == base:
-                slices, indices = self.slices_indices()
-                _indices = _base.indices
-                
-                if len(_indices) <= len(slices):
-                    return
-                
-                if not slices_contains_indices(slices, _indices):
-                    return
-                
-                if indices_contains_indices(indices, _indices[len(slices):]):
-                    return other
+        if not (other.is_Indexed or other.is_Sliced) or self.base != other.base: 
+            return False
 
-        if other.is_SlicedIndexed:
-            if self.base != other.base: 
-                return
-            
-            slices, indices = self.slices_indices()
-            _slices, _indices = other.slices_indices()
-            if len(_slices) > len(slices):
-                return
-            
-            if not slices_contains_slices(slices, _slices):
-                return
-            
-            if len(_slices) + len(_indices) < len(slices) + len(indices):
-                return
-                
-            if len(_slices) < len(slices):
-                if not slices_contains_indices(slices[len(_slices):], indices):
-                    return
-            
-                if indices_contains_indices(indices, _indices[len(slices) - len(_slices):]):
-                    return other
-            else:
-                if indices_contains_indices(indices, _indices):
-                    return other
-
-    # performing indices complement
-    def index_complement(self, other):
-        if other.is_Indexed:
-            if self.base != other.base: 
-                return self
-            
-            slices, indices = self.slices_indices()
-            _indices = other.indices
-            if len(_indices) < len(slices) + len(indices):
-                return self
-    
-            if not slices_contains_indices(slices, _indices):
-                return self
-            
-            if indices_contains_indices(indices, _indices):
-                return
-            return self
+        start, stop = self.index
+        if other.is_Sliced: 
+            _start, _stop = other.index
+            return _start >= start and _stop <= stop
+        
+        if len(other.indices) > 1:
+            return False
 
-        if other.is_Sliced:
-            base = self.base
-            _base = other.base
-            if base == _base:
-                return self
-
-            elif _base.is_Indexed and _base.base == base:
-                slices, indices = self.slices_indices()
-                _indices = _base.indices
-                
-                if len(_indices) <= len(slices):
-                    return self
-                
-                if not slices_contains_indices(slices, _indices):
-                    return self
-                
-                if indices_contains_indices(indices, _indices[len(slices):]):
-                    return
-                return self
-            
-        if other.is_SlicedIndexed:
-            if self.base != other.base: 
-                return self
-            
-            slices, indices = self.slices_indices()
-            _slices, _indices = other.slices_indices()
-            if len(_slices) > len(slices):
-                return self
-            
-            if not slices_contains_slices(slices, _slices):
-                return self
-            
-            if len(_slices) + len(_indices) < len(slices) + len(indices):
-                return self
-                
-            if len(_slices) < len(slices):
-                if not slices_contains_indices(slices[len(_slices):], indices):
-                    return self
-            
-                if indices_contains_indices(indices, _indices[len(slices) - len(_slices):]):
-                    return
-            else:
-                if indices_contains_indices(indices, _indices):
-                    return
-                
-            return self
+        index = other.indices[0]
+        return index >= start and index < stop
 
     def cup_finiteset(self, var=None):
         from sympy.concrete.sets import Cup
 
         i = self.generate_var(integer=True, var=var)
         return Cup({self.base[i]}, (i, *self.index))
 
@@ -2623,33 +2077,33 @@
                 args.append('%s:%s:%s' % (start, stop, step))
             
         args += [p._print(i) for i in indices]
             
         base = self.base
         if base.is_Indexed: 
             args = [p._print(index) for index in base.indices] + args
-            base = base.base
+            base = base.base            
             
         return "%s[%s]" % (p.doprint(base), ', '.join(args))
 
-    def _latex(self, p, **kwargs):
+    def _latex(self, p):
         slices, indices = self.slices_indices()
         
         args = []
         for i, s in enumerate(slices):
             start, stop, step = s.slice_args
             if step is None:
                 step = S.One
                 
             if start.is_zero:
                 start = ''
             else:
                 start = p._print(start)
             
-            if stop == self.base.shape[i]:
+            if stop == self.base.shape[-i - 1]:
                 stop = ''
             else: 
                 stop = p._print(stop)
                 
             if step.is_One:
                 args.append('%s:%s' % (start, stop))
             else:
@@ -2659,15 +2113,15 @@
         args += [p._print(i) for i in indices]
         
         base = self.base
         if base.is_Indexed: 
             args = [p._print(index) for index in base.indices] + args
             base = base.base
             
-        return "{%s}_{%s}" % (base._latex(p, **kwargs), ','.join(args))
+        return "{%s}_{%s}" % (p._print(base), ','.join(args))
 
     @cacheit
     def _eval_free_symbols(self):
         indices_free_symbols = {fs for i in self.args for fs in i.free_symbols}
         if self.base.is_Symbol:
             return {self} | indices_free_symbols
         else:
@@ -2762,21 +2216,25 @@
     def _eval_is_finite(self):
         return self.base.is_finite
 
     def _eval_is_zero(self):
         return self.base.is_zero
 
     def _eval_is_random(self):
-        return any(arg.is_random for arg in self.args)
+        return self.base.is_random
     
     @property
     def is_given(self): 
         return self.base.is_given
 
-    as_boolean = Symbol.as_boolean
+    def as_boolean(self):
+        if self.is_random:
+            from sympy import Equal
+            from sympy.stats.rv import pspace
+            return Equal(self, pspace(self).symbol)
 
     @cacheit
     def _eval_domain_defined(self, x, allow_empty=False, **_):
         domain = self.base.domain_defined(x)
         for s in self.slices:
             start, stop = s
             if allow_empty:
@@ -2785,15 +2243,15 @@
                 domain &= x.domain_conditioned(start < stop)
         
         return domain
 
     def _eval_transpose(self, axis=-1):
         if axis == self.default_axis:
             if len(self.shape) < 2:
-                return self
+                return self        
 
     def domain_definition(self):
         eqs = []
         for i, (start, stop) in enumerate(self.slices): 
             eqs.append((start < stop) & stop <= self.shape[i])
         from sympy import And
         return And(*eqs)        
@@ -2855,35 +2313,14 @@
 
     def _eval_torch(self):
         base = self.base.torch
         slices = [slice(*[None if arg is None else arg.torch for arg in index.args]) for index in self.slices]
         indices = [index.torch for index in self.indices]
         return base[tuple((*slices, *indices))]
     
-    @property
-    def var(self):
-        assert self.base.is_random
-        assert not any(index.is_random for index in self.indices)
-        return self.base.var[self.indices]
-
-    @property
-    def surrogate(self):
-        assert self.base.is_random
-        assert not any(index.is_random for index in self.indices)
-        return self.base.surrogate[self.indices]
-
-    def __and__(self, other):
-        """Overloading for & operator"""
-        if self.is_random and other.is_random:
-            if not other.is_bool:
-                other = other.as_boolean()
-            return self.as_boolean() & other
-
-        return super(SlicedIndexed, self).__and__(other)
-
 
 # Warning: the following class is obsolete!!! using Symbol.x(shape=(m,n,k)) instead
 class IndexedBase(Expr, NotIterable):
     """Represent the base or stem of an indexed object
 
     The IndexedBase class represent an array that contains elements. The main purpose
     of this class is to allow the convenient creation of objects of the Indexed
@@ -3326,124 +2763,7 @@
 
         if self.lower is not None and (self.lower > other_upper) == True:
             return True
         if self.upper is not None and (self.upper <= other_lower) == True:
             return False
         return super(Idx, self).__gt__(other)
 
-
-def slices_contains_slices(slices, _slices):
-    return all(_start >= start and _stop <= stop for (start, stop), (_start, _stop) in zip(slices, _slices))
-
-def slices_contains_indices(slices, indices):
-    from sympy import Range
-    return all(Range(a, b).conditionally_contains(i) for (a, b), i in zip(slices, indices))
-
-def indices_contains_indices(indices, _indices):
-    if len(_indices) < len(indices):
-        return False
-
-    if len(_indices) > len(indices):
-        return _indices[:len(indices)] == indices
-    
-    return _indices == indices
-
-
-#given: lhs, rhs are sets of symbols
-def index_intersect(lhs, rhs):
-    vars = set()
-    for v in lhs:
-        for _v in rhs:
-            if (_v := _v.index_intersect(v)) is not None:
-                vars.add(_v)
-
-    return vars
-
-#given: lhs, rhs are each a set of symbols, or a symbol
-def index_complement(lhs, rhs):
-    if isinstance(lhs, set):
-        ret = set()
-        for v in lhs:
-            ret |= index_complement(v, rhs)
-    
-        return ret
-    
-    if isinstance(rhs, set):
-        if not rhs:
-            return {lhs}
-        
-        for v in rhs:
-            lhs = index_complement(lhs, v)
-        
-        return lhs
-
-    if ret := lhs.index_complement(rhs):
-        if isinstance(ret, set):
-            return ret
-        return {ret}
-
-    return set()
-
-def enlarge_indices(limit, indices):
-    i, a, b = limit
-    for t, d in enumerate(indices):
-        if d.is_Tuple:
-            start = None
-            if d[0]._has(i):
-                h, k = d[0].of_simple_poly(i)
-                if k:
-                    if k < 0:
-                        k = -k
-                        a, b = b - 1, a - 1
-    
-                    if k > 0:
-                        if k > 1:
-                            print('unresolved cases')
-                        start = (a * k + h, b * k + h)
-            else:
-                start = d[0]
-    
-            if start is None:
-                continue
-    
-            stop = None
-            if d[1]._has(i):
-                h, k = d[1].of_simple_poly(i)
-                if k:
-                    if k < 0:
-                        k = -k
-                        a, b = b - 1, a - 1
-    
-                    if k > 0:
-                        if k > 1:
-                            print('unresolved cases')
-                        stop = (a * k + h, b * k + h)
-            else:
-                stop = d[1]
-    
-            if stop is None:
-                continue
-    
-            if isinstance(start, tuple):
-                if isinstance(stop, tuple):
-                    args = (start[0], stop[1]) 
-                else:
-                    args = (start[0], stop)
-            else:
-                if isinstance(stop, tuple):
-                    args = (start, stop[1]) 
-                else:
-                    continue
-    
-            return t, slice(*args)
-            
-        else:
-            h, k = d.of_simple_poly(i)
-            if k:
-                if k < 0:
-                    k = -k
-                    a, b = b - 1, a - 1
-    
-                if k > 0:
-                    if k > 1:
-                        print('unresolved cases')
-                    return t, Tuple(a * k + h, b * k + h)
```

### Comparing `sympy.keras-1.0.21/sympy/tensor/tensor.py` & `sympy.keras-1.0.4/sympy/tensor/tensor.py`

 * *Files 0% similar despite different names*

```diff
@@ -4503,15 +4503,15 @@
         other = sympify(other)
         if other.is_Equal: 
             return self.func(self.lhs - other.lhs, self.rhs - other.rhs, **other.add_sub_assumptions(self))
         elif other.is_Quantifier:
             return self.bfn(self.__sub__, other)
         else: 
             assert not other.is_set
-            assert other.is_complex, 'try to prove %s is complex' % other
+            assert other.is_complex, 'try to prove %s is complex' % other 
             return self.func((self.lhs - other).simplify(), (self.rhs - other).simplify())
 
     def __mul__(self, other):
         if isinstance(other, TensorEqual):
             if other.lhs.is_nonzero or other.rhs.is_nonzero:
                 return self.func(self.lhs * other.lhs, self.rhs * other.rhs)
             return self.func(self.lhs * other.lhs, self.rhs * other.rhs, given=[self, other])
@@ -4803,15 +4803,15 @@
             return Or(self.func(other, 0), self.func(lhs, rhs))
 
     def __rmul__(self, lhs):
         return self.__mul__(lhs)
         
     def __mod__(self, other):
         other = sympify(other)
-        assert other.is_integer
+        assert other.is_integer        
         return TensorEqual(self.lhs % other, self.rhs % other, given=self)
      
     def __mul__(self, other):
         other = sympify(other)
         if isinstance(other, TensorEqual):
             if other.lhs.is_nonzero or other.rhs.is_nonzero:
                 return TensorEqual(self.lhs * other.lhs, self.rhs * other.rhs)
@@ -4865,15 +4865,15 @@
     def __rpow__(self, other):
         if other.is_positive:
             return self.func(other ** self.lhs, other ** self.rhs)
         
         if self.lhs.is_positive or self.rhs.is_positive:
             return self.func(other ** self.lhs, other ** self.rhs, given=self)
         
-        return self
+        return self    
 
     def __pow__(self, other):
         other = sympify(other)
         if other.is_positive:
             return self.func(self.lhs ** other, self.rhs ** other, given=self)
         return self
         
@@ -4986,15 +4986,15 @@
 
         if x is not None and not y._has(x):
             domain = limits_dict[x]
             if isinstance(domain, Boolean):
                 function = domain._subs(x, y)
                 if function == False:
                     function = self.limits_cond.invert()
-                    return function
+                    return function                
 
     def simplify_Intersection(self, lhs):
         if len(lhs.args) == 2:
             A, B = lhs.args
             if A.is_FiniteSet and B.is_FiniteSet:
                 if len(A) == len(B) == 1:
                     return TensorUnequal(A.arg, B.arg)
@@ -5093,25 +5093,25 @@
             if self.lhs == other.lhs and self.lhs.is_integer and self.rhs == other.rhs + 1:
 #                 x == 3 and x <= 2 => x <= 3
                 return TensorLessEqual(*self.args)
         elif other.is_GreaterEqual:
             if {*other.args} == {*self.args}:
                 return other
             if self.lhs == other.lhs and self.lhs.is_integer and self.rhs + 1 == other.rhs:
-#                 x == 3 and x >= 2 => x >= 3
+#                 x == 3 and x >= 2 => x >= 3                
                 return TensorGreaterEqual(*self.args)
             
         return TensorRelational.__or__(self, other)
 
     def simplify_condition_on_random_variable(self):
         lhs, rhs = self.args
         from sympy.stats.rv import pspace
         if lhs.is_symbol and pspace(lhs).symbol == rhs:
             return lhs
-        return self
+        return self             
 
     def domain_conditioned(self, var):
         if var.shape:
             if self.lhs == var:
                 return self.rhs.set
             
             if self.rhs == var:
@@ -5138,15 +5138,15 @@
                 args = cls.args
                 if isinstance(args, tuple) and len(args) == 1:
                     _a, _b = res
                     a, b = self.args
                     if a is _a:
                         return (_b, _a)
             
-        return res
+        return res 
 
     invert = TensorBinaryCondition.invert
     
 eq = TensorEqual
 
 
 class TensorUnequal(TensorRelational):
@@ -5305,15 +5305,15 @@
                 return self.func(self.lhs / other.lhs, self.rhs / other.rhs)
             return self
         else:
             if other.is_nonzero:
                 return self.func((self.lhs / other).ratsimp(), (self.rhs / other).ratsimp())
             if other.is_zero:
                 return self
-            from sympy import Or
+            from sympy import Or 
             return Or(TensorEqual(other, 0), self.func((self.lhs / other).ratsimp(), (self.rhs / other).ratsimp()))
 
     def __mul__(self, other):
         if isinstance(other, TensorUnequal):
             return self.func(self.lhs * other.lhs, self.rhs * other.rhs, given=[self, other])
         
         return TensorRelational.__mul__(self, other)
@@ -5464,18 +5464,18 @@
     @property
     def lts(self):
         return self._args[0]
 
     def __and__(self, other):
         if isinstance(other, _TensorGreater):
             if self.rhs == other.rhs: 
-                left = self.lhs
+                left = self.lhs 
                 left_open = isinstance(self, TensorLess)
                 
-                right = other.lhs
+                right = other.lhs 
                 right_open = isinstance(other, TensorGreater)
                 
                 if left_open:
                     if right_open:
                         ...
                     else:
                         if left >= right:
@@ -5785,37 +5785,37 @@
                 if self.rhs == other.rhs:
                     return TensorEqual(*self.args)
                 if other.rhs < self.rhs:
                     return S.false
         if isinstance(other, TensorLess):
             if self.lhs == other.lhs:
                 if self.rhs >= other.rhs:
-                    return S.false
+                    return S.false            
         elif isinstance(other, TensorGreater):
             if self.lhs == other.lhs:
                 if self.rhs <= other.rhs:
                     return other
 #                 x >= 1 and x > 0
                 if self.rhs > other.rhs:
                     return self
         elif isinstance(other, TensorUnequal):
             if {*self.args} == {*other.args}:
                 return TensorGreater(self.lhs, self.rhs)            
         elif isinstance(other, TensorEqual):
             if {*self.args} == {*other.args}:
-                return other
+                return other            
         elif other.is_Element:
             if other.rhs.is_Range or other.rhs.is_Interval:
                 if self.lhs == other.lhs:
                     if other.rhs.right_open:
                         if self.rhs >= other.rhs.stop:
-                            return S.false
+                            return S.false           
                     else:
                         if self.rhs > other.rhs.stop:
-                            return S.false
+                            return S.false           
         elif other.is_NotElement:
             if other.rhs.is_Range or other.rhs.is_Interval:
                 if self.lhs == other.lhs:
                     if other.rhs.left_open and self.rhs > other.rhs.start or \
                     not other.rhs.left_open and self.rhs >= other.rhs.start:
                         if other.rhs.right_open:
                             if self.lhs < other.rhs.stop:
@@ -5871,15 +5871,15 @@
                 if self.rhs <= other.rhs:
                     return S.true
                 
         elif other.is_LessEqual:
             if self.lhs == other.lhs:
                 if self.rhs <= other.rhs:
                     return S.true
-                # x >= 1 and x <= 0
+                # x >= 1 and x <= 0  
                 if self.lhs.is_integer and self.rhs <= other.rhs + 1:
                     return S.true
             
         elif other.is_GreaterEqual:
             if self.lhs == other.lhs:
                 # x >= a or x >= a + 1
                 if self.rhs >= other.rhs:
@@ -5887,15 +5887,15 @@
                 if self.rhs <= other.rhs:
                     return self
             
         return TensorRelational.__or__(self, other)
 
     def simplify(self, deep=False, wrt=None):
         if self.lhs.is_Maxima:
-            maximize = self.lhs
+            maximize = self.lhs 
             if maximize.expr == self.rhs:
                 if all(len(limit) == 1 for limit in maximize.limits):
                     return S.true
         return TensorRelational.simplify(self, deep=deep, wrt=wrt)
     
     def of(self, cls):
         res = Boolean.of(self, cls)
@@ -5915,15 +5915,15 @@
                 res = Boolean.of(self, cls)
                 if b.is_Number:
                     return res
                 if isinstance(res, tuple):
                     b, a = res
                     return (a, b)         
             
-        return res
+        return res 
 
 
 ge = TensorGreaterEqual
 
 
 class TensorLessEqual(_TensorLess):
     __doc__ = TensorGreaterEqual.__doc__
@@ -6014,26 +6014,26 @@
 
     def __and__(self, other):
         if other.is_LessEqual:
             if self.lhs == other.rhs:
                 if other.lhs == self.rhs:
                     return TensorEqual(self.lhs, self.rhs)
                 if other.lhs > self.rhs:
-                    return S.false
+                    return S.false   
             elif self.lhs == other.lhs:
                 # x <= a, x <= b
                 if self.rhs <= other.rhs:
                     return self
                 
                 if self.rhs >= other.rhs:
                     return other
                 
         elif other.is_Less:
             if self.lhs == other.lhs:
-#                 x <= 1 and x < 0
+#                 x <= 1 and x < 0                
                 if self.rhs >= other.rhs:
                     return other
 #                 x <= 0 and x < 1
                 if self.rhs < other.rhs:
                     return self
 
             elif self.lhs == other.rhs:
@@ -6060,18 +6060,18 @@
                         return S.false
 
                     return other.func(self.lhs, other.rhs.func(S.NegativeInfinity, self.rhs + 1) & other.rhs).simplify()
             elif other.rhs.is_Interval:
                 if self.lhs == other.lhs:
                     if other.rhs.left_open:
                         if self.rhs <= other.rhs.start:
-                            return S.false
+                            return S.false           
                     else:
                         if self.rhs < other.rhs.start:
-                            return S.false
+                            return S.false           
 
                     return other.func(self.lhs, other.rhs.func(S.NegativeInfinity, self.rhs) & other.rhs).simplify()
                 
         elif other.is_Unequal:
             if {*self.args} == {*other.args}:
                 return TensorLess(*self.args)
             
@@ -6116,15 +6116,15 @@
                 return self.func(*other.args)
             
         elif other.is_Unequal:
             if other.lhs == self.lhs and other.rhs <= self.rhs or \
             other.lhs == self.rhs and self.rhs <= other.rhs or \
             other.rhs == self.lhs and other.lhs <= self.rhs or \
             other.rhs == self.rhs and self.lhs <= other.rhs:
-                return S.true
+                return S.true 
             
         elif other.is_Greater:
 #             x <= 1 | x > 0
             if self.lhs == other.lhs:
                 if self.rhs >= other.rhs:
                     return S.true
         elif other.is_GreaterEqual:
@@ -6144,15 +6144,15 @@
                 if self.rhs >= other.rhs:
                     return self
             
         return TensorRelational.__or__(self, other)
 
     def simplify(self, deep=False, wrt=None):
         if self.lhs.is_Minima:
-            minimize = self.lhs
+            minimize = self.lhs 
             if minimize.expr == self.rhs:
                 if all(len(limit) == 1 for limit in minimize.limits):
                     return S.true
         return TensorRelational.simplify(self, deep=deep, wrt=wrt)
 
     def of(self, cls):
         res = Boolean.of(self, cls)
@@ -6172,15 +6172,15 @@
                 res = Boolean.of(self, cls)
                 if b.is_Number:
                     return res
                 if isinstance(res, tuple):
                     b, a = res
                     return (a, b)         
             
-        return res
+        return res 
 
 
 le = TensorLessEqual
 
 
 class TensorGreater(_TensorGreater):
     __doc__ = TensorGreaterEqual.__doc__
@@ -6296,20 +6296,20 @@
 
     def __or__(self, other):
         if isinstance(other, TensorUnequal):
             if self.lhs == other.lhs:
                 if self.rhs == other.rhs: 
                     return other
                 if self.lhs <= other.rhs:
-                    return (self.lhs < other.rhs) | self
+                    return (self.lhs < other.rhs) | self 
             elif self.lhs == other.rhs:
                 if self.rhs == other.lhs:
                     return other
                 if self.lhs <= other.lhs:
-                    return (self.lhs < other.lhs) | self
+                    return (self.lhs < other.lhs) | self                
         elif isinstance(other, TensorEqual):
             if set(self.args) == set(other.args):
                 return TensorGreaterEqual(self.lhs, self.rhs)
             
         elif isinstance(other, TensorLess):
             if self.lhs == other.lhs:
                 if other.rhs > self.rhs:
@@ -6339,22 +6339,22 @@
                 
         elif isinstance(other, TensorLessEqual):
             if self.lhs == other.lhs:
                 if self.rhs <= other.rhs:
                     return S.true
             if self.rhs == other.rhs:
                 if other.lhs <= self.lhs:
-                    return S.true
+                    return S.true                              
         elif isinstance(other, TensorGreaterEqual):
             if self.lhs == other.rhs:
                 if self.rhs <= other.lhs:
                     return S.true
             if self.rhs == other.lhs:
                 if other.rhs <= self.lhs:
-                    return S.true
+                    return S.true                              
             
         return _TensorGreater.__or__(self, other)
 
     def __mul__(self, other):
         if isinstance(other, TensorGreater):
             if self.rhs.is_extended_nonnegative: 
                 if other.rhs.is_extended_nonnegative:
@@ -6403,15 +6403,15 @@
                 res = Boolean.of(self, cls)
                 if b.is_Number:
                     return res
                 if isinstance(res, tuple):
                     b, a = res
                     return (a, b)         
             
-        return res
+        return res 
 
 
 gt = TensorGreater
 TensorLessEqual.invert_type = TensorGreater
 
 
 class TensorLess(_TensorLess):
@@ -6487,20 +6487,20 @@
             if set(self.args) == set(other.args):
                 return self
         elif isinstance(other, TensorEqual):
             if set(self.args) == set(other.args):
                 return S.false
         elif isinstance(other, _TensorLess):
             if self.lhs == other.lhs:
-#                 x < 0 and x <= 1
+#                 x < 0 and x <= 1                
                 if self.rhs <= other.rhs:
                     return self
 #                 x < 1 and x <= 0
                 if self.rhs > other.rhs:
-                    return other
+                    return other 
             if self.rhs == other.lhs:
 #                 x < a and a < x - 1
                 if self.lhs >= other.rhs:
                     return S.false
         
         elif other.is_Element:
             if other.rhs.is_Range or other.rhs.is_Interval:
@@ -6522,15 +6522,15 @@
 
     def __or__(self, other):
         if isinstance(other, TensorUnequal):
             if self.lhs == other.lhs:
                 if self.rhs == other.rhs: 
                     return other
                 if self.lhs >= other.rhs:
-                    return (self.lhs > other.rhs) | self
+                    return (self.lhs > other.rhs) | self 
             elif self.lhs == other.rhs:
                 if self.rhs == other.lhs:
                     return other
                 if self.lhs >= other.lhs:
                     return (self.lhs > other.lhs) | self
         elif isinstance(other, TensorEqual):
             if set(self.args) == set(other.args):
@@ -6540,40 +6540,40 @@
             if self.lhs == other.lhs:
                 if self.rhs > other.rhs:
                     return S.true
                 if other.rhs == self.rhs:
                     return TensorUnequal(*self.args)
             if self.rhs == other.rhs:
                 if other.lhs > self.lhs:
-                    return S.true
+                    return S.true                              
         elif isinstance(other, TensorLess):
             if self.lhs == other.rhs:
                 if self.rhs > other.lhs:
                     return S.true
                 if other.lhs == self.rhs:
                     return TensorUnequal(*self.args)
                 
             if self.rhs == other.lhs:
                 if other.rhs > self.lhs:
-                    return S.true
+                    return S.true                            
             
             if self.lhs == other.lhs:
                 # x < a or x < a + 1
                 if self.rhs <= other.rhs:
                     return other
                 if self.rhs >= other.rhs:
                     return self
             
         elif isinstance(other, TensorGreaterEqual):
             if self.lhs == other.lhs:
                 if self.rhs >= other.rhs:
                     return S.true
             if self.rhs == other.rhs:
                 if other.lhs >= self.lhs:
-                    return S.true
+                    return S.true                              
         elif isinstance(other, TensorLessEqual):
             if self.lhs == other.rhs:
                 if self.rhs >= other.lhs:
                     return S.true
             if self.rhs == other.lhs:
                 if other.rhs >= self.lhs:
                     return S.true
@@ -6634,15 +6634,15 @@
                 res = Boolean.of(self, cls)
                 if b.is_Number:
                     return res
                 if isinstance(res, tuple):
                     b, a = res
                     return (a, b)         
             
-        return res
+        return res 
 
 
 lt = TensorLess
 TensorGreaterEqual.invert_type = TensorLess
 
 ge.reversed_type = le
 lt.reversed_type = gt
```

### Comparing `sympy.keras-1.0.21/sympy/tensor/toperators.py` & `sympy.keras-1.0.4/sympy/tensor/toperators.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/testing/pytest.py` & `sympy.keras-1.0.4/sympy/testing/pytest.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/testing/quality_unicode.py` & `sympy.keras-1.0.4/sympy/testing/quality_unicode.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/testing/randtest.py` & `sympy.keras-1.0.4/sympy/testing/randtest.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/testing/runtests.py` & `sympy.keras-1.0.4/sympy/testing/runtests.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/testing/tmpfiles.py` & `sympy.keras-1.0.4/sympy/testing/tmpfiles.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/this.py` & `sympy.keras-1.0.4/sympy/this.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/unify/core.py` & `sympy.keras-1.0.4/sympy/unify/core.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/unify/rewrite.py` & `sympy.keras-1.0.4/sympy/unify/rewrite.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/unify/usympy.py` & `sympy.keras-1.0.4/sympy/unify/usympy.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/utilities/__init__.py` & `sympy.keras-1.0.4/sympy/utilities/__init__.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/utilities/_compilation/__init__.py` & `sympy.keras-1.0.4/sympy/utilities/_compilation/__init__.py`

 * *Files 22% similar despite different names*

```diff
@@ -12,7 +12,11 @@
 - caching of compiler choice and intermediate files
 
 """
 
 from .compilation import compile_link_import_strings, compile_run_strings
 from .availability import has_fortran, has_c, has_cxx
 
+__all__ = [
+    'compile_link_import_strings', 'compile_run_strings',
+    'has_fortran', 'has_c', 'has_cxx',
+]
```

### Comparing `sympy.keras-1.0.21/sympy/utilities/_compilation/availability.py` & `sympy.keras-1.0.4/sympy/utilities/_compilation/availability.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/utilities/_compilation/compilation.py` & `sympy.keras-1.0.4/sympy/utilities/_compilation/compilation.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/utilities/_compilation/runners.py` & `sympy.keras-1.0.4/sympy/utilities/_compilation/runners.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/utilities/_compilation/util.py` & `sympy.keras-1.0.4/sympy/utilities/_compilation/util.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/utilities/autowrap.py` & `sympy.keras-1.0.4/sympy/utilities/autowrap.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/utilities/benchmarking.py` & `sympy.keras-1.0.4/sympy/testing/benchmarking.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/utilities/codegen.py` & `sympy.keras-1.0.4/sympy/utilities/codegen.py`

 * *Files 0% similar despite different names*

```diff
@@ -92,14 +92,26 @@
 from sympy.printing.octave import OctaveCodePrinter
 from sympy.printing.rust import RustCodePrinter
 from sympy.tensor import Idx, Indexed, IndexedBase
 from sympy.matrices import (MatrixSymbol, ImmutableMatrix, MatrixBase,
                             MatrixExpr, MatrixSlice)
 
 
+__all__ = [
+    # description of routines
+    "Routine", "DataType", "default_datatypes", "get_default_datatype",
+    "Argument", "InputArgument", "OutputArgument", "Result",
+    # routines -> code
+    "CodeGen", "CCodeGen", "FCodeGen", "JuliaCodeGen", "OctaveCodeGen",
+    "RustCodeGen",
+    # friendly functions
+    "codegen", "make_routine",
+]
+
+
 #
 # Description of routines
 #
 
 
 class Routine(object):
     """Generic description of evaluation routine for set of expressions.
```

### Comparing `sympy.keras-1.0.21/sympy/utilities/decorator.py` & `sympy.keras-1.0.4/sympy/utilities/decorator.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/utilities/enumerative.py` & `sympy.keras-1.0.4/sympy/utilities/enumerative.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/utilities/exceptions.py` & `sympy.keras-1.0.4/sympy/utilities/exceptions.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/utilities/iterables.py` & `sympy.keras-1.0.4/sympy/utilities/iterables.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/utilities/lambdify.py` & `sympy.keras-1.0.4/sympy/utilities/lambdify.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/utilities/matchpy_connector.py` & `sympy.keras-1.0.4/sympy/utilities/matchpy_connector.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/utilities/mathml/__init__.py` & `sympy.keras-1.0.4/sympy/utilities/mathml/__init__.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/utilities/memoization.py` & `sympy.keras-1.0.4/sympy/utilities/memoization.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/utilities/pkgdata.py` & `sympy.keras-1.0.4/sympy/utilities/pkgdata.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/utilities/source.py` & `sympy.keras-1.0.4/sympy/utilities/source.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/utilities/timeutils.py` & `sympy.keras-1.0.4/sympy/utilities/timeutils.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/vector/__init__.py` & `sympy.keras-1.0.4/sympy/vector/__init__.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/vector/basisdependent.py` & `sympy.keras-1.0.4/sympy/vector/basisdependent.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/vector/coordsysrect.py` & `sympy.keras-1.0.4/sympy/vector/coordsysrect.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/vector/deloperator.py` & `sympy.keras-1.0.4/sympy/vector/deloperator.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/vector/dyadic.py` & `sympy.keras-1.0.4/sympy/vector/dyadic.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/vector/functions.py` & `sympy.keras-1.0.4/sympy/vector/functions.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/vector/implicitregion.py` & `sympy.keras-1.0.4/sympy/vector/implicitregion.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/vector/integrals.py` & `sympy.keras-1.0.4/sympy/vector/integrals.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/vector/operators.py` & `sympy.keras-1.0.4/sympy/vector/operators.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/vector/orienters.py` & `sympy.keras-1.0.4/sympy/vector/orienters.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/vector/parametricregion.py` & `sympy.keras-1.0.4/sympy/vector/parametricregion.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/vector/point.py` & `sympy.keras-1.0.4/sympy/vector/point.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/vector/scalar.py` & `sympy.keras-1.0.4/sympy/vector/scalar.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy/vector/vector.py` & `sympy.keras-1.0.4/sympy/vector/vector.py`

 * *Files identical despite different names*

### Comparing `sympy.keras-1.0.21/sympy.keras.egg-info/PKG-INFO` & `sympy.keras-1.0.4/sympy.keras.egg-info/PKG-INFO`

 * *Files 24% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 1.1
 Name: sympy.keras
-Version: 1.0.21
+Version: 1.0.4
 Summary: UNKNOWN
 Home-page: https://github.com/cosmosZhou/sympy
 Author: Cosmos
 Author-email: 744984949@qq.com
 License: MIT
 Description: # axiom
```

